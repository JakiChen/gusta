!function () {
    function e(t, n, i) {
        function r(o, s) {
            if (!n[o]) {
                if (!t[o]) {
                    var l = "function" == typeof require && require;
                    if (!s && l) return l(o, !0);
                    if (a) return a(o, !0);
                    var c = new Error("Cannot find module '" + o + "'");
                    throw c.code = "MODULE_NOT_FOUND", c
                }
                var u = n[o] = {
                    exports: {}
                };
                t[o][0].call(u.exports, function (e) {
                    var n = t[o][1][e];
                    return r(n || e)
                }, u, u.exports, e, t, n, i)
            }
            return n[o].exports
        }
        for (var a = "function" == typeof require && require, o = 0; o < i.length; o++) r(i[o]);
        return r
    }
    return e
}()({
    1: [function (e, t, n) {
        "use strict";

        function i(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }
        var r = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/intersection-observer"),
            a = (i(r), e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/vanilla-lazyload")),
            o = i(a),
            s = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/object-fit-videos"),
            l = i(s),
            c = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils"),
            u = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax-history"),
            h = i(u),
            d = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/scroll"),
            p = i(d),
            f = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/resize"),
            m = i(f),
            v = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/animate-in"),
            g = i(v),
            y = e("/Users/andreaslorentsson/Projects/animal/frontend/js/objects/swiper"),
            x = i(y),
            b = e("/Users/andreaslorentsson/Projects/animal/frontend/js/modules/about-promo"),
            _ = i(b),
            w = e("/Users/andreaslorentsson/Projects/animal/frontend/js/modules/featured-case"),
            M = i(w),
            T = e("/Users/andreaslorentsson/Projects/animal/frontend/js/modules/image-grid"),
            E = i(T),
            S = e("/Users/andreaslorentsson/Projects/animal/frontend/js/modules/text-carousel"),
            P = i(S),
            C = e("/Users/andreaslorentsson/Projects/animal/frontend/js/modules/clients"),
            A = i(C),
            L = e("/Users/andreaslorentsson/Projects/animal/frontend/js/modules/stats"),
            R = i(L),
            I = e("/Users/andreaslorentsson/Projects/animal/frontend/js/components/latest"),
            O = i(I),
            k = e("/Users/andreaslorentsson/Projects/animal/frontend/js/components/color-stop"),
            D = i(k),
            z = e("/Users/andreaslorentsson/Projects/animal/frontend/js/components/header"),
            B = i(z),
            N = e("/Users/andreaslorentsson/Projects/animal/frontend/js/components/drawing-app"),
            U = i(N),
            j = e("/Users/andreaslorentsson/Projects/animal/frontend/js/components/video"),
            F = i(j),
            G = e("/Users/andreaslorentsson/Projects/animal/frontend/js/components/audio"),
            H = i(G),
            V = e("/Users/andreaslorentsson/Projects/animal/frontend/js/components/three-hero"),
            W = i(V),
            q = e("/Users/andreaslorentsson/Projects/animal/frontend/js/components/cursor"),
            X = (i(q), e("/Users/andreaslorentsson/Projects/animal/frontend/js/components/illustration")),
            Y = i(X),
            Z = e("/Users/andreaslorentsson/Projects/animal/frontend/js/components/info-disclaimer"),
            J = i(Z),
            $ = {
                initialLoad: !1,
                components: {
                    latest: null,
                    header: null,
                    color_stop: null,
                    three_hero: null,
                    cursor: null,
                    illustrations: null
                },
                modules: {
                    about_promo: null,
                    text_carousel: null,
                    clients: null,
                    stats: null
                },
                objects: {
                    swiper: null
                },
                utils: {
                    ajax_history: null,
                    lazyload: null,
                    animate_in: null
                },
                setVhHeight: function () {
                    var e = .01 * window.innerHeight;
                    (0, c.isTouchDevice)() && !this.initialLoad ? (document.documentElement.style.setProperty("--vh", e + "px"), document.documentElement.style.setProperty("--flex-vh", e + "px")) : (0, c.isTouchDevice)() && document.documentElement.style.setProperty("--flex-vh", e + "px")
                },
                init: function () {
                    var e = this;
                    11 == (0, c.detectIE)() && document.body.classList.add("is-ie");
                    var t = new p["default"];
                    t.init(), document.querySelector(".o-main-wrapper__inner").style.visibility = "visible";
                    var n = new m["default"];
                    n.init(), n.addListener(function () {
                        (0, c.setInnerHeight)(window.innerHeight), (0, c.setInnerWidth)(window.innerWidth)
                    }), (0, c.setInnerHeight)(window.innerHeight), (0, c.setInnerWidth)(window.innerWidth), this.setVhHeight(), n.addListener(this.setVhHeight.bind(this)), this.initialLoad = !0, (0, c.isTouchDevice)() && document.body.classList.add("is-touch"), this.utils.animate_in = new g["default"]({
                        killWhenVisible: !0
                    }), this.utils.lazyload = new o["default"]({
                        elements_selector: ".o-image__lazy",
                        load_delay: 100,
                        threshold: 0,
                        callback_loaded: function () {
                            (0, l["default"])()
                        }
                    }), this.components.infoDisclaimer = new J["default"]({
                        block: "c-info-disclaimer",
                        settings: {
                            multiple: !0
                        }
                    }), this.components.infoDisclaimer.init(), this.components.header = new B["default"]({
                        block: "c-header",
                        settings: {
                            multiple: !1
                        },
                        elements: ["burger", "nav", "logo", "logo-title", "logo-title-wrapper", "logo-image", "action", "top-nav-line", "bottom-nav-line", "mid-line", "animate-in", "mid-nav-left", "mid-nav-right", "nav-bg", "nav-inner"]
                    }, {
                        onActionClicked: function (t) {
                            "draw" == t && (e.components.header.drawingAppEnabled || e.initDrawingApp())
                        }
                    }), this.components.header.setHeader(), this.components.drawing_app = new U["default"]({
                        block: "c-drawing-app",
                        settings: {
                            multiple: !1
                        },
                        elements: ["undo", "send", "color-pick", "canvas-wrapper", "active-color-pick", "playground", "success", "color-pickers", "draw-area", "new-napkin", "draw-again", "close"]
                    }), $.utils.ajax_history = new h["default"]({
                        contentSelector: ".o-main-wrapper__inner",
                        contentWrapperSelector: ".o-main-wrapper",
                        beforeLoadingPage: function (t, n, i, r, a) {
                            "1" == n && e.components.header.animateOutLogo(), e.components.drawing_app.isOpen && e.components.drawing_app.closeModal(), e.components.three_hero && (e.components.three_hero.fallbackInterval && clearInterval(e.components.three_hero.fallbackInterval), e.components.three_hero.engine && e.components.three_hero.engine.running && e.components.three_hero.engine.stop()), e.modules.text_carousel && e.modules.text_carousel.isPresent && e.modules.text_carousel.stop(), e.components.image_grid && e.components.image_grid.stop(), e.components.color_stop && e.components.color_stop.stop(), e.modules.featured_case && e.modules.featured_case.isPresent && e.modules.featured_case.stop(), e.utils.animate_in && e.utils.animate_in.stop(), e.components.header.isOpen && e.components.header.removeMod(e.components.header.block, "burger-close"), $.components.header.beforeSetHeader(), a()
                        },
                        duringLoadingPage: function (e, t) {},
                        afterLoadingPage: function (t, n) {
                            e.components.header.isOpen && $.components.header.close(!0), e.components.illustrations && e.components.illustrations.isPresent && e.components.illustrations.destroyAll(), e.registerTemplateSpecificComponents(), e.registerAfterAnimationTemplateSpecificComponents(function () {
                                e.utils.lazyload.update();
                                document.querySelector("#page-title").value;
                                n()
                            })
                        },
                        afterAnimatedPage: function (t) {
                            $.components.header.setHeader(), e.registerAfterAnimationPage(), t()
                        },
                        onConstantTriggerClick: function (e) {},
                        duplicateClicked: function () {
                            e.components.header.isOpen && $.components.header.close()
                        }
                    }, {
                        header: this.components.header
                    }), this.registerTemplateSpecificComponents(), this.registerAfterAnimationTemplateSpecificComponents(function () {}), this.registerAfterAnimationPage()
                },
                registerTemplateSpecificComponents: function () {
                    var e = this;
                    (0, c.nodesAsArray)(document.querySelectorAll("img")).forEach(function (e) {
                        e.addEventListener("contextmenu", function (e) {
                            e.preventDefault()
                        })
                    }), this.components.three_hero = new W["default"]({
                        block: "c-three-hero",
                        settings: {
                            multiple: !1
                        },
                        elements: ["cursor", "cursor-dot", "cursor-dot-inner", "fallback-items", "fallback-item", "loader"]
                    }, {
                        onLoaded: function () {}
                    }), this.components.three_hero.isPresent || TweenLite.set(document.querySelector(".c-header__top-nav"), {
                        opacity: 1
                    }), this.components.latest = new O["default"]({
                        block: "c-latest",
                        settings: {
                            multiple: !1
                        },
                        elements: ["load-more", "list"]
                    }), this.components.audio = new H["default"]({
                        block: "c-audio",
                        settings: {
                            multiple: !0
                        }
                    }), this.components.color_stop = new D["default"]({
                        block: "c-color-stop",
                        settings: {
                            multiple: !0
                        }
                    }, {
                        defaultColors: {
                            background: document.getElementById("main-background-color").value,
                            text: document.getElementById("main-text-color").value
                        }
                    }), this.components.video = new F["default"]({
                        block: "c-video",
                        settings: {
                            multiple: !0
                        }
                    }, {
                        onVideoMouseLeave: function () {},
                        onVideoMouseOver: function () {}
                    }), this.objects.swiper = new x["default"]({
                        block: "o-swiper",
                        settings: {
                            multiple: !0
                        }
                    }, {
                        onMouseEnter: function () {},
                        onMouseLeave: function () {}
                    }), this.modules.about_promo = new _["default"]({
                        block: "m-about-promo",
                        settings: {
                            multiple: !1
                        },
                        elements: ["by-day", "by-night", "data-item", "text-wrapper-inner"]
                    }), this.modules.stats && this.modules.stats.isPresent && this.modules.stats.stop(), this.modules.stats = new R["default"]({
                        block: "m-stats-module",
                        settings: {
                            multiple: !0
                        },
                        elements: ["number"]
                    }), this.modules.featured_case = new M["default"]({
                        block: "m-featured-case",
                        settings: {
                            multiple: !1
                        },
                        elements: ["cursor", "item", "text-inner", "anchor-wrapper", "total-index", "current-index"]
                    }, {
                        onCaseChanged: function (t) {
                            e.components.color_stop.changeManually(t, "white")
                        },
                        onMouseEnter: function () {},
                        onMouseLeave: function () {}
                    }), this.modules.image_grid = new E["default"]({
                        block: "m-image-grid",
                        settings: {
                            multiple: !1
                        },
                        elements: ["shuffle", "container", "shuffle-button"]
                    }), this.modules.text_carousel = new P["default"]({
                        block: "m-text-carousel",
                        settings: {
                            multiple: !1
                        },
                        elements: ["item", "item-wrapper", "item-wrapper-inner", "cursor", "active-index", "total-index", "navigate-arrow"]
                    }, {
                        onMouseEnter: function () {},
                        onMouseLeave: function () {}
                    }), this.modules.clients && this.modules.clients.isPresent && this.modules.clients.stop(), this.modules.clients = new A["default"]({
                        block: "m-clients",
                        settings: {
                            multiple: !1
                        },
                        elements: ["client-wrapper"]
                    });
                    var t = document.querySelector(".js-open-drawing-app");
                    t && t.addEventListener("click", function () {
                        e.initDrawingApp()
                    }), (0, c.changeSiteTitle)()
                },
                registerAfterAnimationTemplateSpecificComponents: function (e) {
                    this.components.illustrations = new Y["default"]({
                        block: "c-illustration",
                        settings: {
                            multiple: !0
                        }
                    }, {
                        onloaded: e.bind(this)
                    }), this.components.illustrations.isPresent || e()
                },
                registerAfterAnimationPage: function () {
                    this.modules.text_carousel && this.modules.text_carousel.isPresent && this.modules.text_carousel.setMinHeight(), this.utils.animate_in.init()
                },
                initDrawingApp: function () {
                    this.components.drawing_app.isPresent && this.components.drawing_app.openModal()
                }
            };
        $.init()
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/components/audio": 3,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/components/color-stop": 4,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/components/cursor": 5,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/components/drawing-app": 6,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/components/header": 7,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/components/illustration": 8,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/components/info-disclaimer": 9,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/components/latest": 10,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/components/three-hero": 11,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/components/video": 12,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/modules/about-promo": 13,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/modules/clients": 14,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/modules/featured-case": 15,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/modules/image-grid": 16,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/modules/stats": 17,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/modules/text-carousel": 18,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/objects/swiper": 19,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax-history": 20,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/animate-in": 22,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/resize": 26,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/scroll": 27,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/intersection-observer": 38,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/object-fit-videos": 40,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/vanilla-lazyload": 51
    }],
    2: [function (e, t, n) {
        "use strict";

        function i(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }

        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var a = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            o = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper"),
            s = (i(o), e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax")),
            l = (i(s), e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix"), e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap"), function () {
                function e(t) {
                    r(this, e), this.elem = t.elem, this.segment = this.elem.querySelector(".c-audio-play-button__segment"), this.duration = t.duration
                }
                return a(e, [{
                    key: "play",
                    value: function () {
                        this.elem.classList.add("c-audio-play-button--playing")
                    }
                }, {
                    key: "pause",
                    value: function (e) {
                        var t = e / this.duration;
                        t >= 1 && this.segment.setAttribute("stroke-dasharray", "0 100"), this.elem.classList.remove("c-audio-play-button--playing")
                    }
                }, {
                    key: "update",
                    value: function (e) {
                        var t = e / this.duration,
                            n = 100 * t,
                            i = 100 - n;
                        this.segment.setAttribute("stroke-dasharray", n + " " + i)
                    }
                }]), e
            }());
        n["default"] = l
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax": 21,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper": 23,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix": 25,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap": 35
    }],
    3: [function (e, t, n) {
        "use strict";

        function i(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }

        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function a(e, t) {
            if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t || "object" != typeof t && "function" != typeof t ? e : t
        }

        function o(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var s = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            l = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper"),
            c = i(l),
            u = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax"),
            h = (i(u), e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix")),
            d = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils"),
            p = (e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap"), e("/Users/andreaslorentsson/Projects/animal/frontend/js/components/audio-play-button")),
            f = i(p),
            m = function (e) {
                function t(e, n) {
                    r(this, t);
                    var i = a(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
                    return i.isPresent ? (i.audio = (0, d.mapElems)(i.block, i.getAudio.bind(i)), i.currentAudio = !1, i.audio.forEach(function (e) {
                        i.prepareOnLoad(e)
                    }), i) : a(i)
                }
                return o(t, e), s(t, [{
                    key: "setEventListeners",
                    value: function (e) {
                        var t = this;
                        e.stateButton.elem.addEventListener("click", function () {
                            t.togglePlayState(e)
                        }), e.player.addEventListener("ended", function () {
                            t.onVideoEnd(e)
                        }), e.isLarge && e.progress.addEventListener("click", function (n) {
                            t.onProgressBarClick(n, e)
                        })
                    }
                }, {
                    key: "getPlayingAudio",
                    value: function () {
                        var e = this.audio.filter(function (e) {
                            return e.isPlaying
                        });
                        return e[0] || !1
                    }
                }, {
                    key: "onProgressBarClick",
                    value: function (e, t) {
                        var n = (e.pageX - t.progress.getBoundingClientRect().left) / t.progress.offsetWidth;
                        t.player.currentTime = n * t.player.duration, this.translateProgressBar(t)
                    }
                }, {
                    key: "onVideoEnd",
                    value: function (e) {
                        this.stopAudio(e)
                    }
                }, {
                    key: "stopAudio",
                    value: function (e) {
                        e.isPlaying = !1, e.player.pause(), this.currentAudio.stateButton.pause(e.player.currentTime), this.onPause()
                    }
                }, {
                    key: "getAudio",
                    value: function (e, t) {
                        var n = this.getChild(e, "player");
                        return {
                            elem: e,
                            isPlaying: !1,
                            player: n,
                            progress: this.getChild(e, "progress"),
                            progressInner: this.getChild(e, "progress-inner"),
                            progressInnerBar: this.getChild(e, "progress-inner-bar"),
                            duration: 0,
                            id: t,
                            isLarge: "large" == e.getAttribute("data-type"),
                            animFrame: null,
                            time: {
                                curr: this.getChild(e, "curr-time")
                            },
                            stateButton: new f["default"]({
                                elem: this.getChild(e, "state-button"),
                                duration: 0
                            })
                        }
                    }
                }, {
                    key: "togglePlayState",
                    value: function (e) {
                        var t = this.getPlayingAudio();
                        t && t.id != e.id && this.stopAudio(t), e.isPlaying ? this.stopAudio(e) : (e.isPlaying = !0, e.player.play(), this.currentAudio = e, this.currentAudio.stateButton.play(), this.onPlay())
                    }
                }, {
                    key: "translateProgressBar",
                    value: function (e) {
                        e.time.curr.innerHTML = (0, d.secAsMMSS)(e.player.currentTime);
                        var t = e.player.currentTime / e.player.duration,
                            n = e.progressInnerBar.offsetWidth,
                            i = t * n,
                            r = t < .015 || t > .93 ? 0 : 1;
                        e.time.curr.style.opacity = r, e.time.curr.style["" + (0, h.getPrefix)("transform")] = "translate3d(" + i + "px, 0px, 0px)", e.progressInnerBar.style["" + (0, h.getPrefix)("transform")] = "translate3d(" + i + "px, 0px, 0px)"
                    }
                }, {
                    key: "onPlay",
                    value: function () {
                        this.currentAudio.isLarge ? this.translateProgressBar(this.currentAudio) : this.currentAudio.stateButton.update(this.currentAudio.player.currentTime), this.currentAudio.animFrame = (0, h.requestAnimationFrame)(this.onPlay.bind(this))
                    }
                }, {
                    key: "onPause",
                    value: function () {
                        (0, h.cancelAnimationFrame)(this.currentAudio.animFrame), this.currentAudio = !1
                    }
                }, {
                    key: "prepareOnLoad",
                    value: function (e) {
                        var t = this;
                        0 === e.player.readyState ? e.player.addEventListener("loadedmetadata", function () {
                            t.onLoadedMeta(e)
                        }) : e.player.readyState >= 1 && this.onLoadedMeta(e)
                    }
                }, {
                    key: "onLoadedMeta",
                    value: function (e) {
                        e.duration = e.player.duration, e.stateButton.duration = e.duration, e.isLarge, this.setEventListeners(e)
                    }
                }]), t
            }(c["default"]);
        n["default"] = m
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/components/audio-play-button": 2,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax": 21,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper": 23,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix": 25,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap": 35
    }],
    4: [function (e, t, n) {
        "use strict";

        function i(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }

        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function a(e, t) {
            if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t || "object" != typeof t && "function" != typeof t ? e : t
        }

        function o(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var s = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            l = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper"),
            c = i(l),
            u = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/scroll"),
            h = i(u),
            d = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils"),
            p = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap"),
            f = function (e) {
                function t(e, n) {
                    r(this, t);
                    var i = a(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
                    return i._scroll = new h["default"], i._scrollID = -1, i._scrollTop = 0, i._defaultColor = n.defaultColors.background || "#ffffff", i._defaultTextColor = n.defaultColors.text || "black", i.header = document.querySelector(".c-header"), i.body = document.body, i.colorStops = (0, d.mapElems)(i.block, i.getColorStop.bind(i)), i.isPresent && i.setEventListeners(), i.setDefaultState(i._defaultColor, i._defaultTextColor), i
                }
                return o(t, e), s(t, [{
                    key: "_setDefaultState",
                    value: function () {
                        this.setDefaultState(this._defaultColor, this._defaultTextColor)
                    }
                }, {
                    key: "getColorStop",
                    value: function (e, t) {
                        var n = e.getAttribute("data-bg"),
                            i = e.getAttribute("data-color");
                        return {
                            elem: e,
                            active: !1,
                            nextEl: this.block[t + 1] || !1,
                            index: t,
                            colors: {
                                bg: "default" == n ? this._defaultColor : n,
                                text: "default" == i ? this._defaultTextColor : i
                            }
                        }
                    }
                }, {
                    key: "getColorStopByBgHex",
                    value: function (e) {
                        var t = this.colorStops.filter(function (t) {
                            if (e == t.colors.bg) return t
                        });
                        return !!t.length && t[0]
                    }
                }, {
                    key: "setEventListeners",
                    value: function () {
                        this._scrollID = this._scroll.addListener(this._onScroll.bind(this), "color stop")
                    }
                }, {
                    key: "stop",
                    value: function () {
                        this._scroll.removeListener(this._scrollID)
                    }
                }, {
                    key: "_onScroll",
                    value: function (e) {
                        this._scrollTop = e, this._checkForElementInViewport()
                    }
                }, {
                    key: "_checkForElementInViewport",
                    value: function () {
                        var e = this;
                        this.colorStops.forEach(function (t, n) {
                            if (null !== t.elem.offsetParent) {
                                var i = e.hasScrolledPass(t.elem, t.nextEl, t.index);
                                i && !t.active ? (e.setAllToActiveFalse(), e.setState(t, !0, t.colors.bg, t.colors.text)) : !i && t.active && (e.somethingInVp() || e.setState(t, !1, e._defaultColor, e._defaultTextColor))
                            }
                        })
                    }
                }, {
                    key: "somethingInVp",
                    value: function () {
                        return this.colorStops.some(function (e) {
                            var t = e.elem.getBoundingClientRect().top,
                                n = (0, d.getInnerHeight)() / 2,
                                i = t <= n;
                            return i && e.elem.offsetParent
                        })
                    }
                }, {
                    key: "changeManually",
                    value: function (e, t) {
                        var n = this.getColorStopByBgHex(e);
                        this.setState(n, !0, n.colors.bg, n.colors.text)
                    }
                }, {
                    key: "setDefaultState",
                    value: function (e, t) {
                        var n = "white" == t ? "#fff" : "#000";
                        p.TweenLite.set(this.body.style, {
                            backgroundColor: e,
                            color: n
                        }), "white" == t ? this.body.classList.add("dark-bg") : this.body.classList.remove("dark-bg"), this.body.style.setProperty("--bg-color", e), this.body.style.setProperty("--text-color", n)
                    }
                }, {
                    key: "setState",
                    value: function (e, t, n, i) {
                        var r = this;
                        e.active = t;
                        var a = "white" == i ? "#fff" : "#000";
                        this.body.style.willChange = "background-color, color", p.TweenLite.to(this.body.style, .35, {
                            backgroundColor: n,
                            color: a,
                            ease: Power0.easeNone,
                            onComplete: function () {
                                r.body.style.willChange = "auto"
                            }
                        }), "white" == i ? this.body.classList.add("dark-bg") : this.body.classList.remove("dark-bg"), this.body.style.setProperty("--bg-color", n), this.body.style.setProperty("--text-color", a)
                    }
                }, {
                    key: "setAllToActiveFalse",
                    value: function () {
                        this.colorStops.forEach(function (e) {
                            e.active = !1
                        })
                    }
                }, {
                    key: "hasScrolledPass",
                    value: function (e, t, n) {
                        var i = 0,
                            r = !1;
                        if (null === t.offsetParent && e.offsetParent) {
                            for (var a = n + 1; a < this.colorStops.length; a++)
                                if (this.colorStops[a].elem.offsetParent) {
                                    r = this.colorStops[a].elem, i = r.getBoundingClientRect().top;
                                    break
                                }
                        } else t && (r = t, i = r.getBoundingClientRect().top);
                        var o = e.getBoundingClientRect().top,
                            s = (0, d.getInnerHeight)() / 2,
                            l = !r || i >= s,
                            c = o <= s && l;
                        return c
                    }
                }]), t
            }(c["default"]);
        n["default"] = f
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper": 23,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/scroll": 27,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap": 35
    }],
    5: [function (e, t, n) {
        "use strict";

        function i(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }

        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function a(e, t) {
            if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t || "object" != typeof t && "function" != typeof t ? e : t
        }

        function o(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var s = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            l = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper"),
            c = i(l),
            u = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils"),
            h = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap"),
            d = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing"),
            p = (i(d), e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix")),
            f = function (e) {
                function t(e, n) {
                    r(this, t);
                    var i = a(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
                    return i.isPresent ? (i.cords = {
                        x: 0,
                        y: 0
                    }, i.rotation = 0, i.dotScale = 1, i.scale = 1, i.arrowActive = !1, i.onHover = !1, i.hoveringBannedArea = !1, i.oldState = !1, i.hidden = !0, (0, u.isTouchDevice)() || i.setEventListners(), i) : a(i)
                }
                return o(t, e), s(t, [{
                    key: "setEventListners",
                    value: function () {
                        document.body.addEventListener("mousemove", this.onMouseMove.bind(this)), this.loop()
                    }
                }, {
                    key: "onMouseMove",
                    value: function (e) {
                        this.hidden && (this.block.style.opacity = 1, this.hidden = !1), this.cords.y = (2 * -(e.clientY / window.innerHeight) + 1) * window.innerHeight / 2, this.cords.x = (e.clientX / window.innerWidth * 2 - 1) * window.innerWidth / 2
                    }
                }, {
                    key: "forceAddDot",
                    value: function () {
                        var e = this;
                        this.arrowActive ? h.TweenLite.to(this.block, .2, {
                            opacity: 0,
                            onComplete: function () {
                                e.removeMod(e.block, "arrow"), e.addMod(e.block, "dot"), e.onHover = !0, e.scale = 2, e.arrowActive = !1, h.TweenLite.to(e.block, .2, {
                                    opacity: 1,
                                    delay: .05
                                })
                            }
                        }) : (this.scale = 2, this.onHover = !0)
                    }
                }, {
                    key: "forceRemoveDot",
                    value: function () {
                        this.scale = 1, this.onHover = !1
                    }
                }, {
                    key: "addArrow",
                    value: function () {
                        var e = this;
                        this.hasMod(this.block, "arrow") || h.TweenLite.to(this.block, .2, {
                            opacity: 0,
                            onComplete: function () {
                                e.removeMod(e.block, "dot"), e.addMod(e.block, "arrow"), e.arrowActive = !0, h.TweenLite.to(e.block, .2, {
                                    opacity: 1,
                                    delay: .05
                                })
                            }
                        })
                    }
                }, {
                    key: "removeArrow",
                    value: function () {
                        var e = this;
                        this.hasMod(this.block, "arrow") && h.TweenLite.to(this.block, .2, {
                            opacity: 0,
                            onComplete: function () {
                                e.removeMod(e.block, "arrow"), e.addMod(e.block, "dot"), e.arrowActive = !1, h.TweenLite.to(e.block, .2, {
                                    opacity: 1
                                })
                            }
                        })
                    }
                }, {
                    key: "showCursor",
                    value: function () {
                        this.block.style.display = "block"
                    }
                }, {
                    key: "hideCursor",
                    value: function () {
                        this.block.style.display = "none"
                    }
                }, {
                    key: "loop",
                    value: function () {
                        this.rotation = this.cords.x < 0 && this.arrowActive ? 180 : 0, this.opacity = this.onHover ? .4 : 1;
                        var e = this.scale - this.dotScale;
                        this.dotScale += e / 10, this.elements.dot.style.opacity = this.opacity, this.elements.dot.style["" + (0, p.getPrefix)("transform")] = "scale(" + this.dotScale + ", " + this.dotScale + ")", this.block.style["" + (0, p.getPrefix)("transform")] = "translate3d(" + this.cords.x + "px, " + -this.cords.y + "px, 0px) rotate(" + this.rotation + "deg)", this.reqFrame = (0, p.requestAnimationFrame)(this.loop.bind(this))
                    }
                }]), t
            }(c["default"]);
        n["default"] = f
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper": 23,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix": 25,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing": 29,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap": 35
    }],
    6: [function (e, t, n) {
        "use strict";

        function i(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }

        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function a(e, t) {
            if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t || "object" != typeof t && "function" != typeof t ? e : t
        }

        function o(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var s = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            l = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils"),
            c = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper"),
            u = i(c),
            h = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax"),
            d = i(h),
            p = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/resize"),
            f = i(p),
            m = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap"),
            v = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/hammerjs"),
            g = i(v),
            y = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing"),
            x = i(y),
            b = "https://gusta.ltd",
            _ = new x["default"](.55, .055, .675, .19),
            w = new x["default"](.645, .045, .355, 1),
            M = ["/application/themes/animal/images/napkins/napkin_1.png", 
                 "/application/themes/animal/images/napkins/napkin_2.png", 
                 "/application/themes/animal/images/napkins/napkin_3.png", 
                 "/application/themes/animal/images/napkins/napkin_4.png"],
            T = function (e) {
                function t(e) {
                    r(this, t);
                    var n = a(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
                    return n.isPresent ? (n.canvas = null, n.ctx = {}, n.painting = !1, n.clickX = [], n.clickY = [], n.clickDrag = [], n.isOpen = !1, n.draws = [], n.activeColor = "", n.activeColorId = 3, n.napkinImages = [], n.napkinImagesArray = [], n.oldTextColor = !1, n.napkinAnimation = {
                        out: 0,
                        "in": 0
                    }, n.dimensions = {
                        xlarge: 400,
                        large: 320,
                        small: 250,
                        xsmall: 200
                    }, n.index = 0, n.animations = {
                        napkinOut: !1,
                        napkinIn: !1
                    }, n._resize = new f["default"], n.undoBtn = n.elements.undo, n.sendBtn = n.elements.send, n.colorPicks = (0, l.mapElems)(n.elements.color_pick, n.getColorPick.bind(n)), n.setActiveColor(n.activeColorId), n) : a(n)
                }
                return o(t, e), s(t, [{
                    key: "getDimension",
                    value: function () {
                        var e = (0, l.getMq)(),
                            t = void 0;
                        return t = e.xxsmall ? this.dimensions.xsmall : e.xsmall ? this.dimensions.small : e.large ? this.dimensions.large : this.dimensions.xlarge
                    }
                }, {
                    key: "init",
                    value: function () {
                        var e = this;
                        this.resizeID = this._resize.addListener(this.onResize.bind(this)), this.canvas || this.loadNapkins(function () {
                            e.initCanvas(), e.setEventListeners(), e.redraw()
                        })
                    }
                }, {
                    key: "onResize",
                    value: function () {
                        var e = this.getDimension(),
                            t = e;
                        this.canvas.width = e * window.devicePixelRatio, this.canvas.height = t * window.devicePixelRatio, this.canvas.style.width = e + "px", this.canvas.style.height = t + "px", this.ctx.lineWidth = 3 * window.devicePixelRatio, this.redraw()
                    }
                }, {
                    key: "loadNapkins",
                    value: function (e) {
                        var t = this,
                            n = 0;
                        M.forEach(function (i) {
                            var r = new Image;
                            r.onload = function () {
                                if (n++, t.napkinImages.push(r), n == M.length) {
                                    for (var i = 0; i < 2; i++) t.napkinImagesArray[i] = t.napkinImages[(0, l.randomIntFromInterval)(0, t.napkinImages.length - 1)];
                                    e()
                                }
                            }, r.src = i
                        })
                    }
                }, {
                    key: "initCanvas",
                    value: function () {
                        var e = this.elements.canvas_wrapper;
                        this.canvas = document.createElement("canvas");
                        var t = this.getDimension(),
                            n = t;
                        this.canvas.width = t * window.devicePixelRatio, this.canvas.height = n * window.devicePixelRatio, this.canvas.style.width = t + "px", this.canvas.style.height = n + "px", this.canvas.setAttribute("id", "canvas"), e.appendChild(this.canvas), this.ctx = this.canvas.getContext("2d"), this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio), this.ctx.lineJoin = "round", this.ctx.lineCap = "round", this.ctx.lineWidth = 3 * window.devicePixelRatio, this.elements.playground.style.opacity = 1, this.mc = new g["default"].Manager(this.elements.draw_area, {}), this.mc.add(new g["default"].Pan({
                            direction: g["default"].DIRECTION_ALL,
                            threshold: 0
                        }))
                    }
                }, {
                    key: "setEventListeners",
                    value: function () {
                        var e = this;
                        (0, l.isTouchDevice)() ? (this.mc.on("panmove", this.onPan.bind(this)), this.mc.on("panstart", this.onPanStart.bind(this)), this.mc.on("panend", this.onPanEnd.bind(this)), this.mc.on("pancancel", this.onPanEnd.bind(this))) : (this.elements.draw_area.addEventListener("mousedown", this.onMouseDown.bind(this)), this.elements.draw_area.addEventListener("mousemove", this.onMouseMove.bind(this)), this.elements.draw_area.addEventListener("mouseup", this.onMouseUp.bind(this)), this.elements.draw_area.addEventListener("mouseleave", this.onMouseLeave.bind(this))), this.undoBtn.addEventListener("click", this.onUndoBtnClicked.bind(this)), this.sendBtn.addEventListener("click", this.sendImage.bind(this)),
                            this.elements.draw_again.addEventListener("click", this.onDrawAgainClicked.bind(this)), this.elements.new_napkin.addEventListener("click", this.animateNapkin.bind(this)), this.elements.close.forEach(function (t) {
                                t.addEventListener("click", e.closeModal.bind(e))
                            }), this.colorPicks.forEach(function (t) {
                                t.elem.addEventListener("click", function () {
                                    e.onColorPickClicked(t)
                                })
                            })
                    }
                }, {
                    key: "getColorPick",
                    value: function (e, t) {
                        var n = e.getAttribute("data-color").split(",");
                        return {
                            elem: e,
                            color: {
                                r: n[0],
                                g: n[1],
                                b: n[2]
                            },
                            active: this.childrenHasMod(e, "color-pick", "active"),
                            id: e.getAttribute("data-id")
                        }
                    }
                }, {
                    key: "onColorPickClicked",
                    value: function (e) {
                        this.setActiveColor(e.id)
                    }
                }, {
                    key: "getColorById",
                    value: function (e) {
                        return this.colorPicks.filter(function (t) {
                            return t.id == e
                        })[0]
                    }
                }, {
                    key: "setActiveColor",
                    value: function (e) {
                        var t = this.getColorById(this.activeColorId),
                            n = this.getColorById(e);
                        t.active = !1, n.active = !0, this.elements.color_pickers.appendChild(t.elem), this.elements.color_pickers.removeChild(n.elem), this.activeColorId = n.id, this.activeColor = n.color, this.elements.active_color_pick.style.backgroundColor = "rgb(" + n.color.r + ", " + n.color.g + ", " + n.color.b + ")"
                    }
                }, {
                    key: "onUndoBtnClicked",
                    value: function () {
                        this.draws.splice(this.draws.length - 1, 1), this.redraw()
                    }
                }, {
                    key: "onPan",
                    value: function (e) {
                        var t = 10,
                            n = this.elements.draw_area.getBoundingClientRect(),
                            i = Math.max(t, e.center.x - n.left),
                            r = Math.min(i, this.elements.draw_area.offsetWidth - t),
                            a = Math.max(t, e.center.y - n.top),
                            o = Math.min(a, this.elements.draw_area.offsetHeight - t);
                        this.painting && (this.addClick(r, o, !0), this.redraw())
                    }
                }, {
                    key: "onPanStart",
                    value: function (e) {
                        var t = 10,
                            n = this.elements.draw_area.getBoundingClientRect(),
                            i = Math.max(t, e.center.x - n.left),
                            r = Math.min(i, this.elements.draw_area.offsetWidth - t),
                            a = Math.max(t, e.center.y - n.top),
                            o = Math.min(a, this.elements.draw_area.offsetHeight - t);
                        this.painting = !0, this.initDraw(), this.addClick(r, o), this.redraw()
                    }
                }, {
                    key: "onPanEnd",
                    value: function (e) {
                        this.painting = !1
                    }
                }, {
                    key: "onMouseDown",
                    value: function (e) {
                        var t = this.canvas.getBoundingClientRect(),
                            n = {
                                x: e.clientX - t.left,
                                y: e.clientY - t.top
                            };
                        this.painting = !0, this.initDraw(), this.addClick(n.x, n.y), this.redraw()
                    }
                }, {
                    key: "onMouseMove",
                    value: function (e) {
                        var t = this.canvas.getBoundingClientRect(),
                            n = {
                                x: e.clientX - t.left,
                                y: e.clientY - t.top
                            };
                        this.painting && (this.addClick(n.x, n.y, !0), this.redraw())
                    }
                }, {
                    key: "onMouseUp",
                    value: function () {
                        this.painting = !1
                    }
                }, {
                    key: "onMouseLeave",
                    value: function () {
                        this.painting = !1
                    }
                }, {
                    key: "initDraw",
                    value: function () {
                        this.draws.push({
                            clickX: [],
                            clickY: [],
                            clickDrag: [],
                            color: this.activeColor
                        })
                    }
                }, {
                    key: "addClick",
                    value: function (e, t, n) {
                        var i = this.draws[this.draws.length - 1];
                        i.clickX.push(e * window.devicePixelRatio), i.clickY.push(t * window.devicePixelRatio), i.clickDrag.push(n)
                    }
                }, {
                    key: "drawImageCenter",
                    value: function (e, t, n, i, r, a, o) {
                        this.ctx.setTransform(a, 0, 0, a, t, n), this.ctx.rotate(o * Math.PI / 180), this.ctx.drawImage(e, -i, -r)
                    }
                }, {
                    key: "getNapkinDimension",
                    value: function () {
                        var e = this.getDimension();
                        return e * window.devicePixelRatio
                    }
                }, {
                    key: "redraw",
                    value: function () {
                        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
                        for (var e = {
                                x: 80 * this.napkinAnimation.out,
                                alpha: 1 - 1 * this.napkinAnimation.out
                            }, t = {
                                x: 30 * this.napkinAnimation["in"],
                                y: 5 * this.napkinAnimation["in"],
                                scale: .05 * this.napkinAnimation["in"]
                            }, n = this.ctx.canvas.width / 2, i = this.ctx.canvas.height / 2, r = 0; r < 2; r++) {
                            var a = this.napkinImagesArray[r];
                            1 == r ? (this.ctx.globalAlpha = e.alpha, this.drawImageCenter(a, n - e.x, i, a.width / 2, a.height / 2, this.getNapkinDimension() / a.width, 0), this.ctx.globalAlpha = 1) : this.drawImageCenter(a, n, i, a.width / 2, a.height / 2, this.getNapkinDimension() / a.width * (.95 + t.scale), 0)
                        }
                        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                        for (var o = 0; o < this.draws.length; o++) {
                            this.ctx.strokeStyle = "rgba(" + this.draws[o].color.r + ", " + this.draws[o].color.g + ", " + this.draws[o].color.b + ", " + e.alpha + ")";
                            for (var s = 0; s < this.draws[o].clickX.length; s++) this.ctx.beginPath(), this.draws[o].clickDrag[s] && s ? this.ctx.moveTo(this.draws[o].clickX[s - 1] - e.x, this.draws[o].clickY[s - 1]) : this.ctx.moveTo(this.draws[o].clickX[s] - 1 - e.x, this.draws[o].clickY[s]), this.ctx.lineTo(this.draws[o].clickX[s] - e.x, this.draws[o].clickY[s]), this.ctx.closePath(), this.ctx.stroke()
                        }
                    }
                }, {
                    key: "animateNapkin",
                    value: function () {
                        var e = this;
                        this.animations.napkinOut || this.animations.napkinIn || (this.animations.napkinOut = !0, m.TweenLite.to(this.napkinAnimation, .35, {
                            out: 1,
                            ease: _,
                            onUpdate: function () {
                                e.redraw()
                            },
                            onComplete: function () {
                                e.animations.napkinOut = !1, e.draws = [], e.animateNewNapkin()
                            }
                        }))
                    }
                }, {
                    key: "animateNewNapkin",
                    value: function () {
                        var e = this;
                        this.animations.napkinIn = !0, m.TweenLite.to(this.napkinAnimation, .3, {
                            "in": 1,
                            ease: w,
                            onUpdate: function () {
                                e.redraw()
                            },
                            onComplete: function () {
                                e.animations.napkinIn = !1, e.napkinAnimation.out = 0, e.napkinAnimation["in"] = 0, e.index++, e.napkinImagesArray.splice(e.napkinImagesArray.length - 1, 1), e.napkinImagesArray.unshift(e.napkinImages[(0, l.randomIntFromInterval)(0, e.napkinImages.length - 1)]), e.redraw()
                            }
                        })
                    }
                }, {
                    key: "sendImage",
                    value: function () {
                        var e = this,
                            t = this.canvas.toDataURL(),
                            n = {
                                action: "save_drawing",
                                data_uri: t
                            };
                        m.TweenLite.to(this.elements.playground, .4, {
                            opacity: 0,
                            onComplete: function () {
                                e.postImage(n, function (t) {
                                    e.removeChildrenMod(e.elements.playground, "playground", "show"), e.addChildrenMod(e.elements.success, "success", "show"), e.draws = [], e.redraw(), m.TweenLite.to(e.elements.success, .4, {
                                        opacity: 1
                                    })
                                })
                            }
                        })
                    }
                }, {
                    key: "onDrawAgainClicked",
                    value: function () {
                        var e = this;
                        this.draws = [], this.redraw(), m.TweenLite.to(this.elements.success, .4, {
                            opacity: 0,
                            onComplete: function () {
                                e.removeChildrenMod(e.elements.success, "success", "show"), e.addChildrenMod(e.elements.playground, "playground", "show"), m.TweenLite.to(e.elements.playground, .4, {
                                    opacity: 1
                                })
                            }
                        })
                    }
                }, {
                    key: "postImage",
                    value: function (e, t) {
                        /*d["default"].post("/wp/wp-admin/admin-ajax.php", e, {
                            onSuccess: function (e) {
                                var n = {
                                        attachments: [{
                                            fallback: "New napkin",
                                            color: "#2eb886",
                                            author_name: "Drawing",
                                            image_url: b + "/application/themes/animal/drawings/" + e.filename,
                                            ts: Math.floor(Date.now() / 1e3)
                                        }]
                                    },
                                    i = "https://hooks.slack.com/services/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";
                                d["default"].post(i, JSON.stringify(n), {
                                    onSuccess: function (e) {
                                        t(e)
                                    },
                                    processData: !1,
                                    json: !1,
                                    formData: !0
                                })
                            }
                        })*/
                    }
                }, {
                    key: "closeModal",
                    value: function () {
                        var e = this;
                        this.isOpen = !1, this._resize.removeListener(this.resizeID), document.body.style.setProperty("--text-color", this.oldTextColor), this.elements.playground.style.opacity = 0;
                        var t = this.childrenHasMod(this.elements.playground, "playground", "show") ? .25 : 0;
                        m.TweenLite.to(this.block, .25, {
                            opacity: 0,
                            delay: t,
                            onComplete: function () {
                                e.draws = [], e.redraw(), e.block.style.display = "none", e.removeChildrenMod(e.elements.success, "success", "show"), e.addChildrenMod(e.elements.playground, "playground", "show")
                            },
                            onStart: function () {
                                e.noScrollToggle(!1)
                            }
                        })
                    }
                }, {
                    key: "openModal",
                    value: function () {
                        var e = this;
                        this.isOpen = !0, this.block.style.display = "block", this.oldTextColor = document.body.style.getPropertyValue("--text-color"), document.body.style.setProperty("--text-color", "#fff"), m.TweenLite.to(this.block, .25, {
                            opacity: 1,
                            onComplete: function () {
                                e.noScrollToggle(!0), e.elements.playground.style.opacity = 1, e.addChildrenMod(e.elements.playground, "playground", "show"), e.init()
                            }
                        })
                    }
                }, {
                    key: "noScrollToggle",
                    value: function (e) {
                        var t = (0, l.isTouchDevice)() ? "noscroll" : "menu-no-scroll";
                        e ? document.documentElement.classList.add(t) : document.documentElement.classList.remove(t)
                    }
                }]), t
            }(u["default"]);
        n["default"] = T
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax": 21,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper": 23,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/resize": 26,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing": 29,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap": 35,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/hammerjs": 36
    }],
    7: [function (e, t, n) {
        "use strict";

        function i(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }

        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function a(e, t) {
            if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t || "object" != typeof t && "function" != typeof t ? e : t
        }

        function o(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var s = Object.assign || function (e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
                }
                return e
            },
            l = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            c = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper"),
            u = i(c),
            h = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils"),
            d = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/scroll"),
            p = i(d),
            f = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap"),
            m = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing"),
            v = i(m),
            g = new v["default"](.365, .305, 0, 1),
            y = function (e) {
                function t(e, n) {
                    r(this, t);
                    var i = a(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
                    return i.isPresent ? (i.isOpen = !1, i.isAnimating = !1, i.drawingAppEnabled = !1, i.logoIsHidden = !1, i.oldTextColor = !1, i._scroll = new p["default"], i.hasLogoTitle = !1, i.hasLightHero = !1, i.hero = !1, i.actions = (0, h.mapElems)(i.elements.action, i.getAction.bind(i)), i.curtainEase = new v["default"](.645, .045, .355, 1), i.headlineEaseIn = new v["default"](.215, .61, .355, 1), i.headlineEaseOut = new v["default"](.55, .055, .675, .19), i.textElements = {
                        left: {
                            headline: i.elements.mid_nav_left.querySelector(".o-animation--headline")
                        },
                        right: {
                            headline: i.elements.mid_nav_right.querySelector(".o-animation--headline")
                        }
                    }, f.TweenLite.set(i.textElements.left.headline, {
                        skewY: 7,
                        y: 80,
                        opacity: 0
                    }), f.TweenLite.set(i.textElements.right.headline, {
                        skewY: 7,
                        y: 80,
                        opacity: 0
                    }), i.onActionClicked = n.onActionClicked, i.setEventListeners(), i) : a(i)
                }
                return o(t, e), l(t, [{
                    key: "setEventListeners",
                    value: function () {
                        var e = this;
                        this.elements.burger.addEventListener("click", this.onBurgerClick.bind(this)), this.elements.action.length ? this.elements.action.forEach(function (t) {
                            t.addEventListener("click", function () {
                                e.onActionClick(t)
                            })
                        }) : this.elements.action.addEventListener("click", function () {
                            e.onActionClick(e.elements.action)
                        }), document.addEventListener("touchmove", function (t) {
                            e.isOpen && t.preventDefault()
                        }, {
                            passive: !1
                        }), this._scroll.addListener(function () {
                            if (e.hero) {
                                var t = ((0, h.getInnerHeight)(), e.hero.getBoundingClientRect().top);
                                if (e.hasLightHero) {
                                    var n = e.hasMod(e.block, "light-hero");
                                    Math.abs(t) >= e.hero.offsetHeight && n ? e.removeMod(e.block, "light-hero") : !n && Math.abs(t) < e.hero.offsetHeight && e.addMod(e.block, "light-hero")
                                } else e.hasMod(e.block, "light-hero") && e.removeMod(e.block, "light-hero");
                                if (e.hasLogoTitle) {
                                    var i = e.childrenHasMod(e.elements.logo_title_wrapper, "logo-title-wrapper", "hidden");
                                    Math.abs(t) >= 150 && !i ? e.addChildrenMod(e.elements.logo_title_wrapper, "logo-title-wrapper", "hidden") : i && Math.abs(t) < 150 && e.removeChildrenMod(e.elements.logo_title_wrapper, "logo-title-wrapper", "hidden")
                                } else e.removeMod(e.elements.logo_title_wrapper, "hidden")
                            } else {
                                var r = e.childrenHasMod(e.elements.logo, "logo", "hidden"),
                                    a = window.pageYOffset;
                                a >= 150 && !r && !e.isOpen && !e.isAnimating ? (e.addChildrenMod(e.elements.logo, "logo", "hidden"), e.logoIsHidden = !0) : r && a < 150 && !e.isAnimating && (e.removeChildrenMod(e.elements.logo, "logo", "hidden"), e.logoIsHidden = !1)
                            }
                        }, "header")
                    }
                }, {
                    key: "getAction",
                    value: function (e) {
                        return {
                            elem: e,
                            id: e.getAttribute("data-actionid"),
                            active: !1
                        }
                    }
                }, {
                    key: "getActiveAction",
                    value: function () {
                        return this.actions.filter(function (e) {
                            return e.active
                        })[0]
                    }
                }, {
                    key: "getActionByIndex",
                    value: function (e) {
                        return this.actions.filter(function (t) {
                            return t.id == e
                        })[0]
                    }
                }, {
                    key: "onActionClick",
                    value: function (e) {
                        var t = e.getAttribute("data-actiontype");
                        this.onActionClicked(t)
                    }
                }, {
                    key: "onBurgerClick",
                    value: function () {
                        this.isAnimating || (this.isOpen ? (this.headerWhenOpened(!1), this.close()) : (this.headerWhenOpened(!0), this.open()))
                    }
                }, {
                    key: "open",
                    value: function () {
                        var e = this;
                        this.setActiveAction("page"), document.documentElement.classList.add("menu-no-scroll"), this.removeChildrenMod(this.elements.logo, "logo", "hidden"), this.isOpen = !0, this.elements.nav.style.display = "block", this.addMod(this.block, "open"), this.addMod(this.block, "burger-close"), this.isAnimating = !0, f.TweenLite.to(this.elements.nav_bg, .75, {
                            yPercent: 100,
                            ease: this.curtainEase
                        }), f.TweenLite.to(this.elements.nav_inner, .4, {
                            opacity: 1,
                            onComplete: function () {
                                e.animateInHeadline(function () {
                                    e.isAnimating = !1
                                }), f.TweenLite.to(e.elements.animate_in, .35, {
                                    opacity: 1,
                                    y: 0,
                                    delay: .4,
                                    ease: e.headlineEaseIn
                                }), f.TweenLite.to([e.elements.bottom_nav_line, e.elements.top_nav_line], .85, {
                                    xPercent: 100,
                                    ease: g
                                }), f.TweenLite.to(e.elements.mid_line, .85, e.getMidLineAnimationObj()["in"])
                            }
                        })
                    }
                }, {
                    key: "close",
                    value: function () {
                        var e = this,
                            t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        this.isOpen = !1, this.removeMod(this.block, "burger-close"), document.documentElement.classList.remove("menu-no-scroll"), this.isAnimating = !0;
                        var n = .85,
                            i = .45,
                            r = .2,
                            a = .35;
                        t ? (f.TweenLite.set([this.elements.bottom_nav_line, this.elements.top_nav_line], {
                            xPercent: 0
                        }), f.TweenLite.set(this.elements.mid_line, this.getMidLineAnimationObj().out), f.TweenLite.set(this.elements.nav_bg, {
                            yPercent: 0
                        }), f.TweenLite.set(this.elements.animate_in, {
                            opacity: 0,
                            y: 15
                        }), f.TweenLite.set(this.elements.nav_inner, {
                            opacity: 0
                        }), f.TweenLite.set(this.block, {
                            backgroundColor: "transparent"
                        }), this.animateOutHeadline(t), this.elements.nav.style.display = "none", this.removeMod(this.block, "open"), this.isAnimating = !1) : (this.removeMod(this.block, "open"), f.TweenLite.to([this.elements.bottom_nav_line, this.elements.top_nav_line], n, {
                            xPercent: 0,
                            ease: g,
                            delay: 0
                        }), f.TweenLite.to(this.elements.mid_line, i, this.getMidLineAnimationObj().out), f.TweenLite.to(this.elements.animate_in, a, {
                            opacity: 0,
                            delay: 0,
                            ease: this.headlineEaseOut,
                            y: 15
                        }), this.animateOutHeadline(t), f.TweenLite.to(this.elements.nav_inner, r, {
                            opacity: 0,
                            delay: .4,
                            onComplete: function () {
                                f.TweenLite.to(e.elements.nav_bg, .75, {
                                    yPercent: 0,
                                    ease: e.curtainEase,
                                    onComplete: function () {
                                        f.TweenLite.to(e.block, .3, {
                                            backgroundColor: "transparent"
                                        }), e.elements.nav.style.display = "none", !t && e.logoIsHidden && e.addChildrenMod(e.elements.logo, "logo", "hidden"), e.setActiveAction(document.getElementById("action-type").value), e.isAnimating = !1
                                    }
                                })
                            }
                        }))
                    }
                }, {
                    key: "animateInHeadline",
                    value: function (e) {
                        f.TweenLite.to(this.textElements.left.headline, .8, {
                            opacity: 1,
                            y: 0,
                            skewY: 0,
                            ease: this.headlineEaseIn
                        }), f.TweenLite.to(this.textElements.right.headline, .8, {
                            opacity: 1,
                            y: 0,
                            skewY: 0,
                            ease: this.headlineEaseIn,
                            onComplete: e.bind(this)
                        })
                    }
                }, {
                    key: "animateOutHeadline",
                    value: function (e) {
                        e ? f.TweenLite.set([this.textElements.right.headline, this.textElements.left.headline], {
                            opacity: 0,
                            skewY: 7,
                            y: 80
                        }) : (f.TweenLite.to(this.textElements.left.headline, .5, {
                            opacity: 0,
                            delay: .1,
                            y: 80,
                            skewY: 7,
                            ease: this.headlineEaseOut
                        }), f.TweenLite.to(this.textElements.right.headline, .5, {
                            opacity: 0,
                            delay: .1,
                            skewY: 7,
                            y: 80,
                            ease: this.headlineEaseOut
                        }))
                    }
                }, {
                    key: "getMidLineAnimationObj",
                    value: function () {
                        var e = {};
                        e = (0, h.getMq)().small ? {
                            "in": {
                                xPercent: 100,
                                delay: .3
                            },
                            out: {
                                xPercent: 0,
                                delay: 0
                            }
                        } : {
                            "in": {
                                yPercent: -100,
                                delay: .3
                            },
                            out: {
                                yPercent: 0,
                                delay: 0
                            }
                        };
                        var t = {
                                ease: g
                            },
                            n = {
                                "in": s(e["in"], t),
                                out: s(e.out, t)
                            };
                        return n
                    }
                }, {
                    key: "setActiveAction",
                    value: function (e) {
                        var t = this,
                            n = e,
                            i = this.getActiveAction(),
                            r = this.getActionByIndex(n);
                        i && i.id != r.id ? this.animate(i.elem, .2, 0, function () {
                            t.removeChildrenMod(i.elem, "action", "show"), i.active = !1, r.active = !0, t.addChildrenMod(r.elem, "action", "show"), t.animate(r.elem, .2, 1)
                        }) : i || (r.active = !0, this.addChildrenMod(r.elem, "action", "show"), this.animate(r.elem, .2, 1))
                    }
                }, {
                    key: "beforeSetHeader",
                    value: function () {
                        var e = this,
                            t = this.elements.logo_title.style.opacity;
                        t && this.animate(this.elements.logo_title, .3, 0, function () {
                            e.elements.logo_title.innerHTML = ""
                        })
                    }
                }, {
                    key: "animateOutLogo",
                    value: function () {
                        this.animate(this.elements.logo_image, .3, 0)
                    }
                }, {
                    key: "setHeader",
                    value: function () {
                        var e = this,
                            t = this.elements.logo_image.style.opacity,
                            n = this.elements.logo_title.style.opacity,
                            i = document.getElementById("header-title").value,
                            r = "" != i;
                        this.setActiveAction(document.getElementById("action-type").value), this.hasLightHero = !(!document.querySelector(".o-main-wrapper--has-light-hero") || !r), this.hero = !!r && document.querySelector(".c-hero"), this.hasLightHero ? this.addMod(this.block, "light-hero") : this.removeMod(this.block, "light-hero"), r ? (t ? (this.elements.logo_title.innerHTML = i, this.animate(this.elements.logo_image, .3, 0, function () {
                            e.animate(e.elements.logo_title, .3, 1, !1, .3)
                        })) : this.animate(this.elements.logo_title, .3, 0, function () {
                            e.elements.logo_title.innerHTML = i, e.animate(e.elements.logo_title, .3, 1, !1, 0)
                        }), this.addChildrenMod(this.elements.logo_image, "logo-image", "hidden"), this.hasLogoTitle = !0) : (n ? this.animate(this.elements.logo_title, .3, 0, function () {
                            e.elements.logo_title.innerHTML = "", e.animate(e.elements.logo_image, .3, 1)
                        }) : this.animate(this.elements.logo_image, .3, 1), this.removeChildrenMod(this.elements.logo_image, "logo-image", "hidden"), this.hasLogoTitle = !1)
                    }
                }, {
                    key: "headerWhenOpened",
                    value: function (e) {
                        var t = this,
                            n = this.elements.logo_title.style.opacity,
                            i = document.getElementById("header-title").value;
                        e && n ? this.animate(this.elements.logo_title, .3, 0, function () {
                            t.animate(t.elements.logo_image, .3, 1), t.removeChildrenMod(t.elements.logo_image, "logo-image", "hidden")
                        }) : e || "" == i || this.animate(this.elements.logo_image, .3, 0, function () {
                            t.animate(t.elements.logo_title, .3, 1), t.addChildrenMod(t.elements.logo_image, "logo-image", "hidden")
                        })
                    }
                }, {
                    key: "animate",
                    value: function (e, t, n) {
                        var i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                            r = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
                        f.TweenLite.to(e, t, {
                            opacity: n,
                            delay: r,
                            onComplete: function () {
                                i && i()
                            }
                        })
                    }
                }, {
                    key: "drawingAppOpen",
                    value: function () {
                        this.drawingAppEnabled = !0
                    }
                }, {
                    key: "drawingAppClosed",
                    value: function () {
                        this.drawingAppEnabled = !1
                    }
                }]), t
            }(u["default"]);
        n["default"] = y
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper": 23,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/scroll": 27,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing": 29,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap": 35
    }],
    8: [function (e, t, n) {
        "use strict";

        function i(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }

        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function a(e, t) {
            if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t || "object" != typeof t && "function" != typeof t ? e : t
        }

        function o(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var s = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            l = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper"),
            c = i(l),
            u = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils"),
            h = (e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap"), e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing")),
            d = (i(h), e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix"), e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/canvid")),
            p = i(d),
            f = {
                conga: {
                    width: 1980,
                    height: 1400,
                    frames: 18,
                    cols: 4,
                    fps: 10,
                    delay: !1,
                    loaded: !1
                },
                group: {
                    width: 712,
                    height: 720,
                    frames: 15,
                    cols: 5,
                    fps: 10,
                    delay: !1,
                    loaded: !1
                },
                thunder: {
                    width: 720,
                    height: 738,
                    frames: 12,
                    cols: 4,
                    fps: 10,
                    delay: !1,
                    loaded: !1
                },
                tree: {
                    width: 800,
                    height: 952,
                    frames: 13,
                    cols: 4,
                    fps: 10,
                    delay: !0,
                    loaded: !1
                },
                pudding: {
                    width: 820,
                    height: 579,
                    frames: 13,
                    cols: 4,
                    fps: 10,
                    delay: !0,
                    loaded: !1
                }
            },
            m = function (e) {
                function t(e, n) {
                    r(this, t);
                    var i = a(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
                    return i.isPresent ? (i.onloaded = n.onloaded, i.illustrations = (0, u.mapElems)(i.block, i.getIllustration.bind(i)), i.preloadSequences(function () {
                        i.onloaded(), i.init()
                    }), i) : a(i)
                }
                return o(t, e), s(t, [{
                    key: "getIllustration",
                    value: function (e, t) {
                        return {
                            elem: e,
                            src: e.getAttribute("data-sprite"),
                            type: e.getAttribute("data-type"),
                            video: !1
                        }
                    }
                }, {
                    key: "preloadSequences",
                    value: function (e) {
                        var t = this,
                            n = 0;
                        this.illustrations.forEach(function (i) {
                            if (f[i.type].loaded) n++, n == t.illustrations.length && e();
                            else {
                                var r = new Image;
                                r.src = i.src, r.onload = function () {
                                    n++, f[i.type].loaded = !0, n == t.illustrations.length && e()
                                }
                            }
                        })
                    }
                }, {
                    key: "init",
                    value: function () {
                        this.illustrations.forEach(function (e) {
                            var t = f[e.type],
                                n = {
                                    src: e.src,
                                    frames: t.frames,
                                    cols: t.cols,
                                    fps: t.fps,
                                    onEnd: function () {
                                        setTimeout(function () {
                                            e.video.play("illustration")
                                        }, 2e3)
                                    }
                                };
                            t.delay && (n.loops = 1), e.video = (0, p["default"])({
                                selector: e.elem,
                                videos: {
                                    illustration: n
                                },
                                width: t.width,
                                height: t.height,
                                loaded: function () {
                                    e.video.play("illustration")
                                }
                            })
                        })
                    }
                }, {
                    key: "destroyAll",
                    value: function () {
                        this.illustrations.forEach(function (e) {
                            e.video && e.video.destroy()
                        })
                    }
                }]), t
            }(c["default"]);
        n["default"] = m
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper": 23,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix": 25,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing": 29,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/canvid": 31,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap": 35
    }],
    9: [function (e, t, n) {
        "use strict";

        function i(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }

        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function a(e, t) {
            if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t || "object" != typeof t && "function" != typeof t ? e : t
        }

        function o(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var s = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            l = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper"),
            c = i(l),
            u = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils"),
            h = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap"),
            d = function (e) {
                function t(e, n) {
                    r(this, t);
                    var i = a(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
                    return i.isPresent ? (i.disclaimers = (0, u.mapElems)(i.block, i.getDisclaimer.bind(i)), i) : a(i)
                }
                return o(t, e), s(t, [{
                    key: "init",
                    value: function () {
                        var e = this;
                        this.disclaimers.forEach(function (t) {
                            "true" != (0, u.getCookie)(t.cookie) ? (e.animateIn(t.block), document.body.classList.add("cookie-display")) : t.block.style.display = "none"
                        }), this.setEventListeners()
                    }
                }, {
                    key: "getDisclaimer",
                    value: function (e) {
                        return {
                            block: e,
                            cookie: e.getAttribute("data-cookie"),
                            closeButton: this.getChildren(e, "close")
                        }
                    }
                }, {
                    key: "setEventListeners",
                    value: function () {
                        var e = this;
                        this.disclaimers.forEach(function (t) {
                            t.closeButton.addEventListener("click", function () {
                                e.onCloseClicked(t)
                            })
                        })
                    }
                }, {
                    key: "animateIn",
                    value: function (e) {
                        h.TweenLite.to(e, .25, {
                            opacity: 1,
                            delay: 1
                        })
                    }
                }, {
                    key: "onCloseClicked",
                    value: function (e) {
                        h.TweenLite.to(e.block, .25, {
                            opacity: 0,
                            onComplete: function () {
                                (0, u.setCookie)(e.cookie, "true", 365), e.block.style.display = "none", document.body.classList.remove("cookie-display")
                            }
                        })
                    }
                }]), t
            }(c["default"]);
        n["default"] = d
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper": 23,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap": 35
    }],
    10: [function (e, t, n) {
        "use strict";

        function i(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }

        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function a(e, t) {
            if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t || "object" != typeof t && "function" != typeof t ? e : t
        }

        function o(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var s = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            l = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper"),
            c = i(l),
            u = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax"),
            h = i(u),
            d = (e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap"), function (e) {
                function t(e, n) {
                    r(this, t);
                    var i = a(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
                    return i.isPresent ? (i.elements.load_more && (i.offset = parseInt(i.elements.load_more.getAttribute("data-offset"))), i.setEventListeners(), i) : a(i)
                }
                return o(t, e), s(t, [{
                    key: "setEventListeners",
                    value: function () {
                        this.elements.load_more && this.elements.load_more.addEventListener("click", this.onLoadMoreClick.bind(this))
                    }
                }, {
                    key: "onLoadMoreClick",
                    value: function () {
                        var e = this,
                            t = {
                                action: "get_articles",
                                offset: this.offset
                            };
                        h["default"].post("/wp/wp-admin/admin-ajax.php", t, {
                            onSuccess: function (t) {
                                t.articles.forEach(function (t) {
                                    var n = '\n                        <div class="o-fb-col o-fb-col--4 o-fb-col--sm-6 o-fb-col--xs-8 o-fb-col--xs-offset-2 u-tac c-latest__col">\n                            <a class="c-latest__item-anchor" href="' + t.permalink + '">\n                                ' + e.getMedia(t) + '\n                                <h2 class="o-typo--ff-headline o-typo--fs-medium o-gutter--mt-small">\n                                    ' + e.getTitle(t) + '\n                                </h2>\n                                <span class="o-typo--ff-base o-typo--fs-xsmall o-gutter--mt-xxxsmall u-dblock o-typo--c-light-grey">' + t.type + "</span>\n                            </a>\n                        </div>\n                    ";
                                    e.elements.list.insertAdjacentHTML("beforeend", n)
                                }), e.offset += t.current_offset, t.has_more_posts ? e.elements.load_more.setAttribute("data-offset", e.offset) : e.elements.load_more.style.display = "none"
                            }
                        })
                    }
                }, {
                    key: "getMedia",
                    value: function (e) {
                        var t = e.tn_type;
                        return "video" == t ? "" : "image" == t ? '<img src="' + e.tn_image.url + '" />' : ""
                    }
                }, {
                    key: "getTitle",
                    value: function (e) {
                        return "" != e.title_first_part ? '<span class="o-typo--c-light-grey">' + e.title_first_part + " –</span> " + e.title_second_part : e.title_second_part
                    }
                }, {
                    key: "articlesLoaded",
                    value: function (e, t) {
                        var n = this;
                        this.elements.load_more.querySelector("span").style.opacity = 1, this.elements.load_more_loading_gif.style.opacity = 0, e.news.forEach(function (e) {
                            n.elements.list.insertAdjacentHTML("beforeend", Templating.getTemplate("newsArchiveItem", e))
                        }), this.offset += e.current_offset, this.hideLoadMore(e.has_more_posts)
                    }
                }, {
                    key: "hideLoadMore",
                    value: function (e) {
                        e || (this.elements.load_more.style.display = "none")
                    }
                }]), t
            }(c["default"]));
        n["default"] = d
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax": 21,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper": 23,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap": 35
    }],
    11: [function (e, t, n) {
        "use strict";

        function i(e) {
            if (e && e.__esModule) return e;
            var t = {};
            if (null != e)
                for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
            return t["default"] = e, t
        }

        function r(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }

        function a(e, t) {
            if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t || "object" != typeof t && "function" != typeof t ? e : t
        }

        function o(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
        }

        function s(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function l(e) {
            var t = 167 == e.x && e.y == -57,
                n = 168 == e.x && e.y == -57;
            return t || n
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var c = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            u = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper"),
            h = r(u),
            d = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/raf-loop"),
            p = r(d),
            f = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/brindille-resize"),
            m = r(f),
            v = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils"),
            g = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix"),
            y = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/three"),
            x = i(y),
            b = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/three-bas"),
            _ = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/mouse-speed"),
            w = r(_),
            M = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing"),
            T = r(M),
            E = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap"),
            S = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax"),
            P = r(S),
            C = e("../utils/general-utils"),
            A = new T["default"](.165, .84, .44, 1),
            L = new T["default"](.215, .61, .355, 1),
            R = [{
                index: 0,
                url: "/application/themes/animal/images/hero/quote-1.png?v=6",
                loaded: !1,
                image: !1,
                points: !1,
                jsonURL: "/application/themes/animal/js/points-1.json"
            }, {
                index: 1,
                url: "/application/themes/animal/images/hero/quote-2.png?v=5",
                loaded: !1,
                image: !1,
                points: !1,
                jsonURL: "/application/themes/animal/js/points-2.json"
            }, {
                index: 2,
                url: "/application/themes/animal/images/hero/quote-3.png?v=5",
                loaded: !1,
                image: !1,
                points: !1,
                jsonURL: "/application/themes/animal/js/points-3.json"
            }, {
                index: 3,
                url: "/application/themes/animal/images/hero/quote-4.png?v=5",
                loaded: !1,
                image: !1,
                points: !1,
                jsonURL: "/application/themes/animal/js/points-4.json"
            }],
            I = !1,
            O = new x.ImageLoader,
            k = function () {
                function e(t, n, i) {
                    var r = this;
                    s(this, e), this.endPointsCollections = [], this.prefabGeometry = new x.CircleGeometry(1.2, 16), this.prefabCount = 0, this.duration = 1, this.maxPrefabDelay = .5, this.totalDuration = this.duration + this.maxPrefabDelay, this.activePixels = 0, this.activeEndPointsCollection = 0, this.initImages(t, function () {
                        r.geometry = new b.PrefabBufferGeometry(r.prefabGeometry, r.prefabCount), r.initAttributes(), r.setStartEndPos(function () {
                            var e = I ? 0 : 900;
                            setTimeout(function () {
                                I = !0, r.setMaterial(), r.mesh = new x.Mesh(r.geometry, r.material), n()
                            }, e)
                        })
                    })
                }
                return c(e, [{
                    key: "initImages",
                    value: function (e, t) {
                        var n = this,
                            i = 0;
                        e.forEach(function (r, a) {
                            P["default"].get(r.jsonURL, {}, {
                                onSuccess: function (o) {
                                    i++;
                                    var s = void 0;
                                    r.points ? s = r.points : (s = o, r.points = s), n.endPointsCollections.push({
                                            points: s,
                                            index: a
                                        }), s.length > n.prefabCount && (n.prefabCount = s.length),
                                        i == e.length && t()
                                }
                            })
                        })
                    }
                }, {
                    key: "initAttributes",
                    value: function () {
                        this.aDelayDuration = this.geometry.createAttribute("aDelayDuration", 2), this.aDelayDuration.dynamic = !0, this.aAlpha = this.geometry.createAttribute("aAlpha", 3), this.aAlpha.dynamic = !0, this.aAnimation = this.geometry.createAttribute("aAnimation", 3), this.aAnimation.dynamic = !0, this.aStartPosition = this.geometry.createAttribute("aStartPosition", 3), this.aEndPosition = this.geometry.createAttribute("aEndPosition", 3)
                    }
                }, {
                    key: "getEndpointByIndex",
                    value: function (e) {
                        return this.endPointsCollections.filter(function (t) {
                            return t.index == e
                        })[0].points
                    }
                }, {
                    key: "setStartEndPos",
                    value: function (e) {
                        var t = this,
                            n = [],
                            i = this.getEndpointByIndex(this.activeEndPointsCollection),
                            r = new Worker("application/themes/animal/js/setStartPos.js");
                        r.postMessage([i, this.prefabCount]), r.addEventListener("message", function (i) {
                            if ("Done" == i.data) e();
                            else {
                                var r = new x.Vector3(i.data[0].startPosition[0], i.data[0].startPosition[1], i.data[0].startPosition[2]),
                                    a = new x.Vector3(i.data[0].endPosition[0], i.data[0].endPosition[1], i.data[0].endPosition[2]),
                                    o = new x.Vector3(i.data[0].animation[0], i.data[0].animation[1], i.data[0].animation[2]),
                                    s = new x.Vector2(i.data[0].delayDuration[0], i.data[0].delayDuration[1], i.data[0].delayDuration[2]),
                                    l = new x.Vector3(i.data[0].alpha[0], i.data[0].alpha[1], i.data[0].alpha[2]);
                                t.geometry.setPrefabData(t.aStartPosition, i.data[1], r.toArray(n)), t.geometry.setPrefabData(t.aEndPosition, i.data[1], a.toArray(n)), t.geometry.setPrefabData(t.aAnimation, i.data[1], o.toArray(n)), t.geometry.setPrefabData(t.aDelayDuration, i.data[1], s.toArray(n)), t.geometry.setPrefabData(t.aAlpha, i.data[1], l.toArray(n))
                            }
                        }, !1)
                    }
                }, {
                    key: "setMaterial",
                    value: function () {
                        this.material = new b.StandardAnimationMaterial({
                            flatShading: !1,
                            transparent: !1,
                            uniforms: {
                                tTime: {
                                    value: 0
                                },
                                uAnimationDuration: {
                                    value: 600
                                },
                                uIntroAnimation: {
                                    value: 1
                                },
                                uIntroAnimationTween: {
                                    value: 0
                                },
                                dir: {
                                    type: "f",
                                    value: 0
                                }
                            },
                            vertexFunctions: [b.ShaderChunk.ease_cubic_out, b.ShaderChunk.ease_quad_out, b.ShaderChunk.ease_expo_in, b.ShaderChunk.ease_back_out],
                            varyingParameters: ["varying float vVisibility;"],
                            vertexParameters: ["uniform float tTime;", "uniform float uAnimationDuration;", "uniform float dir;", "uniform float uIntroAnimation;", "uniform float uIntroAnimationTween;", "attribute vec2 aDelayDuration;", "attribute vec3 aStartPosition;", "attribute vec3 aEndPosition;", "attribute vec3 aAlpha;", "attribute vec3 aAnimation;"],
                            vertexInit: document.getElementById("vertex-init").innerHTML,
                            vertexPosition: document.getElementById("vertex-position").innerHTML,
                            fragmentDiffuse: ["diffuseColor.a *= (1.0 * vVisibility);"]
                        })
                    }
                }, {
                    key: "time",
                    get: function () {
                        return this.material.uniforms.uTime.value
                    },
                    set: function (e) {
                        this.material.uniforms.uTime.value = e
                    }
                }]), e
            }(),
            D = function (e) {
                function t(e, n) {
                    s(this, t);
                    var i = a(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
                    if (!i.isPresent) return a(i);
                    if (i.onLoaded = n.onLoaded, i.fallback = (0, v.isTouchDevice)() || (0, v.getMq)().medium || (0, v.detectIE)(), i.fallback) {
                        i.addMod(i.block, "fallback"), i.initFallback();
                        var r = (0, C.nodesAsArray)(document.querySelectorAll(".u-pixel-hero-anchor"));
                        E.TweenLite.to(document.querySelector(".c-header__top-nav"), .4, {
                            opacity: 1,
                            onComplete: function () {
                                r.forEach(function (e, t) {
                                    E.TweenLite.fromTo(e, .65, {
                                        y: 50,
                                        skewY: 12,
                                        opacity: 0
                                    }, {
                                        opacity: 1,
                                        y: 0,
                                        skewY: 0,
                                        ease: L,
                                        paused: !1,
                                        delay: .3 + .1 * t
                                    })
                                })
                            }
                        })
                    } else i.initWebgl();
                    return i
                }
                return o(t, e), c(t, [{
                    key: "initFallback",
                    value: function () {
                        this.fallback_items = (0, v.mapElems)(this.elements.fallback_item, this.getFallbackItem.bind(this)), this.headlineEaseIn = L, this.headlineEaseOut = new T["default"](.55, .055, .675, .19), this.activeFallbackItemIndex = 1, this.setMinHeight(), this.animateInItem(this.getFallbackItemByIndex(this.activeFallbackItemIndex), this.onAnimationComplete.bind(this), .8), this.fallbackInterval = setInterval(this.onFallbackInterval.bind(this), 5e3)
                    }
                }, {
                    key: "onFallbackInterval",
                    value: function () {
                        var e = this.activeFallbackItemIndex;
                        this.animateOutItem(this.getFallbackItemByIndex(e), this.setNewActiveIndex.bind(this))
                    }
                }, {
                    key: "setNewActiveIndex",
                    value: function () {
                        this.activeFallbackItemIndex < this.fallback_items.length ? this.activeFallbackItemIndex += 1 : this.activeFallbackItemIndex = 1;
                        var e = this.activeFallbackItemIndex;
                        this.animateInItem(this.getFallbackItemByIndex(e), this.onAnimationComplete.bind(this))
                    }
                }, {
                    key: "getFallbackItem",
                    value: function (e, t) {
                        return {
                            elem: e,
                            index: t + 1,
                            headline: e.querySelector(".o-animation--headline")
                        }
                    }
                }, {
                    key: "setMinHeight",
                    value: function () {
                        var e = 0;
                        this.fallback_items.forEach(function (t) {
                            t.elem.offsetHeight > e && (e = t.elem.offsetHeight)
                        }), this.elements.fallback_items.style.minHeight = e + "px"
                    }
                }, {
                    key: "getFallbackItemByIndex",
                    value: function (e) {
                        return this.fallback_items.filter(function (t) {
                            return t.index == e
                        })[0]
                    }
                }, {
                    key: "animateInItem",
                    value: function (e, t) {
                        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .5;
                        e.elem.style.opacity = 1, E.TweenLite.set(e.headline, {
                            y: 150,
                            opacity: 0,
                            skewY: 9
                        }), E.TweenLite.to(e.headline, .9, {
                            opacity: 1,
                            y: 0,
                            skewY: 0,
                            delay: n,
                            ease: this.headlineEaseIn
                        })
                    }
                }, {
                    key: "animateOutItem",
                    value: function (e, t) {
                        E.TweenLite.to(e.headline, .65, {
                            opacity: 0,
                            delay: .1,
                            skewY: 6,
                            y: 150,
                            ease: this.headlineEaseOut,
                            onComplete: function () {
                                e.elem.style.opacity = 0, t()
                            }
                        })
                    }
                }, {
                    key: "onAnimationComplete",
                    value: function () {}
                }, {
                    key: "initWebgl",
                    value: function () {
                        var e = this;
                        this.container = this.block, this.renderer = !1, this.scene = !1, this.camera = !1, this.controls = !1, this.engine = !1, this.lights = {}, this.ready = !1, this.movingMouse = !1, this.time = 0, this.startTime = 0, this.eraserLimit = (0, v.isSafari)() ? 30 : 10, this.loadedImages = [], this.cleanedUp = 0, this.mouseOver = !1, this.renderer = this.initRenderer(), this.scene = this.initScene(), this.camera = this.initCamera(), this.camera.position.set(0, 0, 250), this.speedMeasurement = new w["default"], this._mousespeed = 0, this.checkMouseInterval = setInterval(function () {
                            e.movingMouse = !1
                        }, 300), this.cursor = this.elements.cursor, this.cursorDot = this.elements.cursor_dot, this.cursorDotInner = this.elements.cursor_dot_inner, this.cursorCords = {
                            x: 0,
                            y: 0
                        }, this.dragCursorPos = {
                            x: 0,
                            y: 0
                        }, this.sceneCords = {
                            x: 0,
                            y: 0
                        }, this.changingAnimation = !1, this.animation = {}, this.init()
                    }
                }, {
                    key: "init",
                    value: function () {
                        var e = this;
                        this.setListeners(), this.engine.start(), E.TweenLite.to(document.querySelector(".c-header__top-nav"), .3, {
                            opacity: 1
                        });
                        var t = (0, C.nodesAsArray)(document.querySelectorAll(".u-pixel-hero-anchor"));
                        t.forEach(function (t, n) {
                            E.TweenLite.fromTo(t, .45, {
                                y: 50,
                                skewY: 12,
                                opacity: 0
                            }, {
                                opacity: 1,
                                y: 0,
                                skewY: 0,
                                ease: L,
                                paused: !1,
                                delay: .1 * n,
                                onComplete: function () {
                                    1 == n && e.loadQuotes(function () {
                                        e.onImagesLoaded(function () {
                                            e.block.addEventListener("mousemove", e.onMouseMove.bind(e)), E.TweenLite.to(e.animation.mesh.material.uniforms.uIntroAnimationTween, 1.6, {
                                                value: 1,
                                                ease: A,
                                                onComplete: function () {
                                                    e.animation.mesh.material.uniforms.uIntroAnimation.value = 0, e.ready = !0
                                                }
                                            }), e.startTime = Date.now(), e.block.addEventListener("mouseleave", function (t) {
                                                e.mouseOver = !1, E.TweenLite.to(e.cursorDot, .45, {
                                                    scale: 0,
                                                    opacity: 0,
                                                    ease: A
                                                })
                                            }), e.block.addEventListener("mouseover", function (t) {
                                                E.TweenLite.to(e.cursorDot, .45, {
                                                    scale: 1,
                                                    opacity: 1,
                                                    ease: A
                                                }), e.mouseOver = !0
                                            }), e.speedMeasurement.init(e.onCalcSpeed.bind(e)), e.onLoaded()
                                        })
                                    })
                                }
                            })
                        })
                    }
                }, {
                    key: "onCalcSpeed",
                    value: function () {
                        var e = this.speedMeasurement.speedX,
                            t = this.speedMeasurement.speedY;
                        this._mousespeed = Math.abs(e) + Math.abs(t)
                    }
                }, {
                    key: "onMouseMove",
                    value: function (e) {
                        0 == this.cursor.style.opacity && (this.cursor.style.opacity = 1, this.mouseOver = !0), this.movingMouse = !0;
                        var t = (0, v.getInnerHeight)(),
                            n = (0, v.getInnerWidth)(),
                            i = new x.Vector3,
                            r = new x.Vector3;
                        i.set(e.clientX / n * 2 - 1, 2 * -(e.clientY / t) + 1, .5), this.cursorCords.y = (2 * -(e.clientY / t) + 1) * t / 2, this.cursorCords.x = (e.clientX / n * 2 - 1) * n / 2, i.unproject(this.camera), i.sub(this.camera.position).normalize();
                        var a = -this.camera.position.z / i.z;
                        r.copy(this.camera.position).add(i.multiplyScalar(a)), this.sceneCords = r
                    }
                }, {
                    key: "loadQuotes",
                    value: function (e) {
                        var t = 0;
                        R.forEach(function (n) {
                            n.loaded ? (t++, t == R.length && e()) : O.load(n.url, function (i) {
                                n.loaded = !0, n.image = i, t++, t == R.length && e()
                            })
                        })
                    }
                }, {
                    key: "onImagesLoaded",
                    value: function (e) {
                        var t = this;
                        this.animation = new k(R, function () {
                            t.animation.mesh.frustumCulled = !1, t.scene.add(t.animation.mesh), e()
                        })
                    }
                }, {
                    key: "setListeners",
                    value: function () {
                        this.onResize(), m["default"].addListener(this.onResize.bind(this)), this.engine = (0, p["default"])(this.render.bind(this))
                    }
                }, {
                    key: "onResize",
                    value: function () {
                        this.camera.aspect = m["default"].width / m["default"].height, this.camera.updateProjectionMatrix(), this.renderer.setSize(m["default"].width, m["default"].height)
                    }
                }, {
                    key: "initRenderer",
                    value: function () {
                        var e = new x.WebGLRenderer({
                                antialias: window.devicePixelRatio <= 1,
                                alpha: !0
                            }),
                            t = window.devicePixelRatio > 1 ? 1.75 : window.devicePixelRatio;
                        return t = (0, v.isSafari)() ? 1.25 : t, e.setPixelRatio(t), e.setClearColor(16777215, 0), e.shadowMap.enabled = !1, e.domElement.className = "c-webgl-canvas", this.container.appendChild(e.domElement), e
                    }
                }, {
                    key: "initScene",
                    value: function () {
                        var e = new x.Scene;
                        return e
                    }
                }, {
                    key: "initCamera",
                    value: function () {
                        var e = new x.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1e3);
                        return e
                    }
                }, {
                    key: "pulse",
                    value: function (e, t) {
                        var n = 3.14,
                            i = t;
                        return .5 * (1 + Math.sin(2 * n * i * e))
                    }
                }, {
                    key: "render",
                    value: function (e) {
                        var t = this;
                        this.time += e;
                        var n = Date.now() + 3e3 - this.startTime;
                        if (this.mouseOver) {
                            var i = this.pulse(n, 5e-4),
                                r = this.cursorCords.x - this.dragCursorPos.x,
                                a = this.cursorCords.y - this.dragCursorPos.y;
                            this.dragCursorPos.x += r / 3, this.dragCursorPos.y += a / 3;
                            var o = 1 + .2 * i;
                            this.cursor.style["" + (0, g.getPrefix)("transform")] = "translate3d(" + this.dragCursorPos.x + "px, " + -this.dragCursorPos.y + "px, 0px)", this.cursorDotInner.style["" + (0, g.getPrefix)("transform")] = "scale(" + o + ")"
                        }
                        if (this.animation.mesh) {
                            var s = this.cleanedUp > this.animation.mesh.geometry.attributes.aStartPosition.count - .05 * this.animation.mesh.geometry.attributes.aStartPosition.count ? 500 : 0,
                                c = this.eraserLimit + this._mousespeed + s;
                            if (!this.changingAnimation && this.ready && this.movingMouse)
                                for (var u = 0; u < this.animation.mesh.geometry.attributes.aStartPosition.count; u++) {
                                    var h = this.animation.mesh.geometry.attributes.aStartPosition.array[3 * u + 0],
                                        d = this.animation.mesh.geometry.attributes.aStartPosition.array[3 * u + 1],
                                        p = this.sceneCords.x - h,
                                        f = this.sceneCords.y - d,
                                        m = Math.sqrt(p * p + f * f);
                                    m < c && 0 == this.animation.mesh.geometry.attributes.aAnimation.array[3 * u + 0] && (this.animation.mesh.geometry.attributes.aAnimation.array[3 * u + 0] = 1, this.animation.mesh.geometry.attributes.aAnimation.array[3 * u + 1] = this.animation.mesh.material.uniforms.tTime.value, this.animation.mesh.geometry.attributes.aAnimation.needsUpdate = !0, this.cleanedUp++)
                                }
                            if (this.cleanedUp == this.animation.mesh.geometry.attributes.aStartPosition.count && !this.changingAnimation) {
                                this.changingAnimation = !0, this.animation.activeEndPointsCollection < this.animation.endPointsCollections.length - 1 ? this.animation.activeEndPointsCollection++ : this.animation.activeEndPointsCollection = 0;
                                var y = this.animation.getEndpointByIndex(this.animation.activeEndPointsCollection),
                                    b = this.animation.aStartPosition,
                                    _ = this.animation.aEndPosition,
                                    w = this.animation.aAnimation;
                                setTimeout(function () {
                                    for (var e = [], n = new x.Vector3, i = new x.Vector3, r = new x.Vector3, a = 0; a < t.animation.prefabCount; a++) {
                                        if (a < y.length) {
                                            if (!l(y[a])) {
                                                var o = a % 10 == 0,
                                                    s = o ? 220 : (0, v.randomIntFromInterval)(30, 140),
                                                    c = y[a].x,
                                                    u = y[a].y;
                                                n.x = c, n.y = u, n.z = (0, v.randomIntFromInterval)(-2, 0);
                                                var h = (0, v.randomIntFromInterval)(c - (s - 0) * (0, v.randomFloatFromInterval)(.001, 1), c + (s - 0) * (0, v.randomFloatFromInterval)(.001, 1)),
                                                    d = (0, v.randomIntFromInterval)(u - s * (0, v.randomFloatFromInterval)(.001, 1) + 0, u + s * (0, v.randomFloatFromInterval)(.001, 1));
                                                i.x = h, i.y = d, i.z = -100, r.x = 1, r.y = t.animation.mesh.material.uniforms.tTime.value, r.z = 1
                                            }
                                        } else n.x = 0, n.y = 0, n.z = 0, r.z = 0;
                                        t.animation.mesh.geometry.setPrefabData(b, a, n.toArray(e)), t.animation.mesh.geometry.setPrefabData(_, a, i.toArray(e)), t.animation.mesh.geometry.setPrefabData(w, a, r.toArray(e))
                                    }
                                    b.needsUpdate = !0, _.needsUpdate = !0, w.needsUpdate = !0, t.animation.mesh.material.uniforms.uAnimationDuration.value = 440, t.animation.mesh.material.uniforms.dir.value = t.animation.mesh.material.uniforms.tTime.value, setTimeout(function () {
                                        for (var e = [], n = new x.Vector3(0, 0, 0), i = 0; i < t.animation.prefabCount; i++) i < y.length ? n.z = 1 : n.z = 0, n.x = 0, t.animation.mesh.geometry.setPrefabData(w, i, n.toArray(e));
                                        t.animation.mesh.material.uniforms.uAnimationDuration.value = 600, t.animation.mesh.material.uniforms.dir.value = 0, w.needsUpdate = !0, t.changingAnimation = !1, t.cleanedUp = 0
                                    }, 1540)
                                }, 1300)
                            }
                            this.animation.mesh.material.uniforms.tTime.value = n, this.renderer.render(this.scene, this.camera)
                        }
                    }
                }]), t
            }(h["default"]);
        n["default"] = D
    }, {
        "../utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax": 21,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper": 23,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix": 25,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing": 29,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/brindille-resize": 30,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap": 35,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/mouse-speed": 39,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/raf-loop": 43,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/three": 49,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/three-bas": 47
    }],
    12: [function (e, t, n) {
        "use strict";

        function i(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }

        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function a(e, t) {
            if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t || "object" != typeof t && "function" != typeof t ? e : t
        }

        function o(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
        }

        function s(e) {
            return e ? {
                show: "pause",
                hide: "play"
            } : {
                hide: "pause",
                show: "play"
            }
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var l = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            c = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils"),
            u = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper"),
            h = i(u),
            d = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing"),
            p = (i(d), e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap")),
            f = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/@vimeo/player"),
            m = i(f),
            v = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix"),
            g = function (e) {
                function t(e, n) {
                    r(this, t);
                    var i = a(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
                    return i.isPresent ? (i.onVideoMouseOver = n.onVideoMouseOver, i.onVideoMouseLeave = n.onVideoMouseLeave, i._loadYoutube(), i) : a(i)
                }
                return o(t, e), l(t, [{
                    key: "init",
                    value: function () {
                        this.videos = (0, c.mapElems)(this.block, this.getVideo.bind(this)), this.setEventListeners()
                    }
                }, {
                    key: "getVideo",
                    value: function (e) {
                        var t = "yt" == e.getAttribute("data-video-type"),
                            n = "vimeo" == e.getAttribute("data-video-type"),
                            i = this.getChildren(e, "player");
                        return {
                            block: e,
                            id: !(!t && !n) && i.getAttribute("data-video-id"),
                            type: e.getAttribute("data-video-type"),
                            player: t ? this._createYT(i, i.getAttribute("data-video-id")) : n ? this._createVimeo(i, i.getAttribute("data-video-id")) : i,
                            playerElem: this.getChildren(e, "player"),
                            playBtn: this.getChildren(e, "play-btn"),
                            overlay: this.getChildren(e, "overlay"),
                            posterMedia: this.getChildren(e, "poster-media"),
                            ratio: this.getChildren(e, "ratio"),
                            posterMediaType: this.getChildren(e, "poster-media").tagName.toLowerCase(),
                            controlsWrapper: this.getChildren(e, "controls"),
                            progress: this.getChildren(e, "progress"),
                            progressBar: this.getChildren(e, "progress-inner"),
                            stateButton: this.getChildren(e, "state-button"),
                            fullscreenButton: this.getChildren(e, "fullscreen-button"),
                            time: {
                                curr: this.getChildren(e, "curr-time"),
                                total: this.getChildren(e, "total-time")
                            },
                            progressBarUpdate: null,
                            firstPlay: !0,
                            isPlaying: !1
                        }
                    }
                }, {
                    key: "getVideoById",
                    value: function (e) {
                        var t = this.videos.filter(function (t) {
                            return t.id == e
                        });
                        if (t[0]) return t[0]
                    }
                }, {
                    key: "setEventListeners",
                    value: function () {
                        var e = this;
                        this.videos.forEach(function (t) {
                            var n = "file" == t.type || "vimeo" == t.type ? t.player : t.player.getIframe(),
                                i = "vimeo" == t.type ? n.element : n;
                            i.addEventListener("mouseleave", function () {
                                e.onVideoMouseLeave()
                            }), i.addEventListener("mouseover", function () {
                                e.onVideoMouseOver()
                            }), t.playBtn.addEventListener("click", function () {
                                t.firstPlay ? ((0, c.isTouchDevice)() && (0, c.getMq)().xsmall && "file" == t.type && (t.player.controls = !0), "file" == t.type && (e.onTimeUpdate(t), t.controlsWrapper.classList.add("show")), t.playerElem.style.opacity = 1, e.animateOutOverlay(t), e.setPlayState(t), t.firstPlay = !1) : (e.animateOutOverlay(t), e.setPlayState(t))
                            }), "vimeo" == t.type && (t.player.getVideoWidth().then(function (e) {
                                t.player.getVideoHeight().then(function (n) {
                                    t.ratio.style.paddingTop = n / e * 100 + "%"
                                })
                            })["catch"](function (e) {}), t.player.on("ended", function (n) {
                                e.videoEnded(t)
                            })), "file" == t.type && (e.prepareOnLoad(t), t.player.addEventListener("click", function () {
                                e.setPlayState(t)
                            }), t.stateButton.addEventListener("click", function () {
                                e.setPlayState(t)
                            }), t.progress.addEventListener("click", function (n) {
                                e.onProgressBarClick(n, t)
                            }), t.progressBarUpdate = function () {
                                e.onTimeUpdate(t)
                            })
                        })
                    }
                }, {
                    key: "openFullscreen",
                    value: function (e) {
                        e.requestFullscreen ? e.requestFullscreen() : e.mozRequestFullScreen ? e.mozRequestFullScreen() : e.webkitRequestFullscreen ? e.webkitRequestFullscreen() : e.msRequestFullscreen && e.msRequestFullscreen()
                    }
                }, {
                    key: "onProgressBarClick",
                    value: function (e, t) {
                        var n = (e.pageX - t.progress.getBoundingClientRect().left) / t.progress.offsetWidth;
                        t.player.currentTime = n * t.player.duration, this.translateProgressBar(t)
                    }
                }, {
                    key: "onTimeUpdate",
                    value: function (e) {
                        var t = e;
                        (0, v.requestAnimationFrame)(t.progressBarUpdate), t.isPlaying && this.translateProgressBar(t);
                        var n = !t.player.paused && !t.player.ended;
                        n != t.isPlaying && (t.stateButton.querySelector("." + s(n).hide).style.display = "none", t.stateButton.querySelector("." + s(n).show).style.display = "block", t.isPlaying = n)
                    }
                }, {
                    key: "translateProgressBar",
                    value: function (e) {
                        e.progressBar.value = e.player.currentTime, e.time.curr.innerHTML = (0, c.secAsMMSS)(e.player.currentTime);
                        var t = e.player.currentTime / e.player.duration,
                            n = e.progressBar.offsetWidth,
                            i = t * n,
                            r = t < .015 || t > .93 ? 0 : 1;
                        e.time.curr.style.opacity = r, e.time.curr.style["" + (0, v.getPrefix)("transform")] = "translate3d(" + i + "px, 0px, 0px)"
                    }
                }, {
                    key: "prepareOnLoad",
                    value: function (e) {
                        var t = this;
                        0 === e.player.readyState ? e.player.addEventListener("loadedmetadata", function () {
                            t.onLoadedMeta(e)
                        }) : e.player.readyState >= 1 && this.onLoadedMeta(e)
                    }
                }, {
                    key: "onLoadedMeta",
                    value: function (e) {
                        e.time.total.innerHTML = (0, c.secAsMMSS)(e.player.duration), e.progressBar.setAttribute("max", e.player.duration)
                    }
                }, {
                    key: "animateOutOverlay",
                    value: function (e) {
                        p.TweenLite.to(e.overlay, .4, {
                            opacity: 0,
                            onComplete: function () {
                                e.overlay.style.display = "none", "video" == e.posterMediaType && e.posterMedia.pause()
                            }
                        })
                    }
                }, {
                    key: "onYTStateChange",
                    value: function (e, t) {
                        var n = this.getVideoById(e);
                        0 == t.data && this.videoEnded(n)
                    }
                }, {
                    key: "videoEnded",
                    value: function (e) {
                        "video" == e.posterMediaType && e.posterMedia.play(), e.overlay.style.display = "block", p.TweenLite.to(e.overlay, .4, {
                            opacity: 1
                        })
                    }
                }, {
                    key: "setPlayState",
                    value: function (e) {
                        "yt" == e.type ? e.player.playVideo() : e.isPlaying ? e.player.pause() : e.player.play()
                    }
                }, {
                    key: "_createVimeo",
                    value: function (e, t) {
                        var n = {
                            url: t,
                            width: "640",
                            loop: !1
                        };
                        return new m["default"](e, n)
                    }
                }, {
                    key: "_loadYoutube",
                    value: function () {
                        this._loadScript(this.init.bind(this))
                    }
                }, {
                    key: "_loadScript",
                    value: function (e) {
                        "undefined" != typeof YT && e();
                        var t = document.createElement("script");
                        t.src = "https://www.youtube.com/iframe_api";
                        var n = document.getElementsByTagName("script")[0];
                        n.parentNode.insertBefore(t, n), window.onYouTubePlayerAPIReady = e
                    }
                }, {
                    key: "_createYT",
                    value: function (e, t) {
                        var n = this;
                        return new YT.Player(e, {
                            height: "390",
                            width: "640",
                            videoId: t,
                            playerVars: {
                                showinfo: 0,
                                rel: 0,
                                fs: 1,
                                color: "white"
                            },
                            events: {
                                onStateChange: function (e) {
                                    n.onYTStateChange(t, e)
                                }
                            }
                        })
                    }
                }]), t
            }(h["default"]);
        n["default"] = g
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper": 23,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix": 25,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/@vimeo/player": 28,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing": 29,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap": 35
    }],
    13: [function (e, t, n) {
        "use strict";

        function i(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }

        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function a(e, t) {
            if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t || "object" != typeof t && "function" != typeof t ? e : t
        }

        function o(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var s = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            l = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper"),
            c = i(l),
            u = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax"),
            h = (i(u), e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils")),
            d = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap"),
            p = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing"),
            f = i(p),
            m = function (e) {
                function t(e, n) {
                    r(this, t);
                    var i = a(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
                    return i.isPresent ? (i.prefix = i.block.getAttribute("data-prefix"), i.activeIndex = 0, i.quotes = (0, h.mapElems)(i.elements.data_item, i.getDataItem.bind(i)), i.headlineEaseIn = new f["default"](.215, .61, .355, 1), i.headlineEaseOut = new f["default"](.55, .055, .675, .19), i.textWrappers = {
                        by_day: {
                            outer: i.elements.by_day,
                            inner: i.elements.by_day.querySelector(".m-about-promo__text-inner")
                        },
                        by_night: {
                            outer: i.elements.by_night,
                            inner: i.elements.by_night.querySelector(".m-about-promo__text-inner")
                        }
                    }, setInterval(i.updateQuote.bind(i), 5e3), i) : a(i)
                }
                return o(t, e), s(t, [{
                    key: "getDataItem",
                    value: function (e) {
                        return {
                            by_day: e.getAttribute("data-day"),
                            by_night: e.getAttribute("data-night")
                        }
                    }
                }, {
                    key: "updateQuote",
                    value: function () {
                        var e = this;
                        this.activeIndex < this.quotes.length - 1 ? this.activeIndex += 1 : this.activeIndex = 0, (0, h.getMq)().small ? this.animateQuote(this.elements.text_wrapper_inner, 0, "out", function (t) {
                            e.textWrappers.by_day.inner.innerHTML = e.quotes[e.activeIndex].by_day, e.textWrappers.by_night.inner.innerHTML = e.quotes[e.activeIndex].by_night, e.animateQuote(e.elements.text_wrapper_inner, .1, "in")
                        }) : (this.animateQuote(this.textWrappers.by_day.inner, 0, "out", function (t) {
                            e.textWrappers.by_day.inner.innerHTML = e.quotes[e.activeIndex].by_day, e.animateQuote(t, .4, "in")
                        }), this.animateQuote(this.textWrappers.by_night.inner, 0, "out", function (t) {
                            e.textWrappers.by_night.inner.innerHTML = e.quotes[e.activeIndex].by_night, e.animateQuote(t, .4, "in")
                        }))
                    }
                }, {
                    key: "animateQuote",
                    value: function (e, t, n, i) {
                        var r = void 0,
                            a = void 0;
                        "in" == n ? (d.TweenLite.set(e, {
                            yPercent: 100,
                            opacity: 0,
                            skewY: 7
                        }), a = .9, r = {
                            yPercent: 0,
                            skewY: 0,
                            opacity: 1,
                            delay: t,
                            ease: this.headlineEaseIn,
                            onComplete: function () {
                                i && i(e)
                            }
                        }) : "out" == n ? (a = .65, r = {
                            skewY: 7,
                            yPercent: 100,
                            opacity: 0,
                            delay: t,
                            ease: this.headlineEaseOut,
                            onComplete: function () {
                                i && i(e)
                            }
                        }) : "fade-out" == n ? (a = .55, r = {
                            opacity: 0,
                            delay: t,
                            onComplete: function () {
                                i && i(e)
                            }
                        }) : "fade-in" == n && (a = .55, r = {
                            opacity: 1,
                            delay: t,
                            onComplete: function () {
                                i && i(e)
                            }
                        }), d.TweenLite.to(e, a, r)
                    }
                }]), t
            }(c["default"]);
        n["default"] = m
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax": 21,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper": 23,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing": 29,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap": 35
    }],
    14: [function (e, t, n) {
        "use strict";

        function i(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }

        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function a(e, t) {
            if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t || "object" != typeof t && "function" != typeof t ? e : t
        }

        function o(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var s = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            l = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper"),
            c = i(l),
            u = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax"),
            h = (i(u), e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/scroll")),
            d = i(h),
            p = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils"),
            f = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap"),
            m = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing"),
            v = i(m),
            g = function (e) {
                function t(e, n) {
                    r(this, t);
                    var i = a(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
                    return i.isPresent ? (i._scroll = new d["default"], i._scrollID = i._scroll.addListener(i._onScroll.bind(i), "clients"), i.reachedModule = !1, i.activeIndex = 0, i.wrappers = (0, p.mapElems)(i.elements.client_wrapper, i.getWrapper.bind(i)), i.headlineEaseIn = new v["default"](.215, .61, .355, 1), i.headlineEaseOut = new v["default"](.55, .055, .675, .19), i) : a(i)
                }
                return o(t, e), s(t, [{
                    key: "_onScroll",
                    value: function (e) {
                        var t = this.block.getBoundingClientRect().top,
                            n = (0, p.getInnerHeight)();
                        t <= n && !this.reachedModule && (this.reachedModule = !0, this._scroll.removeListener(this._scrollID), this.updateLogos(!0))
                    }
                }, {
                    key: "stop",
                    value: function () {
                        this._scroll.removeListener(this._scrollID)
                    }
                }, {
                    key: "getWrapper",
                    value: function (e) {
                        return {
                            elem: e,
                            logos: this.getChildren(e, "client-logo")
                        }
                    }
                }, {
                    key: "updateLogos",
                    value: function () {
                        var e = this,
                            t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        if (t) this.wrappers[this.activeIndex].logos.forEach(function (t, n) {
                            var i = .2 * n;
                            e.animateLogo(t, i, "in", function () {})
                        }), setInterval(this.updateLogos.bind(this), 5e3);
                        else {
                            var n = 0;
                            this.wrappers[this.activeIndex].logos.forEach(function (t, i) {
                                var r = .4 - .3 * i;
                                e.animateLogo(t, r, "out", function () {
                                    n++, n == e.wrappers[e.activeIndex].logos.length && (e.wrappers[e.activeIndex].elem.style.display = "none", e.onAnimatedOut())
                                })
                            })
                        }
                    }
                }, {
                    key: "onAnimatedOut",
                    value: function () {
                        var e = this;
                        this.activeIndex < this.wrappers.length - 1 ? this.activeIndex += 1 : this.activeIndex = 0, this.wrappers[this.activeIndex].elem.style.display = "flex", this.wrappers[this.activeIndex].logos.forEach(function (t, n) {
                            var i = .8 + .3 * n;
                            e.animateLogo(t, i, "in", function () {})
                        })
                    }
                }, {
                    key: "animateLogo",
                    value: function (e, t, n, i) {
                        var r = void 0,
                            a = void 0;
                        "in" == n ? (a = .55, r = {
                            y: 0,
                            opacity: 1,
                            delay: t,
                            ease: this.headlineEaseIn,
                            onComplete: function () {
                                i && i(e)
                            }
                        }) : "out" == n && (a = .55, r = {
                            y: 50,
                            opacity: 0,
                            delay: t,
                            ease: this.headlineEaseOut,
                            onComplete: function () {
                                i && i(e)
                            }
                        }), f.TweenLite.to(e, a, r)
                    }
                }]), t
            }(c["default"]);
        n["default"] = g
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax": 21,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper": 23,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/scroll": 27,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing": 29,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap": 35
    }],
    15: [function (e, t, n) {
        "use strict";

        function i(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }

        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function a(e, t) {
            if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t || "object" != typeof t && "function" != typeof t ? e : t
        }

        function o(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var s = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            l = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper"),
            c = i(l),
            u = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax"),
            h = (i(u), e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils")),
            d = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix"),
            p = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap"),
            f = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing"),
            m = i(f),
            v = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/vanilla-lazyload"),
            g = i(v),
            y = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/scroll"),
            x = i(y),
            b = function (e) {
                function t(e, n) {
                    r(this, t);
                    var i = a(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
                    return i.isPresent ? (i.onMouseEnter = n.onMouseEnter, i.onMouseLeave = n.onMouseLeave, i.onCaseChanged = n.onCaseChanged, i._scroll = new x["default"], i._scrollID = i._scroll.addListener(i._onScroll.bind(i), "featured case"), i.mouse = {
                        x: 0,
                        y: 0,
                        opacity: 0
                    }, i.dir = !1, i.dragCursorPos = {
                        x: 0,
                        y: 0
                    }, i._lazyLoad = new g["default"]({
                        elements_selector: ".o-image__lazy-force",
                        threshold: 500
                    }), i.active = !1, i.hoveringBannedArea = !1, i.reachedModule = !1, i.loaded = !1, i.curtainEase = new m["default"](.215, .61, .355, 1), i.lazyEase = new m["default"](.215, .61, .355, 1), i.headlineEaseIn = new m["default"](.215, .61, .355, 1), i.headlineEaseOut = new m["default"](.55, .055, .675, .19), i.rotation = 0, i.activeItemIndex = 1, i.items = (0, h.mapElems)(i.elements.item, i.getItem.bind(i)), i.elements.total_index.innerHTML = i.items.length, i.reqFrame = !1, i.reqLoop = i.loop.bind(i), i.setEventListeners(), i) : a(i)
                }
                return o(t, e), s(t, [{
                    key: "_onScroll",
                    value: function (e) {
                        var t = this.block.getBoundingClientRect().top,
                            n = (0, h.getInnerHeight)() + (0, h.getInnerHeight)() / 2;
                        t <= n && !this.reachedModule && (this._lazyLoad.loadAll(), this.reachedModule = !0, this._scroll.removeListener(this._scrollID), this.animateInItem(this.getItemByIndex(this.activeItemIndex), this.onAnimationComplete.bind(this), !0))
                    }
                }, {
                    key: "stop",
                    value: function () {
                        this._scroll.removeListener(this._scrollID)
                    }
                }, {
                    key: "getItem",
                    value: function (e, t) {
                        return {
                            elem: e,
                            index: t + 1,
                            bgColor: e.getAttribute("data-bgcolor"),
                            textColor: e.getAttribute("data-color"),
                            children: {
                                headline: e.querySelector(".o-headline__inner"),
                                client: this.getChild(e, "client"),
                                anchor: this.getChild(e, "anchor-wrapper"),
                                lazy: e.querySelector(".m-featured-case__image"),
                                lazyMobile: "true" == e.querySelector(".o-image").getAttribute("data-mobile-asset") && e.querySelector(".m-featured-case__image.o-image__xsmall"),
                                curtain: e.querySelector(".o-image__curtain")
                            }
                        }
                    }
                }, {
                    key: "getItemByIndex",
                    value: function (e) {
                        return this.items.filter(function (t) {
                            return t.index == e
                        })[0]
                    }
                }, {
                    key: "setEventListeners",
                    value: function () {
                        var e = this;
                        (0, h.isTouchDevice)() ? (this.mc = new Hammer.Manager(this.block, {}), this.mc.add(new Hammer.Swipe({
                            direction: Hammer.DIRECTION_HORIZONTAL,
                            threshold: 0
                        })), this.mc.on("swipeleft", this.onPanLeft.bind(this)), this.mc.on("swiperight", this.onPanRight.bind(this))) : (this.block.addEventListener("mousemove", this.onMouseMove.bind(this)), this.block.addEventListener("click", this.onMouseClick.bind(this)), this.block.addEventListener("mouseleave", function (t) {
                            e.active = !1, e.elements.cursor.style.opacity = 0, (0, d.cancelAnimationFrame)(e.reqFrame)
                        }), this.block.addEventListener("mouseenter", function (t) {
                            e.active = !0, e.loop()
                        }), this.elements.anchor_wrapper.forEach(function (t) {
                            t.addEventListener("mouseover", function (t) {
                                e.hoveringBannedArea = !0
                            }), t.addEventListener("mouseleave", function (t) {
                                e.hoveringBannedArea = !1
                            })
                        }))
                    }
                }, {
                    key: "onPanLeft",
                    value: function () {
                        if (!this.animating) {
                            this.dir = "forward";
                            var e = this.activeItemIndex;
                            this.animateOutItem(this.getItemByIndex(e), this.setNewActiveIndex.bind(this), this.dir)
                        }
                    }
                }, {
                    key: "onPanRight",
                    value: function () {
                        if (!this.animating) {
                            this.dir = "back";
                            var e = this.activeItemIndex;
                            this.animateOutItem(this.getItemByIndex(e), this.setNewActiveIndex.bind(this), this.dir)
                        }
                    }
                }, {
                    key: "onMouseMove",
                    value: function (e) {
                        this.mouse.y = (2 * -((e.clientY - this.block.getBoundingClientRect().top) / this.block.offsetHeight) + 1) * this.block.offsetHeight / 2, this.mouse.x = ((e.clientX - this.block.getBoundingClientRect().left) / this.block.offsetWidth * 2 - 1) * this.block.offsetWidth / 2;
                        var t = this.mouse.x / (this.block.offsetWidth / 2);
                        this.mouse.opacity = !this.hoveringBannedArea && this.active ? 1 : 0, this.dir = t < 0 ? "back" : t > 0 && "forward", this.rotation = this.mouse.x < 0 ? 180 : 0
                    }
                }, {
                    key: "onMouseClick",
                    value: function () {
                        if (this.dir || !this.animating) {
                            var e = this.activeItemIndex;
                            this.animateOutItem(this.getItemByIndex(e), this.setNewActiveIndex.bind(this), this.dir)
                        }
                    }
                }, {
                    key: "getNexActiveIndex",
                    value: function () {
                        var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                            t = e ? e : this.dir;
                        return "forward" == t && this.activeItemIndex < this.items.length ? this.activeItemIndex + 1 : "back" == t && this.activeItemIndex > 1 ? this.activeItemIndex - 1 : "forward" == t ? 1 : this.items.length
                    }
                }, {
                    key: "setNewActiveIndex",
                    value: function (e) {
                        this.activeItemIndex = this.getNexActiveIndex(e), this.elements.current_index.innerHTML = this.activeItemIndex;
                        var t = this.activeItemIndex;
                        this.animateInItem(this.getItemByIndex(t), this.onAnimationComplete.bind(this))
                    }
                }, {
                    key: "animateInItem",
                    value: function (e, t) {
                        var n = this,
                            i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                        e.elem.style.display = "block";
                        var r = 0;
                        i && (r = 0);
                        var a = (0, h.getMq)().xsmall && e.children.lazyMobile ? e.children.lazyMobile : e.children.lazy;
                        p.TweenLite.to(a, 1.05, {
                            scale: 1,
                            ease: this.lazyEase,
                            delay: r
                        }), p.TweenLite.to(e.children.anchor, .4, {
                            opacity: 1,
                            delay: .4 + r
                        }), p.TweenLite.set(e.children.client, {
                            y: 150,
                            opacity: 0,
                            skewY: 7
                        }), p.TweenLite.to(e.children.client, .75, {
                            opacity: .4,
                            skewY: 0,
                            y: 0,
                            delay: 0 + r,
                            ease: this.headlineEaseIn
                        }), p.TweenLite.set(e.children.headline, {
                            y: 150,
                            opacity: 0,
                            skewY: 7
                        }), p.TweenLite.to(e.children.headline, .75, {
                            y: 0,
                            skewY: 0,
                            opacity: 1,
                            delay: .1 + r,
                            ease: this.headlineEaseIn
                        }), p.TweenLite.to(e.children.curtain, 1.05, {
                            x: e.children.curtain.offsetWidth,
                            ease: this.curtainEase,
                            delay: r,
                            onComplete: function () {
                                p.TweenLite.set(e.children.curtain, {
                                    x: -Math.abs(e.children.curtain.offsetWidth)
                                }), n.animating = !1, t()
                            }
                        })
                    }
                }, {
                    key: "animateOutItem",
                    value: function (e, t, n) {
                        if (!this.animating) {
                            this.animating = !0;
                            var i = this.getItemByIndex(this.getNexActiveIndex(n)).bgColor;
                            this.onCaseChanged(i);
                            var r = (0, h.getMq)().xsmall && e.children.lazyMobile ? e.children.lazyMobile : e.children.lazy;
                            p.TweenLite.to(e.children.client, .65, {
                                opacity: 0,
                                y: 150,
                                skewY: 7,
                                ease: this.headlineEaseOut,
                                delay: .1
                            }), p.TweenLite.to(e.children.anchor, .4, {
                                opacity: 0
                            }), p.TweenLite.to(e.children.headline, .65, {
                                y: 150,
                                opacity: 0,
                                skewY: 7,
                                ease: this.headlineEaseOut,
                                onComplete: function () {}
                            }), p.TweenLite.to(e.children.curtain, 1.05, {
                                x: 0,
                                ease: this.curtainEase,
                                delay: .3,
                                onComplete: function () {
                                    p.TweenLite.set(r, {
                                        scale: 1.29
                                    }), e.elem.style.display = "none", t(n)
                                }
                            })
                        }
                    }
                }, {
                    key: "onAnimationComplete",
                    value: function () {}
                }, {
                    key: "loop",
                    value: function () {
                        var e = this.mouse.x - this.dragCursorPos.x,
                            t = this.mouse.y - this.dragCursorPos.y;
                        this.dragCursorPos.x += e, this.dragCursorPos.y += t, this.elements.cursor.style.opacity = this.mouse.opacity, this.elements.cursor.style["" + (0, d.getPrefix)("transform")] = "translate3d(" + this.dragCursorPos.x + "px, " + -this.dragCursorPos.y + "px, 0px) rotate(" + this.rotation + "deg)", this.reqFrame = (0, d.requestAnimationFrame)(this.reqLoop)
                    }
                }]), t
            }(c["default"]);
        n["default"] = b
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax": 21,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper": 23,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix": 25,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/scroll": 27,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing": 29,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap": 35,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/vanilla-lazyload": 51
    }],
    16: [function (e, t, n) {
        "use strict";

        function i(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }

        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function a(e, t) {
            if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t || "object" != typeof t && "function" != typeof t ? e : t
        }

        function o(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var s = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            l = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper"),
            c = i(l),
            u = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax"),
            h = (i(u), e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils")),
            d = (e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix"), e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/scroll")),
            p = i(d),
            f = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap"),
            m = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing"),
            v = i(m),
            g = e("/Users/andreaslorentsson/Projects/animal/frontend/js/components/audio-play-button"),
            y = i(g),
            x = function (e) {
                function t(e, n) {
                    r(this, t);
                    var i = a(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
                    return i.isPresent ? (i._scroll = new p["default"], i._scrollID = i._scroll.addListener(i._onScroll.bind(i), "image-grid"), i.containers = (0, h.mapElems)(i.elements.container, i.getContainer.bind(i)), i.activeContainer = -1, i.animating = !0, i.autoPlay = !0, i.reachedModule = !1, i.elements.shuffle.addEventListener("click", i.onShuffleClick.bind(i)), i.shuffleButton = new y["default"]({
                        elem: i.elements.shuffle_button,
                        duration: 1e4
                    }), i.lazyEase = new v["default"](.215, .61, .355, 1), i.duration = {
                        value: 0
                    }, i.currentTween = !1, i) : a(i)
                }
                return o(t, e), s(t, [{
                    key: "_onScroll",
                    value: function (e) {
                        var t = this.block.getBoundingClientRect().top,
                            n = (0, h.getInnerHeight)();
                        t <= n && !this.reachedModule && (this.reachedModule = !0, this._scroll.removeListener(this._scrollID), this.setActiveContainer(), this.tween())
                    }
                }, {
                    key: "stop",
                    value: function () {
                        this._scroll.removeListener(this._scrollID)
                    }
                }, {
                    key: "tween",
                    value: function () {
                        var e = this;
                        this.currentTween = f.TweenLite.to(this.duration, 10, {
                            value: 1e4,
                            ease: Power0.easeNone,
                            onUpdate: function () {
                                e.shuffleButton.update(e.duration.value)
                            },
                            onComplete: function () {
                                e.animateOutItem(e.getItemByIndex(e.activeContainer), function () {
                                    e.setActiveContainer(), e.duration.value = 0, e.tween()
                                })
                            }
                        })
                    }
                }, {
                    key: "getContainer",
                    value: function (e, t) {
                        return {
                            elem: e,
                            index: t,
                            visible: !1,
                            images: (0, h.mapElems)(this.getChildren(e, "image"), this.getImage.bind(this))
                        }
                    }
                }, {
                    key: "getImage",
                    value: function (e, t) {
                        return {
                            elem: e,
                            lazy: e.querySelector(".m-image-grid__image-lazy"),
                            curtain: e.querySelector(".o-image__curtain")
                        }
                    }
                }, {
                    key: "getItemByIndex",
                    value: function (e) {
                        return this.containers.filter(function (t) {
                            return t.index == e
                        })[0]
                    }
                }, {
                    key: "setActiveContainer",
                    value: function () {
                        this.activeContainer < this.containers.length - 1 ? this.activeContainer += 1 : this.activeContainer = 0;
                        var e = this.activeContainer;
                        this.animateInItem(this.getItemByIndex(e), function () {})
                    }
                }, {
                    key: "animateInItem",
                    value: function (e, t) {
                        var n = this;
                        this.animating = !0;
                        var i = 0;
                        e.elem.style.display = "block", e.images.forEach(function (r) {
                            var a = (0, h.randomFloatFromInterval)(0, .4);
                            f.TweenLite.to(r.lazy, 1.05, {
                                scale: 1,
                                ease: n.lazyEase,
                                delay: a
                            }), f.TweenLite.to(r.curtain, 1.05, {
                                x: r.curtain.offsetWidth,
                                ease: n.lazyEase,
                                delay: a,
                                onComplete: function () {
                                    i++, f.TweenLite.to(r.curtain, 0, {
                                        x: -Math.abs(r.curtain.offsetWidth)
                                    }), i == e.images.length && (n.animating = !1, t())
                                }
                            })
                        })
                    }
                }, {
                    key: "animateOutItem",
                    value: function (e, t) {
                        var n = 0;
                        this.animating = !0;
                        var i = (0, h.randomFloatFromInterval)(0, .4);
                        e.images.forEach(function (r) {
                            f.TweenLite.to(r.curtain, .55, {
                                x: 0,
                                delay: i,
                                onComplete: function () {
                                    n++, f.TweenLite.to(r.lazy, 0, {
                                        scale: 1.29
                                    }), n == e.images.length && (e.elem.style.display = "none", t())
                                }
                            })
                        })
                    }
                }, {
                    key: "onShuffleClick",
                    value: function () {
                        var e = this;
                        this.animating || this.animateOutItem(this.getItemByIndex(this.activeContainer), function () {
                            e.setActiveContainer(), e.currentTween && e.currentTween.kill(), e.duration.value = 0, e.tween()
                        })
                    }
                }]), t
            }(c["default"]);
        n["default"] = x
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/components/audio-play-button": 2,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax": 21,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper": 23,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix": 25,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/scroll": 27,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing": 29,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap": 35
    }],
    17: [function (e, t, n) {
        "use strict";

        function i(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }

        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function a(e, t) {
            if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t || "object" != typeof t && "function" != typeof t ? e : t
        }

        function o(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var s = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            l = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper"),
            c = i(l),
            u = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax"),
            h = (i(u), e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/scroll")),
            d = i(h),
            p = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils"),
            f = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap"),
            m = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing"),
            v = i(m),
            g = new v["default"](.645, .045, .355, 1),
            y = function (e) {
                function t(e, n) {
                    r(this, t);
                    var i = a(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
                    return i.isPresent ? (i.statsBlock = (0, p.mapElems)(i.block, i.getStatsBlock.bind(i)), i.statsBlock.forEach(function (e) {
                        e.stats.forEach(function (t) {
                            var n = t.getAttribute("data-animate"),
                                r = t.querySelector(".m-stats-module__number"),
                                a = parseInt(r.innerHTML, 10);
                            if (a && n) {
                                var o = a - 5;
                                o = o < 0 ? 0 : o, r.innerHTML = o, e.statsFormatted.push({
                                    finish: a,
                                    start: o,
                                    tween: i.getTween(o, a, r)
                                })
                            }
                        })
                    }), i._scroll = new d["default"], i._scrollID = i._scroll.addListener(i._onScroll.bind(i), "stats"), setTimeout(function () {
                        i._onScroll()
                    }, 1e3), i) : a(i)
                }
                return o(t, e), s(t, [{
                    key: "_onScroll",
                    value: function () {
                        this.statsBlock.forEach(function (e) {
                            var t = e.elem.getBoundingClientRect().top,
                                n = (0, p.getInnerHeight)();
                            t <= n - .1 * n && !e.reachedModule && (e.reachedModule = !0, e.statsFormatted.forEach(function (e) {
                                e.tween.play()
                            }))
                        })
                    }
                }, {
                    key: "stop",
                    value: function () {
                        this._scroll.removeListener(this._scrollID)
                    }
                }, {
                    key: "getTween",
                    value: function (e, t, n) {
                        var i = {
                            value: e
                        };
                        return new f.TweenLite(i, (0, p.randomFloatFromInterval)(1.5, 3), {
                            value: t,
                            ease: g,
                            roundProps: "value",
                            paused: !0,
                            onUpdate: function () {
                                n.innerHTML != i.value && (n.innerHTML = i.value)
                            }
                        })
                    }
                }, {
                    key: "getStatsBlock",
                    value: function (e) {
                        return {
                            elem: e,
                            stats: this.getChildren(e, "number-wrapper"),
                            statsFormatted: [],
                            reachedModule: !1
                        }
                    }
                }]), t
            }(c["default"]);
        n["default"] = y
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax": 21,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper": 23,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/scroll": 27,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing": 29,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap": 35
    }],
    18: [function (e, t, n) {
        "use strict";

        function i(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }

        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function a(e, t) {
            if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t || "object" != typeof t && "function" != typeof t ? e : t
        }

        function o(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var s = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            l = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper"),
            c = i(l),
            u = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax"),
            h = (i(u), e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/scroll")),
            d = i(h),
            p = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils"),
            f = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix"),
            m = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap"),
            v = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing"),
            g = i(v),
            y = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/hammerjs"),
            x = i(y),
            b = function (e) {
                function t(e, n) {
                    r(this, t);
                    var i = a(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
                    return i.isPresent ? (i.mouse = {
                        x: 0,
                        y: 0,
                        opacity: 0
                    }, i.dir = !1, i.dragCursorPos = {
                        x: 0,
                        y: 0
                    }, i.reqAnim = !1, i.reqLoop = i.loop.bind(i), i.hoveringModule = !1, i.hoveringBannedArea = !1, i.reachedModule = !1, i.headlineEaseIn = new g["default"](.215, .61, .355, 1), i.headlineEaseOut = new g["default"](.55, .055, .675, .19), i.rotation = 0, i.activeItemIndex = 1, i.items = (0, p.mapElems)(i.elements.item, i.getItem.bind(i)), i._scroll = new d["default"], i._scrollID = i._scroll.addListener(i._onScroll.bind(i), "image-grid"), i.elements.total_index.innerHTML = i.items.length, i.setEventListeners(), i) : a(i)
                }
                return o(t, e), s(t, [{
                    key: "_onScroll",
                    value: function (e) {
                        var t = this.block.getBoundingClientRect().top,
                            n = (0, p.getInnerHeight)();
                        t <= n && !this.reachedModule && (this.reachedModule = !0, this._scroll.removeListener(this._scrollID), this.animateInItem(this.getItemByIndex(this.activeItemIndex), this.onAnimationComplete.bind(this)))
                    }
                }, {
                    key: "stop",
                    value: function () {
                        this._scroll.removeListener(this._scrollID)
                    }
                }, {
                    key: "getItem",
                    value: function (e, t) {
                        return {
                            elem: e,
                            index: t + 1,
                            headline: e.querySelector(".o-animation--headline"),
                            paragraph: e.querySelector(".o-animation--paragraph")
                        }
                    }
                }, {
                    key: "setMinHeight",
                    value: function () {
                        var e = 0;
                        this.items.forEach(function (t) {
                            t.elem.offsetHeight > e && (e = t.elem.offsetHeight)
                        }), this.elements.item_wrapper_inner.style.minHeight = e + "px"
                    }
                }, {
                    key: "getItemByIndex",
                    value: function (e) {
                        return this.items.filter(function (t) {
                            return t.index == e
                        })[0]
                    }
                }, {
                    key: "setEventListeners",
                    value: function () {
                        var e = this;
                        (0, p.isTouchDevice)() ? (this.mc = new x["default"].Manager(this.block, {}), this.mc.add(new x["default"].Swipe({
                            direction: x["default"].DIRECTION_HORIZONTAL,
                            threshold: 0
                        })), this.mc.on("swipeleft", this.onPanLeft.bind(this)), this.mc.on("swiperight", this.onPanRight.bind(this))) : (this.block.addEventListener("mouseenter", this.onMouseEnter.bind(this)), this.block.addEventListener("mouseleave", this.onMouseLeave.bind(this)), this.block.addEventListener("mousemove", this.onMouseMove.bind(this)), this.block.addEventListener("click", this.onMouseClick.bind(this))), this.elements.navigate_arrow.forEach(function (t) {
                            t.addEventListener("click", function () {
                                e.onArrowClick(t)
                            })
                        })
                    }
                }, {
                    key: "onArrowClick",
                    value: function (e) {
                        var t = e.getAttribute("data-dir");
                        this.dir = t;
                        var n = this.activeItemIndex;
                        this.animateOutItem(this.getItemByIndex(n), this.setNewActiveIndex.bind(this))
                    }
                }, {
                    key: "onPanLeft",
                    value: function () {
                        this.dir = "forward";
                        var e = this.activeItemIndex;
                        this.animateOutItem(this.getItemByIndex(e), this.setNewActiveIndex.bind(this))
                    }
                }, {
                    key: "onPanRight",
                    value: function () {
                        this.dir = "back";
                        var e = this.activeItemIndex;
                        this.animateOutItem(this.getItemByIndex(e), this.setNewActiveIndex.bind(this))
                    }
                }, {
                    key: "onMouseEnter",
                    value: function () {
                        this.active = !0, this.loop()
                    }
                }, {
                    key: "onMouseLeave",
                    value: function () {
                        this.active = !1, this.elements.cursor.style.opacity = 0, (0, f.cancelAnimationFrame)(this.reqAnim)
                    }
                }, {
                    key: "onMouseMove",
                    value: function (e) {
                        this.mouse.y = (2 * -((e.clientY - this.block.getBoundingClientRect().top) / this.block.offsetHeight) + 1) * this.block.offsetHeight / 2, this.mouse.x = ((e.clientX - this.block.getBoundingClientRect().left) / this.block.offsetWidth * 2 - 1) * this.block.offsetWidth / 2, this.mouse.opacity = !this.hoveringBannedArea && this.active ? 1 : 0, this.dir = !this.hoveringBannedArea && (this.mouse.x <= 0 ? "back" : "forward"), this.rotation = this.mouse.x < 0 ? 180 : 0
                    }
                }, {
                    key: "onMouseClick",
                    value: function () {
                        if (this.dir && !this.animating) {
                            var e = this.activeItemIndex;
                            this.animateOutItem(this.getItemByIndex(e), this.setNewActiveIndex.bind(this))
                        }
                    }
                }, {
                    key: "setNewActiveIndex",
                    value: function () {
                        "forward" == this.dir && this.activeItemIndex < this.items.length ? this.activeItemIndex += 1 : "back" == this.dir && this.activeItemIndex > 1 ? this.activeItemIndex -= 1 : this.activeItemIndex = "forward" == this.dir ? 1 : this.items.length;
                        var e = this.activeItemIndex;
                        this.elements.active_index.innerHTML = e, this.animateInItem(this.getItemByIndex(e), this.onAnimationComplete.bind(this))
                    }
                }, {
                    key: "animateInItem",
                    value: function (e, t) {
                        var n = this;
                        e.elem.style.opacity = 1, m.TweenLite.set(e.headline, {
                            y: 150,
                            opacity: 0,
                            skewY: 6
                        }), m.TweenLite.set(e.paragraph, {
                            y: 150,
                            opacity: 0,
                            skewY: 6
                        }), m.TweenLite.to(e.headline, .9, {
                            opacity: 1,
                            y: 0,
                            skewY: 0,
                            ease: this.headlineEaseIn
                        }), m.TweenLite.to(e.paragraph, .9, {
                            opacity: 1,
                            y: 0,
                            skewY: 0,
                            delay: .1,
                            ease: this.headlineEaseIn,
                            onComplete: function () {
                                n.animating = !1, t()
                            }
                        })
                    }
                }, {
                    key: "animateOutItem",
                    value: function (e, t) {
                        this.animating = !0, m.TweenLite.to(e.headline, .65, {
                            opacity: 0,
                            delay: .1,
                            skewY: 6,
                            y: 80,
                            ease: this.headlineEaseOut,
                            onComplete: function () {
                                e.elem.style.opacity = 0, t()
                            }
                        }), m.TweenLite.to(e.paragraph, .65, {
                            opacity: 0,
                            y: 80,
                            ease: this.headlineEaseOut
                        })
                    }
                }, {
                    key: "onAnimationComplete",
                    value: function () {}
                }, {
                    key: "loop",
                    value: function () {
                        var e = this.mouse.x - this.dragCursorPos.x,
                            t = this.mouse.y - this.dragCursorPos.y;
                        this.dragCursorPos.x += e, this.dragCursorPos.y += t, this.elements.cursor.style.opacity = this.mouse.opacity, this.elements.cursor.style["" + (0, f.getPrefix)("transform")] = "translate3d(" + this.dragCursorPos.x + "px, " + -this.dragCursorPos.y + "px, 0px) rotate(" + this.rotation + "deg)", this.reqAnim = (0, f.requestAnimationFrame)(this.reqLoop)
                    }
                }]), t
            }(c["default"]);
        n["default"] = b
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax": 21,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper": 23,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix": 25,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/scroll": 27,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing": 29,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap": 35,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/hammerjs": 36
    }],
    19: [function (e, t, n) {
        "use strict";

        function i(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }

        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function a(e, t) {
            if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return !t || "object" != typeof t && "function" != typeof t ? e : t
        }

        function o(e, t) {
            if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + typeof t);
            e.prototype = Object.create(t && t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var s = Object.assign || function (e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
                }
                return e
            },
            l = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            c = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper"),
            u = i(c),
            h = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/swiper"),
            d = i(h),
            p = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils"),
            f = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix"),
            m = (e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap"), {
                media_carousel: function (e) {
                    return {
                        speed: 200,
                        longSwipesRatio: .2,
                        slidesPerView: 1,
                        setWrapperSize: !0,
                        centeredSlides: !1,
                        slideToClickedSlide: !0,
                        paginationClickable: !1,
                        touchRatio: (0, p.isTouchDevice)() ? 1 : 0,
                        initialSlide: 0,
                        loopAdditionalSlides: 1,
                        spaceBetween: 60,
                        freeMode: !1,
                        loop: !1,
                        effect: "fade",
                        pagination: {
                            el: e.pagination,
                            type: "progressbar",
                            modifierClass: "o-swiper__",
                            progressbarFillClass: "o-swiper__progressbar-fill"
                        },
                        breakpoints: {
                            640: {
                                slidesPerView: 1,
                                spaceBetween: 15
                            }
                        },
                        on: {
                            init: function () {
                                this.$wrapperEl[0].style.opacity = 1, e.indexTotal.innerHTML = e.numberOfSlides, e.indexWrapper.style.opacity = .4
                            },
                            slideChange: function () {
                                e.indexCurrent.innerHTML = (0, p.limitNumber)(this.realIndex + 1, 1, e.numberOfSlides)
                            }
                        }
                    }
                },
                some_carousel: function (e) {
                    return {
                        speed: 200,
                        longSwipesRatio: .2,
                        slidesPerView: 1,
                        setWrapperSize: !0,
                        centeredSlides: !1,
                        slideToClickedSlide: !0,
                        paginationClickable: !0,
                        touchRatio: (0, p.isTouchDevice)() ? 1 : 0,
                        initialSlide: 0,
                        loopAdditionalSlides: 1,
                        spaceBetween: 60,
                        freeMode: !1,
                        loop: !0,
                        effect: "fade",
                        pagination: {
                            el: ".swiper-pagination",
                            type: "bullets",
                            modifierClass: "o-swiper__"
                        },
                        breakpoints: {
                            640: {
                                slidesPerView: 1,
                                spaceBetween: 15
                            }
                        },
                        on: {
                            init: function () {
                                this.$wrapperEl[0].style.opacity = 1
                            }
                        }
                    }
                }
            }),
            v = {
                loop: !0,
                speed: 600,
                longSwipesRatio: .1,
                wrapperClass: "o-swiper__wrapper",
                slideClass: "o-swiper__item",
                slideActiveClass: "o-swiper__item--active",
                slideDuplicatedActiveClass: "o-swiper__item--duplicate-active",
                slideVisibleClass: "o-swiper__item--visible",
                slideDuplicateClas: "o-swiper__item--duplicate",
                slideNextClass: "o-swiper__item--next",
                slideDuplicatedNextClass: "o-swiper__item--duplicate-next",
                slidePrevClass: "o-swiper__item--prev",
                slideDuplicatedPrevClass: "o-swiper__item--duplicate-prev"
            },
            g = function (e) {
                function t(e, n) {
                    r(this, t);
                    var i = a(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e));
                    return i.isPresent ? (i.options = n, i.onMouseEnter = n.onMouseEnter, i.onMouseLeave = n.onMouseLeave, i.wrappers = (0, p.mapElems)(i.block, i.initSwiper.bind(i)), i.activeSwiper = !1, i.reqFrame = !1, i.reqLoop = i.loop.bind(i), i.setEventListeners(i.wrappers), i) : a(i)
                }
                return o(t, e), l(t, [{
                    key: "initSwiper",
                    value: function (e) {
                        var t = this.getChildren(e, "container"),
                            n = {
                                indexCurrent: this.getChild(e, "current-index"),
                                indexTotal: this.getChild(e, "total-index"),
                                indexWrapper: this.getChild(e, "index"),
                                numberOfSlides: e.getAttribute("data-number-of-slides")
                            },
                            i = e.getAttribute("data-swiper-type").split("-").join("_"),
                            r = s({}, v, m[i](n)),
                            a = this.getChildren(e, "wrapper"),
                            o = this.getChildren(e, "item").length;
                        return o || "product_carousel" == i ? {
                            block: e,
                            type: i,
                            container: t,
                            options: r,
                            hovering: !1,
                            dir: !1,
                            hoveringBannedArea: !1,
                            iframes: [],
                            mouse: {
                                x: 0,
                                y: 0,
                                opacity: 0,
                                rotation: 0
                            },
                            cursor: e.querySelector(".o-swiper__cursor"),
                            dragCursorPos: {
                                x: 0,
                                y: 0
                            },
                            slider: new d["default"](t, r)
                        } : void(a.style.opacity = 1)
                    }
                }, {
                    key: "setEventListeners",
                    value: function (e) {
                        var t = this;
                        e.forEach(function (e) {
                            var n = (0, p.nodesAsArray)(e.block.querySelectorAll(".c-video__play-btn")),
                                i = (0, p.nodesAsArray)(e.block.querySelectorAll(".c-video__progress")),
                                r = (0, p.nodesAsArray)(e.block.querySelectorAll(".c-video__player"));
                            (0, p.isTouchDevice)() || (e.block.addEventListener("mousemove", function (n) {
                                t.onMouseMove(n, e)
                            }), e.block.addEventListener("mouseleave", function (e) {
                                (0, f.cancelAnimationFrame)(t.reqFrame), t.activeSwiper.cursor.style.opacity = 0, t.activeSwiper = !1
                            }), e.block.addEventListener("mouseenter", function (n) {
                                t.activeSwiper = e, t.loop()
                            }), n.forEach(function (t) {
                                t.addEventListener("mouseover", function () {
                                    e.hoveringBannedArea = !0
                                }), t.addEventListener("mouseleave", function () {
                                    e.hoveringBannedArea = !1
                                })
                            }), i.forEach(function (t) {
                                t.addEventListener("mouseover", function () {
                                    e.hoveringBannedArea = !0
                                }), t.addEventListener("mouseleave", function () {
                                    e.hoveringBannedArea = !1
                                })
                            }), r.forEach(function (t) {
                                t.addEventListener("mouseover", function () {
                                    e.hoveringBannedArea = !0
                                }), t.addEventListener("mouseleave", function () {
                                    e.hoveringBannedArea = !1
                                })
                            }), e.block.addEventListener("click", function () {
                                e.dir && ("forward" == e.dir ? e.slider.slideNext() : "back" == e.dir && e.slider.slidePrev())
                            }))
                        })
                    }
                }, {
                    key: "onMouseMove",
                    value: function (e, t) {
                        t.mouse.y = (2 * -((e.clientY - t.block.getBoundingClientRect().top) / t.block.offsetHeight) + 1) * t.block.offsetHeight / 2, t.mouse.x = ((e.clientX - t.block.getBoundingClientRect().left) / t.block.offsetWidth * 2 - 1) * t.block.offsetWidth / 2, t.mouse.opacity = t.hoveringBannedArea ? 0 : 1, t.dir = !t.hoveringBannedArea && (t.mouse.x <= 0 ? "back" : "forward"), t.mouse.rotation = t.mouse.x < 0 ? 180 : 0
                    }
                }, {
                    key: "removeEventListeners",
                    value: function () {}
                }, {
                    key: "loop",
                    value: function () {
                        var e = this.activeSwiper.mouse.x - this.activeSwiper.dragCursorPos.x,
                            t = this.activeSwiper.mouse.y - this.activeSwiper.dragCursorPos.y;
                        this.activeSwiper.dragCursorPos.x += e, this.activeSwiper.dragCursorPos.y += t, this.activeSwiper.cursor.style.opacity = this.activeSwiper.mouse.opacity, this.activeSwiper.cursor.style["" + (0, f.getPrefix)("transform")] = "translate3d(" + this.activeSwiper.dragCursorPos.x + "px, " + -this.activeSwiper.dragCursorPos.y + "px, 0px) rotate(" + this.activeSwiper.mouse.rotation + "deg)", this.reqFrame = (0, f.requestAnimationFrame)(this.reqLoop)
                    }
                }]), t
            }(u["default"]);
        n["default"] = g
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper": 23,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix": 25,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap": 35,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/swiper": 46
    }],
    20: [function (e, t, n) {
        "use strict";

        function i(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }

        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var a = Object.assign || function (e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
                }
                return e
            },
            o = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            s = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap"),
            l = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing"),
            c = i(l),
            u = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax"),
            h = i(u),
            d = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils"),
            p = new c["default"](.645, .045, .355, 1),
            f = function () {
                function e(t, n) {
                    r(this, e);
                    var i = {
                        constantAnchorClassName: ".js-constant-anchor",
                        anchorClassName: ".js-anchor",
                        contentSelector: ".content",
                        contentWrapperSelector: ".content-wrapper",
                        activeClass: "is-visible",
                        beforeLoadingPage: null,
                        duringLoadingPage: null,
                        afterLoadingPage: null,
                        afterAnimatedPage: null,
                        duplicateClicked: null,
                        onConstantTriggerClick: null
                    };
                    this._header = n.header, this.settings = a(i, t), this.loadedContent = {}, this._hash = !1, this._popStateTriggered = !1, this._initiPopFired = !1, this._anchorTarget = null, this._isCached = !1, this._animating = !1, this.loadingCurtain = document.querySelector(".loading-curtain"), "scrollRestoration" in history && (history.scrollRestoration = "manual"), this.init()
                }
                return o(e, [{
                    key: "init",
                    value: function () {
                        this._pushState(window.location.pathname), this._setEventListeners()
                    }
                }, {
                    key: "_setEventListeners",
                    value: function () {
                        var e = this;
                        this._setConstantTriggerEventListeners(), this._setTriggerEventListeners(), window.addEventListener("popstate", function (t) {
                            return e._onPopState(t)
                        })
                    }
                }, {
                    key: "_setConstantTriggerEventListeners",
                    value: function () {
                        var e = this,
                            t = this._getConstantTriggers();
                        t.forEach(function (t) {
                            t.addEventListener("click", function (t) {
                                e.settings.onConstantTriggerClick(t.currentTarget.getAttribute("data-id")), e._onTriggerClicked(t)
                            })
                        })
                    }
                }, {
                    key: "_setTriggerEventListeners",
                    value: function () {
                        var e = this,
                            t = this._getAvailableTriggers();
                        t.forEach(function (t) {
                            e.addTrigger(t)
                        })
                    }
                }, {
                    key: "_getConstantTriggers",
                    value: function () {
                        return Array.prototype.slice.call(document.querySelectorAll("" + this.settings.constantAnchorClassName))
                    }
                }, {
                    key: "_getAvailableTriggers",
                    value: function () {
                        return Array.prototype.slice.call(document.querySelectorAll("" + this.settings.anchorClassName))
                    }
                }, {
                    key: "addTrigger",
                    value: function (e) {
                        var t = this;
                        e.addEventListener("click", function (e) {
                            return t._onTriggerClicked(e)
                        })
                    }
                }, {
                    key: "_onPopState",
                    value: function (e) {
                        var t = this,
                            n = e.state;
                        if (n && !this._animating) {
                            if (navigator.userAgent.match("CriOS") && !this._initiPopFired) return void(this._initiPopFired = !0);
                            this._popStateTriggered = !0;
                            var i = n;
                            if (this.settings.beforeLoadingPage) {
                                this._isCached = this.loadedContent[i] || "undefined" != typeof this.loadedContent[i];
                                var r = !!this._isCached && this.loadedContent[i].bgColor;
                                r && (this.loadingCurtain.style.backgroundColor = r), this.settings.beforeLoadingPage(this._isCached, !1, !1, !1, function () {
                                    t._animateOutContent(function () {
                                        t._getPageByHref(i)
                                    })
                                })
                            }
                        }
                    }
                }, {
                    key: "_onTriggerClicked",
                    value: function (e) {
                        var t = this;
                        if (e.preventDefault(), !this._animating) {
                            this._popStateTriggered = !1;
                            var n = e.currentTarget,
                                i = n.getAttribute("data-bgcolor"),
                                r = n.getAttribute("data-is-post"),
                                a = n.getAttribute("href") || n.getAttribute("data-href");
                            if (i && (this.loadingCurtain.style.backgroundColor = i), this._isCached = this.loadedContent[a] || "undefined" != typeof this.loadedContent[a], a === window.location.href || a === window.location.pathname) return void this.settings.duplicateClicked();
                            if (this._stripHashFromUrl(a) === this._stripHashFromUrl(window.location.href)) return void this._scrollToHash();
                            this._animating = !0, this.settings.beforeLoadingPage && this.settings.beforeLoadingPage(this._isCached, r, !1, !1, function () {
                                t._animateOutContent(function () {
                                    t._getPageByHref(a, i)
                                })
                            })
                        }
                    }
                }, {
                    key: "_stripHashFromUrl",
                    value: function (e) {
                        return e.indexOf("#") !== -1 ? e.substr(0, e.indexOf("#")) : e
                    }
                }, {
                    key: "_getPageByHref",
                    value: function (e) {
                        var t = this,
                            n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        this.loadedContent[e] || "undefined" != typeof this.loadedContent[e] ? this._onRequestCompleted(this.loadedContent[e].response, e) : h["default"].get(e, {}, {
                            onSuccess: function (i) {
                                t.loadedContent[e] = {}, t.loadedContent[e].response = i, n && (t.loadedContent[e].bgColor = n), t._onRequestCompleted(i, e)
                            },
                            onError: this._onRequestError.bind(this),
                            processData: !1,
                            json: !1
                        })
                    }
                }, {
                    key: "_onRequestCompleted",
                    value: function (e, t) {
                        var n = document.createElement("div");
                        n.innerHTML = e;
                        var i = n.querySelector(".o-main-wrapper__inner"),
                            r = i.querySelector("#page-title").value;
                        this._popStateTriggered || this._pushState(t, r), this.settings.duringLoadingPage && this.settings.duringLoadingPage(t, i.querySelector("#page-id").value), this._transformToTargetPage(i, t)
                    }
                }, {
                    key: "_onRequestError",
                    value: function (e) {
                        console.error("failed!", e)
                    }
                }, {
                    key: "_animateOutContent",
                    value: function (e) {
                        var t = this,
                            n = document.querySelector(this.settings.contentSelector);
                        this._animateContent(n, "remove", function () {
                            t._scrollToTop(), e()
                        })
                    }
                }, {
                    key: "_transformToTargetPage",
                    value: function (e, t) {
                        var n = this,
                            i = e,
                            r = !1,
                            a = this._appendTargetContent(i);
                        this.settings.afterLoadingPage(this._isCached, function () {
                            var e = (n._isCached, .4);
                            n._animateContent(a, "add", function () {
                                r || (n._postLoadedContent(t), r = !0)
                            }, e)
                        })
                    }
                }, {
                    key: "_animateContent",
                    value: function (e, t, n) {
                        var i = this,
                            r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0;
                        this.loadingCurtain.style.display = "block";
                        var a = (this._header.isAnimating && this._isCached && "remove" == t, 0),
                            o = parseInt(document.getElementById("curtain-disabled").value, 10),
                            l = "add" === t && o ? 0 : .75;
                        s.TweenLite.to(this.loadingCurtain, l, {
                            y: "remove" === t ? 0 : -Math.abs((0, d.getInnerHeight)()),
                            delay: "add" === t ? r : a,
                            ease: p,
                            onComplete: function () {
                                "add" === t ? (s.TweenLite.set(i.loadingCurtain, {
                                    y: Math.abs((0, d.getInnerHeight)())
                                }), document.documentElement.classList.remove("noscroll-hidden"), i.loadingCurtain.style.display = "none") : "remove" == t && document.documentElement.classList.add("noscroll-hidden"), n()
                            }
                        })
                    }
                }, {
                    key: "_appendTargetContent",
                    value: function (e) {
                        if (e) {
                            var t = document.querySelector(this.settings.contentWrapperSelector);
                            return t.removeChild(t.querySelector(this.settings.contentSelector)), t.appendChild(e), t.querySelector(this.settings.contentSelector)
                        }
                    }
                }, {
                    key: "_postLoadedContent",
                    value: function () {
                        var e = this;
                        this.settings.afterAnimatedPage && this.settings.afterAnimatedPage(function () {
                            e._animating = !1
                        }), this._anchorTarget = !1, this._setTriggerEventListeners()
                    }
                }, {
                    key: "_scrollToHash",
                    value: function () {
                        if (window.location.hash) {
                            var e = document.querySelector(window.location.hash);
                            s.TweenLite.to(window, 1.2, {
                                scrollTo: e,
                                ease: Power3.easeInOut
                            })
                        }
                    }
                }, {
                    key: "_pushState",
                    value: function (e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                        history.pushState(e, t, e)
                    }
                }, {
                    key: "_scrollToTop",
                    value: function () {
                        window.scrollTo(0, 0)
                    }
                }, {
                    key: "_parseHtmlString",
                    value: function (e) {
                        var t = new DOMParser;
                        return t.parseFromString(e, "text/html")
                    }
                }]), e
            }();
        n["default"] = f
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/ajax": 21,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing": 29,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap": 35
    }],
    21: [function (e, t, n) {
        "use strict";
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var i = Object.assign || function (e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
                }
                return e
            },
            r = {
                async: !0,
                processData: !0,
                json: !0,
                formData: !1,
                onSuccess: function () {},
                onError: function () {}
            },
            a = {
                x: function () {
                    if ("undefined" != typeof XMLHttpRequest) return new XMLHttpRequest;
                    for (var e, t = ["MSXML2.XmlHttp.6.0", "MSXML2.XmlHttp.5.0", "MSXML2.XmlHttp.4.0", "MSXML2.XmlHttp.3.0", "MSXML2.XmlHttp.2.0", "Microsoft.XmlHttp"], n = 0; n < t.length; n++) try {
                        e = new ActiveXObject(t[n]);
                        break
                    } catch (i) {}
                    return e
                },
                parseData: function (e, t) {
                    return e ? JSON.parse(t) : t
                },
                send: function (e, t, n, i) {
                    var r = a.x();
                    r.open(i, e, n.async), r.onreadystatechange = function () {
                        r.readyState == r.DONE && (404 == r.status || 400 == r.status || 403 == r.status ? n.onError(a.parseData(n.json, r.responseText)) : n.onSuccess(a.parseData(n.json, r.responseText)))
                    }, "POST" == i && r.setRequestHeader("Content-type", "application/x-www-form-urlencoded"), r.send(t)
                },
                "delete": function (e, t, n) {
                    var o = i({}, r, n),
                        s = [];
                    for (var l in t) s.push(encodeURIComponent(l) + "=" + encodeURIComponent(t[l]));
                    a.send(e + (s.length ? "?" + s.join("&") : ""), {}, o, "DELETE")
                },
                get: function (e, t, n) {
                    var o = i({}, r, n),
                        s = [];
                    for (var l in t) s.push(encodeURIComponent(l) + "=" + encodeURIComponent(t[l]));
                    a.send(e + (s.length ? "?" + s.join("&") : ""), {}, o, "GET")
                },
                post: function (e, t, n) {
                    var o, s = i({}, r, n),
                        l = [];
                    if (s.formData) o = t;
                    else if (s.processData) {
                        for (var c in t) l.push(encodeURIComponent(c) + "=" + encodeURIComponent(t[c]));
                        o = l.join("&")
                    } else o = JSON.stringify(t);
                    a.send(e, o, s, "POST")
                }
            };
        n["default"] = a
    }, {}],
    22: [function (e, t, n) {
        "use strict";

        function i(e) {
            return e && e.__esModule ? e : {
                "default": e
            }
        }

        function r(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var a = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            o = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper"),
            s = (i(o), e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/scroll")),
            l = i(s),
            c = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils"),
            u = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap"),
            h = e("/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing"),
            d = i(h),
            p = (new d["default"](.23, 1, .32, 1), new d["default"](.215, .61, .355, 1), new d["default"](.215, .61, .355, 1)),
            f = function () {
                function e(t) {
                    r(this, e), this.killWhenVisible = t.killWhenVisible, this._scrollID = -1, this._scrollTop = 0, this.stopped = !1, this.firstInit = !0, this.isMobile = (0, c.getMq)().xsmall, this.animations = {
                        paragraph: {
                            y: this.isMobile ? 60 : 80,
                            opacity: 0
                        },
                        skew: {
                            y: this.isMobile ? 50 : 150,
                            skewY: 7,
                            opacity: 0
                        }
                    }, this._scroll = new l["default"]
                }
                return a(e, [{
                    key: "init",
                    value: function () {
                        var e = this;
                        this._elements = (0, c.nodesAsArray)(document.querySelectorAll("[data-in-viewport]")), this._elementData = this._getElementData(), this._scrollID = this._scroll.addListener(this._onScroll.bind(this), "animate in");
                        var t = this.firstInit ? 400 : 0;
                        setTimeout(function () {
                            e._checkForElementInViewport()
                        }, t), this.firstInit = !1
                    }
                }, {
                    key: "_getElementData",
                    value: function () {
                        var e = this,
                            t = this._elements.map(function (t) {
                                var n = t.getAttribute("data-animation-type"),
                                    i = t.getAttribute("data-offset") ? parseInt(t.getAttribute("data-offset")) : 0,
                                    r = t.getAttribute("data-delay") ? parseInt(t.getAttribute("data-delay")) / 1e3 : 0,
                                    a = t.hasAttribute("data-no-transform"),
                                    o = (t.getAttribute("data-in-viewport-disabled"), !!t.getAttribute("data-no-delay") && (0, c.getMq)()[t.getAttribute("data-no-delay")]),
                                    s = o ? 0 : r,
                                    l = e.getAnimationObject(n, t, s),
                                    u = {
                                        elem: t,
                                        additionalOffset: i / 1e3,
                                        delay: s,
                                        isVisible: !1,
                                        disabledTransform: a,
                                        animation: l
                                    };
                                return u
                            });
                        return t
                    }
                }, {
                    key: "getAnimationObject",
                    value: function (e, t) {
                        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        switch (e) {
                            case "headline":
                                return u.TweenLite.fromTo(t, .9, {
                                    skewY: 7,
                                    yPercent: 0,
                                    opacity: 0
                                }, {
                                    yPercent: -100,
                                    skewY: 0,
                                    opacity: 1,
                                    ease: p,
                                    delay: n,
                                    paused: !0,
                                    onComplete: this.onAnimationCompleted.bind(t)
                                });
                            case "paragraph":
                                return u.TweenLite.fromTo(t, .9, this.animations.paragraph, {
                                    opacity: 1,
                                    y: 0,
                                    ease: p,
                                    paused: !0,
                                    delay: n,
                                    onComplete: this.onAnimationCompleted.bind(t)
                                });
                            case "skew-text":
                                return u.TweenLite.fromTo(t, .9, this.animations.skew, {
                                    opacity: 1,
                                    y: 0,
                                    skewY: 0,
                                    ease: p,
                                    paused: !0,
                                    delay: n,
                                    onComplete: this.onAnimationCompleted.bind(t)
                                });
                            case "fade":
                                return u.TweenLite.fromTo(t, .9, {
                                    opacity: 0
                                }, {
                                    opacity: 1,
                                    paused: !0,
                                    delay: n,
                                    onComplete: this.onAnimationCompleted.bind(t)
                                });
                            case "reveal":
                                return u.TweenLite.fromTo(t, 0, {
                                    opacity: 0
                                }, {
                                    opacity: 1,
                                    paused: !0,
                                    delay: n,
                                    onComplete: this.onAnimationCompleted.bind(t)
                                });
                            default:
                                return !1
                        }
                    }
                }, {
                    key: "onAnimationCompleted",
                    value: function () {
                        this.classList.add("animated"), this.style.willChange = "auto"
                    }
                }, {
                    key: "_onScroll",
                    value: function () {
                        this._checkForElementInViewport()
                    }
                }, {
                    key: "_checkForElementInViewport",
                    value: function () {
                        var e = this;
                        this._elementData.map(function (t) {
                            if (!t.isVisible) {
                                var n = e._getOffset(t.elem, t.additionalOffset);
                                n && (t.isVisible = !0, t.animation && (t.elem.style.willChange = "transform", t.animation.play()), e.isInViewport && e.isInViewport(t.elem))
                            }
                        })
                    }
                }, {
                    key: "_allElementsIsVisible",
                    value: function () {
                        return this._elementData.every(function (e) {
                            return e.isVisible
                        })
                    }
                }, {
                    key: "_getOffset",
                    value: function (e, t) {
                        var n = (0, c.getInnerHeight)(),
                            i = e.getBoundingClientRect().top,
                            r = n - n * t;
                        return i <= r
                    }
                }, {
                    key: "stop",
                    value: function () {
                        this._scroll.removeListener(this._scrollID)
                    }
                }]), e
            }();
        n["default"] = f
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/block-helper": 23,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/scroll": 27,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/bezier-easing": 29,
        "/Users/andreaslorentsson/Projects/animal/frontend/node_modules/gsap": 35
    }],
    23: [function (e, t, n) {
        "use strict";

        function i(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var r = Object.assign || function (e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
                }
                return e
            },
            a = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            o = function () {
                function e(t) {
                    i(this, e);
                    var n = {
                            multiple: !0
                        },
                        a = t.settings || {};
                    this.settings = r(n, a), this.id = t.block, this.parent = t.parent ? t.parent : document, this.block = this._getBlock(this.id), this.elements = this._getElements(t.elements), this.isPresent = !(!this.block || 0 === this.block.length)
                }
                return a(e, [{
                    key: "_getBlock",
                    value: function (e) {
                        if (e) return this.settings.multiple ? Array.prototype.slice.call(this.parent.querySelectorAll("." + this.id)) : this.parent.querySelector("." + this.id)
                    }
                }, {
                    key: "_getElements",
                    value: function (e) {
                        var t = this;
                        if (e) {
                            var n = {};
                            return e.forEach(function (e) {
                                var i = Array.prototype.slice.call(t.parent.querySelectorAll("." + t.id + " ." + t.id + "__" + e));
                                n[e.split("-").join("_")] = i.length > 1 ? i : i[0]
                            }), n
                        }
                    }
                }, {
                    key: "getChildren",
                    value: function (e, t, n) {
                        var i = void 0;
                        i = "undefined" != typeof n ? "." + this.id + "__" + t + "--" + n : "." + this.id + "__" + t;
                        var r = Array.prototype.slice.call(e.querySelectorAll(i));
                        return e && r.length > 1 ? r : !(!e || 1 != r.length) && r[0]
                    }
                }, {
                    key: "getChild",
                    value: function (e, t, n) {
                        var i = void 0;
                        i = "undefined" != typeof n ? "." + this.id + "__" + t + "--" + n : "." + this.id + "__" + t;
                        var r = Array.prototype.slice.call(e.querySelectorAll(i));
                        return e && r.length > 1 ? r : !(!e || 1 != r.length) && r[0]
                    }
                }, {
                    key: "hasMod",
                    value: function (e, t) {
                        return e.classList.contains(this.id + "--" + t)
                    }
                }, {
                    key: "childrenHasMod",
                    value: function (e, t, n) {
                        return e.classList.contains(this.id + "__" + t + "--" + n)
                    }
                }, {
                    key: "addMod",
                    value: function (e, t) {
                        e.classList.add(this.id + "--" + t)
                    }
                }, {
                    key: "addChildrenMod",
                    value: function (e, t, n) {
                        e.classList.add(this.id + "__" + t + "--" + n)
                    }
                }, {
                    key: "removeMod",
                    value: function (e, t) {
                        e.classList.remove(this.id + "--" + t)
                    }
                }, {
                    key: "removeChildrenMod",
                    value: function (e, t, n) {
                        e.classList.remove(this.id + "__" + t + "--" + n)
                    }
                }, {
                    key: "getParentBlock",
                    value: function (e) {
                        for (var t = e; !t.parentNode.classList.contains(this.id);) t = t.parentNode;
                        return t.parentNode
                    }
                }]), e
            }();
        n["default"] = o
    }, {}],
    24: [function (e, t, n) {
        "use strict";

        function i(e, t) {
            return Math.floor(Math.random() * (t - e + 1) + e)
        }

        function r(e, t) {
            return (Math.random() * (t - e) + e).toFixed(2)
        }

        function a(e, t, n) {
            return Math.min(Math.max(parseFloat(e), t), n)
        }

        function o(e, t, n) {
            return e * (n - t) + t
        }

        function s() {
            return {
                width: window.innerWidth,
                height: window.innerHeight
            }
        }

        function l(e, t) {
            t || (t = window.location.href), e = e.replace(/[\[\]]/g, "\\$&");
            var n = new RegExp("[?&]" + e + "(=([^&#]*)|&|#|$)"),
                i = n.exec(t);
            return i ? i[2] ? decodeURIComponent(i[2].replace(/\+/g, " ")) : "" : null
        }

        function c() {
            return /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
        }

        function u(e, t) {
            var n = Array.isArray(e) ? e : [e],
                i = n.map(t);
            return i
        }

        function h(e) {
            return [].slice.call(e)
        }

        function d() {
            var e = " -webkit- -moz- -o- -ms- ".split(" "),
                t = function (e) {
                    return window.matchMedia(e).matches
                };
            if ("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch) return !0;
            var n = ["(", e.join("touch-enabled),("), "heartz", ")"].join("");
            return t(n)
        }

        function p() {
            var e = 1560,
                t = 1100,
                n = 800,
                i = 640,
                r = 374;
            return {
                large: window.matchMedia("(max-width: " + e + "px)").matches,
                medium: window.matchMedia("(max-width: " + t + "px)").matches,
                small: window.matchMedia("(max-width: " + n + "px)").matches,
                xsmall: window.matchMedia("(max-width: " + i + "px)").matches,
                xxsmall: window.matchMedia("(max-width: " + r + "px)").matches
            }
        }

        function f() {
            return /Trident.*rv[ :]*11\./.test(navigator.userAgent)
        }

        function m(e, t) {
            var n = document.createAttribute(e);
            return n.value = t, n
        }

        function v(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "",
                i = document.createElement(e);
            return i.className = t, i.innerHTML = n, i
        }

        function g(e, t, n) {
            var i = new Date;
            i.setTime(i.getTime() + 24 * n * 60 * 60 * 1e3);
            var r = "expires=" + i.toUTCString();
            document.cookie = e + "=" + t + ";" + r + ";path=/"
        }

        function y(e) {
            for (var t = e + "=", n = document.cookie.split(";"), i = 0; i < n.length; i++) {
                for (var r = n[i];
                    " " == r.charAt(0);) r = r.substring(1);
                if (0 == r.indexOf(t)) return r.substring(t.length, r.length)
            }
            return ""
        }

        function x() {
            var e = document.querySelector("#page-title").value;
            e && (document.title = e)
        }

        function b(e) {
            var t = new Date(null);
            return t.setSeconds(Math.floor(e)), t.toISOString().substr(14, 5)
        }

        function _() {
            var e = window.navigator.userAgent,
                t = e.indexOf("MSIE ");
            if (t > 0) return parseInt(e.substring(t + 5, e.indexOf(".", t)), 10);
            var n = e.indexOf("Trident/");
            if (n > 0) {
                var i = e.indexOf("rv:");
                return parseInt(e.substring(i + 3, e.indexOf(".", i)), 10)
            }
            var r = e.indexOf("Edge/");
            return r > 0 && parseInt(e.substring(r + 5, e.indexOf(".", r)), 10)
        }

        function w(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                n = e.width * t,
                i = e.height * t,
                r = document.createElement("canvas");
            document.body.appendChild(r), r.width = n, r.height = i, r.style.display = "none";
            var a = r.getContext("2d");
            a.drawImage(e, 0, 0, n, i);
            var o = a.getImageData(0, 0, n, i);
            document.body.removeChild(r);
            for (var s = [], l = 1, c = 1, u = 0; u < n; u += l)
                for (var h = 0; h < i; h += c) {
                    var d = 4 * (h * n + u);
                    o.data[d + 4] <= 0 || s.push({
                        x: u - n / 2,
                        y: -(h - i / 2),
                        z: 0
                    })
                }
            return s
        }

        function M() {
            return P
        }

        function T(e) {
            P = e
        }

        function E() {
            return C
        }

        function S(e) {
            C = e
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        }), n.randomIntFromInterval = i, n.randomFloatFromInterval = r, n.limitNumber = a, n.getNormalizedValue = o, n.getDimensions = s, n.getParameterByName = l, n.isSafari = c, n.mapElems = u, n.nodesAsArray = h, n.isTouchDevice = d, n.getMq = p, n.isIE11 = f, n.createNodeAttribute = m, n.createNode = v, n.setCookie = g, n.getCookie = y, n.changeSiteTitle = x, n.secAsMMSS = b, n.detectIE = _, n.getPointsOnPicture = w, n.getInnerHeight = M, n.setInnerHeight = T, n.getInnerWidth = E, n.setInnerWidth = S;
        var P = 0,
            C = 0
    }, {}],
    25: [function (e, t, n) {
        "use strict";

        function i() {
            var e = document.createElement("div");
            if (null == e.style.transform) {
                var t = ["Webkit", "Moz", "ms"];
                for (var n in t)
                    if (void 0 !== e.style[t[n] + "Transform"]) return t[n] + "Transform"
            }
            return "transform"
        }

        function r(e) {
            return a
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        }), n.getPrefix = r;
        var a = i();
        n.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame, n.cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame
    }, {}],
    26: [function (e, t, n) {
        "use strict";

        function i(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var r = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            a = null,
            o = function () {
                function e() {
                    return i(this, e), a || (a = this), this._isResizing = !1, this._isResizingInterval = null, this._resizeListener = this._onResize.bind(this), this._callbacks = [], a
                }
                return r(e, [{
                    key: "init",
                    value: function () {
                        var e = this;
                        this._isResizingInterval = setInterval(function () {
                            e._isResizing && (e._isResizing = !1)
                        }, 100), window.addEventListener("resize", this._resizeListener)
                    }
                }, {
                    key: "_onResize",
                    value: function () {
                        this._isResizing = !0, this._callbacks.forEach(function (e) {
                            e.cb()
                        })
                    }
                }, {
                    key: "addListener",
                    value: function (e) {
                        var t = {
                            id: this._callbacks.length,
                            cb: e
                        };
                        return this._callbacks.push(t), t.id
                    }
                }, {
                    key: "getListenerBydId",
                    value: function (e) {
                        return this._callbacks.filter(function (t) {
                            return t.id == e
                        })[0]
                    }
                }, {
                    key: "removeListener",
                    value: function (e) {
                        var t = this.getListenerBydId(e);
                        if (t) {
                            var n = this._callbacks.indexOf(t);
                            n > -1 && this._callbacks.splice(n, 1)
                        }
                    }
                }]), e
            }();
        n["default"] = o
    }, {}],
    27: [function (e, t, n) {
        "use strict";

        function i(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }
        Object.defineProperty(n, "__esModule", {
            value: !0
        });
        var r = function () {
                function e(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }
                return function (t, n, i) {
                    return n && e(t.prototype, n), i && e(t, i), t
                }
            }(),
            a = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix"),
            o = e("/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils"),
            s = null,
            l = function () {
                function e() {
                    return i(this, e), s || (s = this), this._isScrolling = !1, this._scrollTop = 0, this._isScrollingInterval = null, this._scrollListener = this._onScroll.bind(this), this._callbacks = [], s
                }
                return r(e, [{
                    key: "init",
                    value: function () {
                        var e = this;
                        this._isScrollingInterval = setInterval(function () {
                            e._isScrolling && (e._isScrolling = !1, document.body.classList.remove("disable-hover"))
                        }, 250), window.addEventListener("scroll", this._scrollListener), this._listen()
                    }
                }, {
                    key: "_onScroll",
                    value: function () {
                        this._isScrolling = !0
                    }
                }, {
                    key: "_listen",
                    value: function () {
                        this._reqAnim = (0, a.requestAnimationFrame)(this._listen.bind(this)), this._checkIfScrolling()
                    }
                }, {
                    key: "_checkIfScrolling",
                    value: function () {
                        this._isScrolling && (document.body.classList.contains("disable-hover") || document.body.classList.add("disable-hover"), this._callbacks.forEach(function (e) {
                            e.cb()
                        }))
                    }
                }, {
                    key: "getListenerBydId",
                    value: function (e) {
                        return this._callbacks.filter(function (t) {
                            return t.id == e
                        })[0]
                    }
                }, {
                    key: "addListener",
                    value: function (e, t) {
                        var n = {
                            id: (0, o.randomIntFromInterval)(1, 999),
                            name: t,
                            cb: e
                        };
                        return this._callbacks.push(n), n.id
                    }
                }, {
                    key: "removeListener",
                    value: function (e) {
                        var t = this.getListenerBydId(e);
                        if (t) {
                            var n = this._callbacks.indexOf(t);
                            n > -1 && this._callbacks.splice(n, 1)
                        }
                    }
                }]), e
            }();
        n["default"] = l
    }, {
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/general-utils": 24,
        "/Users/andreaslorentsson/Projects/animal/frontend/js/utils/prefix": 25
    }],
    28: [function (e, t, n) {
        (function (e, i) {
            ! function (e, i) {
                "object" == typeof n && "undefined" != typeof t ? t.exports = i() : "function" == typeof define && define.amd ? define(i) : (e.Vimeo = e.Vimeo || {}, e.Vimeo.Player = i())
            }(this, function () {
                "use strict";

                function t(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }

                function n(e, t) {
                    for (var n = 0; n < t.length; n++) {
                        var i = t[n];
                        i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                    }
                }

                function r(e, t, i) {
                    return t && n(e.prototype, t), i && n(e, i), e
                }

                function a(e, t) {
                    return 0 === e.indexOf(t.toLowerCase()) ? e : "".concat(t.toLowerCase()).concat(e.substr(0, 1).toUpperCase()).concat(e.substr(1))
                }

                function o(e) {
                    return Boolean(e && 1 === e.nodeType && "nodeName" in e && e.ownerDocument && e.ownerDocument.defaultView)
                }

                function s(e) {
                    return !isNaN(parseFloat(e)) && isFinite(e) && Math.floor(e) == e
                }

                function l(e) {
                    return /^(https?:)?\/\/((player|www)\.)?vimeo\.com(?=$|\/)/.test(e)
                }

                function c() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        t = e.id,
                        n = e.url,
                        i = t || n;
                    if (!i) throw new Error("An id or url must be passed, either in an options object or as a data-vimeo-id or data-vimeo-url attribute.");
                    if (s(i)) return "https://vimeo.com/".concat(i);
                    if (l(i)) return i.replace("http:", "https:");
                    if (t) throw new TypeError("“".concat(t, "” is not a valid video id."));
                    throw new TypeError("“".concat(i, "” is not a vimeo.com url."))
                }

                function u(e, t) {
                    return t = {
                        exports: {}
                    }, e(t, t.exports), t.exports
                }

                function h(e, t, n) {
                    var i = A.get(e.element) || {};
                    t in i || (i[t] = []), i[t].push(n), A.set(e.element, i)
                }

                function d(e, t) {
                    var n = A.get(e.element) || {};
                    return n[t] || []
                }

                function p(e, t, n) {
                    var i = A.get(e.element) || {};
                    if (!i[t]) return !0;
                    if (!n) return i[t] = [], A.set(e.element, i), !0;
                    var r = i[t].indexOf(n);
                    return r !== -1 && i[t].splice(r, 1), A.set(e.element, i), i[t] && 0 === i[t].length
                }

                function f(e, t) {
                    var n = d(e, t);
                    if (n.length < 1) return !1;
                    var i = n.shift();
                    return p(e, t, i), i
                }

                function m(e, t) {
                    var n = A.get(e);
                    A.set(t, n), A["delete"](e)
                }

                function v(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    return L.reduce(function (t, n) {
                        var i = e.getAttribute("data-vimeo-".concat(n));
                        return (i || "" === i) && (t[n] = "" === i ? 1 : i), t
                    }, t)
                }

                function g(e, t) {
                    var n = e.html;
                    if (!t) throw new TypeError("An element must be provided");
                    if (null !== t.getAttribute("data-vimeo-initialized")) return t.querySelector("iframe");
                    var i = document.createElement("div");
                    return i.innerHTML = n, t.appendChild(i.firstChild), t.setAttribute("data-vimeo-initialized", "true"), t.querySelector("iframe")
                }

                function y(e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                        n = arguments.length > 2 ? arguments[2] : void 0;
                    return new Promise(function (i, r) {
                        if (!l(e)) throw new TypeError("“".concat(e, "” is not a vimeo.com url."));
                        var a = "https://vimeo.com/api/oembed.json?url=".concat(encodeURIComponent(e), "&domain=").concat(window.location.hostname);
                        for (var o in t) t.hasOwnProperty(o) && (a += "&".concat(o, "=").concat(encodeURIComponent(t[o])));
                        var s = "XDomainRequest" in window ? new XDomainRequest : new XMLHttpRequest;
                        s.open("GET", a, !0), s.onload = function () {
                            if (404 === s.status) return void r(new Error("“".concat(e, "” was not found.")));
                            if (403 === s.status) return void r(new Error("“".concat(e, "” is not embeddable.")));
                            try {
                                var t = JSON.parse(s.responseText);
                                if (403 === t.domain_status_code) return g(t, n), void r(new Error("“".concat(e, "” is not embeddable.")));
                                i(t)
                            } catch (a) {
                                r(a)
                            }
                        }, s.onerror = function () {
                            var e = s.status ? " (".concat(s.status, ")") : "";
                            r(new Error("There was an error fetching the embed code from Vimeo".concat(e, ".")))
                        }, s.send()
                    })
                }

                function x() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document,
                        t = [].slice.call(e.querySelectorAll("[data-vimeo-id], [data-vimeo-url]")),
                        n = function (e) {
                            "console" in window && console.error && console.error("There was an error creating an embed: ".concat(e))
                        };
                    t.forEach(function (e) {
                        try {
                            if (null !== e.getAttribute("data-vimeo-defer")) return;
                            var t = v(e),
                                i = c(t);
                            y(i, t, e).then(function (t) {
                                return g(t, e)
                            })["catch"](n)
                        } catch (r) {
                            n(r)
                        }
                    })
                }

                function b() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : document;
                    if (!window.VimeoPlayerResizeEmbeds_) {
                        window.VimeoPlayerResizeEmbeds_ = !0;
                        var t = function (t) {
                            if (l(t.origin) && t.data && "spacechange" === t.data.event)
                                for (var n = e.querySelectorAll("iframe"), i = 0; i < n.length; i++)
                                    if (n[i].contentWindow === t.source) {
                                        var r = n[i].parentElement;
                                        r.style.paddingBottom = "".concat(t.data.data[0].bottom, "px");
                                        break
                                    }
                        };
                        window.addEventListener ? window.addEventListener("message", t, !1) : window.attachEvent && window.attachEvent("onmessage", t)
                    }
                }

                function _(e) {
                    return "string" == typeof e && (e = JSON.parse(e)), e
                }

                function w(e, t, n) {
                    if (e.element.contentWindow && e.element.contentWindow.postMessage) {
                        var i = {
                            method: t
                        };
                        void 0 !== n && (i.value = n);
                        var r = parseFloat(navigator.userAgent.toLowerCase().replace(/^.*msie (\d+).*$/, "$1"));
                        r >= 8 && r < 10 && (i = JSON.stringify(i)), e.element.contentWindow.postMessage(i, e.origin)
                    }
                }

                function M(e, t) {
                    t = _(t);
                    var n, i = [];
                    if (t.event) {
                        if ("error" === t.event) {
                            var r = d(e, t.data.method);
                            r.forEach(function (n) {
                                var i = new Error(t.data.message);
                                i.name = t.data.name, n.reject(i), p(e, t.data.method, n)
                            })
                        }
                        i = d(e, "event:".concat(t.event)), n = t.data
                    } else if (t.method) {
                        var a = f(e, t.method);
                        a && (i.push(a), n = t.value)
                    }
                    i.forEach(function (t) {
                        try {
                            if ("function" == typeof t) return void t.call(e, n);
                            t.resolve(n)
                        } catch (i) {}
                    })
                }
                var T = "undefined" != typeof e && "[object global]" === {}.toString.call(e),
                    E = "undefined" != typeof Array.prototype.indexOf,
                    S = "undefined" != typeof window && "undefined" != typeof window.postMessage;
                if (!(T || E && S)) throw new Error("Sorry, the Vimeo Player API is not available in this browser.");
                var P = "undefined" != typeof window ? window : "undefined" != typeof e ? e : "undefined" != typeof self ? self : {};
                ! function (e) {
                    function t(e) {
                        return Object(e) === e
                    }
                    if (!e.WeakMap) {
                        var n = Object.prototype.hasOwnProperty,
                            i = function (e, t, n) {
                                Object.defineProperty ? Object.defineProperty(e, t, {
                                    configurable: !0,
                                    writable: !0,
                                    value: n
                                }) : e[t] = n
                            };
                        e.WeakMap = function () {
                            function e() {
                                if (void 0 === this) throw new TypeError("Constructor WeakMap requires 'new'");
                                if (i(this, "_id", a("_WeakMap")), arguments.length > 0) throw new TypeError("WeakMap iterable is not supported")
                            }

                            function r(e, i) {
                                if (!t(e) || !n.call(e, "_id")) throw new TypeError(i + " method called on incompatible receiver " + typeof e)
                            }

                            function a(e) {
                                return e + "_" + o() + "." + o()
                            }

                            function o() {
                                return Math.random().toString().substring(2)
                            }
                            return i(e.prototype, "delete", function (e) {
                                if (r(this, "delete"), !t(e)) return !1;
                                var n = e[this._id];
                                return !(!n || n[0] !== e) && (delete e[this._id], !0)
                            }), i(e.prototype, "get", function (e) {
                                if (r(this, "get"), t(e)) {
                                    var n = e[this._id];
                                    return n && n[0] === e ? n[1] : void 0
                                }
                            }), i(e.prototype, "has", function (e) {
                                if (r(this, "has"), !t(e)) return !1;
                                var n = e[this._id];
                                return !(!n || n[0] !== e)
                            }), i(e.prototype, "set", function (e, n) {
                                if (r(this, "set"), !t(e)) throw new TypeError("Invalid value used as weak map key");
                                var a = e[this._id];
                                return a && a[0] === e ? (a[1] = n, this) : (i(e, this._id, [e, n]), this)
                            }), i(e, "_polyfill", !0), e
                        }()
                    }
                }("undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof P ? P : P);
                var C = u(function (e) {
                        ! function (t, n, i) {
                            n[t] = n[t] || i(), e.exports && (e.exports = n[t])
                        }("Promise", "undefined" != typeof P ? P : P, function () {
                            function e(e, t) {
                                p.add(e, t), d || (d = m(p.drain))
                            }

                            function t(e) {
                                var t, n = typeof e;
                                return null == e || "object" != n && "function" != n || (t = e.then), "function" == typeof t && t
                            }

                            function n() {
                                for (var e = 0; e < this.chain.length; e++) r(this, 1 === this.state ? this.chain[e].success : this.chain[e].failure, this.chain[e]);
                                this.chain.length = 0
                            }

                            function r(e, n, i) {
                                var r, a;
                                try {
                                    n === !1 ? i.reject(e.msg) : (r = n === !0 ? e.msg : n.call(void 0, e.msg), r === i.promise ? i.reject(TypeError("Promise-chain cycle")) : (a = t(r)) ? a.call(r, i.resolve, i.reject) : i.resolve(r))
                                } catch (o) {
                                    i.reject(o)
                                }
                            }

                            function a(i) {
                                var r, s = this;
                                if (!s.triggered) {
                                    s.triggered = !0, s.def && (s = s.def);
                                    try {
                                        (r = t(i)) ? e(function () {
                                            var e = new l(s);
                                            try {
                                                r.call(i, function () {
                                                    a.apply(e, arguments)
                                                }, function () {
                                                    o.apply(e, arguments)
                                                })
                                            } catch (t) {
                                                o.call(e, t)
                                            }
                                        }): (s.msg = i, s.state = 1, s.chain.length > 0 && e(n, s))
                                    } catch (c) {
                                        o.call(new l(s), c)
                                    }
                                }
                            }

                            function o(t) {
                                var i = this;
                                i.triggered || (i.triggered = !0, i.def && (i = i.def), i.msg = t, i.state = 2, i.chain.length > 0 && e(n, i))
                            }

                            function s(e, t, n, i) {
                                for (var r = 0; r < t.length; r++) ! function (r) {
                                    e.resolve(t[r]).then(function (e) {
                                        n(r, e)
                                    }, i)
                                }(r)
                            }

                            function l(e) {
                                this.def = e, this.triggered = !1
                            }

                            function c(e) {
                                this.promise = e, this.state = 0, this.triggered = !1, this.chain = [], this.msg = void 0
                            }

                            function u(t) {
                                if ("function" != typeof t) throw TypeError("Not a function");
                                if (0 !== this.__NPO__) throw TypeError("Not a promise");
                                this.__NPO__ = 1;
                                var i = new c(this);
                                this.then = function (t, r) {
                                    var a = {
                                        success: "function" != typeof t || t,
                                        failure: "function" == typeof r && r
                                    };
                                    return a.promise = new this.constructor(function (e, t) {
                                        if ("function" != typeof e || "function" != typeof t) throw TypeError("Not a function");
                                        a.resolve = e, a.reject = t
                                    }), i.chain.push(a), 0 !== i.state && e(n, i), a.promise
                                }, this["catch"] = function (e) {
                                    return this.then(void 0, e)
                                };
                                try {
                                    t.call(void 0, function (e) {
                                        a.call(i, e)
                                    }, function (e) {
                                        o.call(i, e)
                                    })
                                } catch (r) {
                                    o.call(i, r)
                                }
                            }
                            var h, d, p, f = Object.prototype.toString,
                                m = "undefined" != typeof i ? function (e) {
                                    return i(e)
                                } : setTimeout;
                            try {
                                Object.defineProperty({}, "x", {}), h = function (e, t, n, i) {
                                    return Object.defineProperty(e, t, {
                                        value: n,
                                        writable: !0,
                                        configurable: i !== !1
                                    })
                                }
                            } catch (v) {
                                h = function (e, t, n) {
                                    return e[t] = n, e
                                }
                            }
                            p = function () {
                                function e(e, t) {
                                    this.fn = e, this.self = t, this.next = void 0
                                }
                                var t, n, i;
                                return {
                                    add: function (r, a) {
                                        i = new e(r, a), n ? n.next = i : t = i, n = i, i = void 0
                                    },
                                    drain: function () {
                                        var e = t;
                                        for (t = n = d = void 0; e;) e.fn.call(e.self), e = e.next
                                    }
                                }
                            }();
                            var g = h({}, "constructor", u, !1);
                            return u.prototype = g, h(g, "__NPO__", 0, !1), h(u, "resolve", function (e) {
                                var t = this;
                                return e && "object" == typeof e && 1 === e.__NPO__ ? e : new t(function (t, n) {
                                    if ("function" != typeof t || "function" != typeof n) throw TypeError("Not a function");
                                    t(e)
                                })
                            }), h(u, "reject", function (e) {
                                return new this(function (t, n) {
                                    if ("function" != typeof t || "function" != typeof n) throw TypeError("Not a function");
                                    n(e)
                                })
                            }), h(u, "all", function (e) {
                                var t = this;
                                return "[object Array]" != f.call(e) ? t.reject(TypeError("Not an array")) : 0 === e.length ? t.resolve([]) : new t(function (n, i) {
                                    if ("function" != typeof n || "function" != typeof i) throw TypeError("Not a function");
                                    var r = e.length,
                                        a = Array(r),
                                        o = 0;
                                    s(t, e, function (e, t) {
                                        a[e] = t, ++o === r && n(a)
                                    }, i)
                                })
                            }), h(u, "race", function (e) {
                                var t = this;
                                return "[object Array]" != f.call(e) ? t.reject(TypeError("Not an array")) : new t(function (n, i) {
                                    if ("function" != typeof n || "function" != typeof i) throw TypeError("Not a function");
                                    s(t, e, function (e, t) {
                                        n(t)
                                    }, i)
                                })
                            }), u
                        })
                    }),
                    A = new WeakMap,
                    L = ["autopause", "autoplay", "background", "byline", "color", "height", "id", "loop", "maxheight", "maxwidth", "muted", "playsinline", "portrait", "responsive", "speed", "title", "transparent", "url", "width"],
                    R = new WeakMap,
                    I = new WeakMap,
                    O = function () {
                        function e(n) {
                            var i = this,
                                r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                            if (t(this, e), window.jQuery && n instanceof jQuery && (n.length > 1 && window.console && console.warn && console.warn("A jQuery object with multiple elements was passed, using the first element."), n = n[0]), "undefined" != typeof document && "string" == typeof n && (n = document.getElementById(n)), !o(n)) throw new TypeError("You must pass either a valid element or a valid id.");
                            var a = n.ownerDocument.defaultView;
                            if ("IFRAME" !== n.nodeName) {
                                var s = n.querySelector("iframe");
                                s && (n = s)
                            }
                            if ("IFRAME" === n.nodeName && !l(n.getAttribute("src") || "")) throw new Error("The player element passed isn’t a Vimeo embed.");
                            if (R.has(n)) return R.get(n);
                            this.element = n, this.origin = "*";
                            var u = new C(function (e, t) {
                                var o = function (n) {
                                    if (l(n.origin) && i.element.contentWindow === n.source) {
                                        "*" === i.origin && (i.origin = n.origin);
                                        var r = _(n.data),
                                            a = r && "error" === r.event,
                                            o = a && r.data && "ready" === r.data.method;
                                        if (o) {
                                            var s = new Error(r.data.message);
                                            return s.name = r.data.name, void t(s)
                                        }
                                        var c = r && "ready" === r.event,
                                            u = r && "ping" === r.method;
                                        return c || u ? (i.element.setAttribute("data-ready", "true"), void e()) : void M(i, r)
                                    }
                                };
                                if (a.addEventListener ? a.addEventListener("message", o, !1) : a.attachEvent && a.attachEvent("onmessage", o), "IFRAME" !== i.element.nodeName) {
                                    var s = v(n, r),
                                        u = c(s);
                                    y(u, s, n).then(function (e) {
                                        var t = g(e, n);
                                        return i.element = t, i._originalElement = n, m(n, t), R.set(i.element, i), e
                                    })["catch"](t)
                                }
                            });
                            return I.set(this, u), R.set(this.element, this), "IFRAME" === this.element.nodeName && w(this, "ping"), this
                        }
                        return r(e, [{
                            key: "callMethod",
                            value: function (e) {
                                var t = this,
                                    n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                                return new C(function (i, r) {
                                    return t.ready().then(function () {
                                        h(t, e, {
                                            resolve: i,
                                            reject: r
                                        }), w(t, e, n)
                                    })["catch"](r)
                                })
                            }
                        }, {
                            key: "get",
                            value: function (e) {
                                var t = this;
                                return new C(function (n, i) {
                                    return e = a(e, "get"), t.ready().then(function () {
                                        h(t, e, {
                                            resolve: n,
                                            reject: i
                                        }), w(t, e)
                                    })["catch"](i)
                                })
                            }
                        }, {
                            key: "set",
                            value: function (e, t) {
                                var n = this;
                                return new C(function (i, r) {
                                    if (e = a(e, "set"), void 0 === t || null === t) throw new TypeError("There must be a value to set.");
                                    return n.ready().then(function () {
                                        h(n, e, {
                                            resolve: i,
                                            reject: r
                                        }), w(n, e, t)
                                    })["catch"](r)
                                })
                            }
                        }, {
                            key: "on",
                            value: function (e, t) {
                                if (!e) throw new TypeError("You must pass an event name.");
                                if (!t) throw new TypeError("You must pass a callback function.");
                                if ("function" != typeof t) throw new TypeError("The callback must be a function.");
                                var n = d(this, "event:".concat(e));
                                0 === n.length && this.callMethod("addEventListener", e)["catch"](function () {}), h(this, "event:".concat(e), t)
                            }
                        }, {
                            key: "off",
                            value: function (e, t) {
                                if (!e) throw new TypeError("You must pass an event name.");
                                if (t && "function" != typeof t) throw new TypeError("The callback must be a function.");
                                var n = p(this, "event:".concat(e), t);
                                n && this.callMethod("removeEventListener", e)["catch"](function (e) {})
                            }
                        }, {
                            key: "loadVideo",
                            value: function (e) {
                                return this.callMethod("loadVideo", e)
                            }
                        }, {
                            key: "ready",
                            value: function () {
                                var e = I.get(this) || new C(function (e, t) {
                                    t(new Error("Unknown player. Probably unloaded."))
                                });
                                return C.resolve(e)
                            }
                        }, {
                            key: "addCuePoint",
                            value: function (e) {
                                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                                return this.callMethod("addCuePoint", {
                                    time: e,
                                    data: t
                                })
                            }
                        }, {
                            key: "removeCuePoint",
                            value: function (e) {
                                return this.callMethod("removeCuePoint", e)
                            }
                        }, {
                            key: "enableTextTrack",
                            value: function (e, t) {
                                if (!e) throw new TypeError("You must pass a language.");
                                return this.callMethod("enableTextTrack", {
                                    language: e,
                                    kind: t
                                })
                            }
                        }, {
                            key: "disableTextTrack",
                            value: function () {
                                return this.callMethod("disableTextTrack")
                            }
                        }, {
                            key: "pause",
                            value: function () {
                                return this.callMethod("pause")
                            }
                        }, {
                            key: "play",
                            value: function () {
                                return this.callMethod("play")
                            }
                        }, {
                            key: "unload",
                            value: function () {
                                return this.callMethod("unload")
                            }
                        }, {
                            key: "destroy",
                            value: function () {
                                var e = this;
                                return new C(function (t) {
                                    I["delete"](e), R["delete"](e.element), e._originalElement && (R["delete"](e._originalElement), e._originalElement.removeAttribute("data-vimeo-initialized")), e.element && "IFRAME" === e.element.nodeName && e.element.parentNode && e.element.parentNode.removeChild(e.element), t()
                                })
                            }
                        }, {
                            key: "getAutopause",
                            value: function () {
                                return this.get("autopause")
                            }
                        }, {
                            key: "setAutopause",
                            value: function (e) {
                                return this.set("autopause", e)
                            }
                        }, {
                            key: "getBuffered",
                            value: function () {
                                return this.get("buffered")
                            }
                        }, {
                            key: "getColor",
                            value: function () {
                                return this.get("color")
                            }
                        }, {
                            key: "setColor",
                            value: function (e) {
                                return this.set("color", e)
                            }
                        }, {
                            key: "getCuePoints",
                            value: function () {
                                return this.get("cuePoints")
                            }
                        }, {
                            key: "getCurrentTime",
                            value: function () {
                                return this.get("currentTime")
                            }
                        }, {
                            key: "setCurrentTime",
                            value: function (e) {
                                return this.set("currentTime", e)
                            }
                        }, {
                            key: "getDuration",
                            value: function () {
                                return this.get("duration")
                            }
                        }, {
                            key: "getEnded",
                            value: function () {
                                return this.get("ended")
                            }
                        }, {
                            key: "getLoop",
                            value: function () {
                                return this.get("loop")
                            }
                        }, {
                            key: "setLoop",
                            value: function (e) {
                                return this.set("loop", e)
                            }
                        }, {
                            key: "getPaused",
                            value: function () {
                                return this.get("paused")
                            }
                        }, {
                            key: "getPlaybackRate",
                            value: function () {
                                return this.get("playbackRate")
                            }
                        }, {
                            key: "setPlaybackRate",
                            value: function (e) {
                                return this.set("playbackRate", e)
                            }
                        }, {
                            key: "getPlayed",
                            value: function () {
                                return this.get("played")
                            }
                        }, {
                            key: "getSeekable",
                            value: function () {
                                return this.get("seekable")
                            }
                        }, {
                            key: "getTextTracks",
                            value: function () {
                                return this.get("textTracks")
                            }
                        }, {
                            key: "getVideoEmbedCode",
                            value: function () {
                                return this.get("videoEmbedCode")
                            }
                        }, {
                            key: "getVideoId",
                            value: function () {
                                return this.get("videoId")
                            }
                        }, {
                            key: "getVideoTitle",
                            value: function () {
                                return this.get("videoTitle")
                            }
                        }, {
                            key: "getVideoWidth",
                            value: function () {
                                return this.get("videoWidth")
                            }
                        }, {
                            key: "getVideoHeight",
                            value: function () {
                                return this.get("videoHeight")
                            }
                        }, {
                            key: "getVideoUrl",
                            value: function () {
                                return this.get("videoUrl")
                            }
                        }, {
                            key: "getVolume",
                            value: function () {
                                return this.get("volume")
                            }
                        }, {
                            key: "setVolume",
                            value: function (e) {
                                return this.set("volume", e)
                            }
                        }]), e
                    }();
                return T || (x(), b()), O
            })
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("timers").setImmediate)
    }, {
        timers: 50
    }],
    29: [function (e, t, n) {
        function i(e, t) {
            return 1 - 3 * t + 3 * e
        }

        function r(e, t) {
            return 3 * t - 6 * e
        }

        function a(e) {
            return 3 * e
        }

        function o(e, t, n) {
            return ((i(t, n) * e + r(t, n)) * e + a(t)) * e
        }

        function s(e, t, n) {
            return 3 * i(t, n) * e * e + 2 * r(t, n) * e + a(t)
        }

        function l(e, t, n, i, r) {
            var a, s, l = 0;
            do s = t + (n - t) / 2, a = o(s, i, r) - e, a > 0 ? n = s : t = s; while (Math.abs(a) > p && ++l < f);
            return s
        }

        function c(e, t, n, i) {
            for (var r = 0; r < h; ++r) {
                var a = s(t, n, i);
                if (0 === a) return t;
                var l = o(t, n, i) - e;
                t -= l / a
            }
            return t
        }

        function u(e) {
            return e
        }
        var h = 4,
            d = .001,
            p = 1e-7,
            f = 10,
            m = 11,
            v = 1 / (m - 1),
            g = "function" == typeof Float32Array;
        t.exports = function (e, t, n, i) {
            function r(t) {
                for (var i = 0, r = 1, o = m - 1; r !== o && a[r] <= t; ++r) i += v;
                --r;
                var u = (t - a[r]) / (a[r + 1] - a[r]),
                    h = i + u * v,
                    p = s(h, e, n);
                return p >= d ? c(t, h, e, n) : 0 === p ? h : l(t, i, i + v, e, n)
            }
            if (!(0 <= e && e <= 1 && 0 <= n && n <= 1)) throw new Error("bezier x values must be in [0, 1] range");
            if (e === t && n === i) return u;
            for (var a = g ? new Float32Array(m) : new Array(m), h = 0; h < m; ++h) a[h] = o(h * v, e, n);
            return function (e) {
                return 0 === e ? 0 : 1 === e ? 1 : o(r(e), t, i)
            }
        }
    }, {}],
    30: [function (e, t, n) {
        "use strict";
        var i = e("component-emitter"),
            r = e("debounce"),
            a = t.exports;
        i(a), a.debounceDelay = 50, a.onGlobalResize = function () {
            this.width = window.innerWidth, this.height = window.innerHeight, this.halfWidth = .5 * this.width, this.halfHeight = .5 * this.height, this.applyResize(), this.debounceDelay > 0 ? this.debounceResize() : this.applyResizeDebounce()
        }, a.applyResizeDebounce = function () {
            this.emit("resizeDebounce")
        }, a.applyResize = function () {
            this.emit("resize")
        }, a.addListener = function (e, t) {
            this.on(t ? "resize" : "resizeDebounce", e)
        }, a.removeListener = function (e) {
            e && (this.off("resize", e), this.off("resizeDebounce", e))
        }, a.debounceResize = r(a.applyResizeDebounce.bind(a), a.debounceDelay), a.onGlobalResize(), window.addEventListener("resize", a.onGlobalResize.bind(a))
    }, {
        "component-emitter": 32,
        debounce: 33
    }],
    31: [function (e, t, n) {
        ! function (e, n) {
            "undefined" != typeof t && t.exports ? t.exports = n() : "function" == typeof define && define.amd ? define([], n) : e.canvid = n()
        }(this, function () {
            function e(e) {
                function t(e, t) {
                    function n() {
                        r--, 0 === r && t(null, i)
                    }
                    var i = {},
                        r = Object.keys(e).length;
                    if (0 === r) return t("You need to define at least one video object.");
                    for (var a in e) i[a] = new Image, i[a].onload = n, i[a].onerror = t, i[a].src = e[a].src
                }

                function n() {
                    var e = document.createElement("canvas");
                    return e.width = d.width, e.height = d.height, e.classList.add("canvid"), p.appendChild(e), e.getContext("2d")
                }

                function i() {
                    [].forEach.call(p.children, function (e) {
                        e.classList.contains("canvid") || (e.style.display = "none")
                    })
                }

                function r() {
                    [].forEach.call(p.children, function (e) {
                        e.classList.contains("canvid") && p.removeChild(e)
                    })
                }

                function a() {
                    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (e) {
                        return setTimeout(e, 1e3 / 60)
                    }
                }

                function o() {
                    var e = document.createElement("canvas");
                    return !(!e.getContext || !e.getContext("2d"))
                }

                function s(e) {
                    return "function" == typeof e || !!(e && e.constructor && e.call && e.apply)
                }

                function l() {
                    for (var e, t = {}, n = 0; n < arguments.length; n++)
                        for (e in arguments[n]) arguments[n].hasOwnProperty(e) && (t[e] = arguments[n][e]);
                    return t
                }
                var c = {
                        width: 800,
                        height: 450,
                        selector: ".canvid-wrapper"
                    },
                    u = !0,
                    h = {
                        play: function () {
                            console.log("Cannot play before images are loaded")
                        }
                    },
                    d = l(c, e),
                    p = "string" == typeof d.selector ? document.querySelector(d.selector) : d.selector;
                if (!p) return console.warn("Error. No element found for selector", d.selector);
                if (!d.videos) return console.warn("Error. You need to define at least one video object");
                if (o()) t(d.videos, function (e, t) {
                    if (e) return console.warn("Error while loading video sources.", e);
                    var o = n(),
                        l = a();
                    h.play = function (e, n, a) {
                        function c() {
                            b || (p(x), x = +x + (n ? -1 : 1), x < 0 && (x += +m.frames), x >= m.frames && (x = 0), (n ? x != m.frames - 1 : x) || w++, m.loops && w >= m.loops && (_ = !1, m.onEnd && s(m.onEnd) && m.onEnd())), b = (b + 1) % M, _ && m.frames > 1 && l(c)
                        }

                        function p(e) {
                            var t = Math.floor(e % m.cols) * v,
                                n = Math.floor(e / m.cols) * g;
                            o.clearRect(0, 0, d.width, d.height), o.drawImage(f, t, n, v, g, 0, 0, d.width, d.height)
                        }
                        h.pause && h.pause();
                        var f = t[e],
                            m = d.videos[e],
                            v = f.width / m.cols,
                            g = f.height / Math.ceil(m.frames / m.cols),
                            y = a || m.fps || 15,
                            x = n ? m.frames - 1 : 0,
                            b = 0,
                            _ = !0,
                            w = 0,
                            M = 60 / y;
                        l(c), h.resume = function () {
                            _ = !0, l(c)
                        }, h.pause = function () {
                            _ = !1, l(c)
                        }, h.isPlaying = function () {
                            return _
                        }, h.destroy = function () {
                            h.pause(), r()
                        }, h.getCurrentFrame = function () {
                            return x
                        }, h.setCurrentFrame = function (e) {
                            return !(e < 0 || e >= m.frames) && (h.isPlaying() || p(e), void(x = e))
                        }, u && (u = !1, i())
                    }, s(d.loaded) && d.loaded(h)
                });
                else if (opts.srcGif) {
                    var f = new Image;
                    f.src = opts.srcGif, p.appendChild(f)
                }
                return h
            }
            return e
        })
    }, {}],
    32: [function (e, t, n) {
        function i(e) {
            if (e) return r(e)
        }

        function r(e) {
            for (var t in i.prototype) e[t] = i.prototype[t];
            return e
        }
        "undefined" != typeof t && (t.exports = i), i.prototype.on = i.prototype.addEventListener = function (e, t) {
            return this._callbacks = this._callbacks || {}, (this._callbacks["$" + e] = this._callbacks["$" + e] || []).push(t), this
        }, i.prototype.once = function (e, t) {
            function n() {
                this.off(e, n), t.apply(this, arguments)
            }
            return n.fn = t, this.on(e, n), this
        }, i.prototype.off = i.prototype.removeListener = i.prototype.removeAllListeners = i.prototype.removeEventListener = function (e, t) {
            if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;
            var n = this._callbacks["$" + e];
            if (!n) return this;
            if (1 == arguments.length) return delete this._callbacks["$" + e], this;
            for (var i, r = 0; r < n.length; r++)
                if (i = n[r], i === t || i.fn === t) {
                    n.splice(r, 1);
                    break
                } return this
        }, i.prototype.emit = function (e) {
            this._callbacks = this._callbacks || {};
            var t = [].slice.call(arguments, 1),
                n = this._callbacks["$" + e];
            if (n) {
                n = n.slice(0);
                for (var i = 0, r = n.length; i < r; ++i) n[i].apply(this, t)
            }
            return this
        }, i.prototype.listeners = function (e) {
            return this._callbacks = this._callbacks || {}, this._callbacks["$" + e] || []
        }, i.prototype.hasListeners = function (e) {
            return !!this.listeners(e).length
        }
    }, {}],
    33: [function (e, t, n) {
        function i(e, t, n) {
            function i() {
                var c = Date.now() - s;
                c < t && c >= 0 ? r = setTimeout(i, t - c) : (r = null, n || (l = e.apply(o, a), o = a = null))
            }
            var r, a, o, s, l;
            null == t && (t = 100);
            var c = function () {
                o = this, a = arguments, s = Date.now();
                var c = n && !r;
                return r || (r = setTimeout(i, t)), c && (l = e.apply(o, a), o = a = null), l
            };
            return c.clear = function () {
                r && (clearTimeout(r), r = null)
            }, c.flush = function () {
                r && (l = e.apply(o, a), o = a = null, clearTimeout(r), r = null)
            }, c
        }
        i.debounce = i, t.exports = i
    }, {}],
    34: [function (e, t, n) {
        function i() {
            this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0
        }

        function r(e) {
            return "function" == typeof e
        }

        function a(e) {
            return "number" == typeof e
        }

        function o(e) {
            return "object" == typeof e && null !== e
        }

        function s(e) {
            return void 0 === e
        }
        t.exports = i, i.EventEmitter = i, i.prototype._events = void 0, i.prototype._maxListeners = void 0, i.defaultMaxListeners = 10, i.prototype.setMaxListeners = function (e) {
            if (!a(e) || e < 0 || isNaN(e)) throw TypeError("n must be a positive number");
            return this._maxListeners = e, this
        }, i.prototype.emit = function (e) {
            var t, n, i, a, l, c;
            if (this._events || (this._events = {}), "error" === e && (!this._events.error || o(this._events.error) && !this._events.error.length)) {
                if (t = arguments[1], t instanceof Error) throw t;
                var u = new Error('Uncaught, unspecified "error" event. (' + t + ")");
                throw u.context = t, u
            }
            if (n = this._events[e], s(n)) return !1;
            if (r(n)) switch (arguments.length) {
                case 1:
                    n.call(this);
                    break;
                case 2:
                    n.call(this, arguments[1]);
                    break;
                case 3:
                    n.call(this, arguments[1], arguments[2]);
                    break;
                default:
                    a = Array.prototype.slice.call(arguments, 1), n.apply(this, a)
            } else if (o(n))
                for (a = Array.prototype.slice.call(arguments, 1), c = n.slice(), i = c.length, l = 0; l < i; l++) c[l].apply(this, a);
            return !0
        }, i.prototype.addListener = function (e, t) {
            var n;
            if (!r(t)) throw TypeError("listener must be a function");
            return this._events || (this._events = {}), this._events.newListener && this.emit("newListener", e, r(t.listener) ? t.listener : t), this._events[e] ? o(this._events[e]) ? this._events[e].push(t) : this._events[e] = [this._events[e], t] : this._events[e] = t, o(this._events[e]) && !this._events[e].warned && (n = s(this._maxListeners) ? i.defaultMaxListeners : this._maxListeners, n && n > 0 && this._events[e].length > n && (this._events[e].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[e].length), "function" == typeof console.trace && console.trace())), this
        }, i.prototype.on = i.prototype.addListener, i.prototype.once = function (e, t) {
            function n() {
                this.removeListener(e, n), i || (i = !0, t.apply(this, arguments))
            }
            if (!r(t)) throw TypeError("listener must be a function");
            var i = !1;
            return n.listener = t, this.on(e, n), this
        }, i.prototype.removeListener = function (e, t) {
            var n, i, a, s;
            if (!r(t)) throw TypeError("listener must be a function");
            if (!this._events || !this._events[e]) return this;
            if (n = this._events[e], a = n.length, i = -1, n === t || r(n.listener) && n.listener === t) delete this._events[e], this._events.removeListener && this.emit("removeListener", e, t);
            else if (o(n)) {
                for (s = a; s-- > 0;)
                    if (n[s] === t || n[s].listener && n[s].listener === t) {
                        i = s;
                        break
                    } if (i < 0) return this;
                1 === n.length ? (n.length = 0, delete this._events[e]) : n.splice(i, 1), this._events.removeListener && this.emit("removeListener", e, t)
            }
            return this
        }, i.prototype.removeAllListeners = function (e) {
            var t, n;
            if (!this._events) return this;
            if (!this._events.removeListener) return 0 === arguments.length ? this._events = {} : this._events[e] && delete this._events[e], this;
            if (0 === arguments.length) {
                for (t in this._events) "removeListener" !== t && this.removeAllListeners(t);
                return this.removeAllListeners("removeListener"), this._events = {}, this
            }
            if (n = this._events[e], r(n)) this.removeListener(e, n);
            else if (n)
                for (; n.length;) this.removeListener(e, n[n.length - 1]);
            return delete this._events[e], this
        }, i.prototype.listeners = function (e) {
            var t;
            return t = this._events && this._events[e] ? r(this._events[e]) ? [this._events[e]] : this._events[e].slice() : []
        }, i.prototype.listenerCount = function (e) {
            if (this._events) {
                var t = this._events[e];
                if (r(t)) return 1;
                if (t) return t.length
            }
            return 0
        }, i.listenerCount = function (e, t) {
            return e.listenerCount(t)
        }
    }, {}],
    35: [function (e, t, n) {
        (function (e) {
            var n = "undefined" != typeof t && t.exports && "undefined" != typeof e ? e : this || window;
            (n._gsQueue || (n._gsQueue = [])).push(function () {
                    "use strict";
                    n._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (e, t, n) {
                            var i = function (e) {
                                    var t, n = [],
                                        i = e.length;
                                    for (t = 0; t !== i; n.push(e[t++]));
                                    return n
                                },
                                r = function (e, t, n) {
                                    var i, r, a = e.cycle;
                                    for (i in a) r = a[i], e[i] = "function" == typeof r ? r(n, t[n]) : r[n % r.length];
                                    delete e.cycle
                                },
                                a = function (e, t, i) {
                                    n.call(this, e, t, i), this._cycle = 0, this._yoyo = this.vars.yoyo === !0 || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = a.prototype.render
                                },
                                o = 1e-10,
                                s = n._internals,
                                l = s.isSelector,
                                c = s.isArray,
                                u = a.prototype = n.to({}, .1, {}),
                                h = [];
                            a.version = "1.20.5", u.constructor = a, u.kill()._gc = !1, a.killTweensOf = a.killDelayedCallsTo = n.killTweensOf, a.getTweensOf = n.getTweensOf, a.lagSmoothing = n.lagSmoothing, a.ticker = n.ticker, a.render = n.render, u.invalidate = function () {
                                return this._yoyo = this.vars.yoyo === !0 || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), n.prototype.invalidate.call(this)
                            }, u.updateTo = function (e, t) {
                                var i, r = this.ratio,
                                    a = this.vars.immediateRender || e.immediateRender;
                                t && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
                                for (i in e) this.vars[i] = e[i];
                                if (this._initted || a)
                                    if (t) this._initted = !1, a && this.render(0, !0, !0);
                                    else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && n._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
                                    var o = this._totalTime;
                                    this.render(0, !0, !1), this._initted = !1, this.render(o, !0, !1)
                                } else if (this._initted = !1, this._init(), this._time > 0 || a)
                                    for (var s, l = 1 / (1 - r), c = this._firstPT; c;) s = c.s + c.c, c.c *= l, c.s = s - c.c, c = c._next;
                                return this
                            }, u.render = function (e, t, i) {
                                this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
                                var r, a, l, c, u, h, d, p, f, m = this._dirty ? this.totalDuration() : this._totalDuration,
                                    v = this._time,
                                    g = this._totalTime,
                                    y = this._cycle,
                                    x = this._duration,
                                    b = this._rawPrevTime;
                                if (e >= m - 1e-7 && e >= 0 ? (this._totalTime = m, this._cycle = this._repeat, this._yoyo && 0 !== (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = x, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (r = !0, a = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === x && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (e = 0), (b < 0 || e <= 0 && e >= -1e-7 || b === o && "isPause" !== this.data) && b !== e && (i = !0, b > o && (a = "onReverseComplete")), this._rawPrevTime = p = !t || e || b === e ? e : o)) : e < 1e-7 ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== g || 0 === x && b > 0) && (a = "onReverseComplete", r = this._reversed), e < 0 && (this._active = !1, 0 === x && (this._initted || !this.vars.lazy || i) && (b >= 0 && (i = !0), this._rawPrevTime = p = !t || e || b === e ? e : o)), this._initted || (i = !0)) : (this._totalTime = this._time = e, 0 !== this._repeat && (c = x + this._repeatDelay, this._cycle = this._totalTime / c >> 0, 0 !== this._cycle && this._cycle === this._totalTime / c && g <= e && this._cycle--, this._time = this._totalTime - this._cycle * c, this._yoyo && 0 !== (1 & this._cycle) && (this._time = x - this._time, f = this._yoyoEase || this.vars.yoyoEase, f && (this._yoyoEase || (f !== !0 || this._initted ? this._yoyoEase = f = f === !0 ? this._ease : f instanceof Ease ? f : Ease.map[f] : (f = this.vars.ease, this._yoyoEase = f = f ? f instanceof Ease ? f : "function" == typeof f ? new Ease(f, this.vars.easeParams) : Ease.map[f] || n.defaultEase : n.defaultEase)), this.ratio = f ? 1 - f.getRatio((x - this._time) / x) : 0)), this._time > x ? this._time = x : this._time < 0 && (this._time = 0)), this._easeType && !f ? (u = this._time / x, h = this._easeType, d = this._easePower, (1 === h || 3 === h && u >= .5) && (u = 1 - u), 3 === h && (u *= 2), 1 === d ? u *= u : 2 === d ? u *= u * u : 3 === d ? u *= u * u * u : 4 === d && (u *= u * u * u * u), 1 === h ? this.ratio = 1 - u : 2 === h ? this.ratio = u : this._time / x < .5 ? this.ratio = u / 2 : this.ratio = 1 - u / 2) : f || (this.ratio = this._ease.getRatio(this._time / x))), v === this._time && !i && y === this._cycle) return void(g !== this._totalTime && this._onUpdate && (t || this._callback("onUpdate")));
                                if (!this._initted) {
                                    if (this._init(), !this._initted || this._gc) return;
                                    if (!i && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = v, this._totalTime = g, this._rawPrevTime = b, this._cycle = y, s.lazyTweens.push(this), void(this._lazy = [e, t]);
                                    !this._time || r || f ? r && this._ease._calcEnd && !f && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) : this.ratio = this._ease.getRatio(this._time / x)
                                }
                                for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== v && e >= 0 && (this._active = !0), 0 === g && (2 === this._initted && e > 0 && this._init(), this._startAt && (e >= 0 ? this._startAt.render(e, !0, i) : a || (a = "_dummyGS")), this.vars.onStart && (0 === this._totalTime && 0 !== x || t || this._callback("onStart"))), l = this._firstPT; l;) l.f ? l.t[l.p](l.c * this.ratio + l.s) : l.t[l.p] = l.c * this.ratio + l.s, l = l._next;
                                this._onUpdate && (e < 0 && this._startAt && this._startTime && this._startAt.render(e, !0, i), t || (this._totalTime !== g || a) && this._callback("onUpdate")), this._cycle !== y && (t || this._gc || this.vars.onRepeat && this._callback("onRepeat")), a && (this._gc && !i || (e < 0 && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(e, !0, i), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[a] && this._callback(a), 0 === x && this._rawPrevTime === o && p !== o && (this._rawPrevTime = 0)))
                            }, a.to = function (e, t, n) {
                                return new a(e, t, n)
                            }, a.from = function (e, t, n) {
                                return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, new a(e, t, n)
                            }, a.fromTo = function (e, t, n, i) {
                                return i.startAt = n, i.immediateRender = 0 != i.immediateRender && 0 != n.immediateRender, new a(e, t, i)
                            }, a.staggerTo = a.allTo = function (e, t, o, s, u, d, p) {
                                s = s || 0;
                                var f, m, v, g, y = 0,
                                    x = [],
                                    b = function () {
                                        o.onComplete && o.onComplete.apply(o.onCompleteScope || this, arguments), u.apply(p || o.callbackScope || this, d || h)
                                    },
                                    _ = o.cycle,
                                    w = o.startAt && o.startAt.cycle;
                                for (c(e) || ("string" == typeof e && (e = n.selector(e) || e), l(e) && (e = i(e))), e = e || [], s < 0 && (e = i(e), e.reverse(), s *= -1), f = e.length - 1, v = 0; v <= f; v++) {
                                    m = {};
                                    for (g in o) m[g] = o[g];
                                    if (_ && (r(m, e, v), null != m.duration && (t = m.duration, delete m.duration)), w) {
                                        w = m.startAt = {};
                                        for (g in o.startAt) w[g] = o.startAt[g];
                                        r(m.startAt, e, v)
                                    }
                                    m.delay = y + (m.delay || 0), v === f && u && (m.onComplete = b), x[v] = new a(e[v], t, m), y += s
                                }
                                return x
                            }, a.staggerFrom = a.allFrom = function (e, t, n, i, r, o, s) {
                                return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, a.staggerTo(e, t, n, i, r, o, s)
                            }, a.staggerFromTo = a.allFromTo = function (e, t, n, i, r, o, s, l) {
                                return i.startAt = n, i.immediateRender = 0 != i.immediateRender && 0 != n.immediateRender, a.staggerTo(e, t, i, r, o, s, l)
                            }, a.delayedCall = function (e, t, n, i, r) {
                                return new a(t, 0, {
                                    delay: e,
                                    onComplete: t,
                                    onCompleteParams: n,
                                    callbackScope: i,
                                    onReverseComplete: t,
                                    onReverseCompleteParams: n,
                                    immediateRender: !1,
                                    useFrames: r,
                                    overwrite: 0
                                })
                            }, a.set = function (e, t) {
                                return new a(e, 0, t)
                            }, a.isTweening = function (e) {
                                return n.getTweensOf(e, !0).length > 0
                            };
                            var d = function (e, t) {
                                    for (var i = [], r = 0, a = e._first; a;) a instanceof n ? i[r++] = a : (t && (i[r++] = a), i = i.concat(d(a, t)), r = i.length), a = a._next;
                                    return i
                                },
                                p = a.getAllTweens = function (t) {
                                    return d(e._rootTimeline, t).concat(d(e._rootFramesTimeline, t))
                                };
                            a.killAll = function (e, n, i, r) {
                                null == n && (n = !0), null == i && (i = !0);
                                var a, o, s, l = p(0 != r),
                                    c = l.length,
                                    u = n && i && r;
                                for (s = 0; s < c; s++) o = l[s], (u || o instanceof t || (a = o.target === o.vars.onComplete) && i || n && !a) && (e ? o.totalTime(o._reversed ? 0 : o.totalDuration()) : o._enabled(!1, !1))
                            }, a.killChildTweensOf = function (e, t) {
                                if (null != e) {
                                    var r, o, u, h, d, p = s.tweenLookup;
                                    if ("string" == typeof e && (e = n.selector(e) || e), l(e) && (e = i(e)), c(e))
                                        for (h = e.length; --h > -1;) a.killChildTweensOf(e[h], t);
                                    else {
                                        r = [];
                                        for (u in p)
                                            for (o = p[u].target.parentNode; o;) o === e && (r = r.concat(p[u].tweens)), o = o.parentNode;
                                        for (d = r.length, h = 0; h < d; h++) t && r[h].totalTime(r[h].totalDuration()), r[h]._enabled(!1, !1)
                                    }
                                }
                            };
                            var f = function (e, n, i, r) {
                                n = n !== !1, i = i !== !1, r = r !== !1;
                                for (var a, o, s = p(r), l = n && i && r, c = s.length; --c > -1;) o = s[c], (l || o instanceof t || (a = o.target === o.vars.onComplete) && i || n && !a) && o.paused(e)
                            };
                            return a.pauseAll = function (e, t, n) {
                                f(!0, e, t, n)
                            }, a.resumeAll = function (e, t, n) {
                                f(!1, e, t, n)
                            }, a.globalTimeScale = function (t) {
                                var i = e._rootTimeline,
                                    r = n.ticker.time;
                                return arguments.length ? (t = t || o, i._startTime = r - (r - i._startTime) * i._timeScale / t, i = e._rootFramesTimeline, r = n.ticker.frame, i._startTime = r - (r - i._startTime) * i._timeScale / t, i._timeScale = e._rootTimeline._timeScale = t, t) : i._timeScale
                            }, u.progress = function (e, t) {
                                return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - e : e) + this._cycle * (this._duration + this._repeatDelay), t) : this._time / this.duration()
                            }, u.totalProgress = function (e, t) {
                                return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this._totalTime / this.totalDuration()
                            }, u.time = function (e, t) {
                                return arguments.length ? (this._dirty && this.totalDuration(), e > this._duration && (e = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? e = this._duration - e + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (e += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(e, t)) : this._time
                            }, u.duration = function (t) {
                                return arguments.length ? e.prototype.duration.call(this, t) : this._duration
                            }, u.totalDuration = function (e) {
                                return arguments.length ? this._repeat === -1 ? this : this.duration((e - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
                            }, u.repeat = function (e) {
                                return arguments.length ? (this._repeat = e, this._uncache(!0)) : this._repeat
                            }, u.repeatDelay = function (e) {
                                return arguments.length ? (this._repeatDelay = e, this._uncache(!0)) : this._repeatDelay
                            }, u.yoyo = function (e) {
                                return arguments.length ? (this._yoyo = e, this) : this._yoyo
                            }, a
                        }, !0), n._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (e, t, i) {
                            var r = function (e) {
                                    t.call(this, e), this._labels = {}, this.autoRemoveChildren = this.vars.autoRemoveChildren === !0, this.smoothChildTiming = this.vars.smoothChildTiming === !0, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
                                    var n, i, r = this.vars;
                                    for (i in r) n = r[i], c(n) && n.join("").indexOf("{self}") !== -1 && (r[i] = this._swapSelfInParams(n));
                                    c(r.tweens) && this.add(r.tweens, 0, r.align, r.stagger)
                                },
                                a = 1e-10,
                                o = i._internals,
                                s = r._internals = {},
                                l = o.isSelector,
                                c = o.isArray,
                                u = o.lazyTweens,
                                h = o.lazyRender,
                                d = n._gsDefine.globals,
                                p = function (e) {
                                    var t, n = {};
                                    for (t in e) n[t] = e[t];
                                    return n
                                },
                                f = function (e, t, n) {
                                    var i, r, a = e.cycle;
                                    for (i in a) r = a[i], e[i] = "function" == typeof r ? r(n, t[n]) : r[n % r.length];
                                    delete e.cycle
                                },
                                m = s.pauseCallback = function () {},
                                v = function (e) {
                                    var t, n = [],
                                        i = e.length;
                                    for (t = 0; t !== i; n.push(e[t++]));
                                    return n
                                },
                                g = r.prototype = new t;
                            return r.version = "1.20.4", g.constructor = r, g.kill()._gc = g._forcingPlayhead = g._hasPause = !1, g.to = function (e, t, n, r) {
                                var a = n.repeat && d.TweenMax || i;
                                return t ? this.add(new a(e, t, n), r) : this.set(e, n, r)
                            }, g.from = function (e, t, n, r) {
                                return this.add((n.repeat && d.TweenMax || i).from(e, t, n), r)
                            }, g.fromTo = function (e, t, n, r, a) {
                                var o = r.repeat && d.TweenMax || i;
                                return t ? this.add(o.fromTo(e, t, n, r), a) : this.set(e, r, a)
                            }, g.staggerTo = function (e, t, n, a, o, s, c, u) {
                                var h, d, m = new r({
                                        onComplete: s,
                                        onCompleteParams: c,
                                        callbackScope: u,
                                        smoothChildTiming: this.smoothChildTiming
                                    }),
                                    g = n.cycle;
                                for ("string" == typeof e && (e = i.selector(e) || e), e = e || [], l(e) && (e = v(e)), a = a || 0, a < 0 && (e = v(e), e.reverse(), a *= -1), d = 0; d < e.length; d++) h = p(n), h.startAt && (h.startAt = p(h.startAt), h.startAt.cycle && f(h.startAt, e, d)), g && (f(h, e, d), null != h.duration && (t = h.duration, delete h.duration)), m.to(e[d], t, h, d * a);
                                return this.add(m, o)
                            }, g.staggerFrom = function (e, t, n, i, r, a, o, s) {
                                return n.immediateRender = 0 != n.immediateRender, n.runBackwards = !0, this.staggerTo(e, t, n, i, r, a, o, s)
                            }, g.staggerFromTo = function (e, t, n, i, r, a, o, s, l) {
                                return i.startAt = n, i.immediateRender = 0 != i.immediateRender && 0 != n.immediateRender, this.staggerTo(e, t, i, r, a, o, s, l)
                            }, g.call = function (e, t, n, r) {
                                return this.add(i.delayedCall(0, e, t, n), r)
                            }, g.set = function (e, t, n) {
                                return n = this._parseTimeOrLabel(n, 0, !0), null == t.immediateRender && (t.immediateRender = n === this._time && !this._paused), this.add(new i(e, 0, t), n)
                            }, r.exportRoot = function (e, t) {
                                e = e || {}, null == e.smoothChildTiming && (e.smoothChildTiming = !0);
                                var n, a, o, s, l = new r(e),
                                    c = l._timeline;
                                for (null == t && (t = !0), c._remove(l, !0), l._startTime = 0, l._rawPrevTime = l._time = l._totalTime = c._time, o = c._first; o;) s = o._next, t && o instanceof i && o.target === o.vars.onComplete || (a = o._startTime - o._delay, a < 0 && (n = 1), l.add(o, a)), o = s;
                                return c.add(l, 0), n && l.totalDuration(), l
                            }, g.add = function (n, a, o, s) {
                                var l, u, h, d, p, f;
                                if ("number" != typeof a && (a = this._parseTimeOrLabel(a, 0, !0, n)), !(n instanceof e)) {
                                    if (n instanceof Array || n && n.push && c(n)) {
                                        for (o = o || "normal", s = s || 0, l = a, u = n.length, h = 0; h < u; h++) c(d = n[h]) && (d = new r({
                                            tweens: d
                                        })), this.add(d, l), "string" != typeof d && "function" != typeof d && ("sequence" === o ? l = d._startTime + d.totalDuration() / d._timeScale : "start" === o && (d._startTime -= d.delay())), l += s;
                                        return this._uncache(!0)
                                    }
                                    if ("string" == typeof n) return this.addLabel(n, a);
                                    if ("function" != typeof n) throw "Cannot add " + n + " into the timeline; it is not a tween, timeline, function, or string.";
                                    n = i.delayedCall(0, n)
                                }
                                if (t.prototype.add.call(this, n, a), n._time && n.render((this.rawTime() - n._startTime) * n._timeScale, !1, !1), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
                                    for (p = this, f = p.rawTime() > n._startTime; p._timeline;) f && p._timeline.smoothChildTiming ? p.totalTime(p._totalTime, !0) : p._gc && p._enabled(!0, !1), p = p._timeline;
                                return this
                            }, g.remove = function (t) {
                                if (t instanceof e) {
                                    this._remove(t, !1);
                                    var n = t._timeline = t.vars.useFrames ? e._rootFramesTimeline : e._rootTimeline;
                                    return t._startTime = (t._paused ? t._pauseTime : n._time) - (t._reversed ? t.totalDuration() - t._totalTime : t._totalTime) / t._timeScale, this
                                }
                                if (t instanceof Array || t && t.push && c(t)) {
                                    for (var i = t.length; --i > -1;) this.remove(t[i]);
                                    return this
                                }
                                return "string" == typeof t ? this.removeLabel(t) : this.kill(null, t)
                            }, g._remove = function (e, n) {
                                t.prototype._remove.call(this, e, n);
                                var i = this._last;
                                return i ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
                            }, g.append = function (e, t) {
                                return this.add(e, this._parseTimeOrLabel(null, t, !0, e))
                            }, g.insert = g.insertMultiple = function (e, t, n, i) {
                                return this.add(e, t || 0, n, i)
                            }, g.appendMultiple = function (e, t, n, i) {
                                return this.add(e, this._parseTimeOrLabel(null, t, !0, e), n, i)
                            }, g.addLabel = function (e, t) {
                                return this._labels[e] = this._parseTimeOrLabel(t), this
                            }, g.addPause = function (e, t, n, r) {
                                var a = i.delayedCall(0, m, n, r || this);
                                return a.vars.onComplete = a.vars.onReverseComplete = t, a.data = "isPause", this._hasPause = !0, this.add(a, e)
                            }, g.removeLabel = function (e) {
                                return delete this._labels[e], this
                            }, g.getLabelTime = function (e) {
                                return null != this._labels[e] ? this._labels[e] : -1
                            }, g._parseTimeOrLabel = function (t, n, i, r) {
                                var a, o;
                                if (r instanceof e && r.timeline === this) this.remove(r);
                                else if (r && (r instanceof Array || r.push && c(r)))
                                    for (o = r.length; --o > -1;) r[o] instanceof e && r[o].timeline === this && this.remove(r[o]);
                                if (a = "number" != typeof t || n ? this.duration() > 99999999999 ? this.recent().endTime(!1) : this._duration : 0, "string" == typeof n) return this._parseTimeOrLabel(n, i && "number" == typeof t && null == this._labels[n] ? t - a : 0, i);
                                if (n = n || 0, "string" != typeof t || !isNaN(t) && null == this._labels[t]) null == t && (t = a);
                                else {
                                    if (o = t.indexOf("="), o === -1) return null == this._labels[t] ? i ? this._labels[t] = a + n : n : this._labels[t] + n;
                                    n = parseInt(t.charAt(o - 1) + "1", 10) * Number(t.substr(o + 1)), t = o > 1 ? this._parseTimeOrLabel(t.substr(0, o - 1), 0, i) : a
                                }
                                return Number(t) + n
                            }, g.seek = function (e, t) {
                                return this.totalTime("number" == typeof e ? e : this._parseTimeOrLabel(e), t !== !1)
                            }, g.stop = function () {
                                return this.paused(!0)
                            }, g.gotoAndPlay = function (e, t) {
                                return this.play(e, t)
                            }, g.gotoAndStop = function (e, t) {
                                return this.pause(e, t)
                            }, g.render = function (e, t, n) {
                                this._gc && this._enabled(!0, !1);
                                var i, r, o, s, l, c, d, p = this._time,
                                    f = this._dirty ? this.totalDuration() : this._totalDuration,
                                    m = this._startTime,
                                    v = this._timeScale,
                                    g = this._paused;
                                if (p !== this._time && (e += this._time - p), e >= f - 1e-7 && e >= 0) this._totalTime = this._time = f, this._reversed || this._hasPausedChild() || (r = !0, s = "onComplete", l = !!this._timeline.autoRemoveChildren, 0 === this._duration && (e <= 0 && e >= -1e-7 || this._rawPrevTime < 0 || this._rawPrevTime === a) && this._rawPrevTime !== e && this._first && (l = !0, this._rawPrevTime > a && (s = "onReverseComplete"))), this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : a, e = f + 1e-4;
                                else if (e < 1e-7)
                                    if (this._totalTime = this._time = 0, (0 !== p || 0 === this._duration && this._rawPrevTime !== a && (this._rawPrevTime > 0 || e < 0 && this._rawPrevTime >= 0)) && (s = "onReverseComplete", r = this._reversed), e < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (l = r = !0, s = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (l = !0), this._rawPrevTime = e;
                                    else {
                                        if (this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : a, 0 === e && r)
                                            for (i = this._first; i && 0 === i._startTime;) i._duration || (r = !1), i = i._next;
                                        e = 0, this._initted || (l = !0)
                                    }
                                else {
                                    if (this._hasPause && !this._forcingPlayhead && !t) {
                                        if (e >= p)
                                            for (i = this._first; i && i._startTime <= e && !c;) i._duration || "isPause" !== i.data || i.ratio || 0 === i._startTime && 0 === this._rawPrevTime || (c = i), i = i._next;
                                        else
                                            for (i = this._last; i && i._startTime >= e && !c;) i._duration || "isPause" === i.data && i._rawPrevTime > 0 && (c = i), i = i._prev;
                                        c && (this._time = e = c._startTime, this._totalTime = e + this._cycle * (this._totalDuration + this._repeatDelay))
                                    }
                                    this._totalTime = this._time = this._rawPrevTime = e
                                }
                                if (this._time !== p && this._first || n || l || c) {
                                    if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== p && e > 0 && (this._active = !0), 0 === p && this.vars.onStart && (0 === this._time && this._duration || t || this._callback("onStart")), d = this._time, d >= p)
                                        for (i = this._first; i && (o = i._next, d === this._time && (!this._paused || g));)(i._active || i._startTime <= d && !i._paused && !i._gc) && (c === i && this.pause(), i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (e - i._startTime) * i._timeScale, t, n) : i.render((e - i._startTime) * i._timeScale, t, n)), i = o;
                                    else
                                        for (i = this._last; i && (o = i._prev, d === this._time && (!this._paused || g));) {
                                            if (i._active || i._startTime <= p && !i._paused && !i._gc) {
                                                if (c === i) {
                                                    for (c = i._prev; c && c.endTime() > this._time;) c.render(c._reversed ? c.totalDuration() - (e - c._startTime) * c._timeScale : (e - c._startTime) * c._timeScale, t, n), c = c._prev;
                                                    c = null, this.pause()
                                                }
                                                i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (e - i._startTime) * i._timeScale, t, n) : i.render((e - i._startTime) * i._timeScale, t, n)
                                            }
                                            i = o
                                        }
                                    this._onUpdate && (t || (u.length && h(), this._callback("onUpdate"))), s && (this._gc || m !== this._startTime && v === this._timeScale || (0 === this._time || f >= this.totalDuration()) && (r && (u.length && h(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[s] && this._callback(s)))
                                }
                            }, g._hasPausedChild = function () {
                                for (var e = this._first; e;) {
                                    if (e._paused || e instanceof r && e._hasPausedChild()) return !0;
                                    e = e._next
                                }
                                return !1
                            }, g.getChildren = function (e, t, n, r) {
                                r = r || -9999999999;
                                for (var a = [], o = this._first, s = 0; o;) o._startTime < r || (o instanceof i ? t !== !1 && (a[s++] = o) : (n !== !1 && (a[s++] = o), e !== !1 && (a = a.concat(o.getChildren(!0, t, n)), s = a.length))), o = o._next;
                                return a
                            }, g.getTweensOf = function (e, t) {
                                var n, r, a = this._gc,
                                    o = [],
                                    s = 0;
                                for (a && this._enabled(!0, !0), n = i.getTweensOf(e), r = n.length; --r > -1;)(n[r].timeline === this || t && this._contains(n[r])) && (o[s++] = n[r]);
                                return a && this._enabled(!1, !0), o
                            }, g.recent = function () {
                                return this._recent
                            }, g._contains = function (e) {
                                for (var t = e.timeline; t;) {
                                    if (t === this) return !0;
                                    t = t.timeline
                                }
                                return !1
                            }, g.shiftChildren = function (e, t, n) {
                                n = n || 0;
                                for (var i, r = this._first, a = this._labels; r;) r._startTime >= n && (r._startTime += e), r = r._next;
                                if (t)
                                    for (i in a) a[i] >= n && (a[i] += e);
                                return this._uncache(!0)
                            }, g._kill = function (e, t) {
                                if (!e && !t) return this._enabled(!1, !1);
                                for (var n = t ? this.getTweensOf(t) : this.getChildren(!0, !0, !1), i = n.length, r = !1; --i > -1;) n[i]._kill(e, t) && (r = !0);
                                return r
                            }, g.clear = function (e) {
                                var t = this.getChildren(!1, !0, !0),
                                    n = t.length;
                                for (this._time = this._totalTime = 0; --n > -1;) t[n]._enabled(!1, !1);
                                return e !== !1 && (this._labels = {}), this._uncache(!0)
                            }, g.invalidate = function () {
                                for (var t = this._first; t;) t.invalidate(), t = t._next;
                                return e.prototype.invalidate.call(this)
                            }, g._enabled = function (e, n) {
                                if (e === this._gc)
                                    for (var i = this._first; i;) i._enabled(e, !0), i = i._next;
                                return t.prototype._enabled.call(this, e, n)
                            }, g.totalTime = function (t, n, i) {
                                this._forcingPlayhead = !0;
                                var r = e.prototype.totalTime.apply(this, arguments);
                                return this._forcingPlayhead = !1, r
                            }, g.duration = function (e) {
                                return arguments.length ? (0 !== this.duration() && 0 !== e && this.timeScale(this._duration / e), this) : (this._dirty && this.totalDuration(), this._duration)
                            }, g.totalDuration = function (e) {
                                if (!arguments.length) {
                                    if (this._dirty) {
                                        for (var t, n, i = 0, r = this._last, a = 999999999999; r;) t = r._prev, r._dirty && r.totalDuration(), r._startTime > a && this._sortChildren && !r._paused && !this._calculatingDuration ? (this._calculatingDuration = 1, this.add(r, r._startTime - r._delay), this._calculatingDuration = 0) : a = r._startTime, r._startTime < 0 && !r._paused && (i -= r._startTime, this._timeline.smoothChildTiming && (this._startTime += r._startTime / this._timeScale, this._time -= r._startTime, this._totalTime -= r._startTime, this._rawPrevTime -= r._startTime), this.shiftChildren(-r._startTime, !1, -9999999999), a = 0), n = r._startTime + r._totalDuration / r._timeScale, n > i && (i = n), r = t;
                                        this._duration = this._totalDuration = i, this._dirty = !1
                                    }
                                    return this._totalDuration
                                }
                                return e && this.totalDuration() ? this.timeScale(this._totalDuration / e) : this
                            }, g.paused = function (t) {
                                if (!t)
                                    for (var n = this._first, i = this._time; n;) n._startTime === i && "isPause" === n.data && (n._rawPrevTime = 0), n = n._next;
                                return e.prototype.paused.apply(this, arguments)
                            }, g.usesFrames = function () {
                                for (var t = this._timeline; t._timeline;) t = t._timeline;
                                return t === e._rootFramesTimeline
                            }, g.rawTime = function (e) {
                                return e && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(e) - this._startTime) * this._timeScale
                            }, r
                        }, !0), n._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function (e, t, i) {
                            var r = function (t) {
                                    e.call(this, t), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._dirty = !0
                                },
                                a = 1e-10,
                                o = t._internals,
                                s = o.lazyTweens,
                                l = o.lazyRender,
                                c = n._gsDefine.globals,
                                u = new i(null, null, 1, 0),
                                h = r.prototype = new e;
                            return h.constructor = r, h.kill()._gc = !1, r.version = "1.20.4", h.invalidate = function () {
                                return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), e.prototype.invalidate.call(this)
                            }, h.addCallback = function (e, n, i, r) {
                                return this.add(t.delayedCall(0, e, i, r), n)
                            }, h.removeCallback = function (e, t) {
                                if (e)
                                    if (null == t) this._kill(null, e);
                                    else
                                        for (var n = this.getTweensOf(e, !1), i = n.length, r = this._parseTimeOrLabel(t); --i > -1;) n[i]._startTime === r && n[i]._enabled(!1, !1);
                                return this
                            }, h.removePause = function (t) {
                                return this.removeCallback(e._internals.pauseCallback, t)
                            }, h.tweenTo = function (e, n) {
                                n = n || {};
                                var i, r, a, o = {
                                        ease: u,
                                        useFrames: this.usesFrames(),
                                        immediateRender: !1,
                                        lazy: !1
                                    },
                                    s = n.repeat && c.TweenMax || t;
                                for (r in n) o[r] = n[r];
                                return o.time = this._parseTimeOrLabel(e), i = Math.abs(Number(o.time) - this._time) / this._timeScale || .001, a = new s(this, i, o), o.onStart = function () {
                                    a.target.paused(!0), a.vars.time === a.target.time() || i !== a.duration() || a.isFromTo || a.duration(Math.abs(a.vars.time - a.target.time()) / a.target._timeScale).render(a.time(), !0, !0), n.onStart && n.onStart.apply(n.onStartScope || n.callbackScope || a, n.onStartParams || [])
                                }, a
                            }, h.tweenFromTo = function (e, t, n) {
                                n = n || {}, e = this._parseTimeOrLabel(e), n.startAt = {
                                    onComplete: this.seek,
                                    onCompleteParams: [e],
                                    callbackScope: this
                                }, n.immediateRender = n.immediateRender !== !1;
                                var i = this.tweenTo(t, n);
                                return i.isFromTo = 1, i.duration(Math.abs(i.vars.time - e) / this._timeScale || .001)
                            }, h.render = function (e, t, n) {
                                this._gc && this._enabled(!0, !1);
                                var i, r, o, c, u, h, d, p, f = this._time,
                                    m = this._dirty ? this.totalDuration() : this._totalDuration,
                                    v = this._duration,
                                    g = this._totalTime,
                                    y = this._startTime,
                                    x = this._timeScale,
                                    b = this._rawPrevTime,
                                    _ = this._paused,
                                    w = this._cycle;
                                if (f !== this._time && (e += this._time - f), e >= m - 1e-7 && e >= 0) this._locked || (this._totalTime = m, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (r = !0, c = "onComplete", u = !!this._timeline.autoRemoveChildren, 0 === this._duration && (e <= 0 && e >= -1e-7 || b < 0 || b === a) && b !== e && this._first && (u = !0, b > a && (c = "onReverseComplete"))), this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : a, this._yoyo && 0 !== (1 & this._cycle) ? this._time = e = 0 : (this._time = v, e = v + 1e-4);
                                else if (e < 1e-7)
                                    if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== f || 0 === v && b !== a && (b > 0 || e < 0 && b >= 0) && !this._locked) && (c = "onReverseComplete", r = this._reversed), e < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (u = r = !0, c = "onReverseComplete") : b >= 0 && this._first && (u = !0), this._rawPrevTime = e;
                                    else {
                                        if (this._rawPrevTime = v || !t || e || this._rawPrevTime === e ? e : a, 0 === e && r)
                                            for (i = this._first; i && 0 === i._startTime;) i._duration || (r = !1), i = i._next;
                                        e = 0, this._initted || (u = !0)
                                    }
                                else if (0 === v && b < 0 && (u = !0), this._time = this._rawPrevTime = e, this._locked || (this._totalTime = e, 0 !== this._repeat && (h = v + this._repeatDelay, this._cycle = this._totalTime / h >> 0, 0 !== this._cycle && this._cycle === this._totalTime / h && g <= e && this._cycle--, this._time = this._totalTime - this._cycle * h, this._yoyo && 0 !== (1 & this._cycle) && (this._time = v - this._time), this._time > v ? (this._time = v, e = v + 1e-4) : this._time < 0 ? this._time = e = 0 : e = this._time)), this._hasPause && !this._forcingPlayhead && !t) {
                                    if (e = this._time, e >= f || this._repeat && w !== this._cycle)
                                        for (i = this._first; i && i._startTime <= e && !d;) i._duration || "isPause" !== i.data || i.ratio || 0 === i._startTime && 0 === this._rawPrevTime || (d = i), i = i._next;
                                    else
                                        for (i = this._last; i && i._startTime >= e && !d;) i._duration || "isPause" === i.data && i._rawPrevTime > 0 && (d = i), i = i._prev;
                                    d && d._startTime < v && (this._time = e = d._startTime, this._totalTime = e + this._cycle * (this._totalDuration + this._repeatDelay))
                                }
                                if (this._cycle !== w && !this._locked) {
                                    var M = this._yoyo && 0 !== (1 & w),
                                        T = M === (this._yoyo && 0 !== (1 & this._cycle)),
                                        E = this._totalTime,
                                        S = this._cycle,
                                        P = this._rawPrevTime,
                                        C = this._time;
                                    if (this._totalTime = w * v, this._cycle < w ? M = !M : this._totalTime += v, this._time = f, this._rawPrevTime = 0 === v ? b - 1e-4 : b, this._cycle = w, this._locked = !0, f = M ? 0 : v, this.render(f, t, 0 === v), t || this._gc || this.vars.onRepeat && (this._cycle = S, this._locked = !1, this._callback("onRepeat")), f !== this._time) return;
                                    if (T && (this._cycle = w, this._locked = !0, f = M ? v + 1e-4 : -1e-4, this.render(f, !0, !1)), this._locked = !1, this._paused && !_) return;
                                    this._time = C, this._totalTime = E, this._cycle = S, this._rawPrevTime = P
                                }
                                if (!(this._time !== f && this._first || n || u || d)) return void(g !== this._totalTime && this._onUpdate && (t || this._callback("onUpdate")));
                                if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== g && e > 0 && (this._active = !0), 0 === g && this.vars.onStart && (0 === this._totalTime && this._totalDuration || t || this._callback("onStart")), p = this._time, p >= f)
                                    for (i = this._first; i && (o = i._next, p === this._time && (!this._paused || _));)(i._active || i._startTime <= this._time && !i._paused && !i._gc) && (d === i && this.pause(), i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (e - i._startTime) * i._timeScale, t, n) : i.render((e - i._startTime) * i._timeScale, t, n)), i = o;
                                else
                                    for (i = this._last; i && (o = i._prev, p === this._time && (!this._paused || _));) {
                                        if (i._active || i._startTime <= f && !i._paused && !i._gc) {
                                            if (d === i) {
                                                for (d = i._prev; d && d.endTime() > this._time;) d.render(d._reversed ? d.totalDuration() - (e - d._startTime) * d._timeScale : (e - d._startTime) * d._timeScale, t, n), d = d._prev;
                                                d = null, this.pause()
                                            }
                                            i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (e - i._startTime) * i._timeScale, t, n) : i.render((e - i._startTime) * i._timeScale, t, n)
                                        }
                                        i = o
                                    }
                                this._onUpdate && (t || (s.length && l(), this._callback("onUpdate"))), c && (this._locked || this._gc || y !== this._startTime && x === this._timeScale || (0 === this._time || m >= this.totalDuration()) && (r && (s.length && l(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[c] && this._callback(c)))
                            }, h.getActive = function (e, t, n) {
                                null == e && (e = !0), null == t && (t = !0), null == n && (n = !1);
                                var i, r, a = [],
                                    o = this.getChildren(e, t, n),
                                    s = 0,
                                    l = o.length;
                                for (i = 0; i < l; i++) r = o[i], r.isActive() && (a[s++] = r);
                                return a
                            }, h.getLabelAfter = function (e) {
                                e || 0 !== e && (e = this._time);
                                var t, n = this.getLabelsArray(),
                                    i = n.length;
                                for (t = 0; t < i; t++)
                                    if (n[t].time > e) return n[t].name;
                                return null
                            }, h.getLabelBefore = function (e) {
                                null == e && (e = this._time);
                                for (var t = this.getLabelsArray(), n = t.length; --n > -1;)
                                    if (t[n].time < e) return t[n].name;
                                return null
                            }, h.getLabelsArray = function () {
                                var e, t = [],
                                    n = 0;
                                for (e in this._labels) t[n++] = {
                                    time: this._labels[e],
                                    name: e
                                };
                                return t.sort(function (e, t) {
                                    return e.time - t.time
                                }), t
                            }, h.invalidate = function () {
                                return this._locked = !1, e.prototype.invalidate.call(this)
                            }, h.progress = function (e, t) {
                                return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - e : e) + this._cycle * (this._duration + this._repeatDelay), t) : this._time / this.duration() || 0
                            }, h.totalProgress = function (e, t) {
                                return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this._totalTime / this.totalDuration() || 0
                            }, h.totalDuration = function (t) {
                                return arguments.length ? this._repeat !== -1 && t ? this.timeScale(this.totalDuration() / t) : this : (this._dirty && (e.prototype.totalDuration.call(this), this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
                            }, h.time = function (e, t) {
                                return arguments.length ? (this._dirty && this.totalDuration(), e > this._duration && (e = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? e = this._duration - e + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (e += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(e, t)) : this._time
                            }, h.repeat = function (e) {
                                return arguments.length ? (this._repeat = e, this._uncache(!0)) : this._repeat
                            }, h.repeatDelay = function (e) {
                                return arguments.length ? (this._repeatDelay = e, this._uncache(!0)) : this._repeatDelay
                            }, h.yoyo = function (e) {
                                return arguments.length ? (this._yoyo = e, this) : this._yoyo
                            }, h.currentLabel = function (e) {
                                return arguments.length ? this.seek(e, !0) : this.getLabelBefore(this._time + 1e-8)
                            }, r
                        }, !0),
                        function () {
                            var e = 180 / Math.PI,
                                t = [],
                                i = [],
                                r = [],
                                a = {},
                                o = n._gsDefine.globals,
                                s = function (e, t, n, i) {
                                    n === i && (n = i - (i - t) / 1e6), e === t && (t = e + (n - e) / 1e6), this.a = e, this.b = t, this.c = n, this.d = i, this.da = i - e, this.ca = n - e, this.ba = t - e
                                },
                                l = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
                                c = function (e, t, n, i) {
                                    var r = {
                                            a: e
                                        },
                                        a = {},
                                        o = {},
                                        s = {
                                            c: i
                                        },
                                        l = (e + t) / 2,
                                        c = (t + n) / 2,
                                        u = (n + i) / 2,
                                        h = (l + c) / 2,
                                        d = (c + u) / 2,
                                        p = (d - h) / 8;
                                    return r.b = l + (e - l) / 4, a.b = h + p, r.c = a.a = (r.b + a.b) / 2, a.c = o.a = (h + d) / 2, o.b = d - p, s.b = u + (i - u) / 4, o.c = s.a = (o.b + s.b) / 2, [r, a, o, s]
                                },
                                u = function (e, n, a, o, s) {
                                    var l, u, h, d, p, f, m, v, g, y, x, b, _, w = e.length - 1,
                                        M = 0,
                                        T = e[0].a;
                                    for (l = 0; l < w; l++) p = e[M], u = p.a, h = p.d, d = e[M + 1].d, s ? (x = t[l], b = i[l], _ = (b + x) * n * .25 / (o ? .5 : r[l] || .5), f = h - (h - u) * (o ? .5 * n : 0 !== x ? _ / x : 0), m = h + (d - h) * (o ? .5 * n : 0 !== b ? _ / b : 0), v = h - (f + ((m - f) * (3 * x / (x + b) + .5) / 4 || 0))) : (f = h - (h - u) * n * .5, m = h + (d - h) * n * .5, v = h - (f + m) / 2), f += v, m += v, p.c = g = f, 0 !== l ? p.b = T : p.b = T = p.a + .6 * (p.c - p.a), p.da = h - u, p.ca = g - u, p.ba = T - u, a ? (y = c(u, T, g, h), e.splice(M, 1, y[0], y[1], y[2], y[3]), M += 4) : M++, T = m;
                                    p = e[M], p.b = T, p.c = T + .4 * (p.d - T), p.da = p.d - p.a, p.ca = p.c - p.a, p.ba = T - p.a, a && (y = c(p.a, T, p.c, p.d), e.splice(M, 1, y[0], y[1], y[2], y[3]))
                                },
                                h = function (e, n, r, a) {
                                    var o, l, c, u, h, d, p = [];
                                    if (a)
                                        for (e = [a].concat(e), l = e.length; --l > -1;) "string" == typeof (d = e[l][n]) && "=" === d.charAt(1) && (e[l][n] = a[n] + Number(d.charAt(0) + d.substr(2)));
                                    if (o = e.length - 2, o < 0) return p[0] = new s(e[0][n], 0, 0, e[0][n]), p;
                                    for (l = 0; l < o; l++) c = e[l][n], u = e[l + 1][n], p[l] = new s(c, 0, 0, u), r && (h = e[l + 2][n], t[l] = (t[l] || 0) + (u - c) * (u - c), i[l] = (i[l] || 0) + (h - u) * (h - u));
                                    return p[l] = new s(e[l][n], 0, 0, e[l + 1][n]), p
                                },
                                d = function (e, n, o, s, c, d) {
                                    var p, f, m, v, g, y, x, b, _ = {},
                                        w = [],
                                        M = d || e[0];
                                    c = "string" == typeof c ? "," + c + "," : l, null == n && (n = 1);
                                    for (f in e[0]) w.push(f);
                                    if (e.length > 1) {
                                        for (b = e[e.length - 1], x = !0, p = w.length; --p > -1;)
                                            if (f = w[p], Math.abs(M[f] - b[f]) > .05) {
                                                x = !1;
                                                break
                                            } x && (e = e.concat(), d && e.unshift(d), e.push(e[1]), d = e[e.length - 3])
                                    }
                                    for (t.length = i.length = r.length = 0, p = w.length; --p > -1;) f = w[p], a[f] = c.indexOf("," + f + ",") !== -1, _[f] = h(e, f, a[f], d);
                                    for (p = t.length; --p > -1;) t[p] = Math.sqrt(t[p]), i[p] = Math.sqrt(i[p]);
                                    if (!s) {
                                        for (p = w.length; --p > -1;)
                                            if (a[f])
                                                for (m = _[w[p]], y = m.length - 1, v = 0; v < y; v++) g = m[v + 1].da / i[v] + m[v].da / t[v] || 0, r[v] = (r[v] || 0) + g * g;
                                        for (p = r.length; --p > -1;) r[p] = Math.sqrt(r[p])
                                    }
                                    for (p = w.length, v = o ? 4 : 1; --p > -1;) f = w[p], m = _[f], u(m, n, o, s, a[f]), x && (m.splice(0, v), m.splice(m.length - v, v));
                                    return _
                                },
                                p = function (e, t, n) {
                                    t = t || "soft";
                                    var i, r, a, o, l, c, u, h, d, p, f, m = {},
                                        v = "cubic" === t ? 3 : 2,
                                        g = "soft" === t,
                                        y = [];
                                    if (g && n && (e = [n].concat(e)), null == e || e.length < v + 1) throw "invalid Bezier data";
                                    for (d in e[0]) y.push(d);
                                    for (c = y.length; --c > -1;) {
                                        for (d = y[c], m[d] = l = [], p = 0, h = e.length, u = 0; u < h; u++) i = null == n ? e[u][d] : "string" == typeof (f = e[u][d]) && "=" === f.charAt(1) ? n[d] + Number(f.charAt(0) + f.substr(2)) : Number(f), g && u > 1 && u < h - 1 && (l[p++] = (i + l[p - 2]) / 2), l[p++] = i;
                                        for (h = p - v + 1, p = 0, u = 0; u < h; u += v) i = l[u], r = l[u + 1], a = l[u + 2], o = 2 === v ? 0 : l[u + 3], l[p++] = f = 3 === v ? new s(i, r, a, o) : new s(i, (2 * r + i) / 3, (2 * r + a) / 3, a);
                                        l.length = p
                                    }
                                    return m
                                },
                                f = function (e, t, n) {
                                    for (var i, r, a, o, s, l, c, u, h, d, p, f = 1 / n, m = e.length; --m > -1;)
                                        for (d = e[m], a = d.a, o = d.d - a, s = d.c - a, l = d.b - a, i = r = 0, u = 1; u <= n; u++) c = f * u, h = 1 - c, i = r - (r = (c * c * o + 3 * h * (c * s + h * l)) * c), p = m * n + u - 1, t[p] = (t[p] || 0) + i * i
                                },
                                m = function (e, t) {
                                    t = t >> 0 || 6;
                                    var n, i, r, a, o = [],
                                        s = [],
                                        l = 0,
                                        c = 0,
                                        u = t - 1,
                                        h = [],
                                        d = [];
                                    for (n in e) f(e[n], o, t);
                                    for (r = o.length, i = 0; i < r; i++) l += Math.sqrt(o[i]), a = i % t, d[a] = l, a === u && (c += l, a = i / t >> 0, h[a] = d, s[a] = c, l = 0, d = []);
                                    return {
                                        length: c,
                                        lengths: s,
                                        segments: h
                                    }
                                },
                                v = n._gsDefine.plugin({
                                    propName: "bezier",
                                    priority: -1,
                                    version: "1.3.8",
                                    API: 2,
                                    global: !0,
                                    init: function (e, t, n) {
                                        this._target = e, t instanceof Array && (t = {
                                            values: t
                                        }), this._func = {}, this._mod = {}, this._props = [], this._timeRes = null == t.timeResolution ? 6 : parseInt(t.timeResolution, 10);
                                        var i, r, a, o, s, l = t.values || [],
                                            c = {},
                                            u = l[0],
                                            h = t.autoRotate || n.vars.orientToBezier;
                                        this._autoRotate = h ? h instanceof Array ? h : [
                                            ["x", "y", "rotation", h === !0 ? 0 : Number(h) || 0]
                                        ] : null;
                                        for (i in u) this._props.push(i);
                                        for (a = this._props.length; --a > -1;) i = this._props[a], this._overwriteProps.push(i), r = this._func[i] = "function" == typeof e[i], c[i] = r ? e[i.indexOf("set") || "function" != typeof e["get" + i.substr(3)] ? i : "get" + i.substr(3)]() : parseFloat(e[i]), s || c[i] !== l[0][i] && (s = c);
                                        if (this._beziers = "cubic" !== t.type && "quadratic" !== t.type && "soft" !== t.type ? d(l, isNaN(t.curviness) ? 1 : t.curviness, !1, "thruBasic" === t.type, t.correlate, s) : p(l, t.type, c), this._segCount = this._beziers[i].length, this._timeRes) {
                                            var f = m(this._beziers, this._timeRes);
                                            this._length = f.length, this._lengths = f.lengths, this._segments = f.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length
                                        }
                                        if (h = this._autoRotate)
                                            for (this._initialRotations = [], h[0] instanceof Array || (this._autoRotate = h = [h]), a = h.length; --a > -1;) {
                                                for (o = 0; o < 3; o++) i = h[a][o], this._func[i] = "function" == typeof e[i] && e[i.indexOf("set") || "function" != typeof e["get" + i.substr(3)] ? i : "get" + i.substr(3)];
                                                i = h[a][2], this._initialRotations[a] = (this._func[i] ? this._func[i].call(this._target) : this._target[i]) || 0, this._overwriteProps.push(i)
                                            }
                                        return this._startRatio = n.vars.runBackwards ? 1 : 0, !0
                                    },
                                    set: function (t) {
                                        var n, i, r, a, o, s, l, c, u, h, d = this._segCount,
                                            p = this._func,
                                            f = this._target,
                                            m = t !== this._startRatio;
                                        if (this._timeRes) {
                                            if (u = this._lengths, h = this._curSeg, t *= this._length, r = this._li, t > this._l2 && r < d - 1) {
                                                for (c = d - 1; r < c && (this._l2 = u[++r]) <= t;);
                                                this._l1 = u[r - 1], this._li = r, this._curSeg = h = this._segments[r], this._s2 = h[this._s1 = this._si = 0]
                                            } else if (t < this._l1 && r > 0) {
                                                for (; r > 0 && (this._l1 = u[--r]) >= t;);
                                                0 === r && t < this._l1 ? this._l1 = 0 : r++, this._l2 = u[r], this._li = r, this._curSeg = h = this._segments[r], this._s1 = h[(this._si = h.length - 1) - 1] || 0, this._s2 = h[this._si]
                                            }
                                            if (n = r, t -= this._l1, r = this._si, t > this._s2 && r < h.length - 1) {
                                                for (c = h.length - 1; r < c && (this._s2 = h[++r]) <= t;);
                                                this._s1 = h[r - 1], this._si = r
                                            } else if (t < this._s1 && r > 0) {
                                                for (; r > 0 && (this._s1 = h[--r]) >= t;);
                                                0 === r && t < this._s1 ? this._s1 = 0 : r++, this._s2 = h[r], this._si = r
                                            }
                                            s = (r + (t - this._s1) / (this._s2 - this._s1)) * this._prec || 0
                                        } else n = t < 0 ? 0 : t >= 1 ? d - 1 : d * t >> 0, s = (t - n * (1 / d)) * d;
                                        for (i = 1 - s, r = this._props.length; --r > -1;) a = this._props[r], o = this._beziers[a][n], l = (s * s * o.da + 3 * i * (s * o.ca + i * o.ba)) * s + o.a, this._mod[a] && (l = this._mod[a](l, f)), p[a] ? f[a](l) : f[a] = l;
                                        if (this._autoRotate) {
                                            var v, g, y, x, b, _, w, M = this._autoRotate;
                                            for (r = M.length; --r > -1;) a = M[r][2], _ = M[r][3] || 0, w = M[r][4] === !0 ? 1 : e, o = this._beziers[M[r][0]], v = this._beziers[M[r][1]], o && v && (o = o[n], v = v[n], g = o.a + (o.b - o.a) * s, x = o.b + (o.c - o.b) * s, g += (x - g) * s, x += (o.c + (o.d - o.c) * s - x) * s, y = v.a + (v.b - v.a) * s, b = v.b + (v.c - v.b) * s, y += (b - y) * s, b += (v.c + (v.d - v.c) * s - b) * s, l = m ? Math.atan2(b - y, x - g) * w + _ : this._initialRotations[r], this._mod[a] && (l = this._mod[a](l, f)), p[a] ? f[a](l) : f[a] = l)
                                        }
                                    }
                                }),
                                g = v.prototype;
                            v.bezierThrough = d, v.cubicToQuadratic = c, v._autoCSS = !0, v.quadraticToCubic = function (e, t, n) {
                                return new s(e, (2 * t + e) / 3, (2 * t + n) / 3, n)
                            }, v._cssRegister = function () {
                                var e = o.CSSPlugin;
                                if (e) {
                                    var t = e._internals,
                                        n = t._parseToProxy,
                                        i = t._setPluginRatio,
                                        r = t.CSSPropTween;
                                    t._registerComplexSpecialProp("bezier", {
                                        parser: function (e, t, a, o, s, l) {
                                            t instanceof Array && (t = {
                                                values: t
                                            }), l = new v;
                                            var c, u, h, d = t.values,
                                                p = d.length - 1,
                                                f = [],
                                                m = {};
                                            if (p < 0) return s;
                                            for (c = 0; c <= p; c++) h = n(e, d[c], o, s, l, p !== c), f[c] = h.end;
                                            for (u in t) m[u] = t[u];
                                            return m.values = f, s = new r(e, "bezier", 0, 0, h.pt, 2), s.data = h, s.plugin = l, s.setRatio = i, 0 === m.autoRotate && (m.autoRotate = !0), !m.autoRotate || m.autoRotate instanceof Array || (c = m.autoRotate === !0 ? 0 : Number(m.autoRotate), m.autoRotate = null != h.end.left ? [
                                                ["left", "top", "rotation", c, !1]
                                            ] : null != h.end.x && [
                                                ["x", "y", "rotation", c, !1]
                                            ]), m.autoRotate && (o._transform || o._enableTransforms(!1), h.autoRotate = o._target._gsTransform, h.proxy.rotation = h.autoRotate.rotation || 0, o._overwriteProps.push("rotation")), l._onInitTween(h.proxy, m, o._tween), s
                                        }
                                    })
                                }
                            }, g._mod = function (e) {
                                for (var t, n = this._overwriteProps, i = n.length; --i > -1;) t = e[n[i]], t && "function" == typeof t && (this._mod[n[i]] = t)
                            }, g._kill = function (e) {
                                var t, n, i = this._props;
                                for (t in this._beziers)
                                    if (t in e)
                                        for (delete this._beziers[t], delete this._func[t], n = i.length; --n > -1;) i[n] === t && i.splice(n, 1);
                                if (i = this._autoRotate)
                                    for (n = i.length; --n > -1;) e[i[n][2]] && i.splice(n, 1);
                                return this._super._kill.call(this, e)
                            }
                        }(), n._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function (e, t) {
                            var i, r, a, o, s = function () {
                                    e.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = s.prototype.setRatio
                                },
                                l = n._gsDefine.globals,
                                c = {},
                                u = s.prototype = new e("css");
                            u.constructor = s, s.version = "1.20.5", s.API = 2, s.defaultTransformPerspective = 0, s.defaultSkewType = "compensated", s.defaultSmoothOrigin = !0, u = "px", s.suffixMap = {
                                top: u,
                                right: u,
                                bottom: u,
                                left: u,
                                width: u,
                                height: u,
                                fontSize: u,
                                padding: u,
                                margin: u,
                                perspective: u,
                                lineHeight: ""
                            };
                            var h, d, p, f, m, v, g, y, x = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
                                b = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
                                _ = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
                                w = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
                                M = /(?:\d|\-|\+|=|#|\.)*/g,
                                T = /opacity *= *([^)]*)/i,
                                E = /opacity:([^;]*)/i,
                                S = /alpha\(opacity *=.+?\)/i,
                                P = /^(rgb|hsl)/,
                                C = /([A-Z])/g,
                                A = /-([a-z])/gi,
                                L = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
                                R = function (e, t) {
                                    return t.toUpperCase()
                                },
                                I = /(?:Left|Right|Width)/i,
                                O = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
                                k = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
                                D = /,(?=[^\)]*(?:\(|$))/gi,
                                z = /[\s,\(]/i,
                                B = Math.PI / 180,
                                N = 180 / Math.PI,
                                U = {},
                                j = {
                                    style: {}
                                },
                                F = n.document || {
                                    createElement: function () {
                                        return j
                                    }
                                },
                                G = function (e, t) {
                                    return F.createElementNS ? F.createElementNS(t || "http://www.w3.org/1999/xhtml", e) : F.createElement(e)
                                },
                                H = G("div"),
                                V = G("img"),
                                W = s._internals = {
                                    _specialProps: c
                                },
                                q = (n.navigator || {}).userAgent || "",
                                X = function () {
                                    var e = q.indexOf("Android"),
                                        t = G("a");
                                    return p = q.indexOf("Safari") !== -1 && q.indexOf("Chrome") === -1 && (e === -1 || parseFloat(q.substr(e + 8, 2)) > 3), m = p && parseFloat(q.substr(q.indexOf("Version/") + 8, 2)) < 6, f = q.indexOf("Firefox") !== -1, (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(q) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(q)) && (v = parseFloat(RegExp.$1)), !!t && (t.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(t.style.opacity))
                                }(),
                                Y = function (e) {
                                    return T.test("string" == typeof e ? e : (e.currentStyle ? e.currentStyle.filter : e.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
                                },
                                Z = function (e) {
                                    n.console && console.log(e)
                                },
                                J = "",
                                $ = "",
                                Q = function (e, t) {
                                    t = t || H;
                                    var n, i, r = t.style;
                                    if (void 0 !== r[e]) return e;
                                    for (e = e.charAt(0).toUpperCase() + e.substr(1), n = ["O", "Moz", "ms", "Ms", "Webkit"], i = 5; --i > -1 && void 0 === r[n[i] + e];);
                                    return i >= 0 ? ($ = 3 === i ? "ms" : n[i], J = "-" + $.toLowerCase() + "-", $ + e) : null
                                },
                                K = ("undefined" != typeof window ? window : F.defaultView || {
                                    getComputedStyle: function () {}
                                }).getComputedStyle,
                                ee = s.getStyle = function (e, t, n, i, r) {
                                    var a;
                                    return X || "opacity" !== t ? (!i && e.style[t] ? a = e.style[t] : (n = n || K(e)) ? a = n[t] || n.getPropertyValue(t) || n.getPropertyValue(t.replace(C, "-$1").toLowerCase()) : e.currentStyle && (a = e.currentStyle[t]), null == r || a && "none" !== a && "auto" !== a && "auto auto" !== a ? a : r) : Y(e)
                                },
                                te = W.convertToPixels = function (e, n, i, r, a) {
                                    if ("px" === r || !r && "lineHeight" !== n) return i;
                                    if ("auto" === r || !i) return 0;
                                    var o, l, c, u = I.test(n),
                                        h = e,
                                        d = H.style,
                                        p = i < 0,
                                        f = 1 === i;
                                    if (p && (i = -i), f && (i *= 100), "lineHeight" !== n || r)
                                        if ("%" === r && n.indexOf("border") !== -1) o = i / 100 * (u ? e.clientWidth : e.clientHeight);
                                        else {
                                            if (d.cssText = "border:0 solid red;position:" + ee(e, "position") + ";line-height:0;", "%" !== r && h.appendChild && "v" !== r.charAt(0) && "rem" !== r) d[u ? "borderLeftWidth" : "borderTopWidth"] = i + r;
                                            else {
                                                if (h = e.parentNode || F.body, ee(h, "display").indexOf("flex") !== -1 && (d.position = "absolute"), l = h._gsCache, c = t.ticker.frame, l && u && l.time === c) return l.width * i / 100;
                                                d[u ? "width" : "height"] = i + r
                                            }
                                            h.appendChild(H), o = parseFloat(H[u ? "offsetWidth" : "offsetHeight"]), h.removeChild(H), u && "%" === r && s.cacheWidths !== !1 && (l = h._gsCache = h._gsCache || {}, l.time = c, l.width = o / i * 100), 0 !== o || a || (o = te(e, n, i, r, !0))
                                        }
                                    else l = K(e).lineHeight, e.style.lineHeight = i, o = parseFloat(K(e).lineHeight), e.style.lineHeight = l;
                                    return f && (o /= 100), p ? -o : o
                                },
                                ne = W.calculateOffset = function (e, t, n) {
                                    if ("absolute" !== ee(e, "position", n)) return 0;
                                    var i = "left" === t ? "Left" : "Top",
                                        r = ee(e, "margin" + i, n);
                                    return e["offset" + i] - (te(e, t, parseFloat(r), r.replace(M, "")) || 0)
                                },
                                ie = function (e, t) {
                                    var n, i, r, a = {};
                                    if (t = t || K(e, null))
                                        if (n = t.length)
                                            for (; --n > -1;) r = t[n], r.indexOf("-transform") !== -1 && Le !== r || (a[r.replace(A, R)] = t.getPropertyValue(r));
                                        else
                                            for (n in t) n.indexOf("Transform") !== -1 && Ae !== n || (a[n] = t[n]);
                                    else if (t = e.currentStyle || e.style)
                                        for (n in t) "string" == typeof n && void 0 === a[n] && (a[n.replace(A, R)] = t[n]);
                                    return X || (a.opacity = Y(e)), i = Ve(e, t, !1), a.rotation = i.rotation, a.skewX = i.skewX, a.scaleX = i.scaleX, a.scaleY = i.scaleY, a.x = i.x, a.y = i.y, Ie && (a.z = i.z, a.rotationX = i.rotationX, a.rotationY = i.rotationY, a.scaleZ = i.scaleZ), a.filters && delete a.filters, a
                                },
                                re = function (e, t, n, i, r) {
                                    var a, o, s, l = {},
                                        c = e.style;
                                    for (o in n) "cssText" !== o && "length" !== o && isNaN(o) && (t[o] !== (a = n[o]) || r && r[o]) && o.indexOf("Origin") === -1 && ("number" != typeof a && "string" != typeof a || (l[o] = "auto" !== a || "left" !== o && "top" !== o ? "" !== a && "auto" !== a && "none" !== a || "string" != typeof t[o] || "" === t[o].replace(w, "") ? a : 0 : ne(e, o), void 0 !== c[o] && (s = new xe(c, o, c[o], s))));
                                    if (i)
                                        for (o in i) "className" !== o && (l[o] = i[o]);
                                    return {
                                        difs: l,
                                        firstMPT: s
                                    }
                                },
                                ae = {
                                    width: ["Left", "Right"],
                                    height: ["Top", "Bottom"]
                                },
                                oe = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
                                se = function (e, t, n) {
                                    if ("svg" === (e.nodeName + "").toLowerCase()) return (n || K(e))[t] || 0;
                                    if (e.getCTM && Fe(e)) return e.getBBox()[t] || 0;
                                    var i = parseFloat("width" === t ? e.offsetWidth : e.offsetHeight),
                                        r = ae[t],
                                        a = r.length;
                                    for (n = n || K(e, null); --a > -1;) i -= parseFloat(ee(e, "padding" + r[a], n, !0)) || 0, i -= parseFloat(ee(e, "border" + r[a] + "Width", n, !0)) || 0;
                                    return i
                                },
                                le = function (e, t) {
                                    if ("contain" === e || "auto" === e || "auto auto" === e) return e + " ";
                                    null != e && "" !== e || (e = "0 0");
                                    var n, i = e.split(" "),
                                        r = e.indexOf("left") !== -1 ? "0%" : e.indexOf("right") !== -1 ? "100%" : i[0],
                                        a = e.indexOf("top") !== -1 ? "0%" : e.indexOf("bottom") !== -1 ? "100%" : i[1];
                                    if (i.length > 3 && !t) {
                                        for (i = e.split(", ").join(",").split(","), e = [], n = 0; n < i.length; n++) e.push(le(i[n]));
                                        return e.join(",")
                                    }
                                    return null == a ? a = "center" === r ? "50%" : "0" : "center" === a && (a = "50%"), ("center" === r || isNaN(parseFloat(r)) && (r + "").indexOf("=") === -1) && (r = "50%"), e = r + " " + a + (i.length > 2 ? " " + i[2] : ""), t && (t.oxp = r.indexOf("%") !== -1, t.oyp = a.indexOf("%") !== -1, t.oxr = "=" === r.charAt(1), t.oyr = "=" === a.charAt(1), t.ox = parseFloat(r.replace(w, "")), t.oy = parseFloat(a.replace(w, "")), t.v = e), t || e
                                },
                                ce = function (e, t) {
                                    return "function" == typeof e && (e = e(y, g)), "string" == typeof e && "=" === e.charAt(1) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(t) || 0
                                },
                                ue = function (e, t) {
                                    return "function" == typeof e && (e = e(y, g)), null == e ? t : "string" == typeof e && "=" === e.charAt(1) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) + t : parseFloat(e) || 0
                                },
                                he = function (e, t, n, i) {
                                    var r, a, o, s, l, c = 1e-6;
                                    return "function" == typeof e && (e = e(y, g)), null == e ? s = t : "number" == typeof e ? s = e : (r = 360, a = e.split("_"), l = "=" === e.charAt(1), o = (l ? parseInt(e.charAt(0) + "1", 10) * parseFloat(a[0].substr(2)) : parseFloat(a[0])) * (e.indexOf("rad") === -1 ? 1 : N) - (l ? 0 : t), a.length && (i && (i[n] = t + o), e.indexOf("short") !== -1 && (o %= r, o !== o % (r / 2) && (o = o < 0 ? o + r : o - r)), e.indexOf("_cw") !== -1 && o < 0 ? o = (o + 9999999999 * r) % r - (o / r | 0) * r : e.indexOf("ccw") !== -1 && o > 0 && (o = (o - 9999999999 * r) % r - (o / r | 0) * r)), s = t + o), s < c && s > -c && (s = 0), s
                                },
                                de = {
                                    aqua: [0, 255, 255],
                                    lime: [0, 255, 0],
                                    silver: [192, 192, 192],
                                    black: [0, 0, 0],
                                    maroon: [128, 0, 0],
                                    teal: [0, 128, 128],
                                    blue: [0, 0, 255],
                                    navy: [0, 0, 128],
                                    white: [255, 255, 255],
                                    fuchsia: [255, 0, 255],
                                    olive: [128, 128, 0],
                                    yellow: [255, 255, 0],
                                    orange: [255, 165, 0],
                                    gray: [128, 128, 128],
                                    purple: [128, 0, 128],
                                    green: [0, 128, 0],
                                    red: [255, 0, 0],
                                    pink: [255, 192, 203],
                                    cyan: [0, 255, 255],
                                    transparent: [255, 255, 255, 0]
                                },
                                pe = function (e, t, n) {
                                    return e = e < 0 ? e + 1 : e > 1 ? e - 1 : e, 255 * (6 * e < 1 ? t + (n - t) * e * 6 : e < .5 ? n : 3 * e < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) + .5 | 0
                                },
                                fe = s.parseColor = function (e, t) {
                                    var n, i, r, a, o, s, l, c, u, h, d;
                                    if (e)
                                        if ("number" == typeof e) n = [e >> 16, e >> 8 & 255, 255 & e];
                                        else {
                                            if ("," === e.charAt(e.length - 1) && (e = e.substr(0, e.length - 1)), de[e]) n = de[e];
                                            else if ("#" === e.charAt(0)) 4 === e.length && (i = e.charAt(1), r = e.charAt(2), a = e.charAt(3), e = "#" + i + i + r + r + a + a), e = parseInt(e.substr(1), 16), n = [e >> 16, e >> 8 & 255, 255 & e];
                                            else if ("hsl" === e.substr(0, 3))
                                                if (n = d = e.match(x), t) {
                                                    if (e.indexOf("=") !== -1) return e.match(b)
                                                } else o = Number(n[0]) % 360 / 360, s = Number(n[1]) / 100, l = Number(n[2]) / 100, r = l <= .5 ? l * (s + 1) : l + s - l * s, i = 2 * l - r, n.length > 3 && (n[3] = Number(n[3])), n[0] = pe(o + 1 / 3, i, r), n[1] = pe(o, i, r), n[2] = pe(o - 1 / 3, i, r);
                                            else n = e.match(x) || de.transparent;
                                            n[0] = Number(n[0]), n[1] = Number(n[1]), n[2] = Number(n[2]), n.length > 3 && (n[3] = Number(n[3]))
                                        }
                                    else n = de.black;
                                    return t && !d && (i = n[0] / 255, r = n[1] / 255, a = n[2] / 255, c = Math.max(i, r, a), u = Math.min(i, r, a), l = (c + u) / 2, c === u ? o = s = 0 : (h = c - u, s = l > .5 ? h / (2 - c - u) : h / (c + u), o = c === i ? (r - a) / h + (r < a ? 6 : 0) : c === r ? (a - i) / h + 2 : (i - r) / h + 4, o *= 60), n[0] = o + .5 | 0, n[1] = 100 * s + .5 | 0, n[2] = 100 * l + .5 | 0), n
                                },
                                me = function (e, t) {
                                    var n, i, r, a = e.match(ve) || [],
                                        o = 0,
                                        s = "";
                                    if (!a.length) return e;
                                    for (n = 0; n < a.length; n++) i = a[n], r = e.substr(o, e.indexOf(i, o) - o), o += r.length + i.length, i = fe(i, t), 3 === i.length && i.push(1), s += r + (t ? "hsla(" + i[0] + "," + i[1] + "%," + i[2] + "%," + i[3] : "rgba(" + i.join(",")) + ")";
                                    return s + e.substr(o)
                                },
                                ve = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                            for (u in de) ve += "|" + u + "\\b";
                            ve = new RegExp(ve + ")", "gi"), s.colorStringFilter = function (e) {
                                var t, n = e[0] + " " + e[1];
                                ve.test(n) && (t = n.indexOf("hsl(") !== -1 || n.indexOf("hsla(") !== -1, e[0] = me(e[0], t), e[1] = me(e[1], t)), ve.lastIndex = 0
                            }, t.defaultStringFilter || (t.defaultStringFilter = s.colorStringFilter);
                            var ge = function (e, t, n, i) {
                                    if (null == e) return function (e) {
                                        return e
                                    };
                                    var r, a = t ? (e.match(ve) || [""])[0] : "",
                                        o = e.split(a).join("").match(_) || [],
                                        s = e.substr(0, e.indexOf(o[0])),
                                        l = ")" === e.charAt(e.length - 1) ? ")" : "",
                                        c = e.indexOf(" ") !== -1 ? " " : ",",
                                        u = o.length,
                                        h = u > 0 ? o[0].replace(x, "") : "";
                                    return u ? r = t ? function (e) {
                                        var t, d, p, f;
                                        if ("number" == typeof e) e += h;
                                        else if (i && D.test(e)) {
                                            for (f = e.replace(D, "|").split("|"), p = 0; p < f.length; p++) f[p] = r(f[p]);
                                            return f.join(",")
                                        }
                                        if (t = (e.match(ve) || [a])[0], d = e.split(t).join("").match(_) || [], p = d.length, u > p--)
                                            for (; ++p < u;) d[p] = n ? d[(p - 1) / 2 | 0] : o[p];
                                        return s + d.join(c) + c + t + l + (e.indexOf("inset") !== -1 ? " inset" : "")
                                    } : function (e) {
                                        var t, a, d;
                                        if ("number" == typeof e) e += h;
                                        else if (i && D.test(e)) {
                                            for (a = e.replace(D, "|").split("|"), d = 0; d < a.length; d++) a[d] = r(a[d]);
                                            return a.join(",")
                                        }
                                        if (t = e.match(_) || [], d = t.length, u > d--)
                                            for (; ++d < u;) t[d] = n ? t[(d - 1) / 2 | 0] : o[d];
                                        return s + t.join(c) + l
                                    } : function (e) {
                                        return e
                                    }
                                },
                                ye = function (e) {
                                    return e = e.split(","),
                                        function (t, n, i, r, a, o, s) {
                                            var l, c = (n + "").split(" ");
                                            for (s = {}, l = 0; l < 4; l++) s[e[l]] = c[l] = c[l] || c[(l - 1) / 2 >> 0];
                                            return r.parse(t, s, a, o)
                                        }
                                },
                                xe = (W._setPluginRatio = function (e) {
                                    this.plugin.setRatio(e);
                                    for (var t, n, i, r, a, o = this.data, s = o.proxy, l = o.firstMPT, c = 1e-6; l;) t = s[l.v], l.r ? t = l.r(t) : t < c && t > -c && (t = 0), l.t[l.p] = t, l = l._next;
                                    if (o.autoRotate && (o.autoRotate.rotation = o.mod ? o.mod.call(this._tween, s.rotation, this.t, this._tween) : s.rotation), 1 === e || 0 === e)
                                        for (l = o.firstMPT, a = 1 === e ? "e" : "b"; l;) {
                                            if (n = l.t, n.type) {
                                                if (1 === n.type) {
                                                    for (r = n.xs0 + n.s + n.xs1, i = 1; i < n.l; i++) r += n["xn" + i] + n["xs" + (i + 1)];
                                                    n[a] = r
                                                }
                                            } else n[a] = n.s + n.xs0;
                                            l = l._next
                                        }
                                }, function (e, t, n, i, r) {
                                    this.t = e, this.p = t, this.v = n, this.r = r, i && (i._prev = this, this._next = i)
                                }),
                                be = (W._parseToProxy = function (e, t, n, i, r, a) {
                                    var o, s, l, c, u, h = i,
                                        d = {},
                                        p = {},
                                        f = n._transform,
                                        m = U;
                                    for (n._transform = null, U = t, i = u = n.parse(e, t, i, r), U = m, a && (n._transform = f, h && (h._prev = null, h._prev && (h._prev._next = null))); i && i !== h;) {
                                        if (i.type <= 1 && (s = i.p, p[s] = i.s + i.c, d[s] = i.s, a || (c = new xe(i, "s", s, c, i.r), i.c = 0), 1 === i.type))
                                            for (o = i.l; --o > 0;) l = "xn" + o, s = i.p + "_" + l, p[s] = i.data[l], d[s] = i[l], a || (c = new xe(i, l, s, c, i.rxp[l]));
                                        i = i._next
                                    }
                                    return {
                                        proxy: d,
                                        end: p,
                                        firstMPT: c,
                                        pt: u
                                    }
                                }, W.CSSPropTween = function (e, t, n, r, a, s, l, c, u, h, d) {
                                    this.t = e, this.p = t, this.s = n, this.c = r, this.n = l || t, e instanceof be || o.push(this.n), this.r = c ? "function" == typeof c ? c : Math.round : c, this.type = s || 0, u && (this.pr = u, i = !0), this.b = void 0 === h ? n : h, this.e = void 0 === d ? n + r : d, a && (this._next = a, a._prev = this)
                                }),
                                _e = function (e, t, n, i, r, a) {
                                    var o = new be(e, t, n, i - n, r, (-1), a);
                                    return o.b = n, o.e = o.xs0 = i, o
                                },
                                we = s.parseComplex = function (e, t, n, i, r, a, o, l, c, u) {
                                    n = n || a || "", "function" == typeof i && (i = i(y, g)), o = new be(e, t, 0, 0, o, u ? 2 : 1, null, (!1), l, n, i), i += "", r && ve.test(i + n) && (i = [n, i], s.colorStringFilter(i), n = i[0], i = i[1]);
                                    var d, p, f, m, v, _, w, M, T, E, S, P, C, A = n.split(", ").join(",").split(" "),
                                        L = i.split(", ").join(",").split(" "),
                                        R = A.length,
                                        I = h !== !1;
                                    for (i.indexOf(",") === -1 && n.indexOf(",") === -1 || ((i + n).indexOf("rgb") !== -1 || (i + n).indexOf("hsl") !== -1 ? (A = A.join(" ").replace(D, ", ").split(" "), L = L.join(" ").replace(D, ", ").split(" ")) : (A = A.join(" ").split(",").join(", ").split(" "), L = L.join(" ").split(",").join(", ").split(" ")), R = A.length), R !== L.length && (A = (a || "").split(" "), R = A.length), o.plugin = c, o.setRatio = u, ve.lastIndex = 0, d = 0; d < R; d++)
                                        if (m = A[d], v = L[d] + "", M = parseFloat(m), M || 0 === M) o.appendXtra("", M, ce(v, M), v.replace(b, ""), !(!I || v.indexOf("px") === -1) && Math.round, !0);
                                        else if (r && ve.test(m)) P = v.indexOf(")") + 1, P = ")" + (P ? v.substr(P) : ""), C = v.indexOf("hsl") !== -1 && X, E = v, m = fe(m, C), v = fe(v, C), T = m.length + v.length > 6, T && !X && 0 === v[3] ? (o["xs" + o.l] += o.l ? " transparent" : "transparent", o.e = o.e.split(L[d]).join("transparent")) : (X || (T = !1), C ? o.appendXtra(E.substr(0, E.indexOf("hsl")) + (T ? "hsla(" : "hsl("), m[0], ce(v[0], m[0]), ",", !1, !0).appendXtra("", m[1], ce(v[1], m[1]), "%,", !1).appendXtra("", m[2], ce(v[2], m[2]), T ? "%," : "%" + P, !1) : o.appendXtra(E.substr(0, E.indexOf("rgb")) + (T ? "rgba(" : "rgb("), m[0], v[0] - m[0], ",", Math.round, !0).appendXtra("", m[1], v[1] - m[1], ",", Math.round).appendXtra("", m[2], v[2] - m[2], T ? "," : P, Math.round),
                                        T && (m = m.length < 4 ? 1 : m[3], o.appendXtra("", m, (v.length < 4 ? 1 : v[3]) - m, P, !1))), ve.lastIndex = 0;
                                    else if (_ = m.match(x)) {
                                        if (w = v.match(b), !w || w.length !== _.length) return o;
                                        for (f = 0, p = 0; p < _.length; p++) S = _[p], E = m.indexOf(S, f), o.appendXtra(m.substr(f, E - f), Number(S), ce(w[p], S), "", !(!I || "px" !== m.substr(E + S.length, 2)) && Math.round, 0 === p), f = E + S.length;
                                        o["xs" + o.l] += m.substr(f)
                                    } else o["xs" + o.l] += o.l || o["xs" + o.l] ? " " + v : v;
                                    if (i.indexOf("=") !== -1 && o.data) {
                                        for (P = o.xs0 + o.data.s, d = 1; d < o.l; d++) P += o["xs" + d] + o.data["xn" + d];
                                        o.e = P + o["xs" + d]
                                    }
                                    return o.l || (o.type = -1, o.xs0 = o.e), o.xfirst || o
                                },
                                Me = 9;
                            for (u = be.prototype, u.l = u.pr = 0; --Me > 0;) u["xn" + Me] = 0, u["xs" + Me] = "";
                            u.xs0 = "", u._next = u._prev = u.xfirst = u.data = u.plugin = u.setRatio = u.rxp = null, u.appendXtra = function (e, t, n, i, r, a) {
                                var o = this,
                                    s = o.l;
                                return o["xs" + s] += a && (s || o["xs" + s]) ? " " + e : e || "", n || 0 === s || o.plugin ? (o.l++, o.type = o.setRatio ? 2 : 1, o["xs" + o.l] = i || "", s > 0 ? (o.data["xn" + s] = t + n, o.rxp["xn" + s] = r, o["xn" + s] = t, o.plugin || (o.xfirst = new be(o, "xn" + s, t, n, o.xfirst || o, 0, o.n, r, o.pr), o.xfirst.xs0 = 0), o) : (o.data = {
                                    s: t + n
                                }, o.rxp = {}, o.s = t, o.c = n, o.r = r, o)) : (o["xs" + s] += t + (i || ""), o)
                            };
                            var Te = function (e, t) {
                                    t = t || {}, this.p = t.prefix ? Q(e) || e : e, c[e] = c[this.p] = this, this.format = t.formatter || ge(t.defaultValue, t.color, t.collapsible, t.multi), t.parser && (this.parse = t.parser), this.clrs = t.color, this.multi = t.multi, this.keyword = t.keyword, this.dflt = t.defaultValue, this.pr = t.priority || 0
                                },
                                Ee = W._registerComplexSpecialProp = function (e, t, n) {
                                    "object" != typeof t && (t = {
                                        parser: n
                                    });
                                    var i, r, a = e.split(","),
                                        o = t.defaultValue;
                                    for (n = n || [o], i = 0; i < a.length; i++) t.prefix = 0 === i && t.prefix, t.defaultValue = n[i] || o, r = new Te(a[i], t)
                                },
                                Se = W._registerPluginProp = function (e) {
                                    if (!c[e]) {
                                        var t = e.charAt(0).toUpperCase() + e.substr(1) + "Plugin";
                                        Ee(e, {
                                            parser: function (e, n, i, r, a, o, s) {
                                                var u = l.com.greensock.plugins[t];
                                                return u ? (u._cssRegister(), c[i].parse(e, n, i, r, a, o, s)) : (Z("Error: " + t + " js file not loaded."), a)
                                            }
                                        })
                                    }
                                };
                            u = Te.prototype, u.parseComplex = function (e, t, n, i, r, a) {
                                var o, s, l, c, u, h, d = this.keyword;
                                if (this.multi && (D.test(n) || D.test(t) ? (s = t.replace(D, "|").split("|"), l = n.replace(D, "|").split("|")) : d && (s = [t], l = [n])), l) {
                                    for (c = l.length > s.length ? l.length : s.length, o = 0; o < c; o++) t = s[o] = s[o] || this.dflt, n = l[o] = l[o] || this.dflt, d && (u = t.indexOf(d), h = n.indexOf(d), u !== h && (h === -1 ? s[o] = s[o].split(d).join("") : u === -1 && (s[o] += " " + d)));
                                    t = s.join(", "), n = l.join(", ")
                                }
                                return we(e, this.p, t, n, this.clrs, this.dflt, i, this.pr, r, a)
                            }, u.parse = function (e, t, n, i, r, o, s) {
                                return this.parseComplex(e.style, this.format(ee(e, this.p, a, !1, this.dflt)), this.format(t), r, o)
                            }, s.registerSpecialProp = function (e, t, n) {
                                Ee(e, {
                                    parser: function (e, i, r, a, o, s, l) {
                                        var c = new be(e, r, 0, 0, o, 2, r, (!1), n);
                                        return c.plugin = s, c.setRatio = t(e, i, a._tween, r), c
                                    },
                                    priority: n
                                })
                            }, s.useSVGTransformAttr = !0;
                            var Pe, Ce = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
                                Ae = Q("transform"),
                                Le = J + "transform",
                                Re = Q("transformOrigin"),
                                Ie = null !== Q("perspective"),
                                Oe = W.Transform = function () {
                                    this.perspective = parseFloat(s.defaultTransformPerspective) || 0, this.force3D = !(s.defaultForce3D === !1 || !Ie) && (s.defaultForce3D || "auto")
                                },
                                ke = n.SVGElement,
                                De = function (e, t, n) {
                                    var i, r = F.createElementNS("http://www.w3.org/2000/svg", e),
                                        a = /([a-z])([A-Z])/g;
                                    for (i in n) r.setAttributeNS(null, i.replace(a, "$1-$2").toLowerCase(), n[i]);
                                    return t.appendChild(r), r
                                },
                                ze = F.documentElement || {},
                                Be = function () {
                                    var e, t, i, r = v || /Android/i.test(q) && !n.chrome;
                                    return F.createElementNS && !r && (e = De("svg", ze), t = De("rect", e, {
                                        width: 100,
                                        height: 50,
                                        x: 100
                                    }), i = t.getBoundingClientRect().width, t.style[Re] = "50% 50%", t.style[Ae] = "scaleX(0.5)", r = i === t.getBoundingClientRect().width && !(f && Ie), ze.removeChild(e)), r
                                }(),
                                Ne = function (e, t, n, i, r, a) {
                                    var o, l, c, u, h, d, p, f, m, v, g, y, x, b, _ = e._gsTransform,
                                        w = He(e, !0);
                                    _ && (x = _.xOrigin, b = _.yOrigin), (!i || (o = i.split(" ")).length < 2) && (p = e.getBBox(), 0 === p.x && 0 === p.y && p.width + p.height === 0 && (p = {
                                        x: parseFloat(e.hasAttribute("x") ? e.getAttribute("x") : e.hasAttribute("cx") ? e.getAttribute("cx") : 0) || 0,
                                        y: parseFloat(e.hasAttribute("y") ? e.getAttribute("y") : e.hasAttribute("cy") ? e.getAttribute("cy") : 0) || 0,
                                        width: 0,
                                        height: 0
                                    }), t = le(t).split(" "), o = [(t[0].indexOf("%") !== -1 ? parseFloat(t[0]) / 100 * p.width : parseFloat(t[0])) + p.x, (t[1].indexOf("%") !== -1 ? parseFloat(t[1]) / 100 * p.height : parseFloat(t[1])) + p.y]), n.xOrigin = u = parseFloat(o[0]), n.yOrigin = h = parseFloat(o[1]), i && w !== Ge && (d = w[0], p = w[1], f = w[2], m = w[3], v = w[4], g = w[5], y = d * m - p * f, y && (l = u * (m / y) + h * (-f / y) + (f * g - m * v) / y, c = u * (-p / y) + h * (d / y) - (d * g - p * v) / y, u = n.xOrigin = o[0] = l, h = n.yOrigin = o[1] = c)), _ && (a && (n.xOffset = _.xOffset, n.yOffset = _.yOffset, _ = n), r || r !== !1 && s.defaultSmoothOrigin !== !1 ? (l = u - x, c = h - b, _.xOffset += l * w[0] + c * w[2] - l, _.yOffset += l * w[1] + c * w[3] - c) : _.xOffset = _.yOffset = 0), a || e.setAttribute("data-svg-origin", o.join(" "))
                                },
                                Ue = function (e) {
                                    var t, n = G("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                                        i = this.parentNode,
                                        r = this.nextSibling,
                                        a = this.style.cssText;
                                    if (ze.appendChild(n), n.appendChild(this), this.style.display = "block", e) try {
                                        t = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = Ue
                                    } catch (o) {} else this._originalGetBBox && (t = this._originalGetBBox());
                                    return r ? i.insertBefore(this, r) : i.appendChild(this), ze.removeChild(n), this.style.cssText = a, t
                                },
                                je = function (e) {
                                    try {
                                        return e.getBBox()
                                    } catch (t) {
                                        return Ue.call(e, !0)
                                    }
                                },
                                Fe = function (e) {
                                    return !(!ke || !e.getCTM || e.parentNode && !e.ownerSVGElement || !je(e))
                                },
                                Ge = [1, 0, 0, 1, 0, 0],
                                He = function (e, t) {
                                    var n, i, r, a, o, s, l = e._gsTransform || new Oe,
                                        c = 1e5,
                                        u = e.style;
                                    if (Ae ? i = ee(e, Le, null, !0) : e.currentStyle && (i = e.currentStyle.filter.match(O), i = i && 4 === i.length ? [i[0].substr(4), Number(i[2].substr(4)), Number(i[1].substr(4)), i[3].substr(4), l.x || 0, l.y || 0].join(",") : ""), n = !i || "none" === i || "matrix(1, 0, 0, 1, 0, 0)" === i, !Ae || !(s = !K(e) || "none" === K(e).display) && e.parentNode || (s && (a = u.display, u.display = "block"), e.parentNode || (o = 1, ze.appendChild(e)), i = ee(e, Le, null, !0), n = !i || "none" === i || "matrix(1, 0, 0, 1, 0, 0)" === i, a ? u.display = a : s && Ye(u, "display"), o && ze.removeChild(e)), (l.svg || e.getCTM && Fe(e)) && (n && (u[Ae] + "").indexOf("matrix") !== -1 && (i = u[Ae], n = 0), r = e.getAttribute("transform"), n && r && (r = e.transform.baseVal.consolidate().matrix, i = "matrix(" + r.a + "," + r.b + "," + r.c + "," + r.d + "," + r.e + "," + r.f + ")", n = 0)), n) return Ge;
                                    for (r = (i || "").match(x) || [], Me = r.length; --Me > -1;) a = Number(r[Me]), r[Me] = (o = a - (a |= 0)) ? (o * c + (o < 0 ? -.5 : .5) | 0) / c + a : a;
                                    return t && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r
                                },
                                Ve = W.getTransform = function (e, n, i, r) {
                                    if (e._gsTransform && i && !r) return e._gsTransform;
                                    var a, o, l, c, u, h, d = i ? e._gsTransform || new Oe : new Oe,
                                        p = d.scaleX < 0,
                                        f = 2e-5,
                                        m = 1e5,
                                        v = Ie ? parseFloat(ee(e, Re, n, !1, "0 0 0").split(" ")[2]) || d.zOrigin || 0 : 0,
                                        g = parseFloat(s.defaultTransformPerspective) || 0;
                                    if (d.svg = !(!e.getCTM || !Fe(e)), d.svg && (Ne(e, ee(e, Re, n, !1, "50% 50%") + "", d, e.getAttribute("data-svg-origin")), Pe = s.useSVGTransformAttr || Be), a = He(e), a !== Ge) {
                                        if (16 === a.length) {
                                            var y, x, b, _, w, M = a[0],
                                                T = a[1],
                                                E = a[2],
                                                S = a[3],
                                                P = a[4],
                                                C = a[5],
                                                A = a[6],
                                                L = a[7],
                                                R = a[8],
                                                I = a[9],
                                                O = a[10],
                                                k = a[12],
                                                D = a[13],
                                                z = a[14],
                                                B = a[11],
                                                U = Math.atan2(A, O);
                                            d.zOrigin && (z = -d.zOrigin, k = R * z - a[12], D = I * z - a[13], z = O * z + d.zOrigin - a[14]), d.rotationX = U * N, U && (_ = Math.cos(-U), w = Math.sin(-U), y = P * _ + R * w, x = C * _ + I * w, b = A * _ + O * w, R = P * -w + R * _, I = C * -w + I * _, O = A * -w + O * _, B = L * -w + B * _, P = y, C = x, A = b), U = Math.atan2(-E, O), d.rotationY = U * N, U && (_ = Math.cos(-U), w = Math.sin(-U), y = M * _ - R * w, x = T * _ - I * w, b = E * _ - O * w, I = T * w + I * _, O = E * w + O * _, B = S * w + B * _, M = y, T = x, E = b), U = Math.atan2(T, M), d.rotation = U * N, U && (_ = Math.cos(U), w = Math.sin(U), y = M * _ + T * w, x = P * _ + C * w, b = R * _ + I * w, T = T * _ - M * w, C = C * _ - P * w, I = I * _ - R * w, M = y, P = x, R = b), d.rotationX && Math.abs(d.rotationX) + Math.abs(d.rotation) > 359.9 && (d.rotationX = d.rotation = 0, d.rotationY = 180 - d.rotationY), U = Math.atan2(P, C), d.scaleX = (Math.sqrt(M * M + T * T + E * E) * m + .5 | 0) / m, d.scaleY = (Math.sqrt(C * C + A * A) * m + .5 | 0) / m, d.scaleZ = (Math.sqrt(R * R + I * I + O * O) * m + .5 | 0) / m, M /= d.scaleX, P /= d.scaleY, T /= d.scaleX, C /= d.scaleY, Math.abs(U) > f ? (d.skewX = U * N, P = 0, "simple" !== d.skewType && (d.scaleY *= 1 / Math.cos(U))) : d.skewX = 0, d.perspective = B ? 1 / (B < 0 ? -B : B) : 0, d.x = k, d.y = D, d.z = z, d.svg && (d.x -= d.xOrigin - (d.xOrigin * M - d.yOrigin * P), d.y -= d.yOrigin - (d.yOrigin * T - d.xOrigin * C))
                                        } else if (!Ie || r || !a.length || d.x !== a[4] || d.y !== a[5] || !d.rotationX && !d.rotationY) {
                                            var j = a.length >= 6,
                                                F = j ? a[0] : 1,
                                                G = a[1] || 0,
                                                H = a[2] || 0,
                                                V = j ? a[3] : 1;
                                            d.x = a[4] || 0, d.y = a[5] || 0, l = Math.sqrt(F * F + G * G), c = Math.sqrt(V * V + H * H), u = F || G ? Math.atan2(G, F) * N : d.rotation || 0, h = H || V ? Math.atan2(H, V) * N + u : d.skewX || 0, d.scaleX = l, d.scaleY = c, d.rotation = u, d.skewX = h, Ie && (d.rotationX = d.rotationY = d.z = 0, d.perspective = g, d.scaleZ = 1), d.svg && (d.x -= d.xOrigin - (d.xOrigin * F + d.yOrigin * H), d.y -= d.yOrigin - (d.xOrigin * G + d.yOrigin * V))
                                        }
                                        Math.abs(d.skewX) > 90 && Math.abs(d.skewX) < 270 && (p ? (d.scaleX *= -1, d.skewX += d.rotation <= 0 ? 180 : -180, d.rotation += d.rotation <= 0 ? 180 : -180) : (d.scaleY *= -1, d.skewX += d.skewX <= 0 ? 180 : -180)), d.zOrigin = v;
                                        for (o in d) d[o] < f && d[o] > -f && (d[o] = 0)
                                    }
                                    return i && (e._gsTransform = d, d.svg && (Pe && e.style[Ae] ? t.delayedCall(.001, function () {
                                        Ye(e.style, Ae)
                                    }) : !Pe && e.getAttribute("transform") && t.delayedCall(.001, function () {
                                        e.removeAttribute("transform")
                                    }))), d
                                },
                                We = function (e) {
                                    var t, n, i = this.data,
                                        r = -i.rotation * B,
                                        a = r + i.skewX * B,
                                        o = 1e5,
                                        s = (Math.cos(r) * i.scaleX * o | 0) / o,
                                        l = (Math.sin(r) * i.scaleX * o | 0) / o,
                                        c = (Math.sin(a) * -i.scaleY * o | 0) / o,
                                        u = (Math.cos(a) * i.scaleY * o | 0) / o,
                                        h = this.t.style,
                                        d = this.t.currentStyle;
                                    if (d) {
                                        n = l, l = -c, c = -n, t = d.filter, h.filter = "";
                                        var p, f, m = this.t.offsetWidth,
                                            g = this.t.offsetHeight,
                                            y = "absolute" !== d.position,
                                            x = "progid:DXImageTransform.Microsoft.Matrix(M11=" + s + ", M12=" + l + ", M21=" + c + ", M22=" + u,
                                            b = i.x + m * i.xPercent / 100,
                                            _ = i.y + g * i.yPercent / 100;
                                        if (null != i.ox && (p = (i.oxp ? m * i.ox * .01 : i.ox) - m / 2, f = (i.oyp ? g * i.oy * .01 : i.oy) - g / 2, b += p - (p * s + f * l), _ += f - (p * c + f * u)), y ? (p = m / 2, f = g / 2, x += ", Dx=" + (p - (p * s + f * l) + b) + ", Dy=" + (f - (p * c + f * u) + _) + ")") : x += ", sizingMethod='auto expand')", t.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1 ? h.filter = t.replace(k, x) : h.filter = x + " " + t, 0 !== e && 1 !== e || 1 === s && 0 === l && 0 === c && 1 === u && (y && x.indexOf("Dx=0, Dy=0") === -1 || T.test(t) && 100 !== parseFloat(RegExp.$1) || t.indexOf(t.indexOf("Alpha")) === -1 && h.removeAttribute("filter")), !y) {
                                            var w, E, S, P = v < 8 ? 1 : -1;
                                            for (p = i.ieOffsetX || 0, f = i.ieOffsetY || 0, i.ieOffsetX = Math.round((m - ((s < 0 ? -s : s) * m + (l < 0 ? -l : l) * g)) / 2 + b), i.ieOffsetY = Math.round((g - ((u < 0 ? -u : u) * g + (c < 0 ? -c : c) * m)) / 2 + _), Me = 0; Me < 4; Me++) E = oe[Me], w = d[E], n = w.indexOf("px") !== -1 ? parseFloat(w) : te(this.t, E, parseFloat(w), w.replace(M, "")) || 0, S = n !== i[E] ? Me < 2 ? -i.ieOffsetX : -i.ieOffsetY : Me < 2 ? p - i.ieOffsetX : f - i.ieOffsetY, h[E] = (i[E] = Math.round(n - S * (0 === Me || 2 === Me ? 1 : P))) + "px"
                                        }
                                    }
                                },
                                qe = W.set3DTransformRatio = W.setTransformRatio = function (e) {
                                    var t, n, i, r, a, o, s, l, c, u, h, d, p, m, v, g, y, x, b, _, w, M, T, E = this.data,
                                        S = this.t.style,
                                        P = E.rotation,
                                        C = E.rotationX,
                                        A = E.rotationY,
                                        L = E.scaleX,
                                        R = E.scaleY,
                                        I = E.scaleZ,
                                        O = E.x,
                                        k = E.y,
                                        D = E.z,
                                        z = E.svg,
                                        N = E.perspective,
                                        U = E.force3D,
                                        j = E.skewY,
                                        F = E.skewX;
                                    if (j && (F += j, P += j), ((1 === e || 0 === e) && "auto" === U && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !U) && !D && !N && !A && !C && 1 === I || Pe && z || !Ie) return void(P || F || z ? (P *= B, M = F * B, T = 1e5, n = Math.cos(P) * L, a = Math.sin(P) * L, i = Math.sin(P - M) * -R, o = Math.cos(P - M) * R, M && "simple" === E.skewType && (t = Math.tan(M - j * B), t = Math.sqrt(1 + t * t), i *= t, o *= t, j && (t = Math.tan(j * B), t = Math.sqrt(1 + t * t), n *= t, a *= t)), z && (O += E.xOrigin - (E.xOrigin * n + E.yOrigin * i) + E.xOffset, k += E.yOrigin - (E.xOrigin * a + E.yOrigin * o) + E.yOffset, Pe && (E.xPercent || E.yPercent) && (v = this.t.getBBox(), O += .01 * E.xPercent * v.width, k += .01 * E.yPercent * v.height), v = 1e-6, O < v && O > -v && (O = 0), k < v && k > -v && (k = 0)), b = (n * T | 0) / T + "," + (a * T | 0) / T + "," + (i * T | 0) / T + "," + (o * T | 0) / T + "," + O + "," + k + ")", z && Pe ? this.t.setAttribute("transform", "matrix(" + b) : S[Ae] = (E.xPercent || E.yPercent ? "translate(" + E.xPercent + "%," + E.yPercent + "%) matrix(" : "matrix(") + b) : S[Ae] = (E.xPercent || E.yPercent ? "translate(" + E.xPercent + "%," + E.yPercent + "%) matrix(" : "matrix(") + L + ",0,0," + R + "," + O + "," + k + ")");
                                    if (f && (v = 1e-4, L < v && L > -v && (L = I = 2e-5), R < v && R > -v && (R = I = 2e-5), !N || E.z || E.rotationX || E.rotationY || (N = 0)), P || F) P *= B, g = n = Math.cos(P), y = a = Math.sin(P), F && (P -= F * B, g = Math.cos(P), y = Math.sin(P), "simple" === E.skewType && (t = Math.tan((F - j) * B), t = Math.sqrt(1 + t * t), g *= t, y *= t, E.skewY && (t = Math.tan(j * B), t = Math.sqrt(1 + t * t), n *= t, a *= t))), i = -y, o = g;
                                    else {
                                        if (!(A || C || 1 !== I || N || z)) return void(S[Ae] = (E.xPercent || E.yPercent ? "translate(" + E.xPercent + "%," + E.yPercent + "%) translate3d(" : "translate3d(") + O + "px," + k + "px," + D + "px)" + (1 !== L || 1 !== R ? " scale(" + L + "," + R + ")" : ""));
                                        n = o = 1, i = a = 0
                                    }
                                    u = 1, r = s = l = c = h = d = 0, p = N ? -1 / N : 0, m = E.zOrigin, v = 1e-6, _ = ",", w = "0", P = A * B, P && (g = Math.cos(P), y = Math.sin(P), l = -y, h = p * -y, r = n * y, s = a * y, u = g, p *= g, n *= g, a *= g), P = C * B, P && (g = Math.cos(P), y = Math.sin(P), t = i * g + r * y, x = o * g + s * y, c = u * y, d = p * y, r = i * -y + r * g, s = o * -y + s * g, u *= g, p *= g, i = t, o = x), 1 !== I && (r *= I, s *= I, u *= I, p *= I), 1 !== R && (i *= R, o *= R, c *= R, d *= R), 1 !== L && (n *= L, a *= L, l *= L, h *= L), (m || z) && (m && (O += r * -m, k += s * -m, D += u * -m + m), z && (O += E.xOrigin - (E.xOrigin * n + E.yOrigin * i) + E.xOffset, k += E.yOrigin - (E.xOrigin * a + E.yOrigin * o) + E.yOffset), O < v && O > -v && (O = w), k < v && k > -v && (k = w), D < v && D > -v && (D = 0)), b = E.xPercent || E.yPercent ? "translate(" + E.xPercent + "%," + E.yPercent + "%) matrix3d(" : "matrix3d(", b += (n < v && n > -v ? w : n) + _ + (a < v && a > -v ? w : a) + _ + (l < v && l > -v ? w : l), b += _ + (h < v && h > -v ? w : h) + _ + (i < v && i > -v ? w : i) + _ + (o < v && o > -v ? w : o), C || A || 1 !== I ? (b += _ + (c < v && c > -v ? w : c) + _ + (d < v && d > -v ? w : d) + _ + (r < v && r > -v ? w : r), b += _ + (s < v && s > -v ? w : s) + _ + (u < v && u > -v ? w : u) + _ + (p < v && p > -v ? w : p) + _) : b += ",0,0,0,0,1,0,", b += O + _ + k + _ + D + _ + (N ? 1 + -D / N : 1) + ")", S[Ae] = b
                                };
                            u = Oe.prototype, u.x = u.y = u.z = u.skewX = u.skewY = u.rotation = u.rotationX = u.rotationY = u.zOrigin = u.xPercent = u.yPercent = u.xOffset = u.yOffset = 0, u.scaleX = u.scaleY = u.scaleZ = 1, Ee("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
                                parser: function (e, t, n, i, r, o, l) {
                                    if (i._lastParsedTransform === l) return r;
                                    i._lastParsedTransform = l;
                                    var c, u = l.scale && "function" == typeof l.scale ? l.scale : 0;
                                    "function" == typeof l[n] && (c = l[n], l[n] = t), u && (l.scale = u(y, e));
                                    var h, d, p, f, m, v, x, b, _, w = e._gsTransform,
                                        M = e.style,
                                        T = 1e-6,
                                        E = Ce.length,
                                        S = l,
                                        P = {},
                                        C = "transformOrigin",
                                        A = Ve(e, a, !0, S.parseTransform),
                                        L = S.transform && ("function" == typeof S.transform ? S.transform(y, g) : S.transform);
                                    if (A.skewType = S.skewType || A.skewType || s.defaultSkewType, i._transform = A, L && "string" == typeof L && Ae) d = H.style, d[Ae] = L, d.display = "block", d.position = "absolute", L.indexOf("%") !== -1 && (d.width = ee(e, "width"), d.height = ee(e, "height")), F.body.appendChild(H), h = Ve(H, null, !1), "simple" === A.skewType && (h.scaleY *= Math.cos(h.skewX * B)), A.svg && (v = A.xOrigin, x = A.yOrigin, h.x -= A.xOffset, h.y -= A.yOffset, (S.transformOrigin || S.svgOrigin) && (L = {}, Ne(e, le(S.transformOrigin), L, S.svgOrigin, S.smoothOrigin, !0), v = L.xOrigin, x = L.yOrigin, h.x -= L.xOffset - A.xOffset, h.y -= L.yOffset - A.yOffset), (v || x) && (b = He(H, !0), h.x -= v - (v * b[0] + x * b[2]), h.y -= x - (v * b[1] + x * b[3]))), F.body.removeChild(H), h.perspective || (h.perspective = A.perspective), null != S.xPercent && (h.xPercent = ue(S.xPercent, A.xPercent)), null != S.yPercent && (h.yPercent = ue(S.yPercent, A.yPercent));
                                    else if ("object" == typeof S) {
                                        if (h = {
                                                scaleX: ue(null != S.scaleX ? S.scaleX : S.scale, A.scaleX),
                                                scaleY: ue(null != S.scaleY ? S.scaleY : S.scale, A.scaleY),
                                                scaleZ: ue(S.scaleZ, A.scaleZ),
                                                x: ue(S.x, A.x),
                                                y: ue(S.y, A.y),
                                                z: ue(S.z, A.z),
                                                xPercent: ue(S.xPercent, A.xPercent),
                                                yPercent: ue(S.yPercent, A.yPercent),
                                                perspective: ue(S.transformPerspective, A.perspective)
                                            }, m = S.directionalRotation, null != m)
                                            if ("object" == typeof m)
                                                for (d in m) S[d] = m[d];
                                            else S.rotation = m;
                                        "string" == typeof S.x && S.x.indexOf("%") !== -1 && (h.x = 0, h.xPercent = ue(S.x, A.xPercent)), "string" == typeof S.y && S.y.indexOf("%") !== -1 && (h.y = 0, h.yPercent = ue(S.y, A.yPercent)), h.rotation = he("rotation" in S ? S.rotation : "shortRotation" in S ? S.shortRotation + "_short" : "rotationZ" in S ? S.rotationZ : A.rotation, A.rotation, "rotation", P), Ie && (h.rotationX = he("rotationX" in S ? S.rotationX : "shortRotationX" in S ? S.shortRotationX + "_short" : A.rotationX || 0, A.rotationX, "rotationX", P), h.rotationY = he("rotationY" in S ? S.rotationY : "shortRotationY" in S ? S.shortRotationY + "_short" : A.rotationY || 0, A.rotationY, "rotationY", P)), h.skewX = he(S.skewX, A.skewX), h.skewY = he(S.skewY, A.skewY)
                                    }
                                    for (Ie && null != S.force3D && (A.force3D = S.force3D, f = !0), p = A.force3D || A.z || A.rotationX || A.rotationY || h.z || h.rotationX || h.rotationY || h.perspective, p || null == S.scale || (h.scaleZ = 1); --E > -1;) _ = Ce[E], L = h[_] - A[_], (L > T || L < -T || null != S[_] || null != U[_]) && (f = !0, r = new be(A, _, A[_], L, r), _ in P && (r.e = P[_]), r.xs0 = 0, r.plugin = o, i._overwriteProps.push(r.n));
                                    return L = S.transformOrigin, A.svg && (L || S.svgOrigin) && (v = A.xOffset, x = A.yOffset, Ne(e, le(L), h, S.svgOrigin, S.smoothOrigin), r = _e(A, "xOrigin", (w ? A : h).xOrigin, h.xOrigin, r, C), r = _e(A, "yOrigin", (w ? A : h).yOrigin, h.yOrigin, r, C), v === A.xOffset && x === A.yOffset || (r = _e(A, "xOffset", w ? v : A.xOffset, A.xOffset, r, C), r = _e(A, "yOffset", w ? x : A.yOffset, A.yOffset, r, C)), L = "0px 0px"), (L || Ie && p && A.zOrigin) && (Ae ? (f = !0, _ = Re, L = (L || ee(e, _, a, !1, "50% 50%")) + "", r = new be(M, _, 0, 0, r, (-1), C), r.b = M[_], r.plugin = o, Ie ? (d = A.zOrigin, L = L.split(" "), A.zOrigin = (L.length > 2 && (0 === d || "0px" !== L[2]) ? parseFloat(L[2]) : d) || 0, r.xs0 = r.e = L[0] + " " + (L[1] || "50%") + " 0px", r = new be(A, "zOrigin", 0, 0, r, (-1), r.n), r.b = d, r.xs0 = r.e = A.zOrigin) : r.xs0 = r.e = L) : le(L + "", A)), f && (i._transformType = A.svg && Pe || !p && 3 !== this._transformType ? 2 : 3), c && (l[n] = c), u && (l.scale = u), r
                                },
                                prefix: !0
                            }), Ee("boxShadow", {
                                defaultValue: "0px 0px 0px 0px #999",
                                prefix: !0,
                                color: !0,
                                multi: !0,
                                keyword: "inset"
                            }), Ee("borderRadius", {
                                defaultValue: "0px",
                                parser: function (e, t, n, i, o, s) {
                                    t = this.format(t);
                                    var l, c, u, h, d, p, f, m, v, g, y, x, b, _, w, M, T = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                                        E = e.style;
                                    for (v = parseFloat(e.offsetWidth), g = parseFloat(e.offsetHeight), l = t.split(" "), c = 0; c < T.length; c++) this.p.indexOf("border") && (T[c] = Q(T[c])), d = h = ee(e, T[c], a, !1, "0px"), d.indexOf(" ") !== -1 && (h = d.split(" "), d = h[0], h = h[1]), p = u = l[c], f = parseFloat(d), x = d.substr((f + "").length), b = "=" === p.charAt(1), b ? (m = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), m *= parseFloat(p), y = p.substr((m + "").length - (m < 0 ? 1 : 0)) || "") : (m = parseFloat(p), y = p.substr((m + "").length)), "" === y && (y = r[n] || x), y !== x && (_ = te(e, "borderLeft", f, x), w = te(e, "borderTop", f, x), "%" === y ? (d = _ / v * 100 + "%", h = w / g * 100 + "%") : "em" === y ? (M = te(e, "borderLeft", 1, "em"), d = _ / M + "em", h = w / M + "em") : (d = _ + "px", h = w + "px"), b && (p = parseFloat(d) + m + y, u = parseFloat(h) + m + y)), o = we(E, T[c], d + " " + h, p + " " + u, !1, "0px", o);
                                    return o
                                },
                                prefix: !0,
                                formatter: ge("0px 0px 0px 0px", !1, !0)
                            }), Ee("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
                                defaultValue: "0px",
                                parser: function (e, t, n, i, r, o) {
                                    return we(e.style, n, this.format(ee(e, n, a, !1, "0px 0px")), this.format(t), !1, "0px", r)
                                },
                                prefix: !0,
                                formatter: ge("0px 0px", !1, !0)
                            }), Ee("backgroundPosition", {
                                defaultValue: "0 0",
                                parser: function (e, t, n, i, r, o) {
                                    var s, l, c, u, h, d, p = "background-position",
                                        f = a || K(e, null),
                                        m = this.format((f ? v ? f.getPropertyValue(p + "-x") + " " + f.getPropertyValue(p + "-y") : f.getPropertyValue(p) : e.currentStyle.backgroundPositionX + " " + e.currentStyle.backgroundPositionY) || "0 0"),
                                        g = this.format(t);
                                    if (m.indexOf("%") !== -1 != (g.indexOf("%") !== -1) && g.split(",").length < 2 && (d = ee(e, "backgroundImage").replace(L, ""), d && "none" !== d)) {
                                        for (s = m.split(" "), l = g.split(" "), V.setAttribute("src", d), c = 2; --c > -1;) m = s[c], u = m.indexOf("%") !== -1, u !== (l[c].indexOf("%") !== -1) && (h = 0 === c ? e.offsetWidth - V.width : e.offsetHeight - V.height, s[c] = u ? parseFloat(m) / 100 * h + "px" : parseFloat(m) / h * 100 + "%");
                                        m = s.join(" ")
                                    }
                                    return this.parseComplex(e.style, m, g, r, o)
                                },
                                formatter: le
                            }), Ee("backgroundSize", {
                                defaultValue: "0 0",
                                formatter: function (e) {
                                    return e += "", "co" === e.substr(0, 2) ? e : le(e.indexOf(" ") === -1 ? e + " " + e : e)
                                }
                            }), Ee("perspective", {
                                defaultValue: "0px",
                                prefix: !0
                            }), Ee("perspectiveOrigin", {
                                defaultValue: "50% 50%",
                                prefix: !0
                            }), Ee("transformStyle", {
                                prefix: !0
                            }), Ee("backfaceVisibility", {
                                prefix: !0
                            }), Ee("userSelect", {
                                prefix: !0
                            }), Ee("margin", {
                                parser: ye("marginTop,marginRight,marginBottom,marginLeft")
                            }), Ee("padding", {
                                parser: ye("paddingTop,paddingRight,paddingBottom,paddingLeft")
                            }), Ee("clip", {
                                defaultValue: "rect(0px,0px,0px,0px)",
                                parser: function (e, t, n, i, r, o) {
                                    var s, l, c;
                                    return v < 9 ? (l = e.currentStyle, c = v < 8 ? " " : ",", s = "rect(" + l.clipTop + c + l.clipRight + c + l.clipBottom + c + l.clipLeft + ")", t = this.format(t).split(",").join(c)) : (s = this.format(ee(e, this.p, a, !1, this.dflt)), t = this.format(t)), this.parseComplex(e.style, s, t, r, o)
                                }
                            }), Ee("textShadow", {
                                defaultValue: "0px 0px 0px #999",
                                color: !0,
                                multi: !0
                            }), Ee("autoRound,strictUnits", {
                                parser: function (e, t, n, i, r) {
                                    return r
                                }
                            }), Ee("border", {
                                defaultValue: "0px solid #000",
                                parser: function (e, t, n, i, r, o) {
                                    var s = ee(e, "borderTopWidth", a, !1, "0px"),
                                        l = this.format(t).split(" "),
                                        c = l[0].replace(M, "");
                                    return "px" !== c && (s = parseFloat(s) / te(e, "borderTopWidth", 1, c) + c), this.parseComplex(e.style, this.format(s + " " + ee(e, "borderTopStyle", a, !1, "solid") + " " + ee(e, "borderTopColor", a, !1, "#000")), l.join(" "), r, o)
                                },
                                color: !0,
                                formatter: function (e) {
                                    var t = e.split(" ");
                                    return t[0] + " " + (t[1] || "solid") + " " + (e.match(ve) || ["#000"])[0]
                                }
                            }), Ee("borderWidth", {
                                parser: ye("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
                            }), Ee("float,cssFloat,styleFloat", {
                                parser: function (e, t, n, i, r, a) {
                                    var o = e.style,
                                        s = "cssFloat" in o ? "cssFloat" : "styleFloat";
                                    return new be(o, s, 0, 0, r, (-1), n, (!1), 0, o[s], t)
                                }
                            });
                            var Xe = function (e) {
                                var t, n = this.t,
                                    i = n.filter || ee(this.data, "filter") || "",
                                    r = this.s + this.c * e | 0;
                                100 === r && (i.indexOf("atrix(") === -1 && i.indexOf("radient(") === -1 && i.indexOf("oader(") === -1 ? (n.removeAttribute("filter"), t = !ee(this.data, "filter")) : (n.filter = i.replace(S, ""), t = !0)), t || (this.xn1 && (n.filter = i = i || "alpha(opacity=" + r + ")"), i.indexOf("pacity") === -1 ? 0 === r && this.xn1 || (n.filter = i + " alpha(opacity=" + r + ")") : n.filter = i.replace(T, "opacity=" + r))
                            };
                            Ee("opacity,alpha,autoAlpha", {
                                defaultValue: "1",
                                parser: function (e, t, n, i, r, o) {
                                    var s = parseFloat(ee(e, "opacity", a, !1, "1")),
                                        l = e.style,
                                        c = "autoAlpha" === n;
                                    return "string" == typeof t && "=" === t.charAt(1) && (t = ("-" === t.charAt(0) ? -1 : 1) * parseFloat(t.substr(2)) + s), c && 1 === s && "hidden" === ee(e, "visibility", a) && 0 !== t && (s = 0), X ? r = new be(l, "opacity", s, t - s, r) : (r = new be(l, "opacity", 100 * s, 100 * (t - s), r), r.xn1 = c ? 1 : 0, l.zoom = 1, r.type = 2, r.b = "alpha(opacity=" + r.s + ")", r.e = "alpha(opacity=" + (r.s + r.c) + ")", r.data = e, r.plugin = o, r.setRatio = Xe), c && (r = new be(l, "visibility", 0, 0, r, (-1), null, (!1), 0, 0 !== s ? "inherit" : "hidden", 0 === t ? "hidden" : "inherit"), r.xs0 = "inherit", i._overwriteProps.push(r.n), i._overwriteProps.push(n)), r
                                }
                            });
                            var Ye = function (e, t) {
                                    t && (e.removeProperty ? ("ms" !== t.substr(0, 2) && "webkit" !== t.substr(0, 6) || (t = "-" + t), e.removeProperty(t.replace(C, "-$1").toLowerCase())) : e.removeAttribute(t))
                                },
                                Ze = function (e) {
                                    if (this.t._gsClassPT = this, 1 === e || 0 === e) {
                                        this.t.setAttribute("class", 0 === e ? this.b : this.e);
                                        for (var t = this.data, n = this.t.style; t;) t.v ? n[t.p] = t.v : Ye(n, t.p), t = t._next;
                                        1 === e && this.t._gsClassPT === this && (this.t._gsClassPT = null)
                                    } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
                                };
                            Ee("className", {
                                parser: function (e, t, n, r, o, s, l) {
                                    var c, u, h, d, p, f = e.getAttribute("class") || "",
                                        m = e.style.cssText;
                                    if (o = r._classNamePT = new be(e, n, 0, 0, o, 2), o.setRatio = Ze, o.pr = -11, i = !0, o.b = f, u = ie(e, a), h = e._gsClassPT) {
                                        for (d = {}, p = h.data; p;) d[p.p] = 1, p = p._next;
                                        h.setRatio(1)
                                    }
                                    return e._gsClassPT = o, o.e = "=" !== t.charAt(1) ? t : f.replace(new RegExp("(?:\\s|^)" + t.substr(2) + "(?![\\w-])"), "") + ("+" === t.charAt(0) ? " " + t.substr(2) : ""), e.setAttribute("class", o.e), c = re(e, u, ie(e), l, d), e.setAttribute("class", f), o.data = c.firstMPT, e.style.cssText = m, o = o.xfirst = r.parse(e, c.difs, o, s)
                                }
                            });
                            var Je = function (e) {
                                if ((1 === e || 0 === e) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                                    var t, n, i, r, a, o = this.t.style,
                                        s = c.transform.parse;
                                    if ("all" === this.e) o.cssText = "", r = !0;
                                    else
                                        for (t = this.e.split(" ").join("").split(","), i = t.length; --i > -1;) n = t[i], c[n] && (c[n].parse === s ? r = !0 : n = "transformOrigin" === n ? Re : c[n].p), Ye(o, n);
                                    r && (Ye(o, Ae), a = this.t._gsTransform, a && (a.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform))
                                }
                            };
                            for (Ee("clearProps", {
                                    parser: function (e, t, n, r, a) {
                                        return a = new be(e, n, 0, 0, a, 2), a.setRatio = Je, a.e = t, a.pr = -10, a.data = r._tween, i = !0, a
                                    }
                                }), u = "bezier,throwProps,physicsProps,physics2D".split(","), Me = u.length; Me--;) Se(u[Me]);
                            u = s.prototype, u._firstPT = u._lastParsedTransform = u._transform = null, u._onInitTween = function (e, t, n, l) {
                                if (!e.nodeType) return !1;
                                this._target = g = e, this._tween = n, this._vars = t, y = l, h = t.autoRound, i = !1, r = t.suffixMap || s.suffixMap, a = K(e, ""), o = this._overwriteProps;
                                var u, f, v, x, b, _, w, M, T, S = e.style;
                                if (d && "" === S.zIndex && (u = ee(e, "zIndex", a), "auto" !== u && "" !== u || this._addLazySet(S, "zIndex", 0)), "string" == typeof t && (x = S.cssText, u = ie(e, a), S.cssText = x + ";" + t, u = re(e, u, ie(e)).difs, !X && E.test(t) && (u.opacity = parseFloat(RegExp.$1)), t = u, S.cssText = x), t.className ? this._firstPT = f = c.className.parse(e, t.className, "className", this, null, null, t) : this._firstPT = f = this.parse(e, t, null), this._transformType) {
                                    for (T = 3 === this._transformType, Ae ? p && (d = !0, "" === S.zIndex && (w = ee(e, "zIndex", a), "auto" !== w && "" !== w || this._addLazySet(S, "zIndex", 0)), m && this._addLazySet(S, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (T ? "visible" : "hidden"))) : S.zoom = 1, v = f; v && v._next;) v = v._next;
                                    M = new be(e, "transform", 0, 0, null, 2), this._linkCSSP(M, null, v), M.setRatio = Ae ? qe : We, M.data = this._transform || Ve(e, a, !0), M.tween = n, M.pr = -1, o.pop()
                                }
                                if (i) {
                                    for (; f;) {
                                        for (_ = f._next, v = x; v && v.pr > f.pr;) v = v._next;
                                        (f._prev = v ? v._prev : b) ? f._prev._next = f: x = f, (f._next = v) ? v._prev = f : b = f, f = _
                                    }
                                    this._firstPT = x
                                }
                                return !0
                            }, u.parse = function (e, t, n, i) {
                                var o, s, l, u, d, p, f, m, v, x, b = e.style;
                                for (o in t) {
                                    if (p = t[o], "function" == typeof p && (p = p(y, g)), s = c[o]) n = s.parse(e, p, o, this, n, i, t);
                                    else {
                                        if ("--" === o.substr(0, 2)) {
                                            this._tween._propLookup[o] = this._addTween.call(this._tween, e.style, "setProperty", K(e).getPropertyValue(o) + "", p + "", o, !1, o);
                                            continue
                                        }
                                        d = ee(e, o, a) + "", v = "string" == typeof p, "color" === o || "fill" === o || "stroke" === o || o.indexOf("Color") !== -1 || v && P.test(p) ? (v || (p = fe(p), p = (p.length > 3 ? "rgba(" : "rgb(") + p.join(",") + ")"), n = we(b, o, d, p, !0, "transparent", n, 0, i)) : v && z.test(p) ? n = we(b, o, d, p, !0, null, n, 0, i) : (l = parseFloat(d), f = l || 0 === l ? d.substr((l + "").length) : "", "" !== d && "auto" !== d || ("width" === o || "height" === o ? (l = se(e, o, a), f = "px") : "left" === o || "top" === o ? (l = ne(e, o, a), f = "px") : (l = "opacity" !== o ? 0 : 1, f = "")), x = v && "=" === p.charAt(1), x ? (u = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), u *= parseFloat(p), m = p.replace(M, "")) : (u = parseFloat(p), m = v ? p.replace(M, "") : ""), "" === m && (m = o in r ? r[o] : f), p = u || 0 === u ? (x ? u + l : u) + m : t[o], f !== m && ("" === m && "lineHeight" !== o || (u || 0 === u) && l && (l = te(e, o, l, f), "%" === m ? (l /= te(e, o, 100, "%") / 100, t.strictUnits !== !0 && (d = l + "%")) : "em" === m || "rem" === m || "vw" === m || "vh" === m ? l /= te(e, o, 1, m) : "px" !== m && (u = te(e, o, u, m), m = "px"), x && (u || 0 === u) && (p = u + l + m))), x && (u += l), !l && 0 !== l || !u && 0 !== u ? void 0 !== b[o] && (p || p + "" != "NaN" && null != p) ? (n = new be(b, o, u || l || 0, 0, n, (-1), o, (!1), 0, d, p), n.xs0 = "none" !== p || "display" !== o && o.indexOf("Style") === -1 ? p : d) : Z("invalid " + o + " tween value: " + t[o]) : (n = new be(b, o, l, u - l, n, 0, o, h !== !1 && ("px" === m || "zIndex" === o), 0, d, p), n.xs0 = m))
                                    }
                                    i && n && !n.plugin && (n.plugin = i)
                                }
                                return n
                            }, u.setRatio = function (e) {
                                var t, n, i, r = this._firstPT,
                                    a = 1e-6;
                                if (1 !== e || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                                    if (e || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -1e-6)
                                        for (; r;) {
                                            if (t = r.c * e + r.s, r.r ? t = r.r(t) : t < a && t > -a && (t = 0), r.type)
                                                if (1 === r.type)
                                                    if (i = r.l, 2 === i) r.t[r.p] = r.xs0 + t + r.xs1 + r.xn1 + r.xs2;
                                                    else if (3 === i) r.t[r.p] = r.xs0 + t + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3;
                                            else if (4 === i) r.t[r.p] = r.xs0 + t + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4;
                                            else if (5 === i) r.t[r.p] = r.xs0 + t + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5;
                                            else {
                                                for (n = r.xs0 + t + r.xs1, i = 1; i < r.l; i++) n += r["xn" + i] + r["xs" + (i + 1)];
                                                r.t[r.p] = n
                                            } else r.type === -1 ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(e);
                                            else r.t[r.p] = t + r.xs0;
                                            r = r._next
                                        } else
                                            for (; r;) 2 !== r.type ? r.t[r.p] = r.b : r.setRatio(e), r = r._next;
                                    else
                                        for (; r;) {
                                            if (2 !== r.type)
                                                if (r.r && r.type !== -1)
                                                    if (t = r.r(r.s + r.c), r.type) {
                                                        if (1 === r.type) {
                                                            for (i = r.l, n = r.xs0 + t + r.xs1, i = 1; i < r.l; i++) n += r["xn" + i] + r["xs" + (i + 1)];
                                                            r.t[r.p] = n
                                                        }
                                                    } else r.t[r.p] = t + r.xs0;
                                            else r.t[r.p] = r.e;
                                            else r.setRatio(e);
                                            r = r._next
                                        }
                            }, u._enableTransforms = function (e) {
                                this._transform = this._transform || Ve(this._target, a, !0), this._transformType = this._transform.svg && Pe || !e && 3 !== this._transformType ? 2 : 3
                            };
                            var $e = function (e) {
                                this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
                            };
                            u._addLazySet = function (e, t, n) {
                                var i = this._firstPT = new be(e, t, 0, 0, this._firstPT, 2);
                                i.e = n, i.setRatio = $e, i.data = this
                            }, u._linkCSSP = function (e, t, n, i) {
                                return e && (t && (t._prev = e), e._next && (e._next._prev = e._prev), e._prev ? e._prev._next = e._next : this._firstPT === e && (this._firstPT = e._next, i = !0), n ? n._next = e : i || null !== this._firstPT || (this._firstPT = e), e._next = t, e._prev = n), e
                            }, u._mod = function (e) {
                                for (var t = this._firstPT; t;) "function" == typeof e[t.p] && (t.r = e[t.p]), t = t._next
                            }, u._kill = function (t) {
                                var n, i, r, a = t;
                                if (t.autoAlpha || t.alpha) {
                                    a = {};
                                    for (i in t) a[i] = t[i];
                                    a.opacity = 1, a.autoAlpha && (a.visibility = 1)
                                }
                                for (t.className && (n = this._classNamePT) && (r = n.xfirst, r && r._prev ? this._linkCSSP(r._prev, n._next, r._prev._prev) : r === this._firstPT && (this._firstPT = n._next), n._next && this._linkCSSP(n._next, n._next._next, r._prev), this._classNamePT = null), n = this._firstPT; n;) n.plugin && n.plugin !== i && n.plugin._kill && (n.plugin._kill(t), i = n.plugin), n = n._next;
                                return e.prototype._kill.call(this, a)
                            };
                            var Qe = function (e, t, n) {
                                var i, r, a, o;
                                if (e.slice)
                                    for (r = e.length; --r > -1;) Qe(e[r], t, n);
                                else
                                    for (i = e.childNodes, r = i.length; --r > -1;) a = i[r], o = a.type, a.style && (t.push(ie(a)), n && n.push(a)), 1 !== o && 9 !== o && 11 !== o || !a.childNodes.length || Qe(a, t, n)
                            };
                            return s.cascadeTo = function (e, n, i) {
                                var r, a, o, s, l = t.to(e, n, i),
                                    c = [l],
                                    u = [],
                                    h = [],
                                    d = [],
                                    p = t._internals.reservedProps;
                                for (e = l._targets || l.target, Qe(e, u, d), l.render(n, !0, !0), Qe(e, h), l.render(0, !0, !0), l._enabled(!0), r = d.length; --r > -1;)
                                    if (a = re(d[r], u[r], h[r]), a.firstMPT) {
                                        a = a.difs;
                                        for (o in i) p[o] && (a[o] = i[o]);
                                        s = {};
                                        for (o in a) s[o] = u[r][o];
                                        c.push(t.fromTo(d[r], n, s, a))
                                    } return c
                            }, e.activate([s]), s
                        }, !0),
                        function () {
                            var e = n._gsDefine.plugin({
                                    propName: "roundProps",
                                    version: "1.7.0",
                                    priority: -1,
                                    API: 2,
                                    init: function (e, t, n) {
                                        return this._tween = n, !0
                                    }
                                }),
                                t = function (e) {
                                    var t = e < 1 ? Math.pow(10, (e + "").length - 2) : 1;
                                    return function (n) {
                                        return (Math.round(n / e) * e * t | 0) / t
                                    }
                                },
                                i = function (e, t) {
                                    for (; e;) e.f || e.blob || (e.m = t || Math.round), e = e._next
                                },
                                r = e.prototype;
                            r._onInitAllProps = function () {
                                var e, n, r, a, o = this._tween,
                                    s = o.vars.roundProps,
                                    l = {},
                                    c = o._propLookup.roundProps;
                                if ("object" != typeof s || s.push)
                                    for ("string" == typeof s && (s = s.split(",")), r = s.length; --r > -1;) l[s[r]] = Math.round;
                                else
                                    for (a in s) l[a] = t(s[a]);
                                for (a in l)
                                    for (e = o._firstPT; e;) n = e._next, e.pg ? e.t._mod(l) : e.n === a && (2 === e.f && e.t ? i(e.t._firstPT, l[a]) : (this._add(e.t, a, e.s, e.c, l[a]), n && (n._prev = e._prev), e._prev ? e._prev._next = n : o._firstPT === e && (o._firstPT = n), e._next = e._prev = null, o._propLookup[a] = c)), e = n;
                                return !1
                            }, r._add = function (e, t, n, i, r) {
                                this._addTween(e, t, n, n + i, t, r || Math.round), this._overwriteProps.push(t)
                            }
                        }(),
                        function () {
                            n._gsDefine.plugin({
                                propName: "attr",
                                API: 2,
                                version: "0.6.1",
                                init: function (e, t, n, i) {
                                    var r, a;
                                    if ("function" != typeof e.setAttribute) return !1;
                                    for (r in t) a = t[r], "function" == typeof a && (a = a(i, e)), this._addTween(e, "setAttribute", e.getAttribute(r) + "", a + "", r, !1, r), this._overwriteProps.push(r);
                                    return !0
                                }
                            })
                        }(), n._gsDefine.plugin({
                            propName: "directionalRotation",
                            version: "0.3.1",
                            API: 2,
                            init: function (e, t, n, i) {
                                "object" != typeof t && (t = {
                                    rotation: t
                                }), this.finals = {};
                                var r, a, o, s, l, c, u = t.useRadians === !0 ? 2 * Math.PI : 360,
                                    h = 1e-6;
                                for (r in t) "useRadians" !== r && (s = t[r], "function" == typeof s && (s = s(i, e)), c = (s + "").split("_"), a = c[0], o = parseFloat("function" != typeof e[r] ? e[r] : e[r.indexOf("set") || "function" != typeof e["get" + r.substr(3)] ? r : "get" + r.substr(3)]()), s = this.finals[r] = "string" == typeof a && "=" === a.charAt(1) ? o + parseInt(a.charAt(0) + "1", 10) * Number(a.substr(2)) : Number(a) || 0, l = s - o, c.length && (a = c.join("_"), a.indexOf("short") !== -1 && (l %= u, l !== l % (u / 2) && (l = l < 0 ? l + u : l - u)), a.indexOf("_cw") !== -1 && l < 0 ? l = (l + 9999999999 * u) % u - (l / u | 0) * u : a.indexOf("ccw") !== -1 && l > 0 && (l = (l - 9999999999 * u) % u - (l / u | 0) * u)), (l > h || l < -h) && (this._addTween(e, r, o, o + l, r), this._overwriteProps.push(r)));
                                return !0
                            },
                            set: function (e) {
                                var t;
                                if (1 !== e) this._super.setRatio.call(this, e);
                                else
                                    for (t = this._firstPT; t;) t.f ? t.t[t.p](this.finals[t.p]) : t.t[t.p] = this.finals[t.p], t = t._next
                            }
                        })._autoCSS = !0, n._gsDefine("easing.Back", ["easing.Ease"], function (e) {
                            var t, i, r, a, o = n.GreenSockGlobals || n,
                                s = o.com.greensock,
                                l = 2 * Math.PI,
                                c = Math.PI / 2,
                                u = s._class,
                                h = function (t, n) {
                                    var i = u("easing." + t, function () {}, !0),
                                        r = i.prototype = new e;
                                    return r.constructor = i, r.getRatio = n, i
                                },
                                d = e.register || function () {},
                                p = function (e, t, n, i, r) {
                                    var a = u("easing." + e, {
                                        easeOut: new t,
                                        easeIn: new n,
                                        easeInOut: new i
                                    }, !0);
                                    return d(a, e), a
                                },
                                f = function (e, t, n) {
                                    this.t = e, this.v = t, n && (this.next = n, n.prev = this, this.c = n.v - t, this.gap = n.t - e)
                                },
                                m = function (t, n) {
                                    var i = u("easing." + t, function (e) {
                                            this._p1 = e || 0 === e ? e : 1.70158, this._p2 = 1.525 * this._p1
                                        }, !0),
                                        r = i.prototype = new e;
                                    return r.constructor = i, r.getRatio = n, r.config = function (e) {
                                        return new i(e)
                                    }, i
                                },
                                v = p("Back", m("BackOut", function (e) {
                                    return (e -= 1) * e * ((this._p1 + 1) * e + this._p1) + 1
                                }), m("BackIn", function (e) {
                                    return e * e * ((this._p1 + 1) * e - this._p1)
                                }), m("BackInOut", function (e) {
                                    return (e *= 2) < 1 ? .5 * e * e * ((this._p2 + 1) * e - this._p2) : .5 * ((e -= 2) * e * ((this._p2 + 1) * e + this._p2) + 2)
                                })),
                                g = u("easing.SlowMo", function (e, t, n) {
                                    t = t || 0 === t ? t : .7, null == e ? e = .7 : e > 1 && (e = 1), this._p = 1 !== e ? t : 0, this._p1 = (1 - e) / 2, this._p2 = e, this._p3 = this._p1 + this._p2, this._calcEnd = n === !0
                                }, !0),
                                y = g.prototype = new e;
                            return y.constructor = g, y.getRatio = function (e) {
                                var t = e + (.5 - e) * this._p;
                                return e < this._p1 ? this._calcEnd ? 1 - (e = 1 - e / this._p1) * e : t - (e = 1 - e / this._p1) * e * e * e * t : e > this._p3 ? this._calcEnd ? 1 === e ? 0 : 1 - (e = (e - this._p3) / this._p1) * e : t + (e - t) * (e = (e - this._p3) / this._p1) * e * e * e : this._calcEnd ? 1 : t
                            }, g.ease = new g(.7, .7), y.config = g.config = function (e, t, n) {
                                return new g(e, t, n)
                            }, t = u("easing.SteppedEase", function (e, t) {
                                e = e || 1, this._p1 = 1 / e, this._p2 = e + (t ? 0 : 1), this._p3 = t ? 1 : 0
                            }, !0), y = t.prototype = new e, y.constructor = t, y.getRatio = function (e) {
                                return e < 0 ? e = 0 : e >= 1 && (e = .999999999), ((this._p2 * e | 0) + this._p3) * this._p1
                            }, y.config = t.config = function (e, n) {
                                return new t(e, n)
                            }, i = u("easing.ExpoScaleEase", function (e, t, n) {
                                this._p1 = Math.log(t / e), this._p2 = t - e, this._p3 = e, this._ease = n
                            }, !0), y = i.prototype = new e, y.constructor = i, y.getRatio = function (e) {
                                return this._ease && (e = this._ease.getRatio(e)), (this._p3 * Math.exp(this._p1 * e) - this._p3) / this._p2
                            }, y.config = i.config = function (e, t, n) {
                                return new i(e, t, n)
                            }, r = u("easing.RoughEase", function (t) {
                                t = t || {};
                                for (var n, i, r, a, o, s, l = t.taper || "none", c = [], u = 0, h = 0 | (t.points || 20), d = h, p = t.randomize !== !1, m = t.clamp === !0, v = t.template instanceof e ? t.template : null, g = "number" == typeof t.strength ? .4 * t.strength : .4; --d > -1;) n = p ? Math.random() : 1 / h * d, i = v ? v.getRatio(n) : n, "none" === l ? r = g : "out" === l ? (a = 1 - n, r = a * a * g) : "in" === l ? r = n * n * g : n < .5 ? (a = 2 * n, r = a * a * .5 * g) : (a = 2 * (1 - n), r = a * a * .5 * g), p ? i += Math.random() * r - .5 * r : d % 2 ? i += .5 * r : i -= .5 * r, m && (i > 1 ? i = 1 : i < 0 && (i = 0)), c[u++] = {
                                    x: n,
                                    y: i
                                };
                                for (c.sort(function (e, t) {
                                        return e.x - t.x
                                    }), s = new f(1, 1, null), d = h; --d > -1;) o = c[d], s = new f(o.x, o.y, s);
                                this._prev = new f(0, 0, 0 !== s.t ? s : s.next)
                            }, !0), y = r.prototype = new e, y.constructor = r, y.getRatio = function (e) {
                                var t = this._prev;
                                if (e > t.t) {
                                    for (; t.next && e >= t.t;) t = t.next;
                                    t = t.prev
                                } else
                                    for (; t.prev && e <= t.t;) t = t.prev;
                                return this._prev = t, t.v + (e - t.t) / t.gap * t.c
                            }, y.config = function (e) {
                                return new r(e)
                            }, r.ease = new r, p("Bounce", h("BounceOut", function (e) {
                                return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
                            }), h("BounceIn", function (e) {
                                return (e = 1 - e) < 1 / 2.75 ? 1 - 7.5625 * e * e : e < 2 / 2.75 ? 1 - (7.5625 * (e -= 1.5 / 2.75) * e + .75) : e < 2.5 / 2.75 ? 1 - (7.5625 * (e -= 2.25 / 2.75) * e + .9375) : 1 - (7.5625 * (e -= 2.625 / 2.75) * e + .984375)
                            }), h("BounceInOut", function (e) {
                                var t = e < .5;
                                return e = t ? 1 - 2 * e : 2 * e - 1, e = e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375, t ? .5 * (1 - e) : .5 * e + .5
                            })), p("Circ", h("CircOut", function (e) {
                                return Math.sqrt(1 - (e -= 1) * e)
                            }), h("CircIn", function (e) {
                                return -(Math.sqrt(1 - e * e) - 1)
                            }), h("CircInOut", function (e) {
                                return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
                            })), a = function (t, n, i) {
                                var r = u("easing." + t, function (e, t) {
                                        this._p1 = e >= 1 ? e : 1, this._p2 = (t || i) / (e < 1 ? e : 1), this._p3 = this._p2 / l * (Math.asin(1 / this._p1) || 0), this._p2 = l / this._p2
                                    }, !0),
                                    a = r.prototype = new e;
                                return a.constructor = r, a.getRatio = n, a.config = function (e, t) {
                                    return new r(e, t)
                                }, r
                            }, p("Elastic", a("ElasticOut", function (e) {
                                return this._p1 * Math.pow(2, -10 * e) * Math.sin((e - this._p3) * this._p2) + 1
                            }, .3), a("ElasticIn", function (e) {
                                return -(this._p1 * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2))
                            }, .3), a("ElasticInOut", function (e) {
                                return (e *= 2) < 1 ? -.5 * (this._p1 * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2) * .5 + 1
                            }, .45)), p("Expo", h("ExpoOut", function (e) {
                                return 1 - Math.pow(2, -10 * e)
                            }), h("ExpoIn", function (e) {
                                return Math.pow(2, 10 * (e - 1)) - .001
                            }), h("ExpoInOut", function (e) {
                                return (e *= 2) < 1 ? .5 * Math.pow(2, 10 * (e - 1)) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
                            })), p("Sine", h("SineOut", function (e) {
                                return Math.sin(e * c)
                            }), h("SineIn", function (e) {
                                return -Math.cos(e * c) + 1
                            }), h("SineInOut", function (e) {
                                return -.5 * (Math.cos(Math.PI * e) - 1)
                            })), u("easing.EaseLookup", {
                                find: function (t) {
                                    return e.map[t]
                                }
                            }, !0), d(o.SlowMo, "SlowMo", "ease,"), d(r, "RoughEase", "ease,"), d(t, "SteppedEase", "ease,"), v
                        }, !0)
                }), n._gsDefine && n._gsQueue.pop()(),
                function (e, n) {
                    "use strict";
                    var i = {},
                        r = e.document,
                        a = e.GreenSockGlobals = e.GreenSockGlobals || e;
                    if (a.TweenLite) return a.TweenLite;
                    var o, s, l, c, u, h = function (e) {
                            var t, n = e.split("."),
                                i = a;
                            for (t = 0; t < n.length; t++) i[n[t]] = i = i[n[t]] || {};
                            return i
                        },
                        d = h("com.greensock"),
                        p = 1e-10,
                        f = function (e) {
                            var t, n = [],
                                i = e.length;
                            for (t = 0; t !== i; n.push(e[t++]));
                            return n
                        },
                        m = function () {},
                        v = function () {
                            var e = Object.prototype.toString,
                                t = e.call([]);
                            return function (n) {
                                return null != n && (n instanceof Array || "object" == typeof n && !!n.push && e.call(n) === t)
                            }
                        }(),
                        g = {},
                        y = function (r, o, s, l) {
                            this.sc = g[r] ? g[r].sc : [], g[r] = this, this.gsClass = null, this.func = s;
                            var c = [];
                            this.check = function (u) {
                                for (var d, p, f, m, v = o.length, x = v; --v > -1;)(d = g[o[v]] || new y(o[v], [])).gsClass ? (c[v] = d.gsClass, x--) : u && d.sc.push(this);
                                if (0 === x && s) {
                                    if (p = ("com.greensock." + r).split("."), f = p.pop(), m = h(p.join("."))[f] = this.gsClass = s.apply(s, c), l)
                                        if (a[f] = i[f] = m, "undefined" != typeof t && t.exports)
                                            if (r === n) {
                                                t.exports = i[n] = m;
                                                for (v in i) m[v] = i[v]
                                            } else i[n] && (i[n][f] = m);
                                    else "function" == typeof define && define.amd && define((e.GreenSockAMDPath ? e.GreenSockAMDPath + "/" : "") + r.split(".").pop(), [], function () {
                                        return m
                                    });
                                    for (v = 0; v < this.sc.length; v++) this.sc[v].check()
                                }
                            }, this.check(!0)
                        },
                        x = e._gsDefine = function (e, t, n, i) {
                            return new y(e, t, n, i)
                        },
                        b = d._class = function (e, t, n) {
                            return t = t || function () {}, x(e, [], function () {
                                return t
                            }, n), t
                        };
                    x.globals = a;
                    var _ = [0, 0, 1, 1],
                        w = b("easing.Ease", function (e, t, n, i) {
                            this._func = e, this._type = n || 0, this._power = i || 0, this._params = t ? _.concat(t) : _
                        }, !0),
                        M = w.map = {},
                        T = w.register = function (e, t, n, i) {
                            for (var r, a, o, s, l = t.split(","), c = l.length, u = (n || "easeIn,easeOut,easeInOut").split(","); --c > -1;)
                                for (a = l[c], r = i ? b("easing." + a, null, !0) : d.easing[a] || {}, o = u.length; --o > -1;) s = u[o], M[a + "." + s] = M[s + a] = r[s] = e.getRatio ? e : e[s] || new e
                        };
                    for (l = w.prototype, l._calcEnd = !1, l.getRatio = function (e) {
                            if (this._func) return this._params[0] = e, this._func.apply(null, this._params);
                            var t = this._type,
                                n = this._power,
                                i = 1 === t ? 1 - e : 2 === t ? e : e < .5 ? 2 * e : 2 * (1 - e);
                            return 1 === n ? i *= i : 2 === n ? i *= i * i : 3 === n ? i *= i * i * i : 4 === n && (i *= i * i * i * i), 1 === t ? 1 - i : 2 === t ? i : e < .5 ? i / 2 : 1 - i / 2
                        }, o = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], s = o.length; --s > -1;) l = o[s] + ",Power" + s, T(new w(null, null, 1, s), l, "easeOut", !0), T(new w(null, null, 2, s), l, "easeIn" + (0 === s ? ",easeNone" : "")), T(new w(null, null, 3, s), l, "easeInOut");
                    M.linear = d.easing.Linear.easeIn, M.swing = d.easing.Quad.easeInOut;
                    var E = b("events.EventDispatcher", function (e) {
                        this._listeners = {}, this._eventTarget = e || this
                    });
                    l = E.prototype, l.addEventListener = function (e, t, n, i, r) {
                        r = r || 0;
                        var a, o, s = this._listeners[e],
                            l = 0;
                        for (this !== c || u || c.wake(), null == s && (this._listeners[e] = s = []), o = s.length; --o > -1;) a = s[o], a.c === t && a.s === n ? s.splice(o, 1) : 0 === l && a.pr < r && (l = o + 1);
                        s.splice(l, 0, {
                            c: t,
                            s: n,
                            up: i,
                            pr: r
                        })
                    }, l.removeEventListener = function (e, t) {
                        var n, i = this._listeners[e];
                        if (i)
                            for (n = i.length; --n > -1;)
                                if (i[n].c === t) return void i.splice(n, 1)
                    }, l.dispatchEvent = function (e) {
                        var t, n, i, r = this._listeners[e];
                        if (r)
                            for (t = r.length, t > 1 && (r = r.slice(0)), n = this._eventTarget; --t > -1;) i = r[t], i && (i.up ? i.c.call(i.s || n, {
                                type: e,
                                target: n
                            }) : i.c.call(i.s || n))
                    };
                    var S = e.requestAnimationFrame,
                        P = e.cancelAnimationFrame,
                        C = Date.now || function () {
                            return (new Date).getTime()
                        },
                        A = C();
                    for (o = ["ms", "moz", "webkit", "o"], s = o.length; --s > -1 && !S;) S = e[o[s] + "RequestAnimationFrame"], P = e[o[s] + "CancelAnimationFrame"] || e[o[s] + "CancelRequestAnimationFrame"];
                    b("Ticker", function (e, t) {
                        var n, i, a, o, s, l = this,
                            h = C(),
                            d = !(t === !1 || !S) && "auto",
                            f = 500,
                            v = 33,
                            g = "tick",
                            y = function (e) {
                                var t, r, c = C() - A;
                                c > f && (h += c - v), A += c, l.time = (A - h) / 1e3, t = l.time - s, (!n || t > 0 || e === !0) && (l.frame++, s += t + (t >= o ? .004 : o - t), r = !0), e !== !0 && (a = i(y)), r && l.dispatchEvent(g)
                            };
                        E.call(l), l.time = l.frame = 0, l.tick = function () {
                            y(!0)
                        }, l.lagSmoothing = function (e, t) {
                            return arguments.length ? (f = e || 1 / p, void(v = Math.min(t, f, 0))) : f < 1 / p
                        }, l.sleep = function () {
                            null != a && (d && P ? P(a) : clearTimeout(a), i = m, a = null, l === c && (u = !1))
                        }, l.wake = function (e) {
                            null !== a ? l.sleep() : e ? h += -A + (A = C()) : l.frame > 10 && (A = C() - f + 5), i = 0 === n ? m : d && S ? S : function (e) {
                                return setTimeout(e, 1e3 * (s - l.time) + 1 | 0)
                            }, l === c && (u = !0), y(2)
                        }, l.fps = function (e) {
                            return arguments.length ? (n = e, o = 1 / (n || 60), s = this.time + o, void l.wake()) : n
                        }, l.useRAF = function (e) {
                            return arguments.length ? (l.sleep(), d = e, void l.fps(n)) : d
                        }, l.fps(e), setTimeout(function () {
                            "auto" === d && l.frame < 5 && "hidden" !== (r || {}).visibilityState && l.useRAF(!1)
                        }, 1500)
                    }), l = d.Ticker.prototype = new d.events.EventDispatcher, l.constructor = d.Ticker;
                    var L = b("core.Animation", function (e, t) {
                        if (this.vars = t = t || {}, this._duration = this._totalDuration = e || 0, this._delay = Number(t.delay) || 0, this._timeScale = 1, this._active = t.immediateRender === !0, this.data = t.data, this._reversed = t.reversed === !0, J) {
                            u || c.wake();
                            var n = this.vars.useFrames ? Z : J;
                            n.add(this, n._time), this.vars.paused && this.paused(!0)
                        }
                    });
                    c = L.ticker = new d.Ticker, l = L.prototype, l._dirty = l._gc = l._initted = l._paused = !1, l._totalTime = l._time = 0, l._rawPrevTime = -1, l._next = l._last = l._onUpdate = l._timeline = l.timeline = null, l._paused = !1;
                    var R = function () {
                        u && C() - A > 2e3 && ("hidden" !== (r || {}).visibilityState || !c.lagSmoothing()) && c.wake();
                        var e = setTimeout(R, 2e3);
                        e.unref && e.unref()
                    };
                    R(), l.play = function (e, t) {
                        return null != e && this.seek(e, t), this.reversed(!1).paused(!1)
                    }, l.pause = function (e, t) {
                        return null != e && this.seek(e, t), this.paused(!0)
                    }, l.resume = function (e, t) {
                        return null != e && this.seek(e, t), this.paused(!1)
                    }, l.seek = function (e, t) {
                        return this.totalTime(Number(e), t !== !1)
                    }, l.restart = function (e, t) {
                        return this.reversed(!1).paused(!1).totalTime(e ? -this._delay : 0, t !== !1, !0)
                    }, l.reverse = function (e, t) {
                        return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1)
                    }, l.render = function (e, t, n) {}, l.invalidate = function () {
                        return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this
                    }, l.isActive = function () {
                        var e, t = this._timeline,
                            n = this._startTime;
                        return !t || !this._gc && !this._paused && t.isActive() && (e = t.rawTime(!0)) >= n && e < n + this.totalDuration() / this._timeScale - 1e-7
                    }, l._enabled = function (e, t) {
                        return u || c.wake(), this._gc = !e, this._active = this.isActive(), t !== !0 && (e && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !e && this.timeline && this._timeline._remove(this, !0)), !1
                    }, l._kill = function (e, t) {
                        return this._enabled(!1, !1)
                    }, l.kill = function (e, t) {
                        return this._kill(e, t), this
                    }, l._uncache = function (e) {
                        for (var t = e ? this : this.timeline; t;) t._dirty = !0, t = t.timeline;
                        return this
                    }, l._swapSelfInParams = function (e) {
                        for (var t = e.length, n = e.concat(); --t > -1;) "{self}" === e[t] && (n[t] = this);
                        return n
                    }, l._callback = function (e) {
                        var t = this.vars,
                            n = t[e],
                            i = t[e + "Params"],
                            r = t[e + "Scope"] || t.callbackScope || this,
                            a = i ? i.length : 0;
                        switch (a) {
                            case 0:
                                n.call(r);
                                break;
                            case 1:
                                n.call(r, i[0]);
                                break;
                            case 2:
                                n.call(r, i[0], i[1]);
                                break;
                            default:
                                n.apply(r, i)
                        }
                    }, l.eventCallback = function (e, t, n, i) {
                        if ("on" === (e || "").substr(0, 2)) {
                            var r = this.vars;
                            if (1 === arguments.length) return r[e];
                            null == t ? delete r[e] : (r[e] = t, r[e + "Params"] = v(n) && n.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(n) : n, r[e + "Scope"] = i), "onUpdate" === e && (this._onUpdate = t)
                        }
                        return this
                    }, l.delay = function (e) {
                        return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + e - this._delay), this._delay = e, this) : this._delay
                    }, l.duration = function (e) {
                        return arguments.length ? (this._duration = this._totalDuration = e, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== e && this.totalTime(this._totalTime * (e / this._duration), !0), this) : (this._dirty = !1, this._duration)
                    }, l.totalDuration = function (e) {
                        return this._dirty = !1, arguments.length ? this.duration(e) : this._totalDuration
                    }, l.time = function (e, t) {
                        return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(e > this._duration ? this._duration : e, t)) : this._time
                    }, l.totalTime = function (e, t, n) {
                        if (u || c.wake(), !arguments.length) return this._totalTime;
                        if (this._timeline) {
                            if (e < 0 && !n && (e += this.totalDuration()), this._timeline.smoothChildTiming) {
                                this._dirty && this.totalDuration();
                                var i = this._totalDuration,
                                    r = this._timeline;
                                if (e > i && !n && (e = i), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? i - e : e) / this._timeScale, r._dirty || this._uncache(!1), r._timeline)
                                    for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline
                            }
                            this._gc && this._enabled(!0, !1), this._totalTime === e && 0 !== this._duration || (z.length && Q(), this.render(e, t, !1), z.length && Q())
                        }
                        return this
                    }, l.progress = l.totalProgress = function (e, t) {
                        var n = this.duration();
                        return arguments.length ? this.totalTime(n * e, t) : n ? this._time / n : this.ratio
                    }, l.startTime = function (e) {
                        return arguments.length ? (e !== this._startTime && (this._startTime = e, this.timeline && this.timeline._sortChildren && this.timeline.add(this, e - this._delay)), this) : this._startTime
                    }, l.endTime = function (e) {
                        return this._startTime + (0 != e ? this.totalDuration() : this.duration()) / this._timeScale
                    }, l.timeScale = function (e) {
                        if (!arguments.length) return this._timeScale;
                        var t, n;
                        for (e = e || p, this._timeline && this._timeline.smoothChildTiming && (t = this._pauseTime, n = t || 0 === t ? t : this._timeline.totalTime(), this._startTime = n - (n - this._startTime) * this._timeScale / e), this._timeScale = e, n = this.timeline; n && n.timeline;) n._dirty = !0, n.totalDuration(), n = n.timeline;
                        return this
                    }, l.reversed = function (e) {
                        return arguments.length ? (e != this._reversed && (this._reversed = e, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
                    }, l.paused = function (e) {
                        if (!arguments.length) return this._paused;
                        var t, n, i = this._timeline;
                        return e != this._paused && i && (u || e || c.wake(), t = i.rawTime(), n = t - this._pauseTime, !e && i.smoothChildTiming && (this._startTime += n, this._uncache(!1)), this._pauseTime = e ? t : null, this._paused = e, this._active = this.isActive(), !e && 0 !== n && this._initted && this.duration() && (t = i.smoothChildTiming ? this._totalTime : (t - this._startTime) / this._timeScale, this.render(t, t === this._totalTime, !0))), this._gc && !e && this._enabled(!0, !1), this
                    };
                    var I = b("core.SimpleTimeline", function (e) {
                        L.call(this, 0, e), this.autoRemoveChildren = this.smoothChildTiming = !0
                    });
                    l = I.prototype = new L, l.constructor = I, l.kill()._gc = !1, l._first = l._last = l._recent = null, l._sortChildren = !1, l.add = l.insert = function (e, t, n, i) {
                        var r, a;
                        if (e._startTime = Number(t || 0) + e._delay, e._paused && this !== e._timeline && (e._pauseTime = this.rawTime() - (e._timeline.rawTime() - e._pauseTime)), e.timeline && e.timeline._remove(e, !0), e.timeline = e._timeline = this, e._gc && e._enabled(!0, !0), r = this._last, this._sortChildren)
                            for (a = e._startTime; r && r._startTime > a;) r = r._prev;
                        return r ? (e._next = r._next, r._next = e) : (e._next = this._first, this._first = e), e._next ? e._next._prev = e : this._last = e, e._prev = r, this._recent = e, this._timeline && this._uncache(!0), this
                    }, l._remove = function (e, t) {
                        return e.timeline === this && (t || e._enabled(!1, !0), e._prev ? e._prev._next = e._next : this._first === e && (this._first = e._next), e._next ? e._next._prev = e._prev : this._last === e && (this._last = e._prev), e._next = e._prev = e.timeline = null, e === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
                    }, l.render = function (e, t, n) {
                        var i, r = this._first;
                        for (this._totalTime = this._time = this._rawPrevTime = e; r;) i = r._next, (r._active || e >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, n) : r.render((e - r._startTime) * r._timeScale, t, n)), r = i
                    }, l.rawTime = function () {
                        return u || c.wake(), this._totalTime
                    };
                    var O = b("TweenLite", function (t, n, i) {
                            if (L.call(this, n, i), this.render = O.prototype.render, null == t) throw "Cannot tween a null target.";
                            this.target = t = "string" != typeof t ? t : O.selector(t) || t;
                            var r, a, o, s = t.jquery || t.length && t !== e && t[0] && (t[0] === e || t[0].nodeType && t[0].style && !t.nodeType),
                                l = this.vars.overwrite;
                            if (this._overwrite = l = null == l ? Y[O.defaultOverwrite] : "number" == typeof l ? l >> 0 : Y[l], (s || t instanceof Array || t.push && v(t)) && "number" != typeof t[0])
                                for (this._targets = o = f(t), this._propLookup = [], this._siblings = [], r = 0; r < o.length; r++) a = o[r], a ? "string" != typeof a ? a.length && a !== e && a[0] && (a[0] === e || a[0].nodeType && a[0].style && !a.nodeType) ? (o.splice(r--, 1), this._targets = o = o.concat(f(a))) : (this._siblings[r] = K(a, this, !1), 1 === l && this._siblings[r].length > 1 && te(a, this, null, 1, this._siblings[r])) : (a = o[r--] = O.selector(a), "string" == typeof a && o.splice(r + 1, 1)) : o.splice(r--, 1);
                            else this._propLookup = {}, this._siblings = K(t, this, !1), 1 === l && this._siblings.length > 1 && te(t, this, null, 1, this._siblings);
                            (this.vars.immediateRender || 0 === n && 0 === this._delay && this.vars.immediateRender !== !1) && (this._time = -p, this.render(Math.min(0, -this._delay)))
                        }, !0),
                        k = function (t) {
                            return t && t.length && t !== e && t[0] && (t[0] === e || t[0].nodeType && t[0].style && !t.nodeType)
                        },
                        D = function (e, t) {
                            var n, i = {};
                            for (n in e) X[n] || n in t && "transform" !== n && "x" !== n && "y" !== n && "width" !== n && "height" !== n && "className" !== n && "border" !== n || !(!V[n] || V[n] && V[n]._autoCSS) || (i[n] = e[n], delete e[n]);
                            e.css = i
                        };
                    l = O.prototype = new L, l.constructor = O, l.kill()._gc = !1, l.ratio = 0, l._firstPT = l._targets = l._overwrittenProps = l._startAt = null, l._notifyPluginsOfEnabled = l._lazy = !1, O.version = "1.20.5", O.defaultEase = l._ease = new w(null, null, 1, 1), O.defaultOverwrite = "auto", O.ticker = c, O.autoSleep = 120, O.lagSmoothing = function (e, t) {
                        c.lagSmoothing(e, t)
                    }, O.selector = e.$ || e.jQuery || function (t) {
                        var n = e.$ || e.jQuery;
                        return n ? (O.selector = n, n(t)) : (r || (r = e.document), r ? r.querySelectorAll ? r.querySelectorAll(t) : r.getElementById("#" === t.charAt(0) ? t.substr(1) : t) : t)
                    };
                    var z = [],
                        B = {},
                        N = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                        U = /[\+-]=-?[\.\d]/,
                        j = function (e) {
                            for (var t, n = this._firstPT, i = 1e-6; n;) t = n.blob ? 1 === e && null != this.end ? this.end : e ? this.join("") : this.start : n.c * e + n.s, n.m ? t = n.m.call(this._tween, t, this._target || n.t, this._tween) : t < i && t > -i && !n.blob && (t = 0), n.f ? n.fp ? n.t[n.p](n.fp, t) : n.t[n.p](t) : n.t[n.p] = t, n = n._next
                        },
                        F = function (e, t, n, i) {
                            var r, a, o, s, l, c, u, h = [],
                                d = 0,
                                p = "",
                                f = 0;
                            for (h.start = e, h.end = t, e = h[0] = e + "", t = h[1] = t + "", n && (n(h), e = h[0], t = h[1]), h.length = 0, r = e.match(N) || [], a = t.match(N) || [], i && (i._next = null, i.blob = 1, h._firstPT = h._applyPT = i), l = a.length, s = 0; s < l; s++) u = a[s], c = t.substr(d, t.indexOf(u, d) - d), p += c || !s ? c : ",", d += c.length, f ? f = (f + 1) % 5 : "rgba(" === c.substr(-5) && (f = 1), u === r[s] || r.length <= s ? p += u : (p && (h.push(p), p = ""), o = parseFloat(r[s]), h.push(o), h._firstPT = {
                                _next: h._firstPT,
                                t: h,
                                p: h.length - 1,
                                s: o,
                                c: ("=" === u.charAt(1) ? parseInt(u.charAt(0) + "1", 10) * parseFloat(u.substr(2)) : parseFloat(u) - o) || 0,
                                f: 0,
                                m: f && f < 4 ? Math.round : 0
                            }), d += u.length;
                            return p += t.substr(d), p && h.push(p), h.setRatio = j, U.test(t) && (h.end = null), h
                        },
                        G = function (e, t, n, i, r, a, o, s, l) {
                            "function" == typeof i && (i = i(l || 0, e));
                            var c, u = typeof e[t],
                                h = "function" !== u ? "" : t.indexOf("set") || "function" != typeof e["get" + t.substr(3)] ? t : "get" + t.substr(3),
                                d = "get" !== n ? n : h ? o ? e[h](o) : e[h]() : e[t],
                                p = "string" == typeof i && "=" === i.charAt(1),
                                f = {
                                    t: e,
                                    p: t,
                                    s: d,
                                    f: "function" === u,
                                    pg: 0,
                                    n: r || t,
                                    m: a ? "function" == typeof a ? a : Math.round : 0,
                                    pr: 0,
                                    c: p ? parseInt(i.charAt(0) + "1", 10) * parseFloat(i.substr(2)) : parseFloat(i) - d || 0
                                };
                            if (("number" != typeof d || "number" != typeof i && !p) && (o || isNaN(d) || !p && isNaN(i) || "boolean" == typeof d || "boolean" == typeof i ? (f.fp = o, c = F(d, p ? parseFloat(f.s) + f.c + (f.s + "").replace(/[0-9\-\.]/g, "") : i, s || O.defaultStringFilter, f), f = {
                                    t: c,
                                    p: "setRatio",
                                    s: 0,
                                    c: 1,
                                    f: 2,
                                    pg: 0,
                                    n: r || t,
                                    pr: 0,
                                    m: 0
                                }) : (f.s = parseFloat(d), p || (f.c = parseFloat(i) - f.s || 0))), f.c) return (f._next = this._firstPT) && (f._next._prev = f), this._firstPT = f, f
                        },
                        H = O._internals = {
                            isArray: v,
                            isSelector: k,
                            lazyTweens: z,
                            blobDif: F
                        },
                        V = O._plugins = {},
                        W = H.tweenLookup = {},
                        q = 0,
                        X = H.reservedProps = {
                            ease: 1,
                            delay: 1,
                            overwrite: 1,
                            onComplete: 1,
                            onCompleteParams: 1,
                            onCompleteScope: 1,
                            useFrames: 1,
                            runBackwards: 1,
                            startAt: 1,
                            onUpdate: 1,
                            onUpdateParams: 1,
                            onUpdateScope: 1,
                            onStart: 1,
                            onStartParams: 1,
                            onStartScope: 1,
                            onReverseComplete: 1,
                            onReverseCompleteParams: 1,
                            onReverseCompleteScope: 1,
                            onRepeat: 1,
                            onRepeatParams: 1,
                            onRepeatScope: 1,
                            easeParams: 1,
                            yoyo: 1,
                            immediateRender: 1,
                            repeat: 1,
                            repeatDelay: 1,
                            data: 1,
                            paused: 1,
                            reversed: 1,
                            autoCSS: 1,
                            lazy: 1,
                            onOverwrite: 1,
                            callbackScope: 1,
                            stringFilter: 1,
                            id: 1,
                            yoyoEase: 1
                        },
                        Y = {
                            none: 0,
                            all: 1,
                            auto: 2,
                            concurrent: 3,
                            allOnStart: 4,
                            preexisting: 5,
                            "true": 1,
                            "false": 0
                        },
                        Z = L._rootFramesTimeline = new I,
                        J = L._rootTimeline = new I,
                        $ = 30,
                        Q = H.lazyRender = function () {
                            var e, t = z.length;
                            for (B = {}; --t > -1;) e = z[t], e && e._lazy !== !1 && (e.render(e._lazy[0], e._lazy[1], !0), e._lazy = !1);
                            z.length = 0
                        };
                    J._startTime = c.time, Z._startTime = c.frame, J._active = Z._active = !0, setTimeout(Q, 1), L._updateRoot = O.render = function () {
                        var e, t, n;
                        if (z.length && Q(), J.render((c.time - J._startTime) * J._timeScale, !1, !1), Z.render((c.frame - Z._startTime) * Z._timeScale, !1, !1), z.length && Q(), c.frame >= $) {
                            $ = c.frame + (parseInt(O.autoSleep, 10) || 120);
                            for (n in W) {
                                for (t = W[n].tweens, e = t.length; --e > -1;) t[e]._gc && t.splice(e, 1);
                                0 === t.length && delete W[n]
                            }
                            if (n = J._first, (!n || n._paused) && O.autoSleep && !Z._first && 1 === c._listeners.tick.length) {
                                for (; n && n._paused;) n = n._next;
                                n || c.sleep()
                            }
                        }
                    }, c.addEventListener("tick", L._updateRoot);
                    var K = function (e, t, n) {
                            var i, r, a = e._gsTweenID;
                            if (W[a || (e._gsTweenID = a = "t" + q++)] || (W[a] = {
                                    target: e,
                                    tweens: []
                                }), t && (i = W[a].tweens, i[r = i.length] = t, n))
                                for (; --r > -1;) i[r] === t && i.splice(r, 1);
                            return W[a].tweens
                        },
                        ee = function (e, t, n, i) {
                            var r, a, o = e.vars.onOverwrite;
                            return o && (r = o(e, t, n, i)), o = O.onOverwrite, o && (a = o(e, t, n, i)), r !== !1 && a !== !1
                        },
                        te = function (e, t, n, i, r) {
                            var a, o, s, l;
                            if (1 === i || i >= 4) {
                                for (l = r.length, a = 0; a < l; a++)
                                    if ((s = r[a]) !== t) s._gc || s._kill(null, e, t) && (o = !0);
                                    else if (5 === i) break;
                                return o
                            }
                            var c, u = t._startTime + p,
                                h = [],
                                d = 0,
                                f = 0 === t._duration;
                            for (a = r.length; --a > -1;)(s = r[a]) === t || s._gc || s._paused || (s._timeline !== t._timeline ? (c = c || ne(t, 0, f), 0 === ne(s, c, f) && (h[d++] = s)) : s._startTime <= u && s._startTime + s.totalDuration() / s._timeScale > u && ((f || !s._initted) && u - s._startTime <= 2e-10 || (h[d++] = s)));
                            for (a = d; --a > -1;)
                                if (s = h[a], 2 === i && s._kill(n, e, t) && (o = !0), 2 !== i || !s._firstPT && s._initted) {
                                    if (2 !== i && !ee(s, t)) continue;
                                    s._enabled(!1, !1) && (o = !0)
                                } return o
                        },
                        ne = function (e, t, n) {
                            for (var i = e._timeline, r = i._timeScale, a = e._startTime; i._timeline;) {
                                if (a += i._startTime, r *= i._timeScale, i._paused) return -100;
                                i = i._timeline
                            }
                            return a /= r, a > t ? a - t : n && a === t || !e._initted && a - t < 2 * p ? p : (a += e.totalDuration() / e._timeScale / r) > t + p ? 0 : a - t - p
                        };
                    l._init = function () {
                        var e, t, n, i, r, a, o = this.vars,
                            s = this._overwrittenProps,
                            l = this._duration,
                            c = !!o.immediateRender,
                            u = o.ease;
                        if (o.startAt) {
                            this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), r = {};
                            for (i in o.startAt) r[i] = o.startAt[i];
                            if (r.data = "isStart", r.overwrite = !1, r.immediateRender = !0, r.lazy = c && o.lazy !== !1, r.startAt = r.delay = null, r.onUpdate = o.onUpdate, r.onUpdateParams = o.onUpdateParams, r.onUpdateScope = o.onUpdateScope || o.callbackScope || this, this._startAt = O.to(this.target || {}, 0, r), c)
                                if (this._time > 0) this._startAt = null;
                                else if (0 !== l) return
                        } else if (o.runBackwards && 0 !== l)
                            if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
                            else {
                                0 !== this._time && (c = !1), n = {};
                                for (i in o) X[i] && "autoCSS" !== i || (n[i] = o[i]);
                                if (n.overwrite = 0, n.data = "isFromStart", n.lazy = c && o.lazy !== !1, n.immediateRender = c, this._startAt = O.to(this.target, 0, n), c) {
                                    if (0 === this._time) return
                                } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                            } if (this._ease = u = u ? u instanceof w ? u : "function" == typeof u ? new w(u, o.easeParams) : M[u] || O.defaultEase : O.defaultEase, o.easeParams instanceof Array && u.config && (this._ease = u.config.apply(u, o.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                            for (a = this._targets.length, e = 0; e < a; e++) this._initProps(this._targets[e], this._propLookup[e] = {}, this._siblings[e], s ? s[e] : null, e) && (t = !0);
                        else t = this._initProps(this.target, this._propLookup, this._siblings, s, 0);
                        if (t && O._onPluginEvent("_onInitAllProps", this), s && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), o.runBackwards)
                            for (n = this._firstPT; n;) n.s += n.c, n.c = -n.c, n = n._next;
                        this._onUpdate = o.onUpdate, this._initted = !0
                    }, l._initProps = function (t, n, i, r, a) {
                        var o, s, l, c, u, h;
                        if (null == t) return !1;
                        B[t._gsTweenID] && Q(), this.vars.css || t.style && t !== e && t.nodeType && V.css && this.vars.autoCSS !== !1 && D(this.vars, t);
                        for (o in this.vars)
                            if (h = this.vars[o], X[o]) h && (h instanceof Array || h.push && v(h)) && h.join("").indexOf("{self}") !== -1 && (this.vars[o] = h = this._swapSelfInParams(h, this));
                            else if (V[o] && (c = new V[o])._onInitTween(t, this.vars[o], this, a)) {
                            for (this._firstPT = u = {
                                    _next: this._firstPT,
                                    t: c,
                                    p: "setRatio",
                                    s: 0,
                                    c: 1,
                                    f: 1,
                                    n: o,
                                    pg: 1,
                                    pr: c._priority,
                                    m: 0
                                }, s = c._overwriteProps.length; --s > -1;) n[c._overwriteProps[s]] = this._firstPT;
                            (c._priority || c._onInitAllProps) && (l = !0), (c._onDisable || c._onEnable) && (this._notifyPluginsOfEnabled = !0), u._next && (u._next._prev = u)
                        } else n[o] = G.call(this, t, o, "get", h, o, 0, null, this.vars.stringFilter, a);
                        return r && this._kill(r, t) ? this._initProps(t, n, i, r, a) : this._overwrite > 1 && this._firstPT && i.length > 1 && te(t, this, n, this._overwrite, i) ? (this._kill(n, t), this._initProps(t, n, i, r, a)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (B[t._gsTweenID] = !0), l)
                    }, l.render = function (e, t, n) {
                        var i, r, a, o, s = this._time,
                            l = this._duration,
                            c = this._rawPrevTime;
                        if (e >= l - 1e-7 && e >= 0) this._totalTime = this._time = l, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (i = !0, r = "onComplete", n = n || this._timeline.autoRemoveChildren), 0 === l && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (e = 0), (c < 0 || e <= 0 && e >= -1e-7 || c === p && "isPause" !== this.data) && c !== e && (n = !0, c > p && (r = "onReverseComplete")), this._rawPrevTime = o = !t || e || c === e ? e : p);
                        else if (e < 1e-7) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== s || 0 === l && c > 0) && (r = "onReverseComplete", i = this._reversed), e < 0 && (this._active = !1, 0 === l && (this._initted || !this.vars.lazy || n) && (c >= 0 && (c !== p || "isPause" !== this.data) && (n = !0), this._rawPrevTime = o = !t || e || c === e ? e : p)), (!this._initted || this._startAt && this._startAt.progress()) && (n = !0);
                        else if (this._totalTime = this._time = e, this._easeType) {
                            var u = e / l,
                                h = this._easeType,
                                d = this._easePower;
                            (1 === h || 3 === h && u >= .5) && (u = 1 - u), 3 === h && (u *= 2), 1 === d ? u *= u : 2 === d ? u *= u * u : 3 === d ? u *= u * u * u : 4 === d && (u *= u * u * u * u), 1 === h ? this.ratio = 1 - u : 2 === h ? this.ratio = u : e / l < .5 ? this.ratio = u / 2 : this.ratio = 1 - u / 2
                        } else this.ratio = this._ease.getRatio(e / l);
                        if (this._time !== s || n) {
                            if (!this._initted) {
                                if (this._init(), !this._initted || this._gc) return;
                                if (!n && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = s, this._rawPrevTime = c, z.push(this), void(this._lazy = [e, t]);
                                this._time && !i ? this.ratio = this._ease.getRatio(this._time / l) : i && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                            }
                            for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== s && e >= 0 && (this._active = !0), 0 === s && (this._startAt && (e >= 0 ? this._startAt.render(e, !0, n) : r || (r = "_dummyGS")), this.vars.onStart && (0 === this._time && 0 !== l || t || this._callback("onStart"))), a = this._firstPT; a;) a.f ? a.t[a.p](a.c * this.ratio + a.s) : a.t[a.p] = a.c * this.ratio + a.s, a = a._next;
                            this._onUpdate && (e < 0 && this._startAt && e !== -1e-4 && this._startAt.render(e, !0, n), t || (this._time !== s || i || n) && this._callback("onUpdate")), r && (this._gc && !n || (e < 0 && this._startAt && !this._onUpdate && e !== -1e-4 && this._startAt.render(e, !0, n), i && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[r] && this._callback(r), 0 === l && this._rawPrevTime === p && o !== p && (this._rawPrevTime = 0)))
                        }
                    }, l._kill = function (e, t, n) {
                        if ("all" === e && (e = null), null == e && (null == t || t === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                        t = "string" != typeof t ? t || this._targets || this.target : O.selector(t) || t;
                        var i, r, a, o, s, l, c, u, h, d = n && this._time && n._startTime === this._startTime && this._timeline === n._timeline;
                        if ((v(t) || k(t)) && "number" != typeof t[0])
                            for (i = t.length; --i > -1;) this._kill(e, t[i], n) && (l = !0);
                        else {
                            if (this._targets) {
                                for (i = this._targets.length; --i > -1;)
                                    if (t === this._targets[i]) {
                                        s = this._propLookup[i] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[i] = e ? this._overwrittenProps[i] || {} : "all";
                                        break
                                    }
                            } else {
                                if (t !== this.target) return !1;
                                s = this._propLookup, r = this._overwrittenProps = e ? this._overwrittenProps || {} : "all"
                            }
                            if (s) {
                                if (c = e || s, u = e !== r && "all" !== r && e !== s && ("object" != typeof e || !e._tempKill), n && (O.onOverwrite || this.vars.onOverwrite)) {
                                    for (a in c) s[a] && (h || (h = []), h.push(a));
                                    if ((h || !e) && !ee(this, n, t, h)) return !1
                                }
                                for (a in c)(o = s[a]) && (d && (o.f ? o.t[o.p](o.s) : o.t[o.p] = o.s, l = !0), o.pg && o.t._kill(c) && (l = !0), o.pg && 0 !== o.t._overwriteProps.length || (o._prev ? o._prev._next = o._next : o === this._firstPT && (this._firstPT = o._next), o._next && (o._next._prev = o._prev), o._next = o._prev = null), delete s[a]), u && (r[a] = 1);
                                !this._firstPT && this._initted && this._enabled(!1, !1)
                            }
                        }
                        return l
                    }, l.invalidate = function () {
                        return this._notifyPluginsOfEnabled && O._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], L.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -p, this.render(Math.min(0, -this._delay))), this
                    }, l._enabled = function (e, t) {
                        if (u || c.wake(), e && this._gc) {
                            var n, i = this._targets;
                            if (i)
                                for (n = i.length; --n > -1;) this._siblings[n] = K(i[n], this, !0);
                            else this._siblings = K(this.target, this, !0)
                        }
                        return L.prototype._enabled.call(this, e, t), !(!this._notifyPluginsOfEnabled || !this._firstPT) && O._onPluginEvent(e ? "_onEnable" : "_onDisable", this)
                    }, O.to = function (e, t, n) {
                        return new O(e, t, n)
                    }, O.from = function (e, t, n) {
                        return n.runBackwards = !0, n.immediateRender = 0 != n.immediateRender, new O(e, t, n)
                    }, O.fromTo = function (e, t, n, i) {
                        return i.startAt = n, i.immediateRender = 0 != i.immediateRender && 0 != n.immediateRender, new O(e, t, i)
                    }, O.delayedCall = function (e, t, n, i, r) {
                        return new O(t, 0, {
                            delay: e,
                            onComplete: t,
                            onCompleteParams: n,
                            callbackScope: i,
                            onReverseComplete: t,
                            onReverseCompleteParams: n,
                            immediateRender: !1,
                            lazy: !1,
                            useFrames: r,
                            overwrite: 0
                        })
                    }, O.set = function (e, t) {
                        return new O(e, 0, t)
                    }, O.getTweensOf = function (e, t) {
                        if (null == e) return [];
                        e = "string" != typeof e ? e : O.selector(e) || e;
                        var n, i, r, a;
                        if ((v(e) || k(e)) && "number" != typeof e[0]) {
                            for (n = e.length, i = []; --n > -1;) i = i.concat(O.getTweensOf(e[n], t));
                            for (n = i.length; --n > -1;)
                                for (a = i[n], r = n; --r > -1;) a === i[r] && i.splice(n, 1)
                        } else if (e._gsTweenID)
                            for (i = K(e).concat(), n = i.length; --n > -1;)(i[n]._gc || t && !i[n].isActive()) && i.splice(n, 1);
                        return i || []
                    }, O.killTweensOf = O.killDelayedCallsTo = function (e, t, n) {
                        "object" == typeof t && (n = t, t = !1);
                        for (var i = O.getTweensOf(e, t), r = i.length; --r > -1;) i[r]._kill(n, e)
                    };
                    var ie = b("plugins.TweenPlugin", function (e, t) {
                        this._overwriteProps = (e || "").split(","), this._propName = this._overwriteProps[0], this._priority = t || 0, this._super = ie.prototype
                    }, !0);
                    if (l = ie.prototype, ie.version = "1.19.0", ie.API = 2, l._firstPT = null, l._addTween = G, l.setRatio = j, l._kill = function (e) {
                            var t, n = this._overwriteProps,
                                i = this._firstPT;
                            if (null != e[this._propName]) this._overwriteProps = [];
                            else
                                for (t = n.length; --t > -1;) null != e[n[t]] && n.splice(t, 1);
                            for (; i;) null != e[i.n] && (i._next && (i._next._prev = i._prev), i._prev ? (i._prev._next = i._next, i._prev = null) : this._firstPT === i && (this._firstPT = i._next)), i = i._next;
                            return !1
                        }, l._mod = l._roundProps = function (e) {
                            for (var t, n = this._firstPT; n;) t = e[this._propName] || null != n.n && e[n.n.split(this._propName + "_").join("")], t && "function" == typeof t && (2 === n.f ? n.t._applyPT.m = t : n.m = t), n = n._next
                        }, O._onPluginEvent = function (e, t) {
                            var n, i, r, a, o, s = t._firstPT;
                            if ("_onInitAllProps" === e) {
                                for (; s;) {
                                    for (o = s._next, i = r; i && i.pr > s.pr;) i = i._next;
                                    (s._prev = i ? i._prev : a) ? s._prev._next = s: r = s, (s._next = i) ? i._prev = s : a = s, s = o
                                }
                                s = t._firstPT = r
                            }
                            for (; s;) s.pg && "function" == typeof s.t[e] && s.t[e]() && (n = !0), s = s._next;
                            return n
                        }, ie.activate = function (e) {
                            for (var t = e.length; --t > -1;) e[t].API === ie.API && (V[(new e[t])._propName] = e[t]);
                            return !0
                        }, x.plugin = function (e) {
                            if (!(e && e.propName && e.init && e.API)) throw "illegal plugin definition.";
                            var t, n = e.propName,
                                i = e.priority || 0,
                                r = e.overwriteProps,
                                a = {
                                    init: "_onInitTween",
                                    set: "setRatio",
                                    kill: "_kill",
                                    round: "_mod",
                                    mod: "_mod",
                                    initAll: "_onInitAllProps"
                                },
                                o = b("plugins." + n.charAt(0).toUpperCase() + n.substr(1) + "Plugin", function () {
                                    ie.call(this, n, i), this._overwriteProps = r || []
                                }, e.global === !0),
                                s = o.prototype = new ie(n);
                            s.constructor = o, o.API = e.API;
                            for (t in a) "function" == typeof e[t] && (s[a[t]] = e[t]);
                            return o.version = e.version, ie.activate([o]), o
                        }, o = e._gsQueue) {
                        for (s = 0; s < o.length; s++) o[s]();
                        for (l in g) g[l].func || e.console.log("GSAP encountered missing dependency: " + l)
                    }
                    u = !1
                }("undefined" != typeof t && t.exports && "undefined" != typeof e ? e : this || window, "TweenMax")
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}],
    36: [function (e, t, n) {
        ! function (e, n, i, r) {
            "use strict";

            function a(e, t, n) {
                return setTimeout(u(e, n), t)
            }

            function o(e, t, n) {
                return !!Array.isArray(e) && (s(e, n[t], n), !0)
            }

            function s(e, t, n) {
                var i;
                if (e)
                    if (e.forEach) e.forEach(t, n);
                    else if (e.length !== r)
                    for (i = 0; i < e.length;) t.call(n, e[i], i, e), i++;
                else
                    for (i in e) e.hasOwnProperty(i) && t.call(n, e[i], i, e)
            }

            function l(t, n, i) {
                var r = "DEPRECATED METHOD: " + n + "\n" + i + " AT \n";
                return function () {
                    var n = new Error("get-stack-trace"),
                        i = n && n.stack ? n.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace",
                        a = e.console && (e.console.warn || e.console.log);
                    return a && a.call(e.console, r, i), t.apply(this, arguments)
                }
            }

            function c(e, t, n) {
                var i, r = t.prototype;
                i = e.prototype = Object.create(r), i.constructor = e, i._super = r, n && de(i, n)
            }

            function u(e, t) {
                return function () {
                    return e.apply(t, arguments)
                }
            }

            function h(e, t) {
                return typeof e == me ? e.apply(t ? t[0] || r : r, t) : e
            }

            function d(e, t) {
                return e === r ? t : e
            }

            function p(e, t, n) {
                s(g(t), function (t) {
                    e.addEventListener(t, n, !1)
                })
            }

            function f(e, t, n) {
                s(g(t), function (t) {
                    e.removeEventListener(t, n, !1)
                })
            }

            function m(e, t) {
                for (; e;) {
                    if (e == t) return !0;
                    e = e.parentNode
                }
                return !1
            }

            function v(e, t) {
                return e.indexOf(t) > -1
            }

            function g(e) {
                return e.trim().split(/\s+/g)
            }

            function y(e, t, n) {
                if (e.indexOf && !n) return e.indexOf(t);
                for (var i = 0; i < e.length;) {
                    if (n && e[i][n] == t || !n && e[i] === t) return i;
                    i++
                }
                return -1
            }

            function x(e) {
                return Array.prototype.slice.call(e, 0)
            }

            function b(e, t, n) {
                for (var i = [], r = [], a = 0; a < e.length;) {
                    var o = t ? e[a][t] : e[a];
                    y(r, o) < 0 && i.push(e[a]), r[a] = o, a++
                }
                return n && (i = t ? i.sort(function (e, n) {
                    return e[t] > n[t]
                }) : i.sort()), i
            }

            function _(e, t) {
                for (var n, i, a = t[0].toUpperCase() + t.slice(1), o = 0; o < pe.length;) {
                    if (n = pe[o], i = n ? n + a : t, i in e) return i;
                    o++
                }
                return r
            }

            function w() {
                return _e++
            }

            function M(t) {
                var n = t.ownerDocument || t;
                return n.defaultView || n.parentWindow || e
            }

            function T(e, t) {
                var n = this;
                this.manager = e, this.callback = t, this.element = e.element, this.target = e.options.inputTarget, this.domHandler = function (t) {
                    h(e.options.enable, [e]) && n.handler(t)
                }, this.init()
            }

            function E(e) {
                var t, n = e.options.inputClass;
                return new(t = n ? n : Te ? U : Ee ? G : Me ? V : N)(e, S)
            }

            function S(e, t, n) {
                var i = n.pointers.length,
                    r = n.changedPointers.length,
                    a = t & Re && i - r === 0,
                    o = t & (Oe | ke) && i - r === 0;
                n.isFirst = !!a, n.isFinal = !!o, a && (e.session = {}), n.eventType = t, P(e, n), e.emit("hammer.input", n), e.recognize(n), e.session.prevInput = n
            }

            function P(e, t) {
                var n = e.session,
                    i = t.pointers,
                    r = i.length;
                n.firstInput || (n.firstInput = L(t)), r > 1 && !n.firstMultiple ? n.firstMultiple = L(t) : 1 === r && (n.firstMultiple = !1);
                var a = n.firstInput,
                    o = n.firstMultiple,
                    s = o ? o.center : a.center,
                    l = t.center = R(i);
                t.timeStamp = ye(), t.deltaTime = t.timeStamp - a.timeStamp, t.angle = D(s, l), t.distance = k(s, l), C(n, t), t.offsetDirection = O(t.deltaX, t.deltaY);
                var c = I(t.deltaTime, t.deltaX, t.deltaY);
                t.overallVelocityX = c.x, t.overallVelocityY = c.y, t.overallVelocity = ge(c.x) > ge(c.y) ? c.x : c.y, t.scale = o ? B(o.pointers, i) : 1, t.rotation = o ? z(o.pointers, i) : 0, t.maxPointers = n.prevInput ? t.pointers.length > n.prevInput.maxPointers ? t.pointers.length : n.prevInput.maxPointers : t.pointers.length, A(n, t);
                var u = e.element;
                m(t.srcEvent.target, u) && (u = t.srcEvent.target), t.target = u
            }

            function C(e, t) {
                var n = t.center,
                    i = e.offsetDelta || {},
                    r = e.prevDelta || {},
                    a = e.prevInput || {};
                t.eventType !== Re && a.eventType !== Oe || (r = e.prevDelta = {
                    x: a.deltaX || 0,
                    y: a.deltaY || 0
                }, i = e.offsetDelta = {
                    x: n.x,
                    y: n.y
                }), t.deltaX = r.x + (n.x - i.x), t.deltaY = r.y + (n.y - i.y)
            }

            function A(e, t) {
                var n, i, a, o, s = e.lastInterval || t,
                    l = t.timeStamp - s.timeStamp;
                if (t.eventType != ke && (l > Le || s.velocity === r)) {
                    var c = t.deltaX - s.deltaX,
                        u = t.deltaY - s.deltaY,
                        h = I(l, c, u);
                    i = h.x, a = h.y, n = ge(h.x) > ge(h.y) ? h.x : h.y, o = O(c, u), e.lastInterval = t
                } else n = s.velocity, i = s.velocityX, a = s.velocityY, o = s.direction;
                t.velocity = n, t.velocityX = i, t.velocityY = a, t.direction = o
            }

            function L(e) {
                for (var t = [], n = 0; n < e.pointers.length;) t[n] = {
                    clientX: ve(e.pointers[n].clientX),
                    clientY: ve(e.pointers[n].clientY)
                }, n++;
                return {
                    timeStamp: ye(),
                    pointers: t,
                    center: R(t),
                    deltaX: e.deltaX,
                    deltaY: e.deltaY
                }
            }

            function R(e) {
                var t = e.length;
                if (1 === t) return {
                    x: ve(e[0].clientX),
                    y: ve(e[0].clientY)
                };
                for (var n = 0, i = 0, r = 0; r < t;) n += e[r].clientX, i += e[r].clientY, r++;
                return {
                    x: ve(n / t),
                    y: ve(i / t)
                }
            }

            function I(e, t, n) {
                return {
                    x: t / e || 0,
                    y: n / e || 0
                }
            }

            function O(e, t) {
                return e === t ? De : ge(e) >= ge(t) ? e < 0 ? ze : Be : t < 0 ? Ne : Ue
            }

            function k(e, t, n) {
                n || (n = He);
                var i = t[n[0]] - e[n[0]],
                    r = t[n[1]] - e[n[1]];
                return Math.sqrt(i * i + r * r)
            }

            function D(e, t, n) {
                n || (n = He);
                var i = t[n[0]] - e[n[0]],
                    r = t[n[1]] - e[n[1]];
                return 180 * Math.atan2(r, i) / Math.PI
            }

            function z(e, t) {
                return D(t[1], t[0], Ve) + D(e[1], e[0], Ve)
            }

            function B(e, t) {
                return k(t[0], t[1], Ve) / k(e[0], e[1], Ve)
            }

            function N() {
                this.evEl = qe, this.evWin = Xe, this.pressed = !1, T.apply(this, arguments)
            }

            function U() {
                this.evEl = Je, this.evWin = $e, T.apply(this, arguments), this.store = this.manager.session.pointerEvents = []
            }

            function j() {
                this.evTarget = Ke, this.evWin = et, this.started = !1, T.apply(this, arguments)
            }

            function F(e, t) {
                var n = x(e.touches),
                    i = x(e.changedTouches);
                return t & (Oe | ke) && (n = b(n.concat(i), "identifier", !0)), [n, i]
            }

            function G() {
                this.evTarget = nt, this.targetIds = {}, T.apply(this, arguments)
            }

            function H(e, t) {
                var n = x(e.touches),
                    i = this.targetIds;
                if (t & (Re | Ie) && 1 === n.length) return i[n[0].identifier] = !0, [n, n];
                var r, a, o = x(e.changedTouches),
                    s = [],
                    l = this.target;
                if (a = n.filter(function (e) {
                        return m(e.target, l)
                    }), t === Re)
                    for (r = 0; r < a.length;) i[a[r].identifier] = !0, r++;
                for (r = 0; r < o.length;) i[o[r].identifier] && s.push(o[r]), t & (Oe | ke) && delete i[o[r].identifier], r++;
                return s.length ? [b(a.concat(s), "identifier", !0), s] : void 0
            }

            function V() {
                T.apply(this, arguments);
                var e = u(this.handler, this);
                this.touch = new G(this.manager, e), this.mouse = new N(this.manager, e), this.primaryTouch = null, this.lastTouches = []
            }

            function W(e, t) {
                e & Re ? (this.primaryTouch = t.changedPointers[0].identifier, q.call(this, t)) : e & (Oe | ke) && q.call(this, t)
            }

            function q(e) {
                var t = e.changedPointers[0];
                if (t.identifier === this.primaryTouch) {
                    var n = {
                        x: t.clientX,
                        y: t.clientY
                    };
                    this.lastTouches.push(n);
                    var i = this.lastTouches,
                        r = function () {
                            var e = i.indexOf(n);
                            e > -1 && i.splice(e, 1)
                        };
                    setTimeout(r, it)
                }
            }

            function X(e) {
                for (var t = e.srcEvent.clientX, n = e.srcEvent.clientY, i = 0; i < this.lastTouches.length; i++) {
                    var r = this.lastTouches[i],
                        a = Math.abs(t - r.x),
                        o = Math.abs(n - r.y);
                    if (a <= rt && o <= rt) return !0
                }
                return !1
            }

            function Y(e, t) {
                this.manager = e, this.set(t)
            }

            function Z(e) {
                if (v(e, ut)) return ut;
                var t = v(e, ht),
                    n = v(e, dt);
                return t && n ? ut : t || n ? t ? ht : dt : v(e, ct) ? ct : lt
            }

            function J() {
                if (!ot) return !1;
                var t = {},
                    n = e.CSS && e.CSS.supports;
                return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function (i) {
                    t[i] = !n || e.CSS.supports("touch-action", i)
                }), t
            }

            function $(e) {
                this.options = de({}, this.defaults, e || {}), this.id = w(), this.manager = null, this.options.enable = d(this.options.enable, !0), this.state = ft, this.simultaneous = {}, this.requireFail = []
            }

            function Q(e) {
                return e & xt ? "cancel" : e & gt ? "end" : e & vt ? "move" : e & mt ? "start" : ""
            }

            function K(e) {
                return e == Ue ? "down" : e == Ne ? "up" : e == ze ? "left" : e == Be ? "right" : ""
            }

            function ee(e, t) {
                var n = t.manager;
                return n ? n.get(e) : e
            }

            function te() {
                $.apply(this, arguments)
            }

            function ne() {
                te.apply(this, arguments), this.pX = null, this.pY = null
            }

            function ie() {
                te.apply(this, arguments)
            }

            function re() {
                $.apply(this, arguments), this._timer = null, this._input = null
            }

            function ae() {
                te.apply(this, arguments)
            }

            function oe() {
                te.apply(this, arguments)
            }

            function se() {
                $.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0
            }

            function le(e, t) {
                return t = t || {}, t.recognizers = d(t.recognizers, le.defaults.preset), new ce(e, t)
            }

            function ce(e, t) {
                this.options = de({}, le.defaults, t || {}), this.options.inputTarget = this.options.inputTarget || e, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = e, this.input = E(this), this.touchAction = new Y(this, this.options.touchAction), ue(this, !0), s(this.options.recognizers, function (e) {
                    var t = this.add(new e[0](e[1]));
                    e[2] && t.recognizeWith(e[2]), e[3] && t.requireFailure(e[3])
                }, this)
            }

            function ue(e, t) {
                var n = e.element;
                if (n.style) {
                    var i;
                    s(e.options.cssProps, function (r, a) {
                        i = _(n.style, a), t ? (e.oldCssProps[i] = n.style[i], n.style[i] = r) : n.style[i] = e.oldCssProps[i] || ""
                    }), t || (e.oldCssProps = {})
                }
            }

            function he(e, t) {
                var i = n.createEvent("Event");
                i.initEvent(e, !0, !0), i.gesture = t, t.target.dispatchEvent(i)
            }
            var de, pe = ["", "webkit", "Moz", "MS", "ms", "o"],
                fe = n.createElement("div"),
                me = "function",
                ve = Math.round,
                ge = Math.abs,
                ye = Date.now;
            de = "function" != typeof Object.assign ? function (e) {
                if (e === r || null === e) throw new TypeError("Cannot convert undefined or null to object");
                for (var t = Object(e), n = 1; n < arguments.length; n++) {
                    var i = arguments[n];
                    if (i !== r && null !== i)
                        for (var a in i) i.hasOwnProperty(a) && (t[a] = i[a])
                }
                return t
            } : Object.assign;
            var xe = l(function (e, t, n) {
                    for (var i = Object.keys(t), a = 0; a < i.length;)(!n || n && e[i[a]] === r) && (e[i[a]] = t[i[a]]), a++;
                    return e
                }, "extend", "Use `assign`."),
                be = l(function (e, t) {
                    return xe(e, t, !0)
                }, "merge", "Use `assign`."),
                _e = 1,
                we = /mobile|tablet|ip(ad|hone|od)|android/i,
                Me = "ontouchstart" in e,
                Te = _(e, "PointerEvent") !== r,
                Ee = Me && we.test(navigator.userAgent),
                Se = "touch",
                Pe = "pen",
                Ce = "mouse",
                Ae = "kinect",
                Le = 25,
                Re = 1,
                Ie = 2,
                Oe = 4,
                ke = 8,
                De = 1,
                ze = 2,
                Be = 4,
                Ne = 8,
                Ue = 16,
                je = ze | Be,
                Fe = Ne | Ue,
                Ge = je | Fe,
                He = ["x", "y"],
                Ve = ["clientX", "clientY"];
            T.prototype = {
                handler: function () {},
                init: function () {
                    this.evEl && p(this.element, this.evEl, this.domHandler), this.evTarget && p(this.target, this.evTarget, this.domHandler), this.evWin && p(M(this.element), this.evWin, this.domHandler)
                },
                destroy: function () {
                    this.evEl && f(this.element, this.evEl, this.domHandler), this.evTarget && f(this.target, this.evTarget, this.domHandler), this.evWin && f(M(this.element), this.evWin, this.domHandler)
                }
            };
            var We = {
                    mousedown: Re,
                    mousemove: Ie,
                    mouseup: Oe
                },
                qe = "mousedown",
                Xe = "mousemove mouseup";
            c(N, T, {
                handler: function (e) {
                    var t = We[e.type];
                    t & Re && 0 === e.button && (this.pressed = !0), t & Ie && 1 !== e.which && (t = Oe), this.pressed && (t & Oe && (this.pressed = !1), this.callback(this.manager, t, {
                        pointers: [e],
                        changedPointers: [e],
                        pointerType: Ce,
                        srcEvent: e
                    }))
                }
            });
            var Ye = {
                    pointerdown: Re,
                    pointermove: Ie,
                    pointerup: Oe,
                    pointercancel: ke,
                    pointerout: ke
                },
                Ze = {
                    2: Se,
                    3: Pe,
                    4: Ce,
                    5: Ae
                },
                Je = "pointerdown",
                $e = "pointermove pointerup pointercancel";
            e.MSPointerEvent && !e.PointerEvent && (Je = "MSPointerDown", $e = "MSPointerMove MSPointerUp MSPointerCancel"), c(U, T, {
                handler: function (e) {
                    var t = this.store,
                        n = !1,
                        i = e.type.toLowerCase().replace("ms", ""),
                        r = Ye[i],
                        a = Ze[e.pointerType] || e.pointerType,
                        o = a == Se,
                        s = y(t, e.pointerId, "pointerId");
                    r & Re && (0 === e.button || o) ? s < 0 && (t.push(e), s = t.length - 1) : r & (Oe | ke) && (n = !0), s < 0 || (t[s] = e, this.callback(this.manager, r, {
                        pointers: t,
                        changedPointers: [e],
                        pointerType: a,
                        srcEvent: e
                    }), n && t.splice(s, 1))
                }
            });
            var Qe = {
                    touchstart: Re,
                    touchmove: Ie,
                    touchend: Oe,
                    touchcancel: ke
                },
                Ke = "touchstart",
                et = "touchstart touchmove touchend touchcancel";
            c(j, T, {
                handler: function (e) {
                    var t = Qe[e.type];
                    if (t === Re && (this.started = !0), this.started) {
                        var n = F.call(this, e, t);
                        t & (Oe | ke) && n[0].length - n[1].length === 0 && (this.started = !1), this.callback(this.manager, t, {
                            pointers: n[0],
                            changedPointers: n[1],
                            pointerType: Se,
                            srcEvent: e
                        })
                    }
                }
            });
            var tt = {
                    touchstart: Re,
                    touchmove: Ie,
                    touchend: Oe,
                    touchcancel: ke
                },
                nt = "touchstart touchmove touchend touchcancel";
            c(G, T, {
                handler: function (e) {
                    var t = tt[e.type],
                        n = H.call(this, e, t);
                    n && this.callback(this.manager, t, {
                        pointers: n[0],
                        changedPointers: n[1],
                        pointerType: Se,
                        srcEvent: e
                    })
                }
            });
            var it = 2500,
                rt = 25;
            c(V, T, {
                handler: function (e, t, n) {
                    var i = n.pointerType == Se,
                        r = n.pointerType == Ce;
                    if (!(r && n.sourceCapabilities && n.sourceCapabilities.firesTouchEvents)) {
                        if (i) W.call(this, t, n);
                        else if (r && X.call(this, n)) return;
                        this.callback(e, t, n)
                    }
                },
                destroy: function () {
                    this.touch.destroy(), this.mouse.destroy()
                }
            });
            var at = _(fe.style, "touchAction"),
                ot = at !== r,
                st = "compute",
                lt = "auto",
                ct = "manipulation",
                ut = "none",
                ht = "pan-x",
                dt = "pan-y",
                pt = J();
            Y.prototype = {
                set: function (e) {
                    e == st && (e = this.compute()), ot && this.manager.element.style && pt[e] && (this.manager.element.style[at] = e), this.actions = e.toLowerCase().trim()
                },
                update: function () {
                    this.set(this.manager.options.touchAction)
                },
                compute: function () {
                    var e = [];
                    return s(this.manager.recognizers, function (t) {
                        h(t.options.enable, [t]) && (e = e.concat(t.getTouchAction()))
                    }), Z(e.join(" "))
                },
                preventDefaults: function (e) {
                    var t = e.srcEvent,
                        n = e.offsetDirection;
                    if (this.manager.session.prevented) return void t.preventDefault();
                    var i = this.actions,
                        r = v(i, ut) && !pt[ut],
                        a = v(i, dt) && !pt[dt],
                        o = v(i, ht) && !pt[ht];
                    if (r) {
                        var s = 1 === e.pointers.length,
                            l = e.distance < 2,
                            c = e.deltaTime < 250;
                        if (s && l && c) return
                    }
                    return o && a ? void 0 : r || a && n & je || o && n & Fe ? this.preventSrc(t) : void 0
                },
                preventSrc: function (e) {
                    this.manager.session.prevented = !0, e.preventDefault()
                }
            };
            var ft = 1,
                mt = 2,
                vt = 4,
                gt = 8,
                yt = gt,
                xt = 16,
                bt = 32;
            $.prototype = {
                defaults: {},
                set: function (e) {
                    return de(this.options, e), this.manager && this.manager.touchAction.update(), this
                },
                recognizeWith: function (e) {
                    if (o(e, "recognizeWith", this)) return this;
                    var t = this.simultaneous;
                    return e = ee(e, this), t[e.id] || (t[e.id] = e, e.recognizeWith(this)), this
                },
                dropRecognizeWith: function (e) {
                    return o(e, "dropRecognizeWith", this) ? this : (e = ee(e, this), delete this.simultaneous[e.id], this)
                },
                requireFailure: function (e) {
                    if (o(e, "requireFailure", this)) return this;
                    var t = this.requireFail;
                    return e = ee(e, this), y(t, e) === -1 && (t.push(e), e.requireFailure(this)), this
                },
                dropRequireFailure: function (e) {
                    if (o(e, "dropRequireFailure", this)) return this;
                    e = ee(e, this);
                    var t = y(this.requireFail, e);
                    return t > -1 && this.requireFail.splice(t, 1), this
                },
                hasRequireFailures: function () {
                    return this.requireFail.length > 0
                },
                canRecognizeWith: function (e) {
                    return !!this.simultaneous[e.id]
                },
                emit: function (e) {
                    function t(t) {
                        n.manager.emit(t, e)
                    }
                    var n = this,
                        i = this.state;
                    i < gt && t(n.options.event + Q(i)), t(n.options.event), e.additionalEvent && t(e.additionalEvent), i >= gt && t(n.options.event + Q(i))
                },
                tryEmit: function (e) {
                    return this.canEmit() ? this.emit(e) : void(this.state = bt)
                },
                canEmit: function () {
                    for (var e = 0; e < this.requireFail.length;) {
                        if (!(this.requireFail[e].state & (bt | ft))) return !1;
                        e++
                    }
                    return !0
                },
                recognize: function (e) {
                    var t = de({}, e);
                    return h(this.options.enable, [this, t]) ? (this.state & (yt | xt | bt) && (this.state = ft), this.state = this.process(t), void(this.state & (mt | vt | gt | xt) && this.tryEmit(t))) : (this.reset(), void(this.state = bt))
                },
                process: function (e) {},
                getTouchAction: function () {},
                reset: function () {}
            }, c(te, $, {
                defaults: {
                    pointers: 1
                },
                attrTest: function (e) {
                    var t = this.options.pointers;
                    return 0 === t || e.pointers.length === t
                },
                process: function (e) {
                    var t = this.state,
                        n = e.eventType,
                        i = t & (mt | vt),
                        r = this.attrTest(e);
                    return i && (n & ke || !r) ? t | xt : i || r ? n & Oe ? t | gt : t & mt ? t | vt : mt : bt
                }
            }), c(ne, te, {
                defaults: {
                    event: "pan",
                    threshold: 10,
                    pointers: 1,
                    direction: Ge
                },
                getTouchAction: function () {
                    var e = this.options.direction,
                        t = [];
                    return e & je && t.push(dt), e & Fe && t.push(ht), t
                },
                directionTest: function (e) {
                    var t = this.options,
                        n = !0,
                        i = e.distance,
                        r = e.direction,
                        a = e.deltaX,
                        o = e.deltaY;
                    return r & t.direction || (t.direction & je ? (r = 0 === a ? De : a < 0 ? ze : Be, n = a != this.pX, i = Math.abs(e.deltaX)) : (r = 0 === o ? De : o < 0 ? Ne : Ue, n = o != this.pY, i = Math.abs(e.deltaY))), e.direction = r, n && i > t.threshold && r & t.direction
                },
                attrTest: function (e) {
                    return te.prototype.attrTest.call(this, e) && (this.state & mt || !(this.state & mt) && this.directionTest(e))
                },
                emit: function (e) {
                    this.pX = e.deltaX, this.pY = e.deltaY;
                    var t = K(e.direction);
                    t && (e.additionalEvent = this.options.event + t), this._super.emit.call(this, e)
                }
            }), c(ie, te, {
                defaults: {
                    event: "pinch",
                    threshold: 0,
                    pointers: 2
                },
                getTouchAction: function () {
                    return [ut]
                },
                attrTest: function (e) {
                    return this._super.attrTest.call(this, e) && (Math.abs(e.scale - 1) > this.options.threshold || this.state & mt)
                },
                emit: function (e) {
                    if (1 !== e.scale) {
                        var t = e.scale < 1 ? "in" : "out";
                        e.additionalEvent = this.options.event + t
                    }
                    this._super.emit.call(this, e)
                }
            }), c(re, $, {
                defaults: {
                    event: "press",
                    pointers: 1,
                    time: 251,
                    threshold: 9
                },
                getTouchAction: function () {
                    return [lt]
                },
                process: function (e) {
                    var t = this.options,
                        n = e.pointers.length === t.pointers,
                        i = e.distance < t.threshold,
                        r = e.deltaTime > t.time;
                    if (this._input = e, !i || !n || e.eventType & (Oe | ke) && !r) this.reset();
                    else if (e.eventType & Re) this.reset(), this._timer = a(function () {
                        this.state = yt, this.tryEmit()
                    }, t.time, this);
                    else if (e.eventType & Oe) return yt;
                    return bt
                },
                reset: function () {
                    clearTimeout(this._timer)
                },
                emit: function (e) {
                    this.state === yt && (e && e.eventType & Oe ? this.manager.emit(this.options.event + "up", e) : (this._input.timeStamp = ye(), this.manager.emit(this.options.event, this._input)))
                }
            }), c(ae, te, {
                defaults: {
                    event: "rotate",
                    threshold: 0,
                    pointers: 2
                },
                getTouchAction: function () {
                    return [ut]
                },
                attrTest: function (e) {
                    return this._super.attrTest.call(this, e) && (Math.abs(e.rotation) > this.options.threshold || this.state & mt)
                }
            }), c(oe, te, {
                defaults: {
                    event: "swipe",
                    threshold: 10,
                    velocity: .3,
                    direction: je | Fe,
                    pointers: 1
                },
                getTouchAction: function () {
                    return ne.prototype.getTouchAction.call(this)
                },
                attrTest: function (e) {
                    var t, n = this.options.direction;
                    return n & (je | Fe) ? t = e.overallVelocity : n & je ? t = e.overallVelocityX : n & Fe && (t = e.overallVelocityY), this._super.attrTest.call(this, e) && n & e.offsetDirection && e.distance > this.options.threshold && e.maxPointers == this.options.pointers && ge(t) > this.options.velocity && e.eventType & Oe
                },
                emit: function (e) {
                    var t = K(e.offsetDirection);
                    t && this.manager.emit(this.options.event + t, e), this.manager.emit(this.options.event, e)
                }
            }), c(se, $, {
                defaults: {
                    event: "tap",
                    pointers: 1,
                    taps: 1,
                    interval: 300,
                    time: 250,
                    threshold: 9,
                    posThreshold: 10
                },
                getTouchAction: function () {
                    return [ct]
                },
                process: function (e) {
                    var t = this.options,
                        n = e.pointers.length === t.pointers,
                        i = e.distance < t.threshold,
                        r = e.deltaTime < t.time;
                    if (this.reset(), e.eventType & Re && 0 === this.count) return this.failTimeout();
                    if (i && r && n) {
                        if (e.eventType != Oe) return this.failTimeout();
                        var o = !this.pTime || e.timeStamp - this.pTime < t.interval,
                            s = !this.pCenter || k(this.pCenter, e.center) < t.posThreshold;
                        this.pTime = e.timeStamp, this.pCenter = e.center, s && o ? this.count += 1 : this.count = 1, this._input = e;
                        var l = this.count % t.taps;
                        if (0 === l) return this.hasRequireFailures() ? (this._timer = a(function () {
                            this.state = yt, this.tryEmit()
                        }, t.interval, this), mt) : yt
                    }
                    return bt
                },
                failTimeout: function () {
                    return this._timer = a(function () {
                        this.state = bt
                    }, this.options.interval, this), bt
                },
                reset: function () {
                    clearTimeout(this._timer)
                },
                emit: function () {
                    this.state == yt && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input))
                }
            }), le.VERSION = "2.0.7", le.defaults = {
                domEvents: !1,
                touchAction: st,
                enable: !0,
                inputTarget: null,
                inputClass: null,
                preset: [
                    [ae, {
                        enable: !1
                    }],
                    [ie, {
                            enable: !1
                        },
                        ["rotate"]
                    ],
                    [oe, {
                        direction: je
                    }],
                    [ne, {
                            direction: je
                        },
                        ["swipe"]
                    ],
                    [se],
                    [se, {
                            event: "doubletap",
                            taps: 2
                        },
                        ["tap"]
                    ],
                    [re]
                ],
                cssProps: {
                    userSelect: "none",
                    touchSelect: "none",
                    touchCallout: "none",
                    contentZooming: "none",
                    userDrag: "none",
                    tapHighlightColor: "rgba(0,0,0,0)"
                }
            };
            var _t = 1,
                wt = 2;
            ce.prototype = {
                set: function (e) {
                    return de(this.options, e), e.touchAction && this.touchAction.update(), e.inputTarget && (this.input.destroy(), this.input.target = e.inputTarget, this.input.init()), this
                },
                stop: function (e) {
                    this.session.stopped = e ? wt : _t
                },
                recognize: function (e) {
                    var t = this.session;
                    if (!t.stopped) {
                        this.touchAction.preventDefaults(e);
                        var n, i = this.recognizers,
                            r = t.curRecognizer;
                        (!r || r && r.state & yt) && (r = t.curRecognizer = null);
                        for (var a = 0; a < i.length;) n = i[a], t.stopped === wt || r && n != r && !n.canRecognizeWith(r) ? n.reset() : n.recognize(e), !r && n.state & (mt | vt | gt) && (r = t.curRecognizer = n), a++
                    }
                },
                get: function (e) {
                    if (e instanceof $) return e;
                    for (var t = this.recognizers, n = 0; n < t.length; n++)
                        if (t[n].options.event == e) return t[n];
                    return null
                },
                add: function (e) {
                    if (o(e, "add", this)) return this;
                    var t = this.get(e.options.event);
                    return t && this.remove(t), this.recognizers.push(e), e.manager = this, this.touchAction.update(), e
                },
                remove: function (e) {
                    if (o(e, "remove", this)) return this;
                    if (e = this.get(e)) {
                        var t = this.recognizers,
                            n = y(t, e);
                        n !== -1 && (t.splice(n, 1), this.touchAction.update())
                    }
                    return this
                },
                on: function (e, t) {
                    if (e !== r && t !== r) {
                        var n = this.handlers;
                        return s(g(e), function (e) {
                            n[e] = n[e] || [], n[e].push(t)
                        }), this
                    }
                },
                off: function (e, t) {
                    if (e !== r) {
                        var n = this.handlers;
                        return s(g(e), function (e) {
                            t ? n[e] && n[e].splice(y(n[e], t), 1) : delete n[e]
                        }), this
                    }
                },
                emit: function (e, t) {
                    this.options.domEvents && he(e, t);
                    var n = this.handlers[e] && this.handlers[e].slice();
                    if (n && n.length) {
                        t.type = e, t.preventDefault = function () {
                            t.srcEvent.preventDefault()
                        };
                        for (var i = 0; i < n.length;) n[i](t), i++
                    }
                },
                destroy: function () {
                    this.element && ue(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null
                }
            }, de(le, {
                INPUT_START: Re,
                INPUT_MOVE: Ie,
                INPUT_END: Oe,
                INPUT_CANCEL: ke,
                STATE_POSSIBLE: ft,
                STATE_BEGAN: mt,
                STATE_CHANGED: vt,
                STATE_ENDED: gt,
                STATE_RECOGNIZED: yt,
                STATE_CANCELLED: xt,
                STATE_FAILED: bt,
                DIRECTION_NONE: De,
                DIRECTION_LEFT: ze,
                DIRECTION_RIGHT: Be,
                DIRECTION_UP: Ne,
                DIRECTION_DOWN: Ue,
                DIRECTION_HORIZONTAL: je,
                DIRECTION_VERTICAL: Fe,
                DIRECTION_ALL: Ge,
                Manager: ce,
                Input: T,
                TouchAction: Y,
                TouchInput: G,
                MouseInput: N,
                PointerEventInput: U,
                TouchMouseInput: V,
                SingleTouchInput: j,
                Recognizer: $,
                AttrRecognizer: te,
                Tap: se,
                Pan: ne,
                Swipe: oe,
                Pinch: ie,
                Rotate: ae,
                Press: re,
                on: p,
                off: f,
                each: s,
                merge: be,
                extend: xe,
                assign: de,
                inherit: c,
                bindFn: u,
                prefixed: _
            });
            var Mt = "undefined" != typeof e ? e : "undefined" != typeof self ? self : {};
            Mt.Hammer = le, "function" == typeof define && define.amd ? define(function () {
                return le
            }) : "undefined" != typeof t && t.exports ? t.exports = le : e[i] = le
        }(window, document, "Hammer")
    }, {}],
    37: [function (e, t, n) {
        "function" == typeof Object.create ? t.exports = function (e, t) {
            e.super_ = t, e.prototype = Object.create(t.prototype, {
                constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            })
        } : t.exports = function (e, t) {
            e.super_ = t;
            var n = function () {};
            n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e
        }
    }, {}],
    38: [function (e, t, n) {
        ! function (e, t) {
            "use strict";

            function n(e) {
                this.time = e.time, this.target = e.target, this.rootBounds = e.rootBounds, this.boundingClientRect = e.boundingClientRect, this.intersectionRect = e.intersectionRect || u(), this.isIntersecting = !!e.intersectionRect;
                var t = this.boundingClientRect,
                    n = t.width * t.height,
                    i = this.intersectionRect,
                    r = i.width * i.height;
                n ? this.intersectionRatio = Number((r / n).toFixed(4)) : this.intersectionRatio = this.isIntersecting ? 1 : 0
            }

            function i(e, t) {
                var n = t || {};
                if ("function" != typeof e) throw new Error("callback must be a function");
                if (n.root && 1 != n.root.nodeType) throw new Error("root must be an Element");
                this._checkForIntersections = a(this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT), this._callback = e, this._observationTargets = [], this._queuedEntries = [], this._rootMarginValues = this._parseRootMargin(n.rootMargin), this.thresholds = this._initThresholds(n.threshold), this.root = n.root || null, this.rootMargin = this._rootMarginValues.map(function (e) {
                    return e.value + e.unit
                }).join(" ")
            }

            function r() {
                return e.performance && performance.now && performance.now()
            }

            function a(e, t) {
                var n = null;
                return function () {
                    n || (n = setTimeout(function () {
                        e(), n = null
                    }, t))
                }
            }

            function o(e, t, n, i) {
                "function" == typeof e.addEventListener ? e.addEventListener(t, n, i || !1) : "function" == typeof e.attachEvent && e.attachEvent("on" + t, n)
            }

            function s(e, t, n, i) {
                "function" == typeof e.removeEventListener ? e.removeEventListener(t, n, i || !1) : "function" == typeof e.detatchEvent && e.detatchEvent("on" + t, n)
            }

            function l(e, t) {
                var n = Math.max(e.top, t.top),
                    i = Math.min(e.bottom, t.bottom),
                    r = Math.max(e.left, t.left),
                    a = Math.min(e.right, t.right),
                    o = a - r,
                    s = i - n;
                return o >= 0 && s >= 0 && {
                    top: n,
                    bottom: i,
                    left: r,
                    right: a,
                    width: o,
                    height: s
                }
            }

            function c(e) {
                var t;
                try {
                    t = e.getBoundingClientRect()
                } catch (n) {}
                return t ? (t.width && t.height || (t = {
                    top: t.top,
                    right: t.right,
                    bottom: t.bottom,
                    left: t.left,
                    width: t.right - t.left,
                    height: t.bottom - t.top
                }), t) : u()
            }

            function u() {
                return {
                    top: 0,
                    bottom: 0,
                    left: 0,
                    right: 0,
                    width: 0,
                    height: 0
                }
            }

            function h(e, t) {
                for (var n = t; n;) {
                    if (n == e) return !0;
                    n = d(n)
                }
                return !1
            }

            function d(e) {
                var t = e.parentNode;
                return t && 11 == t.nodeType && t.host ? t.host : t
            }
            if ("IntersectionObserver" in e && "IntersectionObserverEntry" in e && "intersectionRatio" in e.IntersectionObserverEntry.prototype) return void("isIntersecting" in e.IntersectionObserverEntry.prototype || Object.defineProperty(e.IntersectionObserverEntry.prototype, "isIntersecting", {
                get: function () {
                    return this.intersectionRatio > 0
                }
            }));
            var p = [];
            i.prototype.THROTTLE_TIMEOUT = 100, i.prototype.POLL_INTERVAL = null, i.prototype.USE_MUTATION_OBSERVER = !0, i.prototype.observe = function (e) {
                var t = this._observationTargets.some(function (t) {
                    return t.element == e
                });
                if (!t) {
                    if (!e || 1 != e.nodeType) throw new Error("target must be an Element");
                    this._registerInstance(), this._observationTargets.push({
                        element: e,
                        entry: null
                    }), this._monitorIntersections(), this._checkForIntersections()
                }
            }, i.prototype.unobserve = function (e) {
                this._observationTargets = this._observationTargets.filter(function (t) {
                    return t.element != e
                }), this._observationTargets.length || (this._unmonitorIntersections(), this._unregisterInstance())
            }, i.prototype.disconnect = function () {
                this._observationTargets = [], this._unmonitorIntersections(), this._unregisterInstance()
            }, i.prototype.takeRecords = function () {
                var e = this._queuedEntries.slice();
                return this._queuedEntries = [], e
            }, i.prototype._initThresholds = function (e) {
                var t = e || [0];
                return Array.isArray(t) || (t = [t]), t.sort().filter(function (e, t, n) {
                    if ("number" != typeof e || isNaN(e) || e < 0 || e > 1) throw new Error("threshold must be a number between 0 and 1 inclusively");
                    return e !== n[t - 1]
                })
            }, i.prototype._parseRootMargin = function (e) {
                var t = e || "0px",
                    n = t.split(/\s+/).map(function (e) {
                        var t = /^(-?\d*\.?\d+)(px|%)$/.exec(e);
                        if (!t) throw new Error("rootMargin must be specified in pixels or percent");
                        return {
                            value: parseFloat(t[1]),
                            unit: t[2]
                        }
                    });
                return n[1] = n[1] || n[0], n[2] = n[2] || n[0], n[3] = n[3] || n[1], n
            }, i.prototype._monitorIntersections = function () {
                this._monitoringIntersections || (this._monitoringIntersections = !0, this.POLL_INTERVAL ? this._monitoringInterval = setInterval(this._checkForIntersections, this.POLL_INTERVAL) : (o(e, "resize", this._checkForIntersections, !0), o(t, "scroll", this._checkForIntersections, !0), this.USE_MUTATION_OBSERVER && "MutationObserver" in e && (this._domObserver = new MutationObserver(this._checkForIntersections), this._domObserver.observe(t, {
                    attributes: !0,
                    childList: !0,
                    characterData: !0,
                    subtree: !0
                }))))
            }, i.prototype._unmonitorIntersections = function () {
                this._monitoringIntersections && (this._monitoringIntersections = !1, clearInterval(this._monitoringInterval), this._monitoringInterval = null, s(e, "resize", this._checkForIntersections, !0), s(t, "scroll", this._checkForIntersections, !0), this._domObserver && (this._domObserver.disconnect(), this._domObserver = null))
            }, i.prototype._checkForIntersections = function () {
                var e = this._rootIsInDom(),
                    t = e ? this._getRootRect() : u();
                this._observationTargets.forEach(function (i) {
                    var a = i.element,
                        o = c(a),
                        s = this._rootContainsTarget(a),
                        l = i.entry,
                        u = e && s && this._computeTargetAndRootIntersection(a, t),
                        h = i.entry = new n({
                            time: r(),
                            target: a,
                            boundingClientRect: o,
                            rootBounds: t,
                            intersectionRect: u
                        });
                    l ? e && s ? this._hasCrossedThreshold(l, h) && this._queuedEntries.push(h) : l && l.isIntersecting && this._queuedEntries.push(h) : this._queuedEntries.push(h)
                }, this), this._queuedEntries.length && this._callback(this.takeRecords(), this)
            }, i.prototype._computeTargetAndRootIntersection = function (n, i) {
                if ("none" != e.getComputedStyle(n).display) {
                    for (var r = c(n), a = r, o = d(n), s = !1; !s;) {
                        var u = null,
                            h = 1 == o.nodeType ? e.getComputedStyle(o) : {};
                        if ("none" == h.display) return;
                        if (o == this.root || o == t ? (s = !0, u = i) : o != t.body && o != t.documentElement && "visible" != h.overflow && (u = c(o)), u && (a = l(u, a), !a)) break;
                        o = d(o)
                    }
                    return a
                }
            }, i.prototype._getRootRect = function () {
                var e;
                if (this.root) e = c(this.root);
                else {
                    var n = t.documentElement,
                        i = t.body;
                    e = {
                        top: 0,
                        left: 0,
                        right: n.clientWidth || i.clientWidth,
                        width: n.clientWidth || i.clientWidth,
                        bottom: n.clientHeight || i.clientHeight,
                        height: n.clientHeight || i.clientHeight
                    }
                }
                return this._expandRectByRootMargin(e)
            }, i.prototype._expandRectByRootMargin = function (e) {
                var t = this._rootMarginValues.map(function (t, n) {
                        return "px" == t.unit ? t.value : t.value * (n % 2 ? e.width : e.height) / 100
                    }),
                    n = {
                        top: e.top - t[0],
                        right: e.right + t[1],
                        bottom: e.bottom + t[2],
                        left: e.left - t[3]
                    };
                return n.width = n.right - n.left, n.height = n.bottom - n.top, n
            }, i.prototype._hasCrossedThreshold = function (e, t) {
                var n = e && e.isIntersecting ? e.intersectionRatio || 0 : -1,
                    i = t.isIntersecting ? t.intersectionRatio || 0 : -1;
                if (n !== i)
                    for (var r = 0; r < this.thresholds.length; r++) {
                        var a = this.thresholds[r];
                        if (a == n || a == i || a < n != a < i) return !0
                    }
            }, i.prototype._rootIsInDom = function () {
                return !this.root || h(t, this.root)
            }, i.prototype._rootContainsTarget = function (e) {
                return h(this.root || t, e)
            }, i.prototype._registerInstance = function () {
                p.indexOf(this) < 0 && p.push(this)
            }, i.prototype._unregisterInstance = function () {
                var e = p.indexOf(this);
                e != -1 && p.splice(e, 1)
            }, e.IntersectionObserver = i, e.IntersectionObserverEntry = n
        }(window, document)
    }, {}],
    39: [function (e, t, n) {
        "use strict";

        function i(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }
        var r = function () {
            function e(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var i = t[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                }
            }
            return function (t, n, i) {
                return n && e(t.prototype, n), i && e(t, i), t
            }
        }();
        t.exports = function () {
            function e() {
                i(this, e), this.cb = function () {}, this.speedX = 0, this.speedY = 0, this.oldX = 0, this.oldY = 0, this.firstCalc = !0, this.timerId, this.calcSpeed = this.calcSpeed.bind(this)
            }
            return r(e, [{
                key: "calcSpeed",
                value: function (e) {
                    this.firstCalc ? (this.oldX = e.clientX, this.oldY = e.clientY, this.firstCalc = !1) : (this.speedX = e.clientX - this.oldX, this.speedY = e.clientY - this.oldY, this.oldX = e.clientX, this.oldY = e.clientY, this.cb(), this.setToZero())
                }
            }, {
                key: "setToZero",
                value: function () {
                    var e = this;
                    clearTimeout(this.timerId), this.timerId = setTimeout(function () {
                        e.speedX = 0, e.speedY = 0, e.cb()
                    }, 50)
                }
            }, {
                key: "init",
                value: function () {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : function () {
                        console.log("pass a callback function on init to access speedX and speedY.")
                    };
                    this.cb = e, window.addEventListener("mousemove", this.calcSpeed)
                }
            }, {
                key: "destroy",
                value: function (e) {
                    window.removeEventListener("mousemove", this.calcSpeed), e()
                }
            }]), e
        }()
    }, {}],
    40: [function (e, t, n) {
        var i = function (e) {
            "use strict";

            function t(e) {
                for (var t = getComputedStyle(e).fontFamily, n = null, i = {}; null !== (n = u.exec(t));) i[n[1]] = n[2];
                return i["object-position"] ? r(i) : i
            }

            function n(e) {
                var n = -1;
                e ? "length" in e || (e = [e]) : e = document.querySelectorAll("video");
                for (; e[++n];) {
                    var r = t(e[n]);
                    (r["object-fit"] || r["object-position"]) && (r["object-fit"] = r["object-fit"] || "fill", i(e[n], r))
                }
            }

            function i(e, t) {
                function n() {
                    var n = e.videoWidth,
                        r = e.videoHeight,
                        o = n / r,
                        s = a.clientWidth,
                        l = a.clientHeight,
                        c = s / l,
                        u = 0,
                        h = 0;
                    i.marginLeft = i.marginTop = 0, (o < c ? "contain" === t["object-fit"] : "cover" === t["object-fit"]) ? (u = l * o, h = s / o, i.width = Math.round(u) + "px", i.height = l + "px", "left" === t["object-position-x"] ? i.marginLeft = 0 : "right" === t["object-position-x"] ? i.marginLeft = Math.round(s - u) + "px" : i.marginLeft = Math.round((s - u) / 2) + "px") : (h = s / o, i.width = s + "px", i.height = Math.round(h) + "px", "top" === t["object-position-y"] ? i.marginTop = 0 : "bottom" === t["object-position-y"] ? i.marginTop = Math.round(l - h) + "px" : i.marginTop = Math.round((l - h) / 2) + "px"), e.autoplay && e.play()
                }
                if ("fill" !== t["object-fit"]) {
                    var i = e.style,
                        r = window.getComputedStyle(e),
                        a = document.createElement("object-fit");
                    a.appendChild(e.parentNode.replaceChild(a, e));
                    var o = {
                        height: "100%",
                        width: "100%",
                        boxSizing: "content-box",
                        display: "inline-block",
                        overflow: "hidden"
                    };
                    "backgroundColor backgroundImage borderColor borderStyle borderWidth bottom fontSize lineHeight left opacity margin position right top visibility".replace(/\w+/g, function (e) {
                        o[e] = r[e]
                    });
                    for (var s in o) a.style[s] = o[s];
                    i.border = i.margin = i.padding = 0, i.display = "block", i.opacity = 1, e.addEventListener("loadedmetadata", n), window.addEventListener("optimizedResize", n), e.readyState >= 1 && (e.removeEventListener("loadedmetadata", n), n())
                }
            }

            function r(e) {
                return ~e["object-position"].indexOf("left") ? e["object-position-x"] = "left" : ~e["object-position"].indexOf("right") ? e["object-position-x"] = "right" : e["object-position-x"] = "center", ~e["object-position"].indexOf("top") ? e["object-position-y"] = "top" : ~e["object-position"].indexOf("bottom") ? e["object-position-y"] = "bottom" : e["object-position-y"] = "center", e
            }

            function a(e, t, n) {
                n = n || window;
                var i = !1,
                    r = null;
                try {
                    r = new CustomEvent(t)
                } catch (a) {
                    r = document.createEvent("Event"), r.initEvent(t, !0, !0)
                }
                var o = function () {
                    i || (i = !0, requestAnimationFrame(function () {
                        n.dispatchEvent(r), i = !1
                    }))
                };
                n.addEventListener(e, o)
            }
            var o = navigator.userAgent.indexOf("Edge/") >= 0,
                s = new Image,
                l = "object-fit" in s.style && !o,
                c = "object-position" in s.style && !o,
                u = /(object-fit|object-position)\s*:\s*([-\w\s%]+)/g;
            l && c || (n(e), a("resize", "optimizedResize"))
        };
        "undefined" != typeof t && "undefined" != typeof t.exports && (t.exports = i);
    }, {}],
    41: [function (e, t, n) {
        (function (e) {
            (function () {
                var n, i, r, a, o, s;
                "undefined" != typeof performance && null !== performance && performance.now ? t.exports = function () {
                    return performance.now()
                } : "undefined" != typeof e && null !== e && e.hrtime ? (t.exports = function () {
                    return (n() - o) / 1e6
                }, i = e.hrtime, n = function () {
                    var e;
                    return e = i(), 1e9 * e[0] + e[1]
                }, a = n(), s = 1e9 * e.uptime(), o = a - s) : Date.now ? (t.exports = function () {
                    return Date.now() - r
                }, r = Date.now()) : (t.exports = function () {
                    return (new Date).getTime() - r
                }, r = (new Date).getTime())
            }).call(this)
        }).call(this, e("_process"))
    }, {
        _process: 42
    }],
    42: [function (e, t, n) {
        function i() {
            throw new Error("setTimeout has not been defined")
        }

        function r() {
            throw new Error("clearTimeout has not been defined")
        }

        function a(e) {
            if (h === setTimeout) return setTimeout(e, 0);
            if ((h === i || !h) && setTimeout) return h = setTimeout, setTimeout(e, 0);
            try {
                return h(e, 0)
            } catch (t) {
                try {
                    return h.call(null, e, 0)
                } catch (t) {
                    return h.call(this, e, 0)
                }
            }
        }

        function o(e) {
            if (d === clearTimeout) return clearTimeout(e);
            if ((d === r || !d) && clearTimeout) return d = clearTimeout, clearTimeout(e);
            try {
                return d(e)
            } catch (t) {
                try {
                    return d.call(null, e)
                } catch (t) {
                    return d.call(this, e)
                }
            }
        }

        function s() {
            v && f && (v = !1, f.length ? m = f.concat(m) : g = -1, m.length && l())
        }

        function l() {
            if (!v) {
                var e = a(s);
                v = !0;
                for (var t = m.length; t;) {
                    for (f = m, m = []; ++g < t;) f && f[g].run();
                    g = -1, t = m.length
                }
                f = null, v = !1, o(e)
            }
        }

        function c(e, t) {
            this.fun = e, this.array = t
        }

        function u() {}
        var h, d, p = t.exports = {};
        ! function () {
            try {
                h = "function" == typeof setTimeout ? setTimeout : i
            } catch (e) {
                h = i
            }
            try {
                d = "function" == typeof clearTimeout ? clearTimeout : r
            } catch (e) {
                d = r
            }
        }();
        var f, m = [],
            v = !1,
            g = -1;
        p.nextTick = function (e) {
            var t = new Array(arguments.length - 1);
            if (arguments.length > 1)
                for (var n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
            m.push(new c(e, t)), 1 !== m.length || v || a(l)
        }, c.prototype.run = function () {
            this.fun.apply(null, this.array)
        }, p.title = "browser", p.browser = !0, p.env = {}, p.argv = [], p.version = "", p.versions = {}, p.on = u, p.addListener = u, p.once = u, p.off = u, p.removeListener = u, p.removeAllListeners = u, p.emit = u, p.prependListener = u, p.prependOnceListener = u, p.listeners = function (e) {
            return []
        }, p.binding = function (e) {
            throw new Error("process.binding is not supported")
        }, p.cwd = function () {
            return "/"
        }, p.chdir = function (e) {
            throw new Error("process.chdir is not supported")
        }, p.umask = function () {
            return 0
        }
    }, {}],
    43: [function (e, t, n) {
        function i(e) {
            return this instanceof i ? (this.running = !1, this.last = o(), this._frame = 0, this._tick = this.tick.bind(this), void(e && this.on("tick", e))) : new i(e)
        }
        var r = e("inherits"),
            a = e("events").EventEmitter,
            o = e("right-now"),
            s = e("raf");
        t.exports = i, r(i, a), i.prototype.start = function () {
            if (!this.running) return this.running = !0, this.last = o(), this._frame = s(this._tick), this
        }, i.prototype.stop = function () {
            return this.running = !1, 0 !== this._frame && s.cancel(this._frame), this._frame = 0, this
        }, i.prototype.tick = function () {
            this._frame = s(this._tick);
            var e = o(),
                t = e - this.last;
            this.emit("tick", t), this.last = e
        }
    }, {
        events: 34,
        inherits: 37,
        raf: 44,
        "right-now": 45
    }],
    44: [function (e, t, n) {
        (function (n) {
            for (var i = e("performance-now"), r = "undefined" == typeof window ? n : window, a = ["moz", "webkit"], o = "AnimationFrame", s = r["request" + o], l = r["cancel" + o] || r["cancelRequest" + o], c = 0; !s && c < a.length; c++) s = r[a[c] + "Request" + o], l = r[a[c] + "Cancel" + o] || r[a[c] + "CancelRequest" + o];
            if (!s || !l) {
                var u = 0,
                    h = 0,
                    d = [],
                    p = 1e3 / 60;
                s = function (e) {
                    if (0 === d.length) {
                        var t = i(),
                            n = Math.max(0, p - (t - u));
                        u = n + t, setTimeout(function () {
                            var e = d.slice(0);
                            d.length = 0;
                            for (var t = 0; t < e.length; t++)
                                if (!e[t].cancelled) try {
                                    e[t].callback(u)
                                } catch (n) {
                                    setTimeout(function () {
                                        throw n
                                    }, 0)
                                }
                        }, Math.round(n))
                    }
                    return d.push({
                        handle: ++h,
                        callback: e,
                        cancelled: !1
                    }), h
                }, l = function (e) {
                    for (var t = 0; t < d.length; t++) d[t].handle === e && (d[t].cancelled = !0)
                }
            }
            t.exports = function (e) {
                return s.call(r, e)
            }, t.exports.cancel = function () {
                l.apply(r, arguments)
            }, t.exports.polyfill = function (e) {
                e || (e = r), e.requestAnimationFrame = s, e.cancelAnimationFrame = l
            }
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {
        "performance-now": 41
    }],
    45: [function (e, t, n) {
        (function (e) {
            t.exports = e.performance && e.performance.now ? function () {
                return performance.now()
            } : Date.now || function () {
                return +new Date
            }
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}],
    46: [function (e, t, n) {
        ! function (e, i) {
            "object" == typeof n && "undefined" != typeof t ? t.exports = i() : "function" == typeof define && define.amd ? define(i) : e.Swiper = i()
        }(this, function () {
            "use strict";

            function e(e, t) {
                var n = [],
                    i = 0;
                if (e && !t && e instanceof De) return e;
                if (e)
                    if ("string" == typeof e) {
                        var r, a, o = e.trim();
                        if (o.indexOf("<") >= 0 && o.indexOf(">") >= 0) {
                            var s = "div";
                            for (0 === o.indexOf("<li") && (s = "ul"), 0 === o.indexOf("<tr") && (s = "tbody"), 0 !== o.indexOf("<td") && 0 !== o.indexOf("<th") || (s = "tr"), 0 === o.indexOf("<tbody") && (s = "table"), 0 === o.indexOf("<option") && (s = "select"), a = Oe.createElement(s), a.innerHTML = o, i = 0; i < a.childNodes.length; i += 1) n.push(a.childNodes[i])
                        } else
                            for (r = t || "#" !== e[0] || e.match(/[ .<>:~]/) ? (t || Oe).querySelectorAll(e.trim()) : [Oe.getElementById(e.trim().split("#")[1])], i = 0; i < r.length; i += 1) r[i] && n.push(r[i])
                    } else if (e.nodeType || e === ke || e === Oe) n.push(e);
                else if (e.length > 0 && e[0].nodeType)
                    for (i = 0; i < e.length; i += 1) n.push(e[i]);
                return new De(n)
            }

            function t(e) {
                for (var t = [], n = 0; n < e.length; n += 1) t.indexOf(e[n]) === -1 && t.push(e[n]);
                return t
            }

            function n(e) {
                if ("undefined" == typeof e) return this;
                for (var t = e.split(" "), n = 0; n < t.length; n += 1)
                    for (var i = 0; i < this.length; i += 1) "undefined" != typeof this[i] && "undefined" != typeof this[i].classList && this[i].classList.add(t[n]);
                return this
            }

            function i(e) {
                for (var t = e.split(" "), n = 0; n < t.length; n += 1)
                    for (var i = 0; i < this.length; i += 1) "undefined" != typeof this[i] && "undefined" != typeof this[i].classList && this[i].classList.remove(t[n]);
                return this
            }

            function r(e) {
                return !!this[0] && this[0].classList.contains(e)
            }

            function a(e) {
                for (var t = e.split(" "), n = 0; n < t.length; n += 1)
                    for (var i = 0; i < this.length; i += 1) "undefined" != typeof this[i] && "undefined" != typeof this[i].classList && this[i].classList.toggle(t[n]);
                return this
            }

            function o(e, t) {
                var n = arguments; {
                    if (1 !== arguments.length || "string" != typeof e) {
                        for (var i = 0; i < this.length; i += 1)
                            if (2 === n.length) this[i].setAttribute(e, t);
                            else
                                for (var r in e) this[i][r] = e[r], this[i].setAttribute(r, e[r]);
                        return this
                    }
                    if (this[0]) return this[0].getAttribute(e)
                }
            }

            function s(e) {
                for (var t = 0; t < this.length; t += 1) this[t].removeAttribute(e);
                return this
            }

            function l(e, t) {
                var n; {
                    if ("undefined" != typeof t) {
                        for (var i = 0; i < this.length; i += 1) n = this[i], n.dom7ElementDataStorage || (n.dom7ElementDataStorage = {}), n.dom7ElementDataStorage[e] = t;
                        return this
                    }
                    if (n = this[0]) {
                        if (n.dom7ElementDataStorage && e in n.dom7ElementDataStorage) return n.dom7ElementDataStorage[e];
                        var r = n.getAttribute("data-" + e);
                        if (r) return r;
                        return
                    }
                }
            }

            function c(e) {
                for (var t = 0; t < this.length; t += 1) {
                    var n = this[t].style;
                    n.webkitTransform = e, n.transform = e
                }
                return this
            }

            function u(e) {
                "string" != typeof e && (e += "ms");
                for (var t = 0; t < this.length; t += 1) {
                    var n = this[t].style;
                    n.webkitTransitionDuration = e, n.transitionDuration = e
                }
                return this
            }

            function h() {
                function t(t) {
                    var n = t.target;
                    if (n) {
                        var i = t.target.dom7EventData || [];
                        if (i.indexOf(t) < 0 && i.unshift(t), e(n).is(s)) l.apply(n, i);
                        else
                            for (var r = e(n).parents(), a = 0; a < r.length; a += 1) e(r[a]).is(s) && l.apply(r[a], i)
                    }
                }

                function n(e) {
                    var t = e && e.target ? e.target.dom7EventData || [] : [];
                    t.indexOf(e) < 0 && t.unshift(e), l.apply(this, t)
                }
                for (var i, r = [], a = arguments.length; a--;) r[a] = arguments[a];
                var o = r[0],
                    s = r[1],
                    l = r[2],
                    c = r[3];
                "function" == typeof r[1] && (i = r, o = i[0], l = i[1], c = i[2], s = void 0), c || (c = !1);
                for (var u, h = o.split(" "), d = 0; d < this.length; d += 1) {
                    var p = this[d];
                    if (s)
                        for (u = 0; u < h.length; u += 1) {
                            var f = h[u];
                            p.dom7LiveListeners || (p.dom7LiveListeners = {}), p.dom7LiveListeners[f] || (p.dom7LiveListeners[f] = []), p.dom7LiveListeners[f].push({
                                listener: l,
                                proxyListener: t
                            }), p.addEventListener(f, t, c)
                        } else
                            for (u = 0; u < h.length; u += 1) {
                                var m = h[u];
                                p.dom7Listeners || (p.dom7Listeners = {}), p.dom7Listeners[m] || (p.dom7Listeners[m] = []), p.dom7Listeners[m].push({
                                    listener: l,
                                    proxyListener: n
                                }), p.addEventListener(m, n, c)
                            }
                }
                return this
            }

            function d() {
                for (var e, t = [], n = arguments.length; n--;) t[n] = arguments[n];
                var i = t[0],
                    r = t[1],
                    a = t[2],
                    o = t[3];
                "function" == typeof t[1] && (e = t, i = e[0], a = e[1], o = e[2], r = void 0), o || (o = !1);
                for (var s = i.split(" "), l = 0; l < s.length; l += 1)
                    for (var c = s[l], u = 0; u < this.length; u += 1) {
                        var h = this[u],
                            d = void 0;
                        if (!r && h.dom7Listeners ? d = h.dom7Listeners[c] : r && h.dom7LiveListeners && (d = h.dom7LiveListeners[c]), d && d.length)
                            for (var p = d.length - 1; p >= 0; p -= 1) {
                                var f = d[p];
                                a && f.listener === a ? (h.removeEventListener(c, f.proxyListener, o), d.splice(p, 1)) : a || (h.removeEventListener(c, f.proxyListener, o), d.splice(p, 1))
                            }
                    }
                return this
            }

            function p() {
                for (var e = [], t = arguments.length; t--;) e[t] = arguments[t];
                for (var n = e[0].split(" "), i = e[1], r = 0; r < n.length; r += 1)
                    for (var a = n[r], o = 0; o < this.length; o += 1) {
                        var s = this[o],
                            l = void 0;
                        try {
                            l = new ke.CustomEvent(a, {
                                detail: i,
                                bubbles: !0,
                                cancelable: !0
                            })
                        } catch (c) {
                            l = Oe.createEvent("Event"), l.initEvent(a, !0, !0), l.detail = i
                        }
                        s.dom7EventData = e.filter(function (e, t) {
                            return t > 0
                        }), s.dispatchEvent(l), s.dom7EventData = [], delete s.dom7EventData
                    }
                return this
            }

            function f(e) {
                function t(a) {
                    if (a.target === this)
                        for (e.call(this, a), n = 0; n < i.length; n += 1) r.off(i[n], t)
                }
                var n, i = ["webkitTransitionEnd", "transitionend"],
                    r = this;
                if (e)
                    for (n = 0; n < i.length; n += 1) r.on(i[n], t);
                return this
            }

            function m(e) {
                if (this.length > 0) {
                    if (e) {
                        var t = this.styles();
                        return this[0].offsetWidth + parseFloat(t.getPropertyValue("margin-right")) + parseFloat(t.getPropertyValue("margin-left"))
                    }
                    return this[0].offsetWidth
                }
                return null
            }

            function v(e) {
                if (this.length > 0) {
                    if (e) {
                        var t = this.styles();
                        return this[0].offsetHeight + parseFloat(t.getPropertyValue("margin-top")) + parseFloat(t.getPropertyValue("margin-bottom"))
                    }
                    return this[0].offsetHeight
                }
                return null
            }

            function g() {
                if (this.length > 0) {
                    var e = this[0],
                        t = e.getBoundingClientRect(),
                        n = Oe.body,
                        i = e.clientTop || n.clientTop || 0,
                        r = e.clientLeft || n.clientLeft || 0,
                        a = e === ke ? ke.scrollY : e.scrollTop,
                        o = e === ke ? ke.scrollX : e.scrollLeft;
                    return {
                        top: t.top + a - i,
                        left: t.left + o - r
                    }
                }
                return null
            }

            function y() {
                return this[0] ? ke.getComputedStyle(this[0], null) : {}
            }

            function x(e, t) {
                var n;
                if (1 === arguments.length) {
                    if ("string" != typeof e) {
                        for (n = 0; n < this.length; n += 1)
                            for (var i in e) this[n].style[i] = e[i];
                        return this
                    }
                    if (this[0]) return ke.getComputedStyle(this[0], null).getPropertyValue(e)
                }
                if (2 === arguments.length && "string" == typeof e) {
                    for (n = 0; n < this.length; n += 1) this[n].style[e] = t;
                    return this
                }
                return this
            }

            function b(e) {
                if (!e) return this;
                for (var t = 0; t < this.length; t += 1)
                    if (e.call(this[t], t, this[t]) === !1) return this;
                return this
            }

            function _(e) {
                if ("undefined" == typeof e) return this[0] ? this[0].innerHTML : void 0;
                for (var t = 0; t < this.length; t += 1) this[t].innerHTML = e;
                return this
            }

            function w(e) {
                if ("undefined" == typeof e) return this[0] ? this[0].textContent.trim() : null;
                for (var t = 0; t < this.length; t += 1) this[t].textContent = e;
                return this
            }

            function M(t) {
                var n, i, r = this[0];
                if (!r || "undefined" == typeof t) return !1;
                if ("string" == typeof t) {
                    if (r.matches) return r.matches(t);
                    if (r.webkitMatchesSelector) return r.webkitMatchesSelector(t);
                    if (r.msMatchesSelector) return r.msMatchesSelector(t);
                    for (n = e(t), i = 0; i < n.length; i += 1)
                        if (n[i] === r) return !0;
                    return !1
                }
                if (t === Oe) return r === Oe;
                if (t === ke) return r === ke;
                if (t.nodeType || t instanceof De) {
                    for (n = t.nodeType ? [t] : t, i = 0; i < n.length; i += 1)
                        if (n[i] === r) return !0;
                    return !1
                }
                return !1
            }

            function T() {
                var e, t = this[0];
                if (t) {
                    for (e = 0; null !== (t = t.previousSibling);) 1 === t.nodeType && (e += 1);
                    return e
                }
            }

            function E(e) {
                if ("undefined" == typeof e) return this;
                var t, n = this.length;
                return e > n - 1 ? new De([]) : e < 0 ? (t = n + e, new De(t < 0 ? [] : [this[t]])) : new De([this[e]])
            }

            function S() {
                for (var e = [], t = arguments.length; t--;) e[t] = arguments[t];
                for (var n, i = 0; i < e.length; i += 1) {
                    n = e[i];
                    for (var r = 0; r < this.length; r += 1)
                        if ("string" == typeof n) {
                            var a = Oe.createElement("div");
                            for (a.innerHTML = n; a.firstChild;) this[r].appendChild(a.firstChild)
                        } else if (n instanceof De)
                        for (var o = 0; o < n.length; o += 1) this[r].appendChild(n[o]);
                    else this[r].appendChild(n)
                }
                return this
            }

            function P(e) {
                var t, n;
                for (t = 0; t < this.length; t += 1)
                    if ("string" == typeof e) {
                        var i = Oe.createElement("div");
                        for (i.innerHTML = e, n = i.childNodes.length - 1; n >= 0; n -= 1) this[t].insertBefore(i.childNodes[n], this[t].childNodes[0])
                    } else if (e instanceof De)
                    for (n = 0; n < e.length; n += 1) this[t].insertBefore(e[n], this[t].childNodes[0]);
                else this[t].insertBefore(e, this[t].childNodes[0]);
                return this
            }

            function C(t) {
                return new De(this.length > 0 ? t ? this[0].nextElementSibling && e(this[0].nextElementSibling).is(t) ? [this[0].nextElementSibling] : [] : this[0].nextElementSibling ? [this[0].nextElementSibling] : [] : [])
            }

            function A(t) {
                var n = [],
                    i = this[0];
                if (!i) return new De([]);
                for (; i.nextElementSibling;) {
                    var r = i.nextElementSibling;
                    t ? e(r).is(t) && n.push(r) : n.push(r), i = r
                }
                return new De(n)
            }

            function L(t) {
                if (this.length > 0) {
                    var n = this[0];
                    return new De(t ? n.previousElementSibling && e(n.previousElementSibling).is(t) ? [n.previousElementSibling] : [] : n.previousElementSibling ? [n.previousElementSibling] : [])
                }
                return new De([])
            }

            function R(t) {
                var n = [],
                    i = this[0];
                if (!i) return new De([]);
                for (; i.previousElementSibling;) {
                    var r = i.previousElementSibling;
                    t ? e(r).is(t) && n.push(r) : n.push(r), i = r
                }
                return new De(n)
            }

            function I(n) {
                for (var i = [], r = 0; r < this.length; r += 1) null !== this[r].parentNode && (n ? e(this[r].parentNode).is(n) && i.push(this[r].parentNode) : i.push(this[r].parentNode));
                return e(t(i))
            }

            function O(n) {
                for (var i = [], r = 0; r < this.length; r += 1)
                    for (var a = this[r].parentNode; a;) n ? e(a).is(n) && i.push(a) : i.push(a), a = a.parentNode;
                return e(t(i))
            }

            function k(e) {
                var t = this;
                return "undefined" == typeof e ? new De([]) : (t.is(e) || (t = t.parents(e).eq(0)), t)
            }

            function D(e) {
                for (var t = [], n = 0; n < this.length; n += 1)
                    for (var i = this[n].querySelectorAll(e), r = 0; r < i.length; r += 1) t.push(i[r]);
                return new De(t)
            }

            function z(n) {
                for (var i = [], r = 0; r < this.length; r += 1)
                    for (var a = this[r].childNodes, o = 0; o < a.length; o += 1) n ? 1 === a[o].nodeType && e(a[o]).is(n) && i.push(a[o]) : 1 === a[o].nodeType && i.push(a[o]);
                return new De(t(i))
            }

            function B() {
                for (var e = 0; e < this.length; e += 1) this[e].parentNode && this[e].parentNode.removeChild(this[e]);
                return this
            }

            function N() {
                for (var t = [], n = arguments.length; n--;) t[n] = arguments[n];
                var i, r, a = this;
                for (i = 0; i < t.length; i += 1) {
                    var o = e(t[i]);
                    for (r = 0; r < o.length; r += 1) a[a.length] = o[r], a.length += 1
                }
                return a
            }

            function U() {
                var e, t, n = this,
                    i = n.$el;
                e = "undefined" != typeof n.params.width ? n.params.width : i[0].clientWidth, t = "undefined" != typeof n.params.height ? n.params.height : i[0].clientHeight, 0 === e && n.isHorizontal() || 0 === t && n.isVertical() || (e = e - parseInt(i.css("padding-left"), 10) - parseInt(i.css("padding-right"), 10), t = t - parseInt(i.css("padding-top"), 10) - parseInt(i.css("padding-bottom"), 10), Be.extend(n, {
                    width: e,
                    height: t,
                    size: n.isHorizontal() ? e : t
                }))
            }

            function j() {
                var e = this,
                    t = e.params,
                    n = e.$wrapperEl,
                    i = e.size,
                    r = e.rtlTranslate,
                    a = e.wrongRTL,
                    o = e.virtual && t.virtual.enabled,
                    s = o ? e.virtual.slides.length : e.slides.length,
                    l = n.children("." + e.params.slideClass),
                    c = o ? e.virtual.slides.length : l.length,
                    u = [],
                    h = [],
                    d = [],
                    p = t.slidesOffsetBefore;
                "function" == typeof p && (p = t.slidesOffsetBefore.call(e));
                var f = t.slidesOffsetAfter;
                "function" == typeof f && (f = t.slidesOffsetAfter.call(e));
                var m = e.snapGrid.length,
                    v = e.snapGrid.length,
                    g = t.spaceBetween,
                    y = -p,
                    x = 0,
                    b = 0;
                if ("undefined" != typeof i) {
                    "string" == typeof g && g.indexOf("%") >= 0 && (g = parseFloat(g.replace("%", "")) / 100 * i), e.virtualSize = -g, r ? l.css({
                        marginLeft: "",
                        marginTop: ""
                    }) : l.css({
                        marginRight: "",
                        marginBottom: ""
                    });
                    var _;
                    t.slidesPerColumn > 1 && (_ = Math.floor(c / t.slidesPerColumn) === c / e.params.slidesPerColumn ? c : Math.ceil(c / t.slidesPerColumn) * t.slidesPerColumn, "auto" !== t.slidesPerView && "row" === t.slidesPerColumnFill && (_ = Math.max(_, t.slidesPerView * t.slidesPerColumn)));
                    for (var w, M = t.slidesPerColumn, T = _ / M, E = Math.floor(c / t.slidesPerColumn), S = 0; S < c; S += 1) {
                        w = 0;
                        var P = l.eq(S);
                        if (t.slidesPerColumn > 1) {
                            var C = void 0,
                                A = void 0,
                                L = void 0;
                            "column" === t.slidesPerColumnFill ? (A = Math.floor(S / M), L = S - A * M, (A > E || A === E && L === M - 1) && (L += 1, L >= M && (L = 0, A += 1)), C = A + L * _ / M, P.css({
                                "-webkit-box-ordinal-group": C,
                                "-moz-box-ordinal-group": C,
                                "-ms-flex-order": C,
                                "-webkit-order": C,
                                order: C
                            })) : (L = Math.floor(S / T), A = S - L * T), P.css("margin-" + (e.isHorizontal() ? "top" : "left"), 0 !== L && t.spaceBetween && t.spaceBetween + "px").attr("data-swiper-column", A).attr("data-swiper-row", L)
                        }
                        if ("none" !== P.css("display")) {
                            if ("auto" === t.slidesPerView) {
                                var R = ke.getComputedStyle(P[0], null),
                                    I = P[0].style.transform,
                                    O = P[0].style.webkitTransform;
                                if (I && (P[0].style.transform = "none"), O && (P[0].style.webkitTransform = "none"), t.roundLengths) w = e.isHorizontal() ? P.outerWidth(!0) : P.outerHeight(!0);
                                else if (e.isHorizontal()) {
                                    var k = parseFloat(R.getPropertyValue("width")),
                                        D = parseFloat(R.getPropertyValue("padding-left")),
                                        z = parseFloat(R.getPropertyValue("padding-right")),
                                        B = parseFloat(R.getPropertyValue("margin-left")),
                                        N = parseFloat(R.getPropertyValue("margin-right")),
                                        U = R.getPropertyValue("box-sizing");
                                    w = U && "border-box" === U ? k + B + N : k + D + z + B + N
                                } else {
                                    var j = parseFloat(R.getPropertyValue("height")),
                                        F = parseFloat(R.getPropertyValue("padding-top")),
                                        G = parseFloat(R.getPropertyValue("padding-bottom")),
                                        H = parseFloat(R.getPropertyValue("margin-top")),
                                        V = parseFloat(R.getPropertyValue("margin-bottom")),
                                        W = R.getPropertyValue("box-sizing");
                                    w = W && "border-box" === W ? j + H + V : j + F + G + H + V
                                }
                                I && (P[0].style.transform = I), O && (P[0].style.webkitTransform = O), t.roundLengths && (w = Math.floor(w))
                            } else w = (i - (t.slidesPerView - 1) * g) / t.slidesPerView, t.roundLengths && (w = Math.floor(w)), l[S] && (e.isHorizontal() ? l[S].style.width = w + "px" : l[S].style.height = w + "px");
                            l[S] && (l[S].swiperSlideSize = w), d.push(w), t.centeredSlides ? (y = y + w / 2 + x / 2 + g, 0 === x && 0 !== S && (y = y - i / 2 - g), 0 === S && (y = y - i / 2 - g), Math.abs(y) < .001 && (y = 0), t.roundLengths && (y = Math.floor(y)), b % t.slidesPerGroup === 0 && u.push(y), h.push(y)) : (t.roundLengths && (y = Math.floor(y)), b % t.slidesPerGroup === 0 && u.push(y), h.push(y), y = y + w + g), e.virtualSize += w + g, x = w, b += 1
                        }
                    }
                    e.virtualSize = Math.max(e.virtualSize, i) + f;
                    var q;
                    if (r && a && ("slide" === t.effect || "coverflow" === t.effect) && n.css({
                            width: e.virtualSize + t.spaceBetween + "px"
                        }), Ne.flexbox && !t.setWrapperSize || (e.isHorizontal() ? n.css({
                            width: e.virtualSize + t.spaceBetween + "px"
                        }) : n.css({
                            height: e.virtualSize + t.spaceBetween + "px"
                        })), t.slidesPerColumn > 1 && (e.virtualSize = (w + t.spaceBetween) * _, e.virtualSize = Math.ceil(e.virtualSize / t.slidesPerColumn) - t.spaceBetween, e.isHorizontal() ? n.css({
                            width: e.virtualSize + t.spaceBetween + "px"
                        }) : n.css({
                            height: e.virtualSize + t.spaceBetween + "px"
                        }), t.centeredSlides)) {
                        q = [];
                        for (var X = 0; X < u.length; X += 1) {
                            var Y = u[X];
                            t.roundLengths && (Y = Math.floor(Y)), u[X] < e.virtualSize + u[0] && q.push(Y)
                        }
                        u = q
                    }
                    if (!t.centeredSlides) {
                        q = [];
                        for (var Z = 0; Z < u.length; Z += 1) {
                            var J = u[Z];
                            t.roundLengths && (J = Math.floor(J)), u[Z] <= e.virtualSize - i && q.push(J)
                        }
                        u = q, Math.floor(e.virtualSize - i) - Math.floor(u[u.length - 1]) > 1 && u.push(e.virtualSize - i)
                    }
                    if (0 === u.length && (u = [0]), 0 !== t.spaceBetween && (e.isHorizontal() ? r ? l.css({
                            marginLeft: g + "px"
                        }) : l.css({
                            marginRight: g + "px"
                        }) : l.css({
                            marginBottom: g + "px"
                        })), t.centerInsufficientSlides) {
                        var $ = 0;
                        if (d.forEach(function (e) {
                                $ += e + (t.spaceBetween ? t.spaceBetween : 0)
                            }), $ -= t.spaceBetween, $ < i) {
                            var Q = (i - $) / 2;
                            u.forEach(function (e, t) {
                                u[t] = e - Q
                            }), h.forEach(function (e, t) {
                                h[t] = e + Q
                            })
                        }
                    }
                    Be.extend(e, {
                        slides: l,
                        snapGrid: u,
                        slidesGrid: h,
                        slidesSizesGrid: d
                    }), c !== s && e.emit("slidesLengthChange"), u.length !== m && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), h.length !== v && e.emit("slidesGridLengthChange"), (t.watchSlidesProgress || t.watchSlidesVisibility) && e.updateSlidesOffset()
                }
            }

            function F(e) {
                var t, n = this,
                    i = [],
                    r = 0;
                if ("number" == typeof e ? n.setTransition(e) : e === !0 && n.setTransition(n.params.speed), "auto" !== n.params.slidesPerView && n.params.slidesPerView > 1)
                    for (t = 0; t < Math.ceil(n.params.slidesPerView); t += 1) {
                        var a = n.activeIndex + t;
                        if (a > n.slides.length) break;
                        i.push(n.slides.eq(a)[0])
                    } else i.push(n.slides.eq(n.activeIndex)[0]);
                for (t = 0; t < i.length; t += 1)
                    if ("undefined" != typeof i[t]) {
                        var o = i[t].offsetHeight;
                        r = o > r ? o : r
                    } r && n.$wrapperEl.css("height", r + "px")
            }

            function G() {
                for (var e = this, t = e.slides, n = 0; n < t.length; n += 1) t[n].swiperSlideOffset = e.isHorizontal() ? t[n].offsetLeft : t[n].offsetTop
            }

            function H(t) {
                void 0 === t && (t = this && this.translate || 0);
                var n = this,
                    i = n.params,
                    r = n.slides,
                    a = n.rtlTranslate;
                if (0 !== r.length) {
                    "undefined" == typeof r[0].swiperSlideOffset && n.updateSlidesOffset();
                    var o = -t;
                    a && (o = t), r.removeClass(i.slideVisibleClass), n.visibleSlidesIndexes = [], n.visibleSlides = [];
                    for (var s = 0; s < r.length; s += 1) {
                        var l = r[s],
                            c = (o + (i.centeredSlides ? n.minTranslate() : 0) - l.swiperSlideOffset) / (l.swiperSlideSize + i.spaceBetween);
                        if (i.watchSlidesVisibility) {
                            var u = -(o - l.swiperSlideOffset),
                                h = u + n.slidesSizesGrid[s],
                                d = u >= 0 && u < n.size || h > 0 && h <= n.size || u <= 0 && h >= n.size;
                            d && (n.visibleSlides.push(l), n.visibleSlidesIndexes.push(s), r.eq(s).addClass(i.slideVisibleClass))
                        }
                        l.progress = a ? -c : c
                    }
                    n.visibleSlides = e(n.visibleSlides)
                }
            }

            function V(e) {
                void 0 === e && (e = this && this.translate || 0);
                var t = this,
                    n = t.params,
                    i = t.maxTranslate() - t.minTranslate(),
                    r = t.progress,
                    a = t.isBeginning,
                    o = t.isEnd,
                    s = a,
                    l = o;
                0 === i ? (r = 0, a = !0, o = !0) : (r = (e - t.minTranslate()) / i, a = r <= 0, o = r >= 1), Be.extend(t, {
                    progress: r,
                    isBeginning: a,
                    isEnd: o
                }), (n.watchSlidesProgress || n.watchSlidesVisibility) && t.updateSlidesProgress(e), a && !s && t.emit("reachBeginning toEdge"), o && !l && t.emit("reachEnd toEdge"), (s && !a || l && !o) && t.emit("fromEdge"), t.emit("progress", r)
            }

            function W() {
                var e = this,
                    t = e.slides,
                    n = e.params,
                    i = e.$wrapperEl,
                    r = e.activeIndex,
                    a = e.realIndex,
                    o = e.virtual && n.virtual.enabled;
                t.removeClass(n.slideActiveClass + " " + n.slideNextClass + " " + n.slidePrevClass + " " + n.slideDuplicateActiveClass + " " + n.slideDuplicateNextClass + " " + n.slideDuplicatePrevClass);
                var s;
                s = o ? e.$wrapperEl.find("." + n.slideClass + '[data-swiper-slide-index="' + r + '"]') : t.eq(r), s.addClass(n.slideActiveClass), n.loop && (s.hasClass(n.slideDuplicateClass) ? i.children("." + n.slideClass + ":not(." + n.slideDuplicateClass + ')[data-swiper-slide-index="' + a + '"]').addClass(n.slideDuplicateActiveClass) : i.children("." + n.slideClass + "." + n.slideDuplicateClass + '[data-swiper-slide-index="' + a + '"]').addClass(n.slideDuplicateActiveClass));
                var l = s.nextAll("." + n.slideClass).eq(0).addClass(n.slideNextClass);
                n.loop && 0 === l.length && (l = t.eq(0), l.addClass(n.slideNextClass));
                var c = s.prevAll("." + n.slideClass).eq(0).addClass(n.slidePrevClass);
                n.loop && 0 === c.length && (c = t.eq(-1), c.addClass(n.slidePrevClass)), n.loop && (l.hasClass(n.slideDuplicateClass) ? i.children("." + n.slideClass + ":not(." + n.slideDuplicateClass + ')[data-swiper-slide-index="' + l.attr("data-swiper-slide-index") + '"]').addClass(n.slideDuplicateNextClass) : i.children("." + n.slideClass + "." + n.slideDuplicateClass + '[data-swiper-slide-index="' + l.attr("data-swiper-slide-index") + '"]').addClass(n.slideDuplicateNextClass), c.hasClass(n.slideDuplicateClass) ? i.children("." + n.slideClass + ":not(." + n.slideDuplicateClass + ')[data-swiper-slide-index="' + c.attr("data-swiper-slide-index") + '"]').addClass(n.slideDuplicatePrevClass) : i.children("." + n.slideClass + "." + n.slideDuplicateClass + '[data-swiper-slide-index="' + c.attr("data-swiper-slide-index") + '"]').addClass(n.slideDuplicatePrevClass))
            }

            function q(e) {
                var t, n = this,
                    i = n.rtlTranslate ? n.translate : -n.translate,
                    r = n.slidesGrid,
                    a = n.snapGrid,
                    o = n.params,
                    s = n.activeIndex,
                    l = n.realIndex,
                    c = n.snapIndex,
                    u = e;
                if ("undefined" == typeof u) {
                    for (var h = 0; h < r.length; h += 1) "undefined" != typeof r[h + 1] ? i >= r[h] && i < r[h + 1] - (r[h + 1] - r[h]) / 2 ? u = h : i >= r[h] && i < r[h + 1] && (u = h + 1) : i >= r[h] && (u = h);
                    o.normalizeSlideIndex && (u < 0 || "undefined" == typeof u) && (u = 0)
                }
                if (t = a.indexOf(i) >= 0 ? a.indexOf(i) : Math.floor(u / o.slidesPerGroup), t >= a.length && (t = a.length - 1), u === s) return void(t !== c && (n.snapIndex = t, n.emit("snapIndexChange")));
                var d = parseInt(n.slides.eq(u).attr("data-swiper-slide-index") || u, 10);
                Be.extend(n, {
                    snapIndex: t,
                    realIndex: d,
                    previousIndex: s,
                    activeIndex: u
                }), n.emit("activeIndexChange"), n.emit("snapIndexChange"), l !== d && n.emit("realIndexChange"), n.emit("slideChange")
            }

            function X(t) {
                var n = this,
                    i = n.params,
                    r = e(t.target).closest("." + i.slideClass)[0],
                    a = !1;
                if (r)
                    for (var o = 0; o < n.slides.length; o += 1) n.slides[o] === r && (a = !0);
                return r && a ? (n.clickedSlide = r, n.virtual && n.params.virtual.enabled ? n.clickedIndex = parseInt(e(r).attr("data-swiper-slide-index"), 10) : n.clickedIndex = e(r).index(), void(i.slideToClickedSlide && void 0 !== n.clickedIndex && n.clickedIndex !== n.activeIndex && n.slideToClickedSlide())) : (n.clickedSlide = void 0, void(n.clickedIndex = void 0))
            }

            function Y(e) {
                void 0 === e && (e = this.isHorizontal() ? "x" : "y");
                var t = this,
                    n = t.params,
                    i = t.rtlTranslate,
                    r = t.translate,
                    a = t.$wrapperEl;
                if (n.virtualTranslate) return i ? -r : r;
                var o = Be.getTranslate(a[0], e);
                return i && (o = -o), o || 0
            }

            function Z(e, t) {
                var n = this,
                    i = n.rtlTranslate,
                    r = n.params,
                    a = n.$wrapperEl,
                    o = n.progress,
                    s = 0,
                    l = 0,
                    c = 0;
                n.isHorizontal() ? s = i ? -e : e : l = e, r.roundLengths && (s = Math.floor(s), l = Math.floor(l)), r.virtualTranslate || (Ne.transforms3d ? a.transform("translate3d(" + s + "px, " + l + "px, " + c + "px)") : a.transform("translate(" + s + "px, " + l + "px)")), n.previousTranslate = n.translate, n.translate = n.isHorizontal() ? s : l;
                var u, h = n.maxTranslate() - n.minTranslate();
                u = 0 === h ? 0 : (e - n.minTranslate()) / h, u !== o && n.updateProgress(e), n.emit("setTranslate", n.translate, t)
            }

            function J() {
                return -this.snapGrid[0]
            }

            function $() {
                return -this.snapGrid[this.snapGrid.length - 1]
            }

            function Q(e, t) {
                var n = this;
                n.$wrapperEl.transition(e), n.emit("setTransition", e, t)
            }

            function K(e, t) {
                void 0 === e && (e = !0);
                var n = this,
                    i = n.activeIndex,
                    r = n.params,
                    a = n.previousIndex;
                r.autoHeight && n.updateAutoHeight();
                var o = t;
                if (o || (o = i > a ? "next" : i < a ? "prev" : "reset"), n.emit("transitionStart"), e && i !== a) {
                    if ("reset" === o) return void n.emit("slideResetTransitionStart");
                    n.emit("slideChangeTransitionStart"), "next" === o ? n.emit("slideNextTransitionStart") : n.emit("slidePrevTransitionStart")
                }
            }

            function ee(e, t) {
                void 0 === e && (e = !0);
                var n = this,
                    i = n.activeIndex,
                    r = n.previousIndex;
                n.animating = !1, n.setTransition(0);
                var a = t;
                if (a || (a = i > r ? "next" : i < r ? "prev" : "reset"), n.emit("transitionEnd"), e && i !== r) {
                    if ("reset" === a) return void n.emit("slideResetTransitionEnd");
                    n.emit("slideChangeTransitionEnd"), "next" === a ? n.emit("slideNextTransitionEnd") : n.emit("slidePrevTransitionEnd")
                }
            }

            function te(e, t, n, i) {
                void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === n && (n = !0);
                var r = this,
                    a = e;
                a < 0 && (a = 0);
                var o = r.params,
                    s = r.snapGrid,
                    l = r.slidesGrid,
                    c = r.previousIndex,
                    u = r.activeIndex,
                    h = r.rtlTranslate;
                if (r.animating && o.preventInteractionOnTransition) return !1;
                var d = Math.floor(a / o.slidesPerGroup);
                d >= s.length && (d = s.length - 1), (u || o.initialSlide || 0) === (c || 0) && n && r.emit("beforeSlideChangeStart");
                var p = -s[d];
                if (r.updateProgress(p), o.normalizeSlideIndex)
                    for (var f = 0; f < l.length; f += 1) - Math.floor(100 * p) >= Math.floor(100 * l[f]) && (a = f);
                if (r.initialized && a !== u) {
                    if (!r.allowSlideNext && p < r.translate && p < r.minTranslate()) return !1;
                    if (!r.allowSlidePrev && p > r.translate && p > r.maxTranslate() && (u || 0) !== a) return !1
                }
                var m;
                return m = a > u ? "next" : a < u ? "prev" : "reset", h && -p === r.translate || !h && p === r.translate ? (r.updateActiveIndex(a), o.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), "slide" !== o.effect && r.setTranslate(p), "reset" !== m && (r.transitionStart(n, m), r.transitionEnd(n, m)), !1) : (0 !== t && Ne.transition ? (r.setTransition(t), r.setTranslate(p), r.updateActiveIndex(a), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, i), r.transitionStart(n, m), r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function (e) {
                    r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(n, m))
                }), r.$wrapperEl[0].addEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd))) : (r.setTransition(0), r.setTranslate(p), r.updateActiveIndex(a), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, i), r.transitionStart(n, m), r.transitionEnd(n, m)), !0)
            }

            function ne(e, t, n, i) {
                void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === n && (n = !0);
                var r = this,
                    a = e;
                return r.params.loop && (a += r.loopedSlides), r.slideTo(a, t, n, i)
            }

            function ie(e, t, n) {
                void 0 === e && (e = this.params.speed), void 0 === t && (t = !0);
                var i = this,
                    r = i.params,
                    a = i.animating;
                return r.loop ? !a && (i.loopFix(), i._clientLeft = i.$wrapperEl[0].clientLeft, i.slideTo(i.activeIndex + r.slidesPerGroup, e, t, n)) : i.slideTo(i.activeIndex + r.slidesPerGroup, e, t, n)
            }

            function re(e, t, n) {
                function i(e) {
                    return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e)
                }
                void 0 === e && (e = this.params.speed), void 0 === t && (t = !0);
                var r = this,
                    a = r.params,
                    o = r.animating,
                    s = r.snapGrid,
                    l = r.slidesGrid,
                    c = r.rtlTranslate;
                if (a.loop) {
                    if (o) return !1;
                    r.loopFix(), r._clientLeft = r.$wrapperEl[0].clientLeft
                }
                var u, h = c ? r.translate : -r.translate,
                    d = i(h),
                    p = s.map(function (e) {
                        return i(e)
                    }),
                    f = (l.map(function (e) {
                        return i(e)
                    }), s[p.indexOf(d)], s[p.indexOf(d) - 1]);
                return "undefined" != typeof f && (u = l.indexOf(f), u < 0 && (u = r.activeIndex - 1)), r.slideTo(u, e, t, n)
            }

            function ae(e, t, n) {
                void 0 === e && (e = this.params.speed), void 0 === t && (t = !0);
                var i = this;
                return i.slideTo(i.activeIndex, e, t, n)
            }

            function oe(e, t, n) {
                void 0 === e && (e = this.params.speed), void 0 === t && (t = !0);
                var i = this,
                    r = i.activeIndex,
                    a = Math.floor(r / i.params.slidesPerGroup);
                if (a < i.snapGrid.length - 1) {
                    var o = i.rtlTranslate ? i.translate : -i.translate,
                        s = i.snapGrid[a],
                        l = i.snapGrid[a + 1];
                    o - s > (l - s) / 2 && (r = i.params.slidesPerGroup)
                }
                return i.slideTo(r, e, t, n)
            }

            function se() {
                var t, n = this,
                    i = n.params,
                    r = n.$wrapperEl,
                    a = "auto" === i.slidesPerView ? n.slidesPerViewDynamic() : i.slidesPerView,
                    o = n.clickedIndex;
                if (i.loop) {
                    if (n.animating) return;
                    t = parseInt(e(n.clickedSlide).attr("data-swiper-slide-index"), 10), i.centeredSlides ? o < n.loopedSlides - a / 2 || o > n.slides.length - n.loopedSlides + a / 2 ? (n.loopFix(), o = r.children("." + i.slideClass + '[data-swiper-slide-index="' + t + '"]:not(.' + i.slideDuplicateClass + ")").eq(0).index(), Be.nextTick(function () {
                        n.slideTo(o)
                    })) : n.slideTo(o) : o > n.slides.length - a ? (n.loopFix(), o = r.children("." + i.slideClass + '[data-swiper-slide-index="' + t + '"]:not(.' + i.slideDuplicateClass + ")").eq(0).index(), Be.nextTick(function () {
                        n.slideTo(o)
                    })) : n.slideTo(o)
                } else n.slideTo(o)
            }

            function le() {
                var t = this,
                    n = t.params,
                    i = t.$wrapperEl;
                i.children("." + n.slideClass + "." + n.slideDuplicateClass).remove();
                var r = i.children("." + n.slideClass);
                if (n.loopFillGroupWithBlank) {
                    var a = n.slidesPerGroup - r.length % n.slidesPerGroup;
                    if (a !== n.slidesPerGroup) {
                        for (var o = 0; o < a; o += 1) {
                            var s = e(Oe.createElement("div")).addClass(n.slideClass + " " + n.slideBlankClass);
                            i.append(s)
                        }
                        r = i.children("." + n.slideClass)
                    }
                }
                "auto" !== n.slidesPerView || n.loopedSlides || (n.loopedSlides = r.length), t.loopedSlides = parseInt(n.loopedSlides || n.slidesPerView, 10), t.loopedSlides += n.loopAdditionalSlides, t.loopedSlides > r.length && (t.loopedSlides = r.length);
                var l = [],
                    c = [];
                r.each(function (n, i) {
                    var a = e(i);
                    n < t.loopedSlides && c.push(i), n < r.length && n >= r.length - t.loopedSlides && l.push(i), a.attr("data-swiper-slide-index", n)
                });
                for (var u = 0; u < c.length; u += 1) i.append(e(c[u].cloneNode(!0)).addClass(n.slideDuplicateClass));
                for (var h = l.length - 1; h >= 0; h -= 1) i.prepend(e(l[h].cloneNode(!0)).addClass(n.slideDuplicateClass))
            }

            function ce() {
                var e, t = this,
                    n = t.params,
                    i = t.activeIndex,
                    r = t.slides,
                    a = t.loopedSlides,
                    o = t.allowSlidePrev,
                    s = t.allowSlideNext,
                    l = t.snapGrid,
                    c = t.rtlTranslate;
                t.allowSlidePrev = !0, t.allowSlideNext = !0;
                var u = -l[i],
                    h = u - t.getTranslate();
                if (i < a) {
                    e = r.length - 3 * a + i, e += a;
                    var d = t.slideTo(e, 0, !1, !0);
                    d && 0 !== h && t.setTranslate((c ? -t.translate : t.translate) - h)
                } else if ("auto" === n.slidesPerView && i >= 2 * a || i >= r.length - a) {
                    e = -r.length + i + a, e += a;
                    var p = t.slideTo(e, 0, !1, !0);
                    p && 0 !== h && t.setTranslate((c ? -t.translate : t.translate) - h)
                }
                t.allowSlidePrev = o, t.allowSlideNext = s
            }

            function ue() {
                var e = this,
                    t = e.$wrapperEl,
                    n = e.params,
                    i = e.slides;
                t.children("." + n.slideClass + "." + n.slideDuplicateClass + ",." + n.slideClass + "." + n.slideBlankClass).remove(), i.removeAttr("data-swiper-slide-index")
            }

            function he(e) {
                var t = this;
                if (!(Ne.touch || !t.params.simulateTouch || t.params.watchOverflow && t.isLocked)) {
                    var n = t.el;
                    n.style.cursor = "move", n.style.cursor = e ? "-webkit-grabbing" : "-webkit-grab", n.style.cursor = e ? "-moz-grabbin" : "-moz-grab", n.style.cursor = e ? "grabbing" : "grab"
                }
            }

            function de() {
                var e = this;
                Ne.touch || e.params.watchOverflow && e.isLocked || (e.el.style.cursor = "")
            }

            function pe(e) {
                var t = this,
                    n = t.$wrapperEl,
                    i = t.params;
                if (i.loop && t.loopDestroy(), "object" == typeof e && "length" in e)
                    for (var r = 0; r < e.length; r += 1) e[r] && n.append(e[r]);
                else n.append(e);
                i.loop && t.loopCreate(), i.observer && Ne.observer || t.update()
            }

            function fe(e) {
                var t = this,
                    n = t.params,
                    i = t.$wrapperEl,
                    r = t.activeIndex;
                n.loop && t.loopDestroy();
                var a = r + 1;
                if ("object" == typeof e && "length" in e) {
                    for (var o = 0; o < e.length; o += 1) e[o] && i.prepend(e[o]);
                    a = r + e.length
                } else i.prepend(e);
                n.loop && t.loopCreate(), n.observer && Ne.observer || t.update(), t.slideTo(a, 0, !1)
            }

            function me(e, t) {
                var n = this,
                    i = n.$wrapperEl,
                    r = n.params,
                    a = n.activeIndex,
                    o = a;
                r.loop && (o -= n.loopedSlides, n.loopDestroy(), n.slides = i.children("." + r.slideClass));
                var s = n.slides.length;
                if (e <= 0) return void n.prependSlide(t);
                if (e >= s) return void n.appendSlide(t);
                for (var l = o > e ? o + 1 : o, c = [], u = s - 1; u >= e; u -= 1) {
                    var h = n.slides.eq(u);
                    h.remove(), c.unshift(h)
                }
                if ("object" == typeof t && "length" in t) {
                    for (var d = 0; d < t.length; d += 1) t[d] && i.append(t[d]);
                    l = o > e ? o + t.length : o
                } else i.append(t);
                for (var p = 0; p < c.length; p += 1) i.append(c[p]);
                r.loop && n.loopCreate(), r.observer && Ne.observer || n.update(), r.loop ? n.slideTo(l + n.loopedSlides, 0, !1) : n.slideTo(l, 0, !1)
            }

            function ve(e) {
                var t = this,
                    n = t.params,
                    i = t.$wrapperEl,
                    r = t.activeIndex,
                    a = r;
                n.loop && (a -= t.loopedSlides, t.loopDestroy(), t.slides = i.children("." + n.slideClass));
                var o, s = a;
                if ("object" == typeof e && "length" in e) {
                    for (var l = 0; l < e.length; l += 1) o = e[l], t.slides[o] && t.slides.eq(o).remove(), o < s && (s -= 1);
                    s = Math.max(s, 0)
                } else o = e, t.slides[o] && t.slides.eq(o).remove(), o < s && (s -= 1), s = Math.max(s, 0);
                n.loop && t.loopCreate(), n.observer && Ne.observer || t.update(), n.loop ? t.slideTo(s + t.loopedSlides, 0, !1) : t.slideTo(s, 0, !1)
            }

            function ge() {
                for (var e = this, t = [], n = 0; n < e.slides.length; n += 1) t.push(n);
                e.removeSlide(t)
            }

            function ye(t) {
                var n = this,
                    i = n.touchEventsData,
                    r = n.params,
                    a = n.touches;
                if (!n.animating || !r.preventInteractionOnTransition) {
                    var o = t;
                    if (o.originalEvent && (o = o.originalEvent), i.isTouchEvent = "touchstart" === o.type, (i.isTouchEvent || !("which" in o) || 3 !== o.which) && !(!i.isTouchEvent && "button" in o && o.button > 0 || i.isTouched && i.isMoved)) {
                        if (r.noSwiping && e(o.target).closest(r.noSwipingSelector ? r.noSwipingSelector : "." + r.noSwipingClass)[0]) return void(n.allowClick = !0);
                        if (!r.swipeHandler || e(o).closest(r.swipeHandler)[0]) {
                            a.currentX = "touchstart" === o.type ? o.targetTouches[0].pageX : o.pageX, a.currentY = "touchstart" === o.type ? o.targetTouches[0].pageY : o.pageY;
                            var s = a.currentX,
                                l = a.currentY,
                                c = r.edgeSwipeDetection || r.iOSEdgeSwipeDetection,
                                u = r.edgeSwipeThreshold || r.iOSEdgeSwipeThreshold;
                            if (!c || !(s <= u || s >= ke.screen.width - u)) {
                                if (Be.extend(i, {
                                        isTouched: !0,
                                        isMoved: !1,
                                        allowTouchCallbacks: !0,
                                        isScrolling: void 0,
                                        startMoving: void 0
                                    }), a.startX = s, a.startY = l, i.touchStartTime = Be.now(), n.allowClick = !0, n.updateSize(), n.swipeDirection = void 0, r.threshold > 0 && (i.allowThresholdMove = !1), "touchstart" !== o.type) {
                                    var h = !0;
                                    e(o.target).is(i.formElements) && (h = !1), Oe.activeElement && e(Oe.activeElement).is(i.formElements) && Oe.activeElement !== o.target && Oe.activeElement.blur();
                                    var d = h && n.allowTouchMove && r.touchStartPreventDefault;
                                    (r.touchStartForcePreventDefault || d) && o.preventDefault()
                                }
                                n.emit("touchStart", o)
                            }
                        }
                    }
                }
            }

            function xe(t) {
                var n = this,
                    i = n.touchEventsData,
                    r = n.params,
                    a = n.touches,
                    o = n.rtlTranslate,
                    s = t;
                if (s.originalEvent && (s = s.originalEvent), !i.isTouched) return void(i.startMoving && i.isScrolling && n.emit("touchMoveOpposite", s));
                if (!i.isTouchEvent || "mousemove" !== s.type) {
                    var l = "touchmove" === s.type ? s.targetTouches[0].pageX : s.pageX,
                        c = "touchmove" === s.type ? s.targetTouches[0].pageY : s.pageY;
                    if (s.preventedByNestedSwiper) return a.startX = l, void(a.startY = c);
                    if (!n.allowTouchMove) return n.allowClick = !1, void(i.isTouched && (Be.extend(a, {
                        startX: l,
                        startY: c,
                        currentX: l,
                        currentY: c
                    }), i.touchStartTime = Be.now()));
                    if (i.isTouchEvent && r.touchReleaseOnEdges && !r.loop)
                        if (n.isVertical()) {
                            if (c < a.startY && n.translate <= n.maxTranslate() || c > a.startY && n.translate >= n.minTranslate()) return i.isTouched = !1, void(i.isMoved = !1)
                        } else if (l < a.startX && n.translate <= n.maxTranslate() || l > a.startX && n.translate >= n.minTranslate()) return;
                    if (i.isTouchEvent && Oe.activeElement && s.target === Oe.activeElement && e(s.target).is(i.formElements)) return i.isMoved = !0, void(n.allowClick = !1);
                    if (i.allowTouchCallbacks && n.emit("touchMove", s), !(s.targetTouches && s.targetTouches.length > 1)) {
                        a.currentX = l, a.currentY = c;
                        var u = a.currentX - a.startX,
                            h = a.currentY - a.startY;
                        if (!(n.params.threshold && Math.sqrt(Math.pow(u, 2) + Math.pow(h, 2)) < n.params.threshold)) {
                            if ("undefined" == typeof i.isScrolling) {
                                var d;
                                n.isHorizontal() && a.currentY === a.startY || n.isVertical() && a.currentX === a.startX ? i.isScrolling = !1 : u * u + h * h >= 25 && (d = 180 * Math.atan2(Math.abs(h), Math.abs(u)) / Math.PI, i.isScrolling = n.isHorizontal() ? d > r.touchAngle : 90 - d > r.touchAngle)
                            }
                            if (i.isScrolling && n.emit("touchMoveOpposite", s), "undefined" == typeof i.startMoving && (a.currentX === a.startX && a.currentY === a.startY || (i.startMoving = !0)), i.isScrolling) return void(i.isTouched = !1);
                            if (i.startMoving) {
                                n.allowClick = !1, s.preventDefault(), r.touchMoveStopPropagation && !r.nested && s.stopPropagation(), i.isMoved || (r.loop && n.loopFix(), i.startTranslate = n.getTranslate(), n.setTransition(0), n.animating && n.$wrapperEl.trigger("webkitTransitionEnd transitionend"), i.allowMomentumBounce = !1, !r.grabCursor || n.allowSlideNext !== !0 && n.allowSlidePrev !== !0 || n.setGrabCursor(!0), n.emit("sliderFirstMove", s)), n.emit("sliderMove", s), i.isMoved = !0;
                                var p = n.isHorizontal() ? u : h;
                                a.diff = p, p *= r.touchRatio, o && (p = -p), n.swipeDirection = p > 0 ? "prev" : "next", i.currentTranslate = p + i.startTranslate;
                                var f = !0,
                                    m = r.resistanceRatio;
                                if (r.touchReleaseOnEdges && (m = 0), p > 0 && i.currentTranslate > n.minTranslate() ? (f = !1, r.resistance && (i.currentTranslate = n.minTranslate() - 1 + Math.pow(-n.minTranslate() + i.startTranslate + p, m))) : p < 0 && i.currentTranslate < n.maxTranslate() && (f = !1, r.resistance && (i.currentTranslate = n.maxTranslate() + 1 - Math.pow(n.maxTranslate() - i.startTranslate - p, m))), f && (s.preventedByNestedSwiper = !0), !n.allowSlideNext && "next" === n.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !n.allowSlidePrev && "prev" === n.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), r.threshold > 0) {
                                    if (!(Math.abs(p) > r.threshold || i.allowThresholdMove)) return void(i.currentTranslate = i.startTranslate);
                                    if (!i.allowThresholdMove) return i.allowThresholdMove = !0, a.startX = a.currentX, a.startY = a.currentY, i.currentTranslate = i.startTranslate, void(a.diff = n.isHorizontal() ? a.currentX - a.startX : a.currentY - a.startY)
                                }
                                r.followFinger && ((r.freeMode || r.watchSlidesProgress || r.watchSlidesVisibility) && (n.updateActiveIndex(), n.updateSlidesClasses()), r.freeMode && (0 === i.velocities.length && i.velocities.push({
                                    position: a[n.isHorizontal() ? "startX" : "startY"],
                                    time: i.touchStartTime
                                }), i.velocities.push({
                                    position: a[n.isHorizontal() ? "currentX" : "currentY"],
                                    time: Be.now()
                                })), n.updateProgress(i.currentTranslate), n.setTranslate(i.currentTranslate))
                            }
                        }
                    }
                }
            }

            function be(e) {
                var t = this,
                    n = t.touchEventsData,
                    i = t.params,
                    r = t.touches,
                    a = t.rtlTranslate,
                    o = t.$wrapperEl,
                    s = t.slidesGrid,
                    l = t.snapGrid,
                    c = e;
                if (c.originalEvent && (c = c.originalEvent), n.allowTouchCallbacks && t.emit("touchEnd", c), n.allowTouchCallbacks = !1, !n.isTouched) return n.isMoved && i.grabCursor && t.setGrabCursor(!1), n.isMoved = !1, void(n.startMoving = !1);
                i.grabCursor && n.isMoved && n.isTouched && (t.allowSlideNext === !0 || t.allowSlidePrev === !0) && t.setGrabCursor(!1);
                var u = Be.now(),
                    h = u - n.touchStartTime;
                if (t.allowClick && (t.updateClickedSlide(c), t.emit("tap", c), h < 300 && u - n.lastClickTime > 300 && (n.clickTimeout && clearTimeout(n.clickTimeout), n.clickTimeout = Be.nextTick(function () {
                        t && !t.destroyed && t.emit("click", c)
                    }, 300)), h < 300 && u - n.lastClickTime < 300 && (n.clickTimeout && clearTimeout(n.clickTimeout), t.emit("doubleTap", c))), n.lastClickTime = Be.now(), Be.nextTick(function () {
                        t.destroyed || (t.allowClick = !0)
                    }), !n.isTouched || !n.isMoved || !t.swipeDirection || 0 === r.diff || n.currentTranslate === n.startTranslate) return n.isTouched = !1, n.isMoved = !1, void(n.startMoving = !1);
                n.isTouched = !1, n.isMoved = !1, n.startMoving = !1;
                var d;
                if (d = i.followFinger ? a ? t.translate : -t.translate : -n.currentTranslate, i.freeMode) {
                    if (d < -t.minTranslate()) return void t.slideTo(t.activeIndex);
                    if (d > -t.maxTranslate()) return void(t.slides.length < l.length ? t.slideTo(l.length - 1) : t.slideTo(t.slides.length - 1));
                    if (i.freeModeMomentum) {
                        if (n.velocities.length > 1) {
                            var p = n.velocities.pop(),
                                f = n.velocities.pop(),
                                m = p.position - f.position,
                                v = p.time - f.time;
                            t.velocity = m / v, t.velocity /= 2, Math.abs(t.velocity) < i.freeModeMinimumVelocity && (t.velocity = 0), (v > 150 || Be.now() - p.time > 300) && (t.velocity = 0)
                        } else t.velocity = 0;
                        t.velocity *= i.freeModeMomentumVelocityRatio, n.velocities.length = 0;
                        var g = 1e3 * i.freeModeMomentumRatio,
                            y = t.velocity * g,
                            x = t.translate + y;
                        a && (x = -x);
                        var b, _, w = !1,
                            M = 20 * Math.abs(t.velocity) * i.freeModeMomentumBounceRatio;
                        if (x < t.maxTranslate()) i.freeModeMomentumBounce ? (x + t.maxTranslate() < -M && (x = t.maxTranslate() - M), b = t.maxTranslate(), w = !0, n.allowMomentumBounce = !0) : x = t.maxTranslate(), i.loop && i.centeredSlides && (_ = !0);
                        else if (x > t.minTranslate()) i.freeModeMomentumBounce ? (x - t.minTranslate() > M && (x = t.minTranslate() + M), b = t.minTranslate(), w = !0, n.allowMomentumBounce = !0) : x = t.minTranslate(), i.loop && i.centeredSlides && (_ = !0);
                        else if (i.freeModeSticky) {
                            for (var T, E = 0; E < l.length; E += 1)
                                if (l[E] > -x) {
                                    T = E;
                                    break
                                } x = Math.abs(l[T] - x) < Math.abs(l[T - 1] - x) || "next" === t.swipeDirection ? l[T] : l[T - 1], x = -x
                        }
                        if (_ && t.once("transitionEnd", function () {
                                t.loopFix()
                            }), 0 !== t.velocity) g = a ? Math.abs((-x - t.translate) / t.velocity) : Math.abs((x - t.translate) / t.velocity);
                        else if (i.freeModeSticky) return void t.slideToClosest();
                        i.freeModeMomentumBounce && w ? (t.updateProgress(b), t.setTransition(g), t.setTranslate(x), t.transitionStart(!0, t.swipeDirection), t.animating = !0, o.transitionEnd(function () {
                            t && !t.destroyed && n.allowMomentumBounce && (t.emit("momentumBounce"), t.setTransition(i.speed), t.setTranslate(b), o.transitionEnd(function () {
                                t && !t.destroyed && t.transitionEnd()
                            }))
                        })) : t.velocity ? (t.updateProgress(x), t.setTransition(g), t.setTranslate(x), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, o.transitionEnd(function () {
                            t && !t.destroyed && t.transitionEnd()
                        }))) : t.updateProgress(x), t.updateActiveIndex(), t.updateSlidesClasses()
                    } else if (i.freeModeSticky) return void t.slideToClosest();
                    return void((!i.freeModeMomentum || h >= i.longSwipesMs) && (t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses()))
                }
                for (var S = 0, P = t.slidesSizesGrid[0], C = 0; C < s.length; C += i.slidesPerGroup) "undefined" != typeof s[C + i.slidesPerGroup] ? d >= s[C] && d < s[C + i.slidesPerGroup] && (S = C, P = s[C + i.slidesPerGroup] - s[C]) : d >= s[C] && (S = C, P = s[s.length - 1] - s[s.length - 2]);
                var A = (d - s[S]) / P;
                if (h > i.longSwipesMs) {
                    if (!i.longSwipes) return void t.slideTo(t.activeIndex);
                    "next" === t.swipeDirection && (A >= i.longSwipesRatio ? t.slideTo(S + i.slidesPerGroup) : t.slideTo(S)), "prev" === t.swipeDirection && (A > 1 - i.longSwipesRatio ? t.slideTo(S + i.slidesPerGroup) : t.slideTo(S))
                } else {
                    if (!i.shortSwipes) return void t.slideTo(t.activeIndex);
                    "next" === t.swipeDirection && t.slideTo(S + i.slidesPerGroup), "prev" === t.swipeDirection && t.slideTo(S)
                }
            }

            function _e() {
                var e = this,
                    t = e.params,
                    n = e.el;
                if (!n || 0 !== n.offsetWidth) {
                    t.breakpoints && e.setBreakpoint();
                    var i = e.allowSlideNext,
                        r = e.allowSlidePrev,
                        a = e.snapGrid;
                    if (e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), t.freeMode) {
                        var o = Math.min(Math.max(e.translate, e.maxTranslate()), e.minTranslate());
                        e.setTranslate(o), e.updateActiveIndex(), e.updateSlidesClasses(), t.autoHeight && e.updateAutoHeight()
                    } else e.updateSlidesClasses(), ("auto" === t.slidesPerView || t.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0);
                    e.allowSlidePrev = r, e.allowSlideNext = i, e.params.watchOverflow && a !== e.snapGrid && e.checkOverflow()
                }
            }

            function we(e) {
                var t = this;
                t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation()))
            }

            function Me() {
                var e = this,
                    t = e.params,
                    n = e.touchEvents,
                    i = e.el,
                    r = e.wrapperEl;
                e.onTouchStart = ye.bind(e), e.onTouchMove = xe.bind(e), e.onTouchEnd = be.bind(e), e.onClick = we.bind(e);
                var a = "container" === t.touchEventsTarget ? i : r,
                    o = !!t.nested;
                if (Ne.touch || !Ne.pointerEvents && !Ne.prefixedPointerEvents) {
                    if (Ne.touch) {
                        var s = !("touchstart" !== n.start || !Ne.passiveListener || !t.passiveListeners) && {
                            passive: !0,
                            capture: !1
                        };
                        a.addEventListener(n.start, e.onTouchStart, s), a.addEventListener(n.move, e.onTouchMove, Ne.passiveListener ? {
                            passive: !1,
                            capture: o
                        } : o), a.addEventListener(n.end, e.onTouchEnd, s)
                    }(t.simulateTouch && !Ye.ios && !Ye.android || t.simulateTouch && !Ne.touch && Ye.ios) && (a.addEventListener("mousedown", e.onTouchStart, !1), Oe.addEventListener("mousemove", e.onTouchMove, o), Oe.addEventListener("mouseup", e.onTouchEnd, !1))
                } else a.addEventListener(n.start, e.onTouchStart, !1), Oe.addEventListener(n.move, e.onTouchMove, o), Oe.addEventListener(n.end, e.onTouchEnd, !1);
                (t.preventClicks || t.preventClicksPropagation) && a.addEventListener("click", e.onClick, !0), e.on(Ye.ios || Ye.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", _e, !0)
            }

            function Te() {
                var e = this,
                    t = e.params,
                    n = e.touchEvents,
                    i = e.el,
                    r = e.wrapperEl,
                    a = "container" === t.touchEventsTarget ? i : r,
                    o = !!t.nested;
                if (Ne.touch || !Ne.pointerEvents && !Ne.prefixedPointerEvents) {
                    if (Ne.touch) {
                        var s = !("onTouchStart" !== n.start || !Ne.passiveListener || !t.passiveListeners) && {
                            passive: !0,
                            capture: !1
                        };
                        a.removeEventListener(n.start, e.onTouchStart, s), a.removeEventListener(n.move, e.onTouchMove, o), a.removeEventListener(n.end, e.onTouchEnd, s)
                    }(t.simulateTouch && !Ye.ios && !Ye.android || t.simulateTouch && !Ne.touch && Ye.ios) && (a.removeEventListener("mousedown", e.onTouchStart, !1), Oe.removeEventListener("mousemove", e.onTouchMove, o), Oe.removeEventListener("mouseup", e.onTouchEnd, !1))
                } else a.removeEventListener(n.start, e.onTouchStart, !1), Oe.removeEventListener(n.move, e.onTouchMove, o), Oe.removeEventListener(n.end, e.onTouchEnd, !1);
                (t.preventClicks || t.preventClicksPropagation) && a.removeEventListener("click", e.onClick, !0), e.off(Ye.ios || Ye.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", _e)
            }

            function Ee() {
                var e = this,
                    t = e.activeIndex,
                    n = e.initialized,
                    i = e.loopedSlides;
                void 0 === i && (i = 0);
                var r = e.params,
                    a = r.breakpoints;
                if (a && (!a || 0 !== Object.keys(a).length)) {
                    var o = e.getBreakpoint(a);
                    if (o && e.currentBreakpoint !== o) {
                        var s = o in a ? a[o] : void 0;
                        s && ["slidesPerView", "spaceBetween", "slidesPerGroup"].forEach(function (e) {
                            var t = s[e];
                            "undefined" != typeof t && ("slidesPerView" !== e || "AUTO" !== t && "auto" !== t ? "slidesPerView" === e ? s[e] = parseFloat(t) : s[e] = parseInt(t, 10) : s[e] = "auto")
                        });
                        var l = s || e.originalParams,
                            c = r.loop && l.slidesPerView !== r.slidesPerView;
                        Be.extend(e.params, l), Be.extend(e, {
                            allowTouchMove: e.params.allowTouchMove,
                            allowSlideNext: e.params.allowSlideNext,
                            allowSlidePrev: e.params.allowSlidePrev
                        }), e.currentBreakpoint = o, c && n && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - i + e.loopedSlides, 0, !1)), e.emit("breakpoint", l)
                    }
                }
            }

            function Se(e) {
                var t = this;
                if (e) {
                    var n = !1,
                        i = [];
                    Object.keys(e).forEach(function (e) {
                        i.push(e)
                    }), i.sort(function (e, t) {
                        return parseInt(e, 10) - parseInt(t, 10)
                    });
                    for (var r = 0; r < i.length; r += 1) {
                        var a = i[r];
                        t.params.breakpointsInverse ? a <= ke.innerWidth && (n = a) : a >= ke.innerWidth && !n && (n = a)
                    }
                    return n || "max"
                }
            }

            function Pe() {
                var e = this,
                    t = e.classNames,
                    n = e.params,
                    i = e.rtl,
                    r = e.$el,
                    a = [];
                a.push(n.direction), n.freeMode && a.push("free-mode"), Ne.flexbox || a.push("no-flexbox"), n.autoHeight && a.push("autoheight"), i && a.push("rtl"), n.slidesPerColumn > 1 && a.push("multirow"), Ye.android && a.push("android"), Ye.ios && a.push("ios"), ($e.isIE || $e.isEdge) && (Ne.pointerEvents || Ne.prefixedPointerEvents) && a.push("wp8-" + n.direction), a.forEach(function (e) {
                    t.push(n.containerModifierClass + e)
                }), r.addClass(t.join(" "))
            }

            function Ce() {
                var e = this,
                    t = e.$el,
                    n = e.classNames;
                t.removeClass(n.join(" "))
            }

            function Ae(e, t, n, i, r, a) {
                function o() {
                    a && a()
                }
                var s;
                e.complete && r ? o() : t ? (s = new ke.Image, s.onload = o, s.onerror = o, i && (s.sizes = i), n && (s.srcset = n), t && (s.src = t)) : o()
            }

            function Le() {
                function e() {
                    "undefined" != typeof t && null !== t && t && !t.destroyed && (void 0 !== t.imagesLoaded && (t.imagesLoaded += 1), t.imagesLoaded === t.imagesToLoad.length && (t.params.updateOnImagesReady && t.update(), t.emit("imagesReady")))
                }
                var t = this;
                t.imagesToLoad = t.$el.find("img");
                for (var n = 0; n < t.imagesToLoad.length; n += 1) {
                    var i = t.imagesToLoad[n];
                    t.loadImage(i, i.currentSrc || i.getAttribute("src"), i.srcset || i.getAttribute("srcset"), i.sizes || i.getAttribute("sizes"), !0, e)
                }
            }

            function Re() {
                var e = this,
                    t = e.isLocked;
                e.isLocked = 1 === e.snapGrid.length, e.allowSlideNext = !e.isLocked, e.allowSlidePrev = !e.isLocked, t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock"), t && t !== e.isLocked && (e.isEnd = !1, e.navigation.update())
            }

            function Ie() {
                var e = "onwheel",
                    t = e in Oe;
                if (!t) {
                    var n = Oe.createElement("div");
                    n.setAttribute(e, "return;"), t = "function" == typeof n[e]
                }
                return !t && Oe.implementation && Oe.implementation.hasFeature && Oe.implementation.hasFeature("", "") !== !0 && (t = Oe.implementation.hasFeature("Events.wheel", "3.0")), t
            }
            var Oe = "undefined" == typeof document ? {
                    body: {},
                    addEventListener: function () {},
                    removeEventListener: function () {},
                    activeElement: {
                        blur: function () {},
                        nodeName: ""
                    },
                    querySelector: function () {
                        return null
                    },
                    querySelectorAll: function () {
                        return []
                    },
                    getElementById: function () {
                        return null
                    },
                    createEvent: function () {
                        return {
                            initEvent: function () {}
                        }
                    },
                    createElement: function () {
                        return {
                            children: [],
                            childNodes: [],
                            style: {},
                            setAttribute: function () {},
                            getElementsByTagName: function () {
                                return []
                            }
                        }
                    },
                    location: {
                        hash: ""
                    }
                } : document,
                ke = "undefined" == typeof window ? {
                    document: Oe,
                    navigator: {
                        userAgent: ""
                    },
                    location: {},
                    history: {},
                    CustomEvent: function () {
                        return this
                    },
                    addEventListener: function () {},
                    removeEventListener: function () {},
                    getComputedStyle: function () {
                        return {
                            getPropertyValue: function () {
                                return ""
                            }
                        }
                    },
                    Image: function () {},
                    Date: function () {},
                    screen: {},
                    setTimeout: function () {},
                    clearTimeout: function () {}
                } : window,
                De = function (e) {
                    for (var t = this, n = 0; n < e.length; n += 1) t[n] = e[n];
                    return t.length = e.length, this
                };
            e.fn = De.prototype, e.Class = De, e.Dom7 = De;
            var ze = {
                addClass: n,
                removeClass: i,
                hasClass: r,
                toggleClass: a,
                attr: o,
                removeAttr: s,
                data: l,
                transform: c,
                transition: u,
                on: h,
                off: d,
                trigger: p,
                transitionEnd: f,
                outerWidth: m,
                outerHeight: v,
                offset: g,
                css: x,
                each: b,
                html: _,
                text: w,
                is: M,
                index: T,
                eq: E,
                append: S,
                prepend: P,
                next: C,
                nextAll: A,
                prev: L,
                prevAll: R,
                parent: I,
                parents: O,
                closest: k,
                find: D,
                children: z,
                remove: B,
                add: N,
                styles: y
            };
            Object.keys(ze).forEach(function (t) {
                e.fn[t] = ze[t]
            });
            var Be = {
                    deleteProps: function (e) {
                        var t = e;
                        Object.keys(t).forEach(function (e) {
                            try {
                                t[e] = null
                            } catch (n) {}
                            try {
                                delete t[e]
                            } catch (n) {}
                        })
                    },
                    nextTick: function (e, t) {
                        return void 0 === t && (t = 0), setTimeout(e, t)
                    },
                    now: function () {
                        return Date.now()
                    },
                    getTranslate: function (e, t) {
                        void 0 === t && (t = "x");
                        var n, i, r, a = ke.getComputedStyle(e, null);
                        return ke.WebKitCSSMatrix ? (i = a.transform || a.webkitTransform, i.split(",").length > 6 && (i = i.split(", ").map(function (e) {
                            return e.replace(",", ".")
                        }).join(", ")), r = new ke.WebKitCSSMatrix("none" === i ? "" : i)) : (r = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), n = r.toString().split(",")), "x" === t && (i = ke.WebKitCSSMatrix ? r.m41 : 16 === n.length ? parseFloat(n[12]) : parseFloat(n[4])), "y" === t && (i = ke.WebKitCSSMatrix ? r.m42 : 16 === n.length ? parseFloat(n[13]) : parseFloat(n[5])), i || 0
                    },
                    parseUrlQuery: function (e) {
                        var t, n, i, r, a = {},
                            o = e || ke.location.href;
                        if ("string" == typeof o && o.length)
                            for (o = o.indexOf("?") > -1 ? o.replace(/\S*\?/, "") : "", n = o.split("&").filter(function (e) {
                                    return "" !== e
                                }), r = n.length, t = 0; t < r; t += 1) i = n[t].replace(/#\S+/g, "").split("="), a[decodeURIComponent(i[0])] = "undefined" == typeof i[1] ? void 0 : decodeURIComponent(i[1]) || "";
                        return a
                    },
                    isObject: function (e) {
                        return "object" == typeof e && null !== e && e.constructor && e.constructor === Object
                    },
                    extend: function () {
                        for (var e = [], t = arguments.length; t--;) e[t] = arguments[t];
                        for (var n = Object(e[0]), i = 1; i < e.length; i += 1) {
                            var r = e[i];
                            if (void 0 !== r && null !== r)
                                for (var a = Object.keys(Object(r)), o = 0, s = a.length; o < s; o += 1) {
                                    var l = a[o],
                                        c = Object.getOwnPropertyDescriptor(r, l);
                                    void 0 !== c && c.enumerable && (Be.isObject(n[l]) && Be.isObject(r[l]) ? Be.extend(n[l], r[l]) : !Be.isObject(n[l]) && Be.isObject(r[l]) ? (n[l] = {}, Be.extend(n[l], r[l])) : n[l] = r[l])
                                }
                        }
                        return n
                    }
                },
                Ne = function () {
                    var e = Oe.createElement("div");
                    return {
                        touch: ke.Modernizr && ke.Modernizr.touch === !0 || function () {
                            return !!(ke.navigator.maxTouchPoints > 0 || "ontouchstart" in ke || ke.DocumentTouch && Oe instanceof ke.DocumentTouch)
                        }(),
                        pointerEvents: !!(ke.navigator.pointerEnabled || ke.PointerEvent || "maxTouchPoints" in ke.navigator),
                        prefixedPointerEvents: !!ke.navigator.msPointerEnabled,
                        transition: function () {
                            var t = e.style;
                            return "transition" in t || "webkitTransition" in t || "MozTransition" in t
                        }(),
                        transforms3d: ke.Modernizr && ke.Modernizr.csstransforms3d === !0 || function () {
                            var t = e.style;
                            return "webkitPerspective" in t || "MozPerspective" in t || "OPerspective" in t || "MsPerspective" in t || "perspective" in t
                        }(),
                        flexbox: function () {
                            for (var t = e.style, n = "alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient".split(" "), i = 0; i < n.length; i += 1)
                                if (n[i] in t) return !0;
                            return !1
                        }(),
                        observer: function () {
                            return "MutationObserver" in ke || "WebkitMutationObserver" in ke
                        }(),
                        passiveListener: function () {
                            var e = !1;
                            try {
                                var t = Object.defineProperty({}, "passive", {
                                    get: function () {
                                        e = !0
                                    }
                                });
                                ke.addEventListener("testPassiveListener", null, t)
                            } catch (n) {}
                            return e
                        }(),
                        gestures: function () {
                            return "ongesturestart" in ke
                        }()
                    }
                }(),
                Ue = function (e) {
                    void 0 === e && (e = {});
                    var t = this;
                    t.params = e, t.eventsListeners = {}, t.params && t.params.on && Object.keys(t.params.on).forEach(function (e) {
                        t.on(e, t.params.on[e])
                    })
                },
                je = {
                    components: {
                        configurable: !0
                    }
                };
            Ue.prototype.on = function (e, t, n) {
                var i = this;
                if ("function" != typeof t) return i;
                var r = n ? "unshift" : "push";
                return e.split(" ").forEach(function (e) {
                    i.eventsListeners[e] || (i.eventsListeners[e] = []), i.eventsListeners[e][r](t)
                }), i
            }, Ue.prototype.once = function (e, t, n) {
                function i() {
                    for (var n = [], a = arguments.length; a--;) n[a] = arguments[a];
                    t.apply(r, n), r.off(e, i)
                }
                var r = this;
                return "function" != typeof t ? r : r.on(e, i, n)
            }, Ue.prototype.off = function (e, t) {
                var n = this;
                return n.eventsListeners ? (e.split(" ").forEach(function (e) {
                    "undefined" == typeof t ? n.eventsListeners[e] = [] : n.eventsListeners[e] && n.eventsListeners[e].length && n.eventsListeners[e].forEach(function (i, r) {
                        i === t && n.eventsListeners[e].splice(r, 1)
                    })
                }), n) : n
            }, Ue.prototype.emit = function () {
                for (var e = [], t = arguments.length; t--;) e[t] = arguments[t];
                var n = this;
                if (!n.eventsListeners) return n;
                var i, r, a;
                "string" == typeof e[0] || Array.isArray(e[0]) ? (i = e[0], r = e.slice(1, e.length), a = n) : (i = e[0].events, r = e[0].data, a = e[0].context || n);
                var o = Array.isArray(i) ? i : i.split(" ");
                return o.forEach(function (e) {
                    if (n.eventsListeners && n.eventsListeners[e]) {
                        var t = [];
                        n.eventsListeners[e].forEach(function (e) {
                            t.push(e)
                        }), t.forEach(function (e) {
                            e.apply(a, r)
                        })
                    }
                }), n
            }, Ue.prototype.useModulesParams = function (e) {
                var t = this;
                t.modules && Object.keys(t.modules).forEach(function (n) {
                    var i = t.modules[n];
                    i.params && Be.extend(e, i.params)
                })
            }, Ue.prototype.useModules = function (e) {
                void 0 === e && (e = {});
                var t = this;
                t.modules && Object.keys(t.modules).forEach(function (n) {
                    var i = t.modules[n],
                        r = e[n] || {};
                    i.instance && Object.keys(i.instance).forEach(function (e) {
                        var n = i.instance[e];
                        "function" == typeof n ? t[e] = n.bind(t) : t[e] = n
                    }), i.on && t.on && Object.keys(i.on).forEach(function (e) {
                        t.on(e, i.on[e])
                    }), i.create && i.create.bind(t)(r)
                })
            }, je.components.set = function (e) {
                var t = this;
                t.use && t.use(e)
            }, Ue.installModule = function (e) {
                for (var t = [], n = arguments.length - 1; n-- > 0;) t[n] = arguments[n + 1];
                var i = this;
                i.prototype.modules || (i.prototype.modules = {});
                var r = e.name || Object.keys(i.prototype.modules).length + "_" + Be.now();
                return i.prototype.modules[r] = e, e.proto && Object.keys(e.proto).forEach(function (t) {
                    i.prototype[t] = e.proto[t]
                }), e["static"] && Object.keys(e["static"]).forEach(function (t) {
                    i[t] = e["static"][t]
                }), e.install && e.install.apply(i, t), i
            }, Ue.use = function (e) {
                for (var t = [], n = arguments.length - 1; n-- > 0;) t[n] = arguments[n + 1];
                var i = this;
                return Array.isArray(e) ? (e.forEach(function (e) {
                    return i.installModule(e)
                }), i) : i.installModule.apply(i, [e].concat(t))
            }, Object.defineProperties(Ue, je);
            var Fe = {
                    updateSize: U,
                    updateSlides: j,
                    updateAutoHeight: F,
                    updateSlidesOffset: G,
                    updateSlidesProgress: H,
                    updateProgress: V,
                    updateSlidesClasses: W,
                    updateActiveIndex: q,
                    updateClickedSlide: X
                },
                Ge = {
                    getTranslate: Y,
                    setTranslate: Z,
                    minTranslate: J,
                    maxTranslate: $
                },
                He = {
                    setTransition: Q,
                    transitionStart: K,
                    transitionEnd: ee
                },
                Ve = {
                    slideTo: te,
                    slideToLoop: ne,
                    slideNext: ie,
                    slidePrev: re,
                    slideReset: ae,
                    slideToClosest: oe,
                    slideToClickedSlide: se
                },
                We = {
                    loopCreate: le,
                    loopFix: ce,
                    loopDestroy: ue
                },
                qe = {
                    setGrabCursor: he,
                    unsetGrabCursor: de
                },
                Xe = {
                    appendSlide: pe,
                    prependSlide: fe,
                    addSlide: me,
                    removeSlide: ve,
                    removeAllSlides: ge
                },
                Ye = function () {
                    var e = ke.navigator.userAgent,
                        t = {
                            ios: !1,
                            android: !1,
                            androidChrome: !1,
                            desktop: !1,
                            windows: !1,
                            iphone: !1,
                            ipod: !1,
                            ipad: !1,
                            cordova: ke.cordova || ke.phonegap,
                            phonegap: ke.cordova || ke.phonegap
                        },
                        n = e.match(/(Windows Phone);?[\s\/]+([\d.]+)?/),
                        i = e.match(/(Android);?[\s\/]+([\d.]+)?/),
                        r = e.match(/(iPad).*OS\s([\d_]+)/),
                        a = e.match(/(iPod)(.*OS\s([\d_]+))?/),
                        o = !r && e.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
                    if (n && (t.os = "windows", t.osVersion = n[2], t.windows = !0), i && !n && (t.os = "android", t.osVersion = i[2], t.android = !0, t.androidChrome = e.toLowerCase().indexOf("chrome") >= 0), (r || o || a) && (t.os = "ios", t.ios = !0), o && !a && (t.osVersion = o[2].replace(/_/g, "."), t.iphone = !0), r && (t.osVersion = r[2].replace(/_/g, "."), t.ipad = !0), a && (t.osVersion = a[3] ? a[3].replace(/_/g, ".") : null, t.iphone = !0), t.ios && t.osVersion && e.indexOf("Version/") >= 0 && "10" === t.osVersion.split(".")[0] && (t.osVersion = e.toLowerCase().split("version/")[1].split(" ")[0]), t.desktop = !(t.os || t.android || t.webView), t.webView = (o || r || a) && e.match(/.*AppleWebKit(?!.*Safari)/i), t.os && "ios" === t.os) {
                        var s = t.osVersion.split("."),
                            l = Oe.querySelector('meta[name="viewport"]');
                        t.minimalUi = !t.webView && (a || o) && (1 * s[0] === 7 ? 1 * s[1] >= 1 : 1 * s[0] > 7) && l && l.getAttribute("content").indexOf("minimal-ui") >= 0
                    }
                    return t.pixelRatio = ke.devicePixelRatio || 1, t
                }(),
                Ze = {
                    attachEvents: Me,
                    detachEvents: Te
                },
                Je = {
                    setBreakpoint: Ee,
                    getBreakpoint: Se
                },
                $e = function () {
                    function e() {
                        var e = ke.navigator.userAgent.toLowerCase();
                        return e.indexOf("safari") >= 0 && e.indexOf("chrome") < 0 && e.indexOf("android") < 0
                    }
                    return {
                        isIE: !!ke.navigator.userAgent.match(/Trident/g) || !!ke.navigator.userAgent.match(/MSIE/g),
                        isEdge: !!ke.navigator.userAgent.match(/Edge/g),
                        isSafari: e(),
                        isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(ke.navigator.userAgent)
                    }
                }(),
                Qe = {
                    addClasses: Pe,
                    removeClasses: Ce
                },
                Ke = {
                    loadImage: Ae,
                    preloadImages: Le
                },
                et = {
                    checkOverflow: Re
                },
                tt = {
                    init: !0,
                    direction: "horizontal",
                    touchEventsTarget: "container",
                    initialSlide: 0,
                    speed: 300,
                    preventInteractionOnTransition: !1,
                    edgeSwipeDetection: !1,
                    edgeSwipeThreshold: 20,
                    freeMode: !1,
                    freeModeMomentum: !0,
                    freeModeMomentumRatio: 1,
                    freeModeMomentumBounce: !0,
                    freeModeMomentumBounceRatio: 1,
                    freeModeMomentumVelocityRatio: 1,
                    freeModeSticky: !1,
                    freeModeMinimumVelocity: .02,
                    autoHeight: !1,
                    setWrapperSize: !1,
                    virtualTranslate: !1,
                    effect: "slide",
                    breakpoints: void 0,
                    breakpointsInverse: !1,
                    spaceBetween: 0,
                    slidesPerView: 1,
                    slidesPerColumn: 1,
                    slidesPerColumnFill: "column",
                    slidesPerGroup: 1,
                    centeredSlides: !1,
                    slidesOffsetBefore: 0,
                    slidesOffsetAfter: 0,
                    normalizeSlideIndex: !0,
                    centerInsufficientSlides: !1,
                    watchOverflow: !1,
                    roundLengths: !1,
                    touchRatio: 1,
                    touchAngle: 45,
                    simulateTouch: !0,
                    shortSwipes: !0,
                    longSwipes: !0,
                    longSwipesRatio: .5,
                    longSwipesMs: 300,
                    followFinger: !0,
                    allowTouchMove: !0,
                    threshold: 0,
                    touchMoveStopPropagation: !0,
                    touchStartPreventDefault: !0,
                    touchStartForcePreventDefault: !1,
                    touchReleaseOnEdges: !1,
                    uniqueNavElements: !0,
                    resistance: !0,
                    resistanceRatio: .85,
                    watchSlidesProgress: !1,
                    watchSlidesVisibility: !1,
                    grabCursor: !1,
                    preventClicks: !0,
                    preventClicksPropagation: !0,
                    slideToClickedSlide: !1,
                    preloadImages: !0,
                    updateOnImagesReady: !0,
                    loop: !1,
                    loopAdditionalSlides: 0,
                    loopedSlides: null,
                    loopFillGroupWithBlank: !1,
                    allowSlidePrev: !0,
                    allowSlideNext: !0,
                    swipeHandler: null,
                    noSwiping: !0,
                    noSwipingClass: "swiper-no-swiping",
                    noSwipingSelector: null,
                    passiveListeners: !0,
                    containerModifierClass: "swiper-container-",
                    slideClass: "swiper-slide",
                    slideBlankClass: "swiper-slide-invisible-blank",
                    slideActiveClass: "swiper-slide-active",
                    slideDuplicateActiveClass: "swiper-slide-duplicate-active",
                    slideVisibleClass: "swiper-slide-visible",
                    slideDuplicateClass: "swiper-slide-duplicate",
                    slideNextClass: "swiper-slide-next",
                    slideDuplicateNextClass: "swiper-slide-duplicate-next",
                    slidePrevClass: "swiper-slide-prev",
                    slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
                    wrapperClass: "swiper-wrapper",
                    runCallbacksOnInit: !0
                },
                nt = {
                    update: Fe,
                    translate: Ge,
                    transition: He,
                    slide: Ve,
                    loop: We,
                    grabCursor: qe,
                    manipulation: Xe,
                    events: Ze,
                    breakpoints: Je,
                    checkOverflow: et,
                    classes: Qe,
                    images: Ke
                },
                it = {},
                rt = function (t) {
                    function n() {
                        for (var i, r = [], a = arguments.length; a--;) r[a] = arguments[a];
                        var o, s;
                        1 === r.length && r[0].constructor && r[0].constructor === Object ? s = r[0] : (i = r, o = i[0], s = i[1]), s || (s = {}), s = Be.extend({}, s), o && !s.el && (s.el = o), t.call(this, s), Object.keys(nt).forEach(function (e) {
                            Object.keys(nt[e]).forEach(function (t) {
                                n.prototype[t] || (n.prototype[t] = nt[e][t])
                            })
                        });
                        var l = this;
                        "undefined" == typeof l.modules && (l.modules = {}), Object.keys(l.modules).forEach(function (e) {
                            var t = l.modules[e];
                            if (t.params) {
                                var n = Object.keys(t.params)[0],
                                    i = t.params[n];
                                if ("object" != typeof i || null === i) return;
                                if (!(n in s && "enabled" in i)) return;
                                s[n] === !0 && (s[n] = {
                                    enabled: !0
                                }), "object" != typeof s[n] || "enabled" in s[n] || (s[n].enabled = !0), s[n] || (s[n] = {
                                    enabled: !1
                                })
                            }
                        });
                        var c = Be.extend({}, tt);
                        l.useModulesParams(c), l.params = Be.extend({}, c, it, s), l.originalParams = Be.extend({}, l.params), l.passedParams = Be.extend({}, s), l.$ = e;
                        var u = e(l.params.el);
                        if (o = u[0]) {
                            if (u.length > 1) {
                                var h = [];
                                return u.each(function (e, t) {
                                    var i = Be.extend({}, s, {
                                        el: t
                                    });
                                    h.push(new n(i))
                                }), h
                            }
                            o.swiper = l, u.data("swiper", l);
                            var d = u.children("." + l.params.wrapperClass);
                            return Be.extend(l, {
                                $el: u,
                                el: o,
                                $wrapperEl: d,
                                wrapperEl: d[0],
                                classNames: [],
                                slides: e(),
                                slidesGrid: [],
                                snapGrid: [],
                                slidesSizesGrid: [],
                                isHorizontal: function () {
                                    return "horizontal" === l.params.direction
                                },
                                isVertical: function () {
                                    return "vertical" === l.params.direction
                                },
                                rtl: "rtl" === o.dir.toLowerCase() || "rtl" === u.css("direction"),
                                rtlTranslate: "horizontal" === l.params.direction && ("rtl" === o.dir.toLowerCase() || "rtl" === u.css("direction")),
                                wrongRTL: "-webkit-box" === d.css("display"),
                                activeIndex: 0,
                                realIndex: 0,
                                isBeginning: !0,
                                isEnd: !1,
                                translate: 0,
                                previousTranslate: 0,
                                progress: 0,
                                velocity: 0,
                                animating: !1,
                                allowSlideNext: l.params.allowSlideNext,
                                allowSlidePrev: l.params.allowSlidePrev,
                                touchEvents: function () {
                                    var e = ["touchstart", "touchmove", "touchend"],
                                        t = ["mousedown", "mousemove", "mouseup"];
                                    return Ne.pointerEvents ? t = ["pointerdown", "pointermove", "pointerup"] : Ne.prefixedPointerEvents && (t = ["MSPointerDown", "MSPointerMove", "MSPointerUp"]), l.touchEventsTouch = {
                                        start: e[0],
                                        move: e[1],
                                        end: e[2]
                                    }, l.touchEventsDesktop = {
                                        start: t[0],
                                        move: t[1],
                                        end: t[2]
                                    }, Ne.touch || !l.params.simulateTouch ? l.touchEventsTouch : l.touchEventsDesktop
                                }(),
                                touchEventsData: {
                                    isTouched: void 0,
                                    isMoved: void 0,
                                    allowTouchCallbacks: void 0,
                                    touchStartTime: void 0,
                                    isScrolling: void 0,
                                    currentTranslate: void 0,
                                    startTranslate: void 0,
                                    allowThresholdMove: void 0,
                                    formElements: "input, select, option, textarea, button, video",
                                    lastClickTime: Be.now(),
                                    clickTimeout: void 0,
                                    velocities: [],
                                    allowMomentumBounce: void 0,
                                    isTouchEvent: void 0,
                                    startMoving: void 0
                                },
                                allowClick: !0,
                                allowTouchMove: l.params.allowTouchMove,
                                touches: {
                                    startX: 0,
                                    startY: 0,
                                    currentX: 0,
                                    currentY: 0,
                                    diff: 0
                                },
                                imagesToLoad: [],
                                imagesLoaded: 0
                            }), l.useModules(), l.params.init && l.init(), l
                        }
                    }
                    t && (n.__proto__ = t), n.prototype = Object.create(t && t.prototype), n.prototype.constructor = n;
                    var i = {
                        extendedDefaults: {
                            configurable: !0
                        },
                        defaults: {
                            configurable: !0
                        },
                        Class: {
                            configurable: !0
                        },
                        $: {
                            configurable: !0
                        }
                    };
                    return n.prototype.slidesPerViewDynamic = function () {
                        var e = this,
                            t = e.params,
                            n = e.slides,
                            i = e.slidesGrid,
                            r = e.size,
                            a = e.activeIndex,
                            o = 1;
                        if (t.centeredSlides) {
                            for (var s, l = n[a].swiperSlideSize, c = a + 1; c < n.length; c += 1) n[c] && !s && (l += n[c].swiperSlideSize, o += 1, l > r && (s = !0));
                            for (var u = a - 1; u >= 0; u -= 1) n[u] && !s && (l += n[u].swiperSlideSize, o += 1, l > r && (s = !0))
                        } else
                            for (var h = a + 1; h < n.length; h += 1) i[h] - i[a] < r && (o += 1);
                        return o
                    }, n.prototype.update = function () {
                        function e() {
                            var e = t.rtlTranslate ? t.translate * -1 : t.translate,
                                n = Math.min(Math.max(e, t.maxTranslate()), t.minTranslate());
                            t.setTranslate(n), t.updateActiveIndex(), t.updateSlidesClasses()
                        }
                        var t = this;
                        if (t && !t.destroyed) {
                            var n = t.snapGrid,
                                i = t.params;
                            i.breakpoints && t.setBreakpoint(), t.updateSize(), t.updateSlides(), t.updateProgress(), t.updateSlidesClasses();
                            var r;
                            t.params.freeMode ? (e(), t.params.autoHeight && t.updateAutoHeight()) : (r = ("auto" === t.params.slidesPerView || t.params.slidesPerView > 1) && t.isEnd && !t.params.centeredSlides ? t.slideTo(t.slides.length - 1, 0, !1, !0) : t.slideTo(t.activeIndex, 0, !1, !0), r || e()), i.watchOverflow && n !== t.snapGrid && t.checkOverflow(), t.emit("update")
                        }
                    }, n.prototype.init = function () {
                        var e = this;
                        e.initialized || (e.emit("beforeInit"), e.params.breakpoints && e.setBreakpoint(), e.addClasses(), e.params.loop && e.loopCreate(), e.updateSize(), e.updateSlides(), e.params.watchOverflow && e.checkOverflow(), e.params.grabCursor && e.setGrabCursor(), e.params.preloadImages && e.preloadImages(),
                            e.params.loop ? e.slideTo(e.params.initialSlide + e.loopedSlides, 0, e.params.runCallbacksOnInit) : e.slideTo(e.params.initialSlide, 0, e.params.runCallbacksOnInit), e.attachEvents(), e.initialized = !0, e.emit("init"))
                    }, n.prototype.destroy = function (e, t) {
                        void 0 === e && (e = !0), void 0 === t && (t = !0);
                        var n = this,
                            i = n.params,
                            r = n.$el,
                            a = n.$wrapperEl,
                            o = n.slides;
                        return "undefined" == typeof n.params || n.destroyed ? null : (n.emit("beforeDestroy"), n.initialized = !1, n.detachEvents(), i.loop && n.loopDestroy(), t && (n.removeClasses(), r.removeAttr("style"), a.removeAttr("style"), o && o.length && o.removeClass([i.slideVisibleClass, i.slideActiveClass, i.slideNextClass, i.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index").removeAttr("data-swiper-column").removeAttr("data-swiper-row")), n.emit("destroy"), Object.keys(n.eventsListeners).forEach(function (e) {
                            n.off(e)
                        }), e !== !1 && (n.$el[0].swiper = null, n.$el.data("swiper", null), Be.deleteProps(n)), n.destroyed = !0, null)
                    }, n.extendDefaults = function (e) {
                        Be.extend(it, e)
                    }, i.extendedDefaults.get = function () {
                        return it
                    }, i.defaults.get = function () {
                        return tt
                    }, i.Class.get = function () {
                        return t
                    }, i.$.get = function () {
                        return e
                    }, Object.defineProperties(n, i), n
                }(Ue),
                at = {
                    name: "device",
                    proto: {
                        device: Ye
                    },
                    "static": {
                        device: Ye
                    }
                },
                ot = {
                    name: "support",
                    proto: {
                        support: Ne
                    },
                    "static": {
                        support: Ne
                    }
                },
                st = {
                    name: "browser",
                    proto: {
                        browser: $e
                    },
                    "static": {
                        browser: $e
                    }
                },
                lt = {
                    name: "resize",
                    create: function () {
                        var e = this;
                        Be.extend(e, {
                            resize: {
                                resizeHandler: function () {
                                    e && !e.destroyed && e.initialized && (e.emit("beforeResize"), e.emit("resize"))
                                },
                                orientationChangeHandler: function () {
                                    e && !e.destroyed && e.initialized && e.emit("orientationchange")
                                }
                            }
                        })
                    },
                    on: {
                        init: function () {
                            var e = this;
                            ke.addEventListener("resize", e.resize.resizeHandler), ke.addEventListener("orientationchange", e.resize.orientationChangeHandler)
                        },
                        destroy: function () {
                            var e = this;
                            ke.removeEventListener("resize", e.resize.resizeHandler), ke.removeEventListener("orientationchange", e.resize.orientationChangeHandler)
                        }
                    }
                },
                ct = {
                    func: ke.MutationObserver || ke.WebkitMutationObserver,
                    attach: function (e, t) {
                        void 0 === t && (t = {});
                        var n = this,
                            i = ct.func,
                            r = new i(function (e) {
                                if (1 === e.length) return void n.emit("observerUpdate", e[0]);
                                var t = function () {
                                    n.emit("observerUpdate", e[0])
                                };
                                ke.requestAnimationFrame ? ke.requestAnimationFrame(t) : ke.setTimeout(t, 0)
                            });
                        r.observe(e, {
                            attributes: "undefined" == typeof t.attributes || t.attributes,
                            childList: "undefined" == typeof t.childList || t.childList,
                            characterData: "undefined" == typeof t.characterData || t.characterData
                        }), n.observer.observers.push(r)
                    },
                    init: function () {
                        var e = this;
                        if (Ne.observer && e.params.observer) {
                            if (e.params.observeParents)
                                for (var t = e.$el.parents(), n = 0; n < t.length; n += 1) e.observer.attach(t[n]);
                            e.observer.attach(e.$el[0], {
                                childList: e.params.observeSlideChildren
                            }), e.observer.attach(e.$wrapperEl[0], {
                                attributes: !1
                            })
                        }
                    },
                    destroy: function () {
                        var e = this;
                        e.observer.observers.forEach(function (e) {
                            e.disconnect()
                        }), e.observer.observers = []
                    }
                },
                ut = {
                    name: "observer",
                    params: {
                        observer: !1,
                        observeParents: !1,
                        observeSlideChildren: !1
                    },
                    create: function () {
                        var e = this;
                        Be.extend(e, {
                            observer: {
                                init: ct.init.bind(e),
                                attach: ct.attach.bind(e),
                                destroy: ct.destroy.bind(e),
                                observers: []
                            }
                        })
                    },
                    on: {
                        init: function () {
                            var e = this;
                            e.observer.init()
                        },
                        destroy: function () {
                            var e = this;
                            e.observer.destroy()
                        }
                    }
                },
                ht = {
                    update: function (e) {
                        function t() {
                            n.updateSlides(), n.updateProgress(), n.updateSlidesClasses(), n.lazy && n.params.lazy.enabled && n.lazy.load()
                        }
                        var n = this,
                            i = n.params,
                            r = i.slidesPerView,
                            a = i.slidesPerGroup,
                            o = i.centeredSlides,
                            s = n.params.virtual,
                            l = s.addSlidesBefore,
                            c = s.addSlidesAfter,
                            u = n.virtual,
                            h = u.from,
                            d = u.to,
                            p = u.slides,
                            f = u.slidesGrid,
                            m = u.renderSlide,
                            v = u.offset;
                        n.updateActiveIndex();
                        var g, y = n.activeIndex || 0;
                        g = n.rtlTranslate ? "right" : n.isHorizontal() ? "left" : "top";
                        var x, b;
                        o ? (x = Math.floor(r / 2) + a + l, b = Math.floor(r / 2) + a + c) : (x = r + (a - 1) + l, b = a + c);
                        var _ = Math.max((y || 0) - b, 0),
                            w = Math.min((y || 0) + x, p.length - 1),
                            M = (n.slidesGrid[_] || 0) - (n.slidesGrid[0] || 0);
                        if (Be.extend(n.virtual, {
                                from: _,
                                to: w,
                                offset: M,
                                slidesGrid: n.slidesGrid
                            }), h === _ && d === w && !e) return n.slidesGrid !== f && M !== v && n.slides.css(g, M + "px"), void n.updateProgress();
                        if (n.params.virtual.renderExternal) return n.params.virtual.renderExternal.call(n, {
                            offset: M,
                            from: _,
                            to: w,
                            slides: function () {
                                for (var e = [], t = _; t <= w; t += 1) e.push(p[t]);
                                return e
                            }()
                        }), void t();
                        var T = [],
                            E = [];
                        if (e) n.$wrapperEl.find("." + n.params.slideClass).remove();
                        else
                            for (var S = h; S <= d; S += 1)(S < _ || S > w) && n.$wrapperEl.find("." + n.params.slideClass + '[data-swiper-slide-index="' + S + '"]').remove();
                        for (var P = 0; P < p.length; P += 1) P >= _ && P <= w && ("undefined" == typeof d || e ? E.push(P) : (P > d && E.push(P), P < h && T.push(P)));
                        E.forEach(function (e) {
                            n.$wrapperEl.append(m(p[e], e))
                        }), T.sort(function (e, t) {
                            return t - e
                        }).forEach(function (e) {
                            n.$wrapperEl.prepend(m(p[e], e))
                        }), n.$wrapperEl.children(".swiper-slide").css(g, M + "px"), t()
                    },
                    renderSlide: function (t, n) {
                        var i = this,
                            r = i.params.virtual;
                        if (r.cache && i.virtual.cache[n]) return i.virtual.cache[n];
                        var a = e(r.renderSlide ? r.renderSlide.call(i, t, n) : '<div class="' + i.params.slideClass + '" data-swiper-slide-index="' + n + '">' + t + "</div>");
                        return a.attr("data-swiper-slide-index") || a.attr("data-swiper-slide-index", n), r.cache && (i.virtual.cache[n] = a), a
                    },
                    appendSlide: function (e) {
                        var t = this;
                        t.virtual.slides.push(e), t.virtual.update(!0)
                    },
                    prependSlide: function (e) {
                        var t = this;
                        if (t.virtual.slides.unshift(e), t.params.virtual.cache) {
                            var n = t.virtual.cache,
                                i = {};
                            Object.keys(n).forEach(function (e) {
                                i[e + 1] = n[e]
                            }), t.virtual.cache = i
                        }
                        t.virtual.update(!0), t.slideNext(0)
                    }
                },
                dt = {
                    name: "virtual",
                    params: {
                        virtual: {
                            enabled: !1,
                            slides: [],
                            cache: !0,
                            renderSlide: null,
                            renderExternal: null,
                            addSlidesBefore: 0,
                            addSlidesAfter: 0
                        }
                    },
                    create: function () {
                        var e = this;
                        Be.extend(e, {
                            virtual: {
                                update: ht.update.bind(e),
                                appendSlide: ht.appendSlide.bind(e),
                                prependSlide: ht.prependSlide.bind(e),
                                renderSlide: ht.renderSlide.bind(e),
                                slides: e.params.virtual.slides,
                                cache: {}
                            }
                        })
                    },
                    on: {
                        beforeInit: function () {
                            var e = this;
                            if (e.params.virtual.enabled) {
                                e.classNames.push(e.params.containerModifierClass + "virtual");
                                var t = {
                                    watchSlidesProgress: !0
                                };
                                Be.extend(e.params, t), Be.extend(e.originalParams, t), e.params.initialSlide || e.virtual.update()
                            }
                        },
                        setTranslate: function () {
                            var e = this;
                            e.params.virtual.enabled && e.virtual.update()
                        }
                    }
                },
                pt = {
                    handle: function (e) {
                        var t = this,
                            n = t.rtlTranslate,
                            i = e;
                        i.originalEvent && (i = i.originalEvent);
                        var r = i.keyCode || i.charCode;
                        if (!t.allowSlideNext && (t.isHorizontal() && 39 === r || t.isVertical() && 40 === r)) return !1;
                        if (!t.allowSlidePrev && (t.isHorizontal() && 37 === r || t.isVertical() && 38 === r)) return !1;
                        if (!(i.shiftKey || i.altKey || i.ctrlKey || i.metaKey || Oe.activeElement && Oe.activeElement.nodeName && ("input" === Oe.activeElement.nodeName.toLowerCase() || "textarea" === Oe.activeElement.nodeName.toLowerCase()))) {
                            if (t.params.keyboard.onlyInViewport && (37 === r || 39 === r || 38 === r || 40 === r)) {
                                var a = !1;
                                if (t.$el.parents("." + t.params.slideClass).length > 0 && 0 === t.$el.parents("." + t.params.slideActiveClass).length) return;
                                var o = ke.innerWidth,
                                    s = ke.innerHeight,
                                    l = t.$el.offset();
                                n && (l.left -= t.$el[0].scrollLeft);
                                for (var c = [
                                        [l.left, l.top],
                                        [l.left + t.width, l.top],
                                        [l.left, l.top + t.height],
                                        [l.left + t.width, l.top + t.height]
                                    ], u = 0; u < c.length; u += 1) {
                                    var h = c[u];
                                    h[0] >= 0 && h[0] <= o && h[1] >= 0 && h[1] <= s && (a = !0)
                                }
                                if (!a) return
                            }
                            t.isHorizontal() ? (37 !== r && 39 !== r || (i.preventDefault ? i.preventDefault() : i.returnValue = !1), (39 === r && !n || 37 === r && n) && t.slideNext(), (37 === r && !n || 39 === r && n) && t.slidePrev()) : (38 !== r && 40 !== r || (i.preventDefault ? i.preventDefault() : i.returnValue = !1), 40 === r && t.slideNext(), 38 === r && t.slidePrev()), t.emit("keyPress", r)
                        }
                    },
                    enable: function () {
                        var t = this;
                        t.keyboard.enabled || (e(Oe).on("keydown", t.keyboard.handle), t.keyboard.enabled = !0)
                    },
                    disable: function () {
                        var t = this;
                        t.keyboard.enabled && (e(Oe).off("keydown", t.keyboard.handle), t.keyboard.enabled = !1)
                    }
                },
                ft = {
                    name: "keyboard",
                    params: {
                        keyboard: {
                            enabled: !1,
                            onlyInViewport: !0
                        }
                    },
                    create: function () {
                        var e = this;
                        Be.extend(e, {
                            keyboard: {
                                enabled: !1,
                                enable: pt.enable.bind(e),
                                disable: pt.disable.bind(e),
                                handle: pt.handle.bind(e)
                            }
                        })
                    },
                    on: {
                        init: function () {
                            var e = this;
                            e.params.keyboard.enabled && e.keyboard.enable()
                        },
                        destroy: function () {
                            var e = this;
                            e.keyboard.enabled && e.keyboard.disable()
                        }
                    }
                },
                mt = {
                    lastScrollTime: Be.now(),
                    event: function () {
                        return ke.navigator.userAgent.indexOf("firefox") > -1 ? "DOMMouseScroll" : Ie() ? "wheel" : "mousewheel"
                    }(),
                    normalize: function (e) {
                        var t = 10,
                            n = 40,
                            i = 800,
                            r = 0,
                            a = 0,
                            o = 0,
                            s = 0;
                        return "detail" in e && (a = e.detail), "wheelDelta" in e && (a = -e.wheelDelta / 120), "wheelDeltaY" in e && (a = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (r = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (r = a, a = 0), o = r * t, s = a * t, "deltaY" in e && (s = e.deltaY), "deltaX" in e && (o = e.deltaX), (o || s) && e.deltaMode && (1 === e.deltaMode ? (o *= n, s *= n) : (o *= i, s *= i)), o && !r && (r = o < 1 ? -1 : 1), s && !a && (a = s < 1 ? -1 : 1), {
                            spinX: r,
                            spinY: a,
                            pixelX: o,
                            pixelY: s
                        }
                    },
                    handleMouseEnter: function () {
                        var e = this;
                        e.mouseEntered = !0
                    },
                    handleMouseLeave: function () {
                        var e = this;
                        e.mouseEntered = !1
                    },
                    handle: function (e) {
                        var t = e,
                            n = this,
                            i = n.params.mousewheel;
                        if (!n.mouseEntered && !i.releaseOnEdges) return !0;
                        t.originalEvent && (t = t.originalEvent);
                        var r = 0,
                            a = n.rtlTranslate ? -1 : 1,
                            o = mt.normalize(t);
                        if (i.forceToAxis)
                            if (n.isHorizontal()) {
                                if (!(Math.abs(o.pixelX) > Math.abs(o.pixelY))) return !0;
                                r = o.pixelX * a
                            } else {
                                if (!(Math.abs(o.pixelY) > Math.abs(o.pixelX))) return !0;
                                r = o.pixelY
                            }
                        else r = Math.abs(o.pixelX) > Math.abs(o.pixelY) ? -o.pixelX * a : -o.pixelY;
                        if (0 === r) return !0;
                        if (i.invert && (r = -r), n.params.freeMode) {
                            n.params.loop && n.loopFix();
                            var s = n.getTranslate() + r * i.sensitivity,
                                l = n.isBeginning,
                                c = n.isEnd;
                            if (s >= n.minTranslate() && (s = n.minTranslate()), s <= n.maxTranslate() && (s = n.maxTranslate()), n.setTransition(0), n.setTranslate(s), n.updateProgress(), n.updateActiveIndex(), n.updateSlidesClasses(), (!l && n.isBeginning || !c && n.isEnd) && n.updateSlidesClasses(), n.params.freeModeSticky && (clearTimeout(n.mousewheel.timeout), n.mousewheel.timeout = Be.nextTick(function () {
                                    n.slideToClosest()
                                }, 300)), n.emit("scroll", t), n.params.autoplay && n.params.autoplayDisableOnInteraction && n.autoplay.stop(), s === n.minTranslate() || s === n.maxTranslate()) return !0
                        } else {
                            if (Be.now() - n.mousewheel.lastScrollTime > 60)
                                if (r < 0)
                                    if (n.isEnd && !n.params.loop || n.animating) {
                                        if (i.releaseOnEdges) return !0
                                    } else n.slideNext(), n.emit("scroll", t);
                            else if (n.isBeginning && !n.params.loop || n.animating) {
                                if (i.releaseOnEdges) return !0
                            } else n.slidePrev(), n.emit("scroll", t);
                            n.mousewheel.lastScrollTime = (new ke.Date).getTime()
                        }
                        return t.preventDefault ? t.preventDefault() : t.returnValue = !1, !1
                    },
                    enable: function () {
                        var t = this;
                        if (!mt.event) return !1;
                        if (t.mousewheel.enabled) return !1;
                        var n = t.$el;
                        return "container" !== t.params.mousewheel.eventsTarged && (n = e(t.params.mousewheel.eventsTarged)), n.on("mouseenter", t.mousewheel.handleMouseEnter), n.on("mouseleave", t.mousewheel.handleMouseLeave), n.on(mt.event, t.mousewheel.handle), t.mousewheel.enabled = !0, !0
                    },
                    disable: function () {
                        var t = this;
                        if (!mt.event) return !1;
                        if (!t.mousewheel.enabled) return !1;
                        var n = t.$el;
                        return "container" !== t.params.mousewheel.eventsTarged && (n = e(t.params.mousewheel.eventsTarged)), n.off(mt.event, t.mousewheel.handle), t.mousewheel.enabled = !1, !0
                    }
                },
                vt = {
                    name: "mousewheel",
                    params: {
                        mousewheel: {
                            enabled: !1,
                            releaseOnEdges: !1,
                            invert: !1,
                            forceToAxis: !1,
                            sensitivity: 1,
                            eventsTarged: "container"
                        }
                    },
                    create: function () {
                        var e = this;
                        Be.extend(e, {
                            mousewheel: {
                                enabled: !1,
                                enable: mt.enable.bind(e),
                                disable: mt.disable.bind(e),
                                handle: mt.handle.bind(e),
                                handleMouseEnter: mt.handleMouseEnter.bind(e),
                                handleMouseLeave: mt.handleMouseLeave.bind(e),
                                lastScrollTime: Be.now()
                            }
                        })
                    },
                    on: {
                        init: function () {
                            var e = this;
                            e.params.mousewheel.enabled && e.mousewheel.enable()
                        },
                        destroy: function () {
                            var e = this;
                            e.mousewheel.enabled && e.mousewheel.disable()
                        }
                    }
                },
                gt = {
                    update: function () {
                        var e = this,
                            t = e.params.navigation;
                        if (!e.params.loop) {
                            var n = e.navigation,
                                i = n.$nextEl,
                                r = n.$prevEl;
                            r && r.length > 0 && (e.isBeginning ? r.addClass(t.disabledClass) : r.removeClass(t.disabledClass), r[e.params.watchOverflow && e.isLocked ? "addClass" : "removeClass"](t.lockClass)), i && i.length > 0 && (e.isEnd ? i.addClass(t.disabledClass) : i.removeClass(t.disabledClass), i[e.params.watchOverflow && e.isLocked ? "addClass" : "removeClass"](t.lockClass))
                        }
                    },
                    onPrevClick: function (e) {
                        var t = this;
                        e.preventDefault(), t.isBeginning && !t.params.loop || t.slidePrev()
                    },
                    onNextClick: function (e) {
                        var t = this;
                        e.preventDefault(), t.isEnd && !t.params.loop || t.slideNext()
                    },
                    init: function () {
                        var t = this,
                            n = t.params.navigation;
                        if (n.nextEl || n.prevEl) {
                            var i, r;
                            n.nextEl && (i = e(n.nextEl), t.params.uniqueNavElements && "string" == typeof n.nextEl && i.length > 1 && 1 === t.$el.find(n.nextEl).length && (i = t.$el.find(n.nextEl))), n.prevEl && (r = e(n.prevEl), t.params.uniqueNavElements && "string" == typeof n.prevEl && r.length > 1 && 1 === t.$el.find(n.prevEl).length && (r = t.$el.find(n.prevEl))), i && i.length > 0 && i.on("click", t.navigation.onNextClick), r && r.length > 0 && r.on("click", t.navigation.onPrevClick), Be.extend(t.navigation, {
                                $nextEl: i,
                                nextEl: i && i[0],
                                $prevEl: r,
                                prevEl: r && r[0]
                            })
                        }
                    },
                    destroy: function () {
                        var e = this,
                            t = e.navigation,
                            n = t.$nextEl,
                            i = t.$prevEl;
                        n && n.length && (n.off("click", e.navigation.onNextClick), n.removeClass(e.params.navigation.disabledClass)), i && i.length && (i.off("click", e.navigation.onPrevClick), i.removeClass(e.params.navigation.disabledClass))
                    }
                },
                yt = {
                    name: "navigation",
                    params: {
                        navigation: {
                            nextEl: null,
                            prevEl: null,
                            hideOnClick: !1,
                            disabledClass: "swiper-button-disabled",
                            hiddenClass: "swiper-button-hidden",
                            lockClass: "swiper-button-lock"
                        }
                    },
                    create: function () {
                        var e = this;
                        Be.extend(e, {
                            navigation: {
                                init: gt.init.bind(e),
                                update: gt.update.bind(e),
                                destroy: gt.destroy.bind(e),
                                onNextClick: gt.onNextClick.bind(e),
                                onPrevClick: gt.onPrevClick.bind(e)
                            }
                        })
                    },
                    on: {
                        init: function () {
                            var e = this;
                            e.navigation.init(), e.navigation.update()
                        },
                        toEdge: function () {
                            var e = this;
                            e.navigation.update()
                        },
                        fromEdge: function () {
                            var e = this;
                            e.navigation.update()
                        },
                        destroy: function () {
                            var e = this;
                            e.navigation.destroy()
                        },
                        click: function (t) {
                            var n = this,
                                i = n.navigation,
                                r = i.$nextEl,
                                a = i.$prevEl;
                            !n.params.navigation.hideOnClick || e(t.target).is(a) || e(t.target).is(r) || (r && r.toggleClass(n.params.navigation.hiddenClass), a && a.toggleClass(n.params.navigation.hiddenClass))
                        }
                    }
                },
                xt = {
                    update: function () {
                        var t = this,
                            n = t.rtl,
                            i = t.params.pagination;
                        if (i.el && t.pagination.el && t.pagination.$el && 0 !== t.pagination.$el.length) {
                            var r, a = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length,
                                o = t.pagination.$el,
                                s = t.params.loop ? Math.ceil((a - 2 * t.loopedSlides) / t.params.slidesPerGroup) : t.snapGrid.length;
                            if (t.params.loop ? (r = Math.ceil((t.activeIndex - t.loopedSlides) / t.params.slidesPerGroup), r > a - 1 - 2 * t.loopedSlides && (r -= a - 2 * t.loopedSlides), r > s - 1 && (r -= s), r < 0 && "bullets" !== t.params.paginationType && (r = s + r)) : r = "undefined" != typeof t.snapIndex ? t.snapIndex : t.activeIndex || 0, "bullets" === i.type && t.pagination.bullets && t.pagination.bullets.length > 0) {
                                var l, c, u, h = t.pagination.bullets;
                                if (i.dynamicBullets && (t.pagination.bulletSize = h.eq(0)[t.isHorizontal() ? "outerWidth" : "outerHeight"](!0), o.css(t.isHorizontal() ? "width" : "height", t.pagination.bulletSize * (i.dynamicMainBullets + 4) + "px"), i.dynamicMainBullets > 1 && void 0 !== t.previousIndex && (t.pagination.dynamicBulletIndex += r - t.previousIndex, t.pagination.dynamicBulletIndex > i.dynamicMainBullets - 1 ? t.pagination.dynamicBulletIndex = i.dynamicMainBullets - 1 : t.pagination.dynamicBulletIndex < 0 && (t.pagination.dynamicBulletIndex = 0)), l = r - t.pagination.dynamicBulletIndex, c = l + (Math.min(h.length, i.dynamicMainBullets) - 1), u = (c + l) / 2), h.removeClass(i.bulletActiveClass + " " + i.bulletActiveClass + "-next " + i.bulletActiveClass + "-next-next " + i.bulletActiveClass + "-prev " + i.bulletActiveClass + "-prev-prev " + i.bulletActiveClass + "-main"), o.length > 1) h.each(function (t, n) {
                                    var a = e(n),
                                        o = a.index();
                                    o === r && a.addClass(i.bulletActiveClass), i.dynamicBullets && (o >= l && o <= c && a.addClass(i.bulletActiveClass + "-main"), o === l && a.prev().addClass(i.bulletActiveClass + "-prev").prev().addClass(i.bulletActiveClass + "-prev-prev"), o === c && a.next().addClass(i.bulletActiveClass + "-next").next().addClass(i.bulletActiveClass + "-next-next"))
                                });
                                else {
                                    var d = h.eq(r);
                                    if (d.addClass(i.bulletActiveClass), i.dynamicBullets) {
                                        for (var p = h.eq(l), f = h.eq(c), m = l; m <= c; m += 1) h.eq(m).addClass(i.bulletActiveClass + "-main");
                                        p.prev().addClass(i.bulletActiveClass + "-prev").prev().addClass(i.bulletActiveClass + "-prev-prev"), f.next().addClass(i.bulletActiveClass + "-next").next().addClass(i.bulletActiveClass + "-next-next")
                                    }
                                }
                                if (i.dynamicBullets) {
                                    var v = Math.min(h.length, i.dynamicMainBullets + 4),
                                        g = (t.pagination.bulletSize * v - t.pagination.bulletSize) / 2 - u * t.pagination.bulletSize,
                                        y = n ? "right" : "left";
                                    h.css(t.isHorizontal() ? y : "top", g + "px")
                                }
                            }
                            if ("fraction" === i.type && (o.find("." + i.currentClass).text(i.formatFractionCurrent(r + 1)), o.find("." + i.totalClass).text(i.formatFractionTotal(s))), "progressbar" === i.type) {
                                var x;
                                x = i.progressbarOpposite ? t.isHorizontal() ? "vertical" : "horizontal" : t.isHorizontal() ? "horizontal" : "vertical";
                                var b = (r + 1) / s,
                                    _ = 1,
                                    w = 1;
                                "horizontal" === x ? _ = b : w = b, o.find("." + i.progressbarFillClass).transform("translate3d(0,0,0) scaleX(" + _ + ") scaleY(" + w + ")").transition(t.params.speed)
                            }
                            "custom" === i.type && i.renderCustom ? (o.html(i.renderCustom(t, r + 1, s)), t.emit("paginationRender", t, o[0])) : t.emit("paginationUpdate", t, o[0]), o[t.params.watchOverflow && t.isLocked ? "addClass" : "removeClass"](i.lockClass)
                        }
                    },
                    render: function () {
                        var e = this,
                            t = e.params.pagination;
                        if (t.el && e.pagination.el && e.pagination.$el && 0 !== e.pagination.$el.length) {
                            var n = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length,
                                i = e.pagination.$el,
                                r = "";
                            if ("bullets" === t.type) {
                                for (var a = e.params.loop ? Math.ceil((n - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length, o = 0; o < a; o += 1) r += t.renderBullet ? t.renderBullet.call(e, o, t.bulletClass) : "<" + t.bulletElement + ' class="' + t.bulletClass + '"></' + t.bulletElement + ">";
                                i.html(r), e.pagination.bullets = i.find("." + t.bulletClass)
                            }
                            "fraction" === t.type && (r = t.renderFraction ? t.renderFraction.call(e, t.currentClass, t.totalClass) : '<span class="' + t.currentClass + '"></span> / <span class="' + t.totalClass + '"></span>', i.html(r)), "progressbar" === t.type && (r = t.renderProgressbar ? t.renderProgressbar.call(e, t.progressbarFillClass) : '<span class="' + t.progressbarFillClass + '"></span>', i.html(r)), "custom" !== t.type && e.emit("paginationRender", e.pagination.$el[0])
                        }
                    },
                    init: function () {
                        var t = this,
                            n = t.params.pagination;
                        if (n.el) {
                            var i = e(n.el);
                            0 !== i.length && (t.params.uniqueNavElements && "string" == typeof n.el && i.length > 1 && 1 === t.$el.find(n.el).length && (i = t.$el.find(n.el)), "bullets" === n.type && n.clickable && i.addClass(n.clickableClass), i.addClass(n.modifierClass + n.type), "bullets" === n.type && n.dynamicBullets && (i.addClass("" + n.modifierClass + n.type + "-dynamic"), t.pagination.dynamicBulletIndex = 0, n.dynamicMainBullets < 1 && (n.dynamicMainBullets = 1)), "progressbar" === n.type && n.progressbarOpposite && i.addClass(n.progressbarOppositeClass), n.clickable && i.on("click", "." + n.bulletClass, function (n) {
                                n.preventDefault();
                                var i = e(this).index() * t.params.slidesPerGroup;
                                t.params.loop && (i += t.loopedSlides), t.slideTo(i)
                            }), Be.extend(t.pagination, {
                                $el: i,
                                el: i[0]
                            }))
                        }
                    },
                    destroy: function () {
                        var e = this,
                            t = e.params.pagination;
                        if (t.el && e.pagination.el && e.pagination.$el && 0 !== e.pagination.$el.length) {
                            var n = e.pagination.$el;
                            n.removeClass(t.hiddenClass), n.removeClass(t.modifierClass + t.type), e.pagination.bullets && e.pagination.bullets.removeClass(t.bulletActiveClass), t.clickable && n.off("click", "." + t.bulletClass)
                        }
                    }
                },
                bt = {
                    name: "pagination",
                    params: {
                        pagination: {
                            el: null,
                            bulletElement: "span",
                            clickable: !1,
                            hideOnClick: !1,
                            renderBullet: null,
                            renderProgressbar: null,
                            renderFraction: null,
                            renderCustom: null,
                            progressbarOpposite: !1,
                            type: "bullets",
                            dynamicBullets: !1,
                            dynamicMainBullets: 1,
                            formatFractionCurrent: function (e) {
                                return e
                            },
                            formatFractionTotal: function (e) {
                                return e
                            },
                            bulletClass: "swiper-pagination-bullet",
                            bulletActiveClass: "swiper-pagination-bullet-active",
                            modifierClass: "swiper-pagination-",
                            currentClass: "swiper-pagination-current",
                            totalClass: "swiper-pagination-total",
                            hiddenClass: "swiper-pagination-hidden",
                            progressbarFillClass: "swiper-pagination-progressbar-fill",
                            progressbarOppositeClass: "swiper-pagination-progressbar-opposite",
                            clickableClass: "swiper-pagination-clickable",
                            lockClass: "swiper-pagination-lock"
                        }
                    },
                    create: function () {
                        var e = this;
                        Be.extend(e, {
                            pagination: {
                                init: xt.init.bind(e),
                                render: xt.render.bind(e),
                                update: xt.update.bind(e),
                                destroy: xt.destroy.bind(e),
                                dynamicBulletIndex: 0
                            }
                        })
                    },
                    on: {
                        init: function () {
                            var e = this;
                            e.pagination.init(), e.pagination.render(), e.pagination.update()
                        },
                        activeIndexChange: function () {
                            var e = this;
                            e.params.loop ? e.pagination.update() : "undefined" == typeof e.snapIndex && e.pagination.update()
                        },
                        snapIndexChange: function () {
                            var e = this;
                            e.params.loop || e.pagination.update()
                        },
                        slidesLengthChange: function () {
                            var e = this;
                            e.params.loop && (e.pagination.render(), e.pagination.update())
                        },
                        snapGridLengthChange: function () {
                            var e = this;
                            e.params.loop || (e.pagination.render(), e.pagination.update())
                        },
                        destroy: function () {
                            var e = this;
                            e.pagination.destroy()
                        },
                        click: function (t) {
                            var n = this;
                            n.params.pagination.el && n.params.pagination.hideOnClick && n.pagination.$el.length > 0 && !e(t.target).hasClass(n.params.pagination.bulletClass) && n.pagination.$el.toggleClass(n.params.pagination.hiddenClass)
                        }
                    }
                },
                _t = {
                    setTranslate: function () {
                        var e = this;
                        if (e.params.scrollbar.el && e.scrollbar.el) {
                            var t = e.scrollbar,
                                n = e.rtlTranslate,
                                i = e.progress,
                                r = t.dragSize,
                                a = t.trackSize,
                                o = t.$dragEl,
                                s = t.$el,
                                l = e.params.scrollbar,
                                c = r,
                                u = (a - r) * i;
                            n ? (u = -u, u > 0 ? (c = r - u, u = 0) : -u + r > a && (c = a + u)) : u < 0 ? (c = r + u, u = 0) : u + r > a && (c = a - u), e.isHorizontal() ? (Ne.transforms3d ? o.transform("translate3d(" + u + "px, 0, 0)") : o.transform("translateX(" + u + "px)"), o[0].style.width = c + "px") : (Ne.transforms3d ? o.transform("translate3d(0px, " + u + "px, 0)") : o.transform("translateY(" + u + "px)"), o[0].style.height = c + "px"), l.hide && (clearTimeout(e.scrollbar.timeout), s[0].style.opacity = 1, e.scrollbar.timeout = setTimeout(function () {
                                s[0].style.opacity = 0, s.transition(400)
                            }, 1e3))
                        }
                    },
                    setTransition: function (e) {
                        var t = this;
                        t.params.scrollbar.el && t.scrollbar.el && t.scrollbar.$dragEl.transition(e)
                    },
                    updateSize: function () {
                        var e = this;
                        if (e.params.scrollbar.el && e.scrollbar.el) {
                            var t = e.scrollbar,
                                n = t.$dragEl,
                                i = t.$el;
                            n[0].style.width = "", n[0].style.height = "";
                            var r, a = e.isHorizontal() ? i[0].offsetWidth : i[0].offsetHeight,
                                o = e.size / e.virtualSize,
                                s = o * (a / e.size);
                            r = "auto" === e.params.scrollbar.dragSize ? a * o : parseInt(e.params.scrollbar.dragSize, 10), e.isHorizontal() ? n[0].style.width = r + "px" : n[0].style.height = r + "px", o >= 1 ? i[0].style.display = "none" : i[0].style.display = "", e.params.scrollbarHide && (i[0].style.opacity = 0), Be.extend(t, {
                                trackSize: a,
                                divider: o,
                                moveDivider: s,
                                dragSize: r
                            }), t.$el[e.params.watchOverflow && e.isLocked ? "addClass" : "removeClass"](e.params.scrollbar.lockClass)
                        }
                    },
                    setDragPosition: function (e) {
                        var t, n = this,
                            i = n.scrollbar,
                            r = n.rtlTranslate,
                            a = i.$el,
                            o = i.dragSize,
                            s = i.trackSize;
                        t = n.isHorizontal() ? "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX || e.clientX : "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY || e.clientY;
                        var l;
                        l = (t - a.offset()[n.isHorizontal() ? "left" : "top"] - o / 2) / (s - o), l = Math.max(Math.min(l, 1), 0), r && (l = 1 - l);
                        var c = n.minTranslate() + (n.maxTranslate() - n.minTranslate()) * l;
                        n.updateProgress(c), n.setTranslate(c), n.updateActiveIndex(), n.updateSlidesClasses()
                    },
                    onDragStart: function (e) {
                        var t = this,
                            n = t.params.scrollbar,
                            i = t.scrollbar,
                            r = t.$wrapperEl,
                            a = i.$el,
                            o = i.$dragEl;
                        t.scrollbar.isTouched = !0, e.preventDefault(), e.stopPropagation(), r.transition(100), o.transition(100), i.setDragPosition(e), clearTimeout(t.scrollbar.dragTimeout), a.transition(0), n.hide && a.css("opacity", 1), t.emit("scrollbarDragStart", e)
                    },
                    onDragMove: function (e) {
                        var t = this,
                            n = t.scrollbar,
                            i = t.$wrapperEl,
                            r = n.$el,
                            a = n.$dragEl;
                        t.scrollbar.isTouched && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, n.setDragPosition(e), i.transition(0), r.transition(0), a.transition(0), t.emit("scrollbarDragMove", e))
                    },
                    onDragEnd: function (e) {
                        var t = this,
                            n = t.params.scrollbar,
                            i = t.scrollbar,
                            r = i.$el;
                        t.scrollbar.isTouched && (t.scrollbar.isTouched = !1, n.hide && (clearTimeout(t.scrollbar.dragTimeout), t.scrollbar.dragTimeout = Be.nextTick(function () {
                            r.css("opacity", 0), r.transition(400)
                        }, 1e3)), t.emit("scrollbarDragEnd", e), n.snapOnRelease && t.slideToClosest())
                    },
                    enableDraggable: function () {
                        var e = this;
                        if (e.params.scrollbar.el) {
                            var t = e.scrollbar,
                                n = e.touchEventsTouch,
                                i = e.touchEventsDesktop,
                                r = e.params,
                                a = t.$el,
                                o = a[0],
                                s = !(!Ne.passiveListener || !r.passiveListeners) && {
                                    passive: !1,
                                    capture: !1
                                },
                                l = !(!Ne.passiveListener || !r.passiveListeners) && {
                                    passive: !0,
                                    capture: !1
                                };
                            Ne.touch ? (o.addEventListener(n.start, e.scrollbar.onDragStart, s), o.addEventListener(n.move, e.scrollbar.onDragMove, s), o.addEventListener(n.end, e.scrollbar.onDragEnd, l)) : (o.addEventListener(i.start, e.scrollbar.onDragStart, s), Oe.addEventListener(i.move, e.scrollbar.onDragMove, s), Oe.addEventListener(i.end, e.scrollbar.onDragEnd, l))
                        }
                    },
                    disableDraggable: function () {
                        var e = this;
                        if (e.params.scrollbar.el) {
                            var t = e.scrollbar,
                                n = e.touchEventsTouch,
                                i = e.touchEventsDesktop,
                                r = e.params,
                                a = t.$el,
                                o = a[0],
                                s = !(!Ne.passiveListener || !r.passiveListeners) && {
                                    passive: !1,
                                    capture: !1
                                },
                                l = !(!Ne.passiveListener || !r.passiveListeners) && {
                                    passive: !0,
                                    capture: !1
                                };
                            Ne.touch ? (o.removeEventListener(n.start, e.scrollbar.onDragStart, s), o.removeEventListener(n.move, e.scrollbar.onDragMove, s), o.removeEventListener(n.end, e.scrollbar.onDragEnd, l)) : (o.removeEventListener(i.start, e.scrollbar.onDragStart, s), Oe.removeEventListener(i.move, e.scrollbar.onDragMove, s), Oe.removeEventListener(i.end, e.scrollbar.onDragEnd, l))
                        }
                    },
                    init: function () {
                        var t = this;
                        if (t.params.scrollbar.el) {
                            var n = t.scrollbar,
                                i = t.$el,
                                r = t.params.scrollbar,
                                a = e(r.el);
                            t.params.uniqueNavElements && "string" == typeof r.el && a.length > 1 && 1 === i.find(r.el).length && (a = i.find(r.el));
                            var o = a.find("." + t.params.scrollbar.dragClass);
                            0 === o.length && (o = e('<div class="' + t.params.scrollbar.dragClass + '"></div>'), a.append(o)), Be.extend(n, {
                                $el: a,
                                el: a[0],
                                $dragEl: o,
                                dragEl: o[0]
                            }), r.draggable && n.enableDraggable()
                        }
                    },
                    destroy: function () {
                        var e = this;
                        e.scrollbar.disableDraggable()
                    }
                },
                wt = {
                    name: "scrollbar",
                    params: {
                        scrollbar: {
                            el: null,
                            dragSize: "auto",
                            hide: !1,
                            draggable: !1,
                            snapOnRelease: !0,
                            lockClass: "swiper-scrollbar-lock",
                            dragClass: "swiper-scrollbar-drag"
                        }
                    },
                    create: function () {
                        var e = this;
                        Be.extend(e, {
                            scrollbar: {
                                init: _t.init.bind(e),
                                destroy: _t.destroy.bind(e),
                                updateSize: _t.updateSize.bind(e),
                                setTranslate: _t.setTranslate.bind(e),
                                setTransition: _t.setTransition.bind(e),
                                enableDraggable: _t.enableDraggable.bind(e),
                                disableDraggable: _t.disableDraggable.bind(e),
                                setDragPosition: _t.setDragPosition.bind(e),
                                onDragStart: _t.onDragStart.bind(e),
                                onDragMove: _t.onDragMove.bind(e),
                                onDragEnd: _t.onDragEnd.bind(e),
                                isTouched: !1,
                                timeout: null,
                                dragTimeout: null
                            }
                        })
                    },
                    on: {
                        init: function () {
                            var e = this;
                            e.scrollbar.init(), e.scrollbar.updateSize(), e.scrollbar.setTranslate()
                        },
                        update: function () {
                            var e = this;
                            e.scrollbar.updateSize()
                        },
                        resize: function () {
                            var e = this;
                            e.scrollbar.updateSize()
                        },
                        observerUpdate: function () {
                            var e = this;
                            e.scrollbar.updateSize()
                        },
                        setTranslate: function () {
                            var e = this;
                            e.scrollbar.setTranslate()
                        },
                        setTransition: function (e) {
                            var t = this;
                            t.scrollbar.setTransition(e)
                        },
                        destroy: function () {
                            var e = this;
                            e.scrollbar.destroy()
                        }
                    }
                },
                Mt = {
                    setTransform: function (t, n) {
                        var i = this,
                            r = i.rtl,
                            a = e(t),
                            o = r ? -1 : 1,
                            s = a.attr("data-swiper-parallax") || "0",
                            l = a.attr("data-swiper-parallax-x"),
                            c = a.attr("data-swiper-parallax-y"),
                            u = a.attr("data-swiper-parallax-scale"),
                            h = a.attr("data-swiper-parallax-opacity");
                        if (l || c ? (l = l || "0", c = c || "0") : i.isHorizontal() ? (l = s, c = "0") : (c = s, l = "0"), l = l.indexOf("%") >= 0 ? parseInt(l, 10) * n * o + "%" : l * n * o + "px", c = c.indexOf("%") >= 0 ? parseInt(c, 10) * n + "%" : c * n + "px", "undefined" != typeof h && null !== h) {
                            var d = h - (h - 1) * (1 - Math.abs(n));
                            a[0].style.opacity = d
                        }
                        if ("undefined" == typeof u || null === u) a.transform("translate3d(" + l + ", " + c + ", 0px)");
                        else {
                            var p = u - (u - 1) * (1 - Math.abs(n));
                            a.transform("translate3d(" + l + ", " + c + ", 0px) scale(" + p + ")")
                        }
                    },
                    setTranslate: function () {
                        var t = this,
                            n = t.$el,
                            i = t.slides,
                            r = t.progress,
                            a = t.snapGrid;
                        n.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function (e, n) {
                            t.parallax.setTransform(n, r)
                        }), i.each(function (n, i) {
                            var o = i.progress;
                            t.params.slidesPerGroup > 1 && "auto" !== t.params.slidesPerView && (o += Math.ceil(n / 2) - r * (a.length - 1)), o = Math.min(Math.max(o, -1), 1), e(i).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function (e, n) {
                                t.parallax.setTransform(n, o)
                            })
                        })
                    },
                    setTransition: function (t) {
                        void 0 === t && (t = this.params.speed);
                        var n = this,
                            i = n.$el;
                        i.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function (n, i) {
                            var r = e(i),
                                a = parseInt(r.attr("data-swiper-parallax-duration"), 10) || t;
                            0 === t && (a = 0), r.transition(a)
                        })
                    }
                },
                Tt = {
                    name: "parallax",
                    params: {
                        parallax: {
                            enabled: !1
                        }
                    },
                    create: function () {
                        var e = this;
                        Be.extend(e, {
                            parallax: {
                                setTransform: Mt.setTransform.bind(e),
                                setTranslate: Mt.setTranslate.bind(e),
                                setTransition: Mt.setTransition.bind(e)
                            }
                        })
                    },
                    on: {
                        beforeInit: function () {
                            var e = this;
                            e.params.parallax.enabled && (e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0)
                        },
                        init: function () {
                            var e = this;
                            e.params.parallax && e.parallax.setTranslate()
                        },
                        setTranslate: function () {
                            var e = this;
                            e.params.parallax && e.parallax.setTranslate()
                        },
                        setTransition: function (e) {
                            var t = this;
                            t.params.parallax && t.parallax.setTransition(e)
                        }
                    }
                },
                Et = {
                    getDistanceBetweenTouches: function (e) {
                        if (e.targetTouches.length < 2) return 1;
                        var t = e.targetTouches[0].pageX,
                            n = e.targetTouches[0].pageY,
                            i = e.targetTouches[1].pageX,
                            r = e.targetTouches[1].pageY,
                            a = Math.sqrt(Math.pow(i - t, 2) + Math.pow(r - n, 2));
                        return a
                    },
                    onGestureStart: function (t) {
                        var n = this,
                            i = n.params.zoom,
                            r = n.zoom,
                            a = r.gesture;
                        if (r.fakeGestureTouched = !1, r.fakeGestureMoved = !1, !Ne.gestures) {
                            if ("touchstart" !== t.type || "touchstart" === t.type && t.targetTouches.length < 2) return;
                            r.fakeGestureTouched = !0, a.scaleStart = Et.getDistanceBetweenTouches(t)
                        }
                        return a.$slideEl && a.$slideEl.length || (a.$slideEl = e(t.target).closest(".swiper-slide"), 0 === a.$slideEl.length && (a.$slideEl = n.slides.eq(n.activeIndex)), a.$imageEl = a.$slideEl.find("img, svg, canvas"), a.$imageWrapEl = a.$imageEl.parent("." + i.containerClass), a.maxRatio = a.$imageWrapEl.attr("data-swiper-zoom") || i.maxRatio, 0 !== a.$imageWrapEl.length) ? (a.$imageEl.transition(0), void(n.zoom.isScaling = !0)) : void(a.$imageEl = void 0)
                    },
                    onGestureChange: function (e) {
                        var t = this,
                            n = t.params.zoom,
                            i = t.zoom,
                            r = i.gesture;
                        if (!Ne.gestures) {
                            if ("touchmove" !== e.type || "touchmove" === e.type && e.targetTouches.length < 2) return;
                            i.fakeGestureMoved = !0, r.scaleMove = Et.getDistanceBetweenTouches(e)
                        }
                        r.$imageEl && 0 !== r.$imageEl.length && (Ne.gestures ? i.scale = e.scale * i.currentScale : i.scale = r.scaleMove / r.scaleStart * i.currentScale, i.scale > r.maxRatio && (i.scale = r.maxRatio - 1 + Math.pow(i.scale - r.maxRatio + 1, .5)), i.scale < n.minRatio && (i.scale = n.minRatio + 1 - Math.pow(n.minRatio - i.scale + 1, .5)), r.$imageEl.transform("translate3d(0,0,0) scale(" + i.scale + ")"))
                    },
                    onGestureEnd: function (e) {
                        var t = this,
                            n = t.params.zoom,
                            i = t.zoom,
                            r = i.gesture;
                        if (!Ne.gestures) {
                            if (!i.fakeGestureTouched || !i.fakeGestureMoved) return;
                            if ("touchend" !== e.type || "touchend" === e.type && e.changedTouches.length < 2 && !Ye.android) return;
                            i.fakeGestureTouched = !1, i.fakeGestureMoved = !1
                        }
                        r.$imageEl && 0 !== r.$imageEl.length && (i.scale = Math.max(Math.min(i.scale, r.maxRatio), n.minRatio), r.$imageEl.transition(t.params.speed).transform("translate3d(0,0,0) scale(" + i.scale + ")"), i.currentScale = i.scale, i.isScaling = !1, 1 === i.scale && (r.$slideEl = void 0))
                    },
                    onTouchStart: function (e) {
                        var t = this,
                            n = t.zoom,
                            i = n.gesture,
                            r = n.image;
                        i.$imageEl && 0 !== i.$imageEl.length && (r.isTouched || (Ye.android && e.preventDefault(), r.isTouched = !0, r.touchesStart.x = "touchstart" === e.type ? e.targetTouches[0].pageX : e.pageX, r.touchesStart.y = "touchstart" === e.type ? e.targetTouches[0].pageY : e.pageY))
                    },
                    onTouchMove: function (e) {
                        var t = this,
                            n = t.zoom,
                            i = n.gesture,
                            r = n.image,
                            a = n.velocity;
                        if (i.$imageEl && 0 !== i.$imageEl.length && (t.allowClick = !1, r.isTouched && i.$slideEl)) {
                            r.isMoved || (r.width = i.$imageEl[0].offsetWidth, r.height = i.$imageEl[0].offsetHeight, r.startX = Be.getTranslate(i.$imageWrapEl[0], "x") || 0, r.startY = Be.getTranslate(i.$imageWrapEl[0], "y") || 0, i.slideWidth = i.$slideEl[0].offsetWidth, i.slideHeight = i.$slideEl[0].offsetHeight, i.$imageWrapEl.transition(0), t.rtl && (r.startX = -r.startX, r.startY = -r.startY));
                            var o = r.width * n.scale,
                                s = r.height * n.scale;
                            if (!(o < i.slideWidth && s < i.slideHeight)) {
                                if (r.minX = Math.min(i.slideWidth / 2 - o / 2, 0), r.maxX = -r.minX, r.minY = Math.min(i.slideHeight / 2 - s / 2, 0), r.maxY = -r.minY, r.touchesCurrent.x = "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX, r.touchesCurrent.y = "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY, !r.isMoved && !n.isScaling) {
                                    if (t.isHorizontal() && (Math.floor(r.minX) === Math.floor(r.startX) && r.touchesCurrent.x < r.touchesStart.x || Math.floor(r.maxX) === Math.floor(r.startX) && r.touchesCurrent.x > r.touchesStart.x)) return void(r.isTouched = !1);
                                    if (!t.isHorizontal() && (Math.floor(r.minY) === Math.floor(r.startY) && r.touchesCurrent.y < r.touchesStart.y || Math.floor(r.maxY) === Math.floor(r.startY) && r.touchesCurrent.y > r.touchesStart.y)) return void(r.isTouched = !1);
                                }
                                e.preventDefault(), e.stopPropagation(), r.isMoved = !0, r.currentX = r.touchesCurrent.x - r.touchesStart.x + r.startX, r.currentY = r.touchesCurrent.y - r.touchesStart.y + r.startY, r.currentX < r.minX && (r.currentX = r.minX + 1 - Math.pow(r.minX - r.currentX + 1, .8)), r.currentX > r.maxX && (r.currentX = r.maxX - 1 + Math.pow(r.currentX - r.maxX + 1, .8)), r.currentY < r.minY && (r.currentY = r.minY + 1 - Math.pow(r.minY - r.currentY + 1, .8)), r.currentY > r.maxY && (r.currentY = r.maxY - 1 + Math.pow(r.currentY - r.maxY + 1, .8)), a.prevPositionX || (a.prevPositionX = r.touchesCurrent.x), a.prevPositionY || (a.prevPositionY = r.touchesCurrent.y), a.prevTime || (a.prevTime = Date.now()), a.x = (r.touchesCurrent.x - a.prevPositionX) / (Date.now() - a.prevTime) / 2, a.y = (r.touchesCurrent.y - a.prevPositionY) / (Date.now() - a.prevTime) / 2, Math.abs(r.touchesCurrent.x - a.prevPositionX) < 2 && (a.x = 0), Math.abs(r.touchesCurrent.y - a.prevPositionY) < 2 && (a.y = 0), a.prevPositionX = r.touchesCurrent.x, a.prevPositionY = r.touchesCurrent.y, a.prevTime = Date.now(), i.$imageWrapEl.transform("translate3d(" + r.currentX + "px, " + r.currentY + "px,0)")
                            }
                        }
                    },
                    onTouchEnd: function () {
                        var e = this,
                            t = e.zoom,
                            n = t.gesture,
                            i = t.image,
                            r = t.velocity;
                        if (n.$imageEl && 0 !== n.$imageEl.length) {
                            if (!i.isTouched || !i.isMoved) return i.isTouched = !1, void(i.isMoved = !1);
                            i.isTouched = !1, i.isMoved = !1;
                            var a = 300,
                                o = 300,
                                s = r.x * a,
                                l = i.currentX + s,
                                c = r.y * o,
                                u = i.currentY + c;
                            0 !== r.x && (a = Math.abs((l - i.currentX) / r.x)), 0 !== r.y && (o = Math.abs((u - i.currentY) / r.y));
                            var h = Math.max(a, o);
                            i.currentX = l, i.currentY = u;
                            var d = i.width * t.scale,
                                p = i.height * t.scale;
                            i.minX = Math.min(n.slideWidth / 2 - d / 2, 0), i.maxX = -i.minX, i.minY = Math.min(n.slideHeight / 2 - p / 2, 0), i.maxY = -i.minY, i.currentX = Math.max(Math.min(i.currentX, i.maxX), i.minX), i.currentY = Math.max(Math.min(i.currentY, i.maxY), i.minY), n.$imageWrapEl.transition(h).transform("translate3d(" + i.currentX + "px, " + i.currentY + "px,0)")
                        }
                    },
                    onTransitionEnd: function () {
                        var e = this,
                            t = e.zoom,
                            n = t.gesture;
                        n.$slideEl && e.previousIndex !== e.activeIndex && (n.$imageEl.transform("translate3d(0,0,0) scale(1)"), n.$imageWrapEl.transform("translate3d(0,0,0)"), t.scale = 1, t.currentScale = 1, n.$slideEl = void 0, n.$imageEl = void 0, n.$imageWrapEl = void 0)
                    },
                    toggle: function (e) {
                        var t = this,
                            n = t.zoom;
                        n.scale && 1 !== n.scale ? n.out() : n["in"](e)
                    },
                    "in": function (t) {
                        var n = this,
                            i = n.zoom,
                            r = n.params.zoom,
                            a = i.gesture,
                            o = i.image;
                        if (a.$slideEl || (a.$slideEl = n.clickedSlide ? e(n.clickedSlide) : n.slides.eq(n.activeIndex), a.$imageEl = a.$slideEl.find("img, svg, canvas"), a.$imageWrapEl = a.$imageEl.parent("." + r.containerClass)), a.$imageEl && 0 !== a.$imageEl.length) {
                            a.$slideEl.addClass("" + r.zoomedSlideClass);
                            var s, l, c, u, h, d, p, f, m, v, g, y, x, b, _, w, M, T;
                            "undefined" == typeof o.touchesStart.x && t ? (s = "touchend" === t.type ? t.changedTouches[0].pageX : t.pageX, l = "touchend" === t.type ? t.changedTouches[0].pageY : t.pageY) : (s = o.touchesStart.x, l = o.touchesStart.y), i.scale = a.$imageWrapEl.attr("data-swiper-zoom") || r.maxRatio, i.currentScale = a.$imageWrapEl.attr("data-swiper-zoom") || r.maxRatio, t ? (M = a.$slideEl[0].offsetWidth, T = a.$slideEl[0].offsetHeight, c = a.$slideEl.offset().left, u = a.$slideEl.offset().top, h = c + M / 2 - s, d = u + T / 2 - l, m = a.$imageEl[0].offsetWidth, v = a.$imageEl[0].offsetHeight, g = m * i.scale, y = v * i.scale, x = Math.min(M / 2 - g / 2, 0), b = Math.min(T / 2 - y / 2, 0), _ = -x, w = -b, p = h * i.scale, f = d * i.scale, p < x && (p = x), p > _ && (p = _), f < b && (f = b), f > w && (f = w)) : (p = 0, f = 0), a.$imageWrapEl.transition(300).transform("translate3d(" + p + "px, " + f + "px,0)"), a.$imageEl.transition(300).transform("translate3d(0,0,0) scale(" + i.scale + ")")
                        }
                    },
                    out: function () {
                        var t = this,
                            n = t.zoom,
                            i = t.params.zoom,
                            r = n.gesture;
                        r.$slideEl || (r.$slideEl = t.clickedSlide ? e(t.clickedSlide) : t.slides.eq(t.activeIndex), r.$imageEl = r.$slideEl.find("img, svg, canvas"), r.$imageWrapEl = r.$imageEl.parent("." + i.containerClass)), r.$imageEl && 0 !== r.$imageEl.length && (n.scale = 1, n.currentScale = 1, r.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"), r.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"), r.$slideEl.removeClass("" + i.zoomedSlideClass), r.$slideEl = void 0)
                    },
                    enable: function () {
                        var e = this,
                            t = e.zoom;
                        if (!t.enabled) {
                            t.enabled = !0;
                            var n = !("touchstart" !== e.touchEvents.start || !Ne.passiveListener || !e.params.passiveListeners) && {
                                passive: !0,
                                capture: !1
                            };
                            Ne.gestures ? (e.$wrapperEl.on("gesturestart", ".swiper-slide", t.onGestureStart, n), e.$wrapperEl.on("gesturechange", ".swiper-slide", t.onGestureChange, n), e.$wrapperEl.on("gestureend", ".swiper-slide", t.onGestureEnd, n)) : "touchstart" === e.touchEvents.start && (e.$wrapperEl.on(e.touchEvents.start, ".swiper-slide", t.onGestureStart, n), e.$wrapperEl.on(e.touchEvents.move, ".swiper-slide", t.onGestureChange, n), e.$wrapperEl.on(e.touchEvents.end, ".swiper-slide", t.onGestureEnd, n)), e.$wrapperEl.on(e.touchEvents.move, "." + e.params.zoom.containerClass, t.onTouchMove)
                        }
                    },
                    disable: function () {
                        var e = this,
                            t = e.zoom;
                        if (t.enabled) {
                            e.zoom.enabled = !1;
                            var n = !("touchstart" !== e.touchEvents.start || !Ne.passiveListener || !e.params.passiveListeners) && {
                                passive: !0,
                                capture: !1
                            };
                            Ne.gestures ? (e.$wrapperEl.off("gesturestart", ".swiper-slide", t.onGestureStart, n), e.$wrapperEl.off("gesturechange", ".swiper-slide", t.onGestureChange, n), e.$wrapperEl.off("gestureend", ".swiper-slide", t.onGestureEnd, n)) : "touchstart" === e.touchEvents.start && (e.$wrapperEl.off(e.touchEvents.start, ".swiper-slide", t.onGestureStart, n), e.$wrapperEl.off(e.touchEvents.move, ".swiper-slide", t.onGestureChange, n), e.$wrapperEl.off(e.touchEvents.end, ".swiper-slide", t.onGestureEnd, n)), e.$wrapperEl.off(e.touchEvents.move, "." + e.params.zoom.containerClass, t.onTouchMove)
                        }
                    }
                },
                St = {
                    name: "zoom",
                    params: {
                        zoom: {
                            enabled: !1,
                            maxRatio: 3,
                            minRatio: 1,
                            toggle: !0,
                            containerClass: "swiper-zoom-container",
                            zoomedSlideClass: "swiper-slide-zoomed"
                        }
                    },
                    create: function () {
                        var e = this,
                            t = {
                                enabled: !1,
                                scale: 1,
                                currentScale: 1,
                                isScaling: !1,
                                gesture: {
                                    $slideEl: void 0,
                                    slideWidth: void 0,
                                    slideHeight: void 0,
                                    $imageEl: void 0,
                                    $imageWrapEl: void 0,
                                    maxRatio: 3
                                },
                                image: {
                                    isTouched: void 0,
                                    isMoved: void 0,
                                    currentX: void 0,
                                    currentY: void 0,
                                    minX: void 0,
                                    minY: void 0,
                                    maxX: void 0,
                                    maxY: void 0,
                                    width: void 0,
                                    height: void 0,
                                    startX: void 0,
                                    startY: void 0,
                                    touchesStart: {},
                                    touchesCurrent: {}
                                },
                                velocity: {
                                    x: void 0,
                                    y: void 0,
                                    prevPositionX: void 0,
                                    prevPositionY: void 0,
                                    prevTime: void 0
                                }
                            };
                        "onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out".split(" ").forEach(function (n) {
                            t[n] = Et[n].bind(e)
                        }), Be.extend(e, {
                            zoom: t
                        });
                        var n = 1;
                        Object.defineProperty(e.zoom, "scale", {
                            get: function () {
                                return n
                            },
                            set: function (t) {
                                if (n !== t) {
                                    var i = e.zoom.gesture.$imageEl ? e.zoom.gesture.$imageEl[0] : void 0,
                                        r = e.zoom.gesture.$slideEl ? e.zoom.gesture.$slideEl[0] : void 0;
                                    e.emit("zoomChange", t, i, r)
                                }
                                n = t
                            }
                        })
                    },
                    on: {
                        init: function () {
                            var e = this;
                            e.params.zoom.enabled && e.zoom.enable()
                        },
                        destroy: function () {
                            var e = this;
                            e.zoom.disable()
                        },
                        touchStart: function (e) {
                            var t = this;
                            t.zoom.enabled && t.zoom.onTouchStart(e)
                        },
                        touchEnd: function (e) {
                            var t = this;
                            t.zoom.enabled && t.zoom.onTouchEnd(e)
                        },
                        doubleTap: function (e) {
                            var t = this;
                            t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && t.zoom.toggle(e)
                        },
                        transitionEnd: function () {
                            var e = this;
                            e.zoom.enabled && e.params.zoom.enabled && e.zoom.onTransitionEnd()
                        }
                    }
                },
                Pt = {
                    loadInSlide: function (t, n) {
                        void 0 === n && (n = !0);
                        var i = this,
                            r = i.params.lazy;
                        if ("undefined" != typeof t && 0 !== i.slides.length) {
                            var a = i.virtual && i.params.virtual.enabled,
                                o = a ? i.$wrapperEl.children("." + i.params.slideClass + '[data-swiper-slide-index="' + t + '"]') : i.slides.eq(t),
                                s = o.find("." + r.elementClass + ":not(." + r.loadedClass + "):not(." + r.loadingClass + ")");
                            !o.hasClass(r.elementClass) || o.hasClass(r.loadedClass) || o.hasClass(r.loadingClass) || (s = s.add(o[0])), 0 !== s.length && s.each(function (t, a) {
                                var s = e(a);
                                s.addClass(r.loadingClass);
                                var l = s.attr("data-background"),
                                    c = s.attr("data-src"),
                                    u = s.attr("data-srcset"),
                                    h = s.attr("data-sizes");
                                i.loadImage(s[0], c || l, u, h, !1, function () {
                                    if ("undefined" != typeof i && null !== i && i && (!i || i.params) && !i.destroyed) {
                                        if (l ? (s.css("background-image", 'url("' + l + '")'), s.removeAttr("data-background")) : (u && (s.attr("srcset", u), s.removeAttr("data-srcset")), h && (s.attr("sizes", h), s.removeAttr("data-sizes")), c && (s.attr("src", c), s.removeAttr("data-src"))), s.addClass(r.loadedClass).removeClass(r.loadingClass), o.find("." + r.preloaderClass).remove(), i.params.loop && n) {
                                            var e = o.attr("data-swiper-slide-index");
                                            if (o.hasClass(i.params.slideDuplicateClass)) {
                                                var t = i.$wrapperEl.children('[data-swiper-slide-index="' + e + '"]:not(.' + i.params.slideDuplicateClass + ")");
                                                i.lazy.loadInSlide(t.index(), !1)
                                            } else {
                                                var a = i.$wrapperEl.children("." + i.params.slideDuplicateClass + '[data-swiper-slide-index="' + e + '"]');
                                                i.lazy.loadInSlide(a.index(), !1)
                                            }
                                        }
                                        i.emit("lazyImageReady", o[0], s[0])
                                    }
                                }), i.emit("lazyImageLoad", o[0], s[0])
                            })
                        }
                    },
                    load: function () {
                        function t(e) {
                            if (l) {
                                if (r.children("." + a.slideClass + '[data-swiper-slide-index="' + e + '"]').length) return !0
                            } else if (o[e]) return !0;
                            return !1
                        }

                        function n(t) {
                            return l ? e(t).attr("data-swiper-slide-index") : e(t).index()
                        }
                        var i = this,
                            r = i.$wrapperEl,
                            a = i.params,
                            o = i.slides,
                            s = i.activeIndex,
                            l = i.virtual && a.virtual.enabled,
                            c = a.lazy,
                            u = a.slidesPerView;
                        if ("auto" === u && (u = 0), i.lazy.initialImageLoaded || (i.lazy.initialImageLoaded = !0), i.params.watchSlidesVisibility) r.children("." + a.slideVisibleClass).each(function (t, n) {
                            var r = l ? e(n).attr("data-swiper-slide-index") : e(n).index();
                            i.lazy.loadInSlide(r)
                        });
                        else if (u > 1)
                            for (var h = s; h < s + u; h += 1) t(h) && i.lazy.loadInSlide(h);
                        else i.lazy.loadInSlide(s);
                        if (c.loadPrevNext)
                            if (u > 1 || c.loadPrevNextAmount && c.loadPrevNextAmount > 1) {
                                for (var d = c.loadPrevNextAmount, p = u, f = Math.min(s + p + Math.max(d, p), o.length), m = Math.max(s - Math.max(p, d), 0), v = s + u; v < f; v += 1) t(v) && i.lazy.loadInSlide(v);
                                for (var g = m; g < s; g += 1) t(g) && i.lazy.loadInSlide(g)
                            } else {
                                var y = r.children("." + a.slideNextClass);
                                y.length > 0 && i.lazy.loadInSlide(n(y));
                                var x = r.children("." + a.slidePrevClass);
                                x.length > 0 && i.lazy.loadInSlide(n(x))
                            }
                    }
                },
                Ct = {
                    name: "lazy",
                    params: {
                        lazy: {
                            enabled: !1,
                            loadPrevNext: !1,
                            loadPrevNextAmount: 1,
                            loadOnTransitionStart: !1,
                            elementClass: "swiper-lazy",
                            loadingClass: "swiper-lazy-loading",
                            loadedClass: "swiper-lazy-loaded",
                            preloaderClass: "swiper-lazy-preloader"
                        }
                    },
                    create: function () {
                        var e = this;
                        Be.extend(e, {
                            lazy: {
                                initialImageLoaded: !1,
                                load: Pt.load.bind(e),
                                loadInSlide: Pt.loadInSlide.bind(e)
                            }
                        })
                    },
                    on: {
                        beforeInit: function () {
                            var e = this;
                            e.params.lazy.enabled && e.params.preloadImages && (e.params.preloadImages = !1)
                        },
                        init: function () {
                            var e = this;
                            e.params.lazy.enabled && !e.params.loop && 0 === e.params.initialSlide && e.lazy.load()
                        },
                        scroll: function () {
                            var e = this;
                            e.params.freeMode && !e.params.freeModeSticky && e.lazy.load()
                        },
                        resize: function () {
                            var e = this;
                            e.params.lazy.enabled && e.lazy.load()
                        },
                        scrollbarDragMove: function () {
                            var e = this;
                            e.params.lazy.enabled && e.lazy.load()
                        },
                        transitionStart: function () {
                            var e = this;
                            e.params.lazy.enabled && (e.params.lazy.loadOnTransitionStart || !e.params.lazy.loadOnTransitionStart && !e.lazy.initialImageLoaded) && e.lazy.load()
                        },
                        transitionEnd: function () {
                            var e = this;
                            e.params.lazy.enabled && !e.params.lazy.loadOnTransitionStart && e.lazy.load()
                        }
                    }
                },
                At = {
                    LinearSpline: function (e, t) {
                        var n = function () {
                            var e, t, n;
                            return function (i, r) {
                                for (t = -1, e = i.length; e - t > 1;) n = e + t >> 1, i[n] <= r ? t = n : e = n;
                                return e
                            }
                        }();
                        this.x = e, this.y = t, this.lastIndex = e.length - 1;
                        var i, r;
                        return this.interpolate = function (e) {
                            return e ? (r = n(this.x, e), i = r - 1, (e - this.x[i]) * (this.y[r] - this.y[i]) / (this.x[r] - this.x[i]) + this.y[i]) : 0
                        }, this
                    },
                    getInterpolateFunction: function (e) {
                        var t = this;
                        t.controller.spline || (t.controller.spline = t.params.loop ? new At.LinearSpline(t.slidesGrid, e.slidesGrid) : new At.LinearSpline(t.snapGrid, e.snapGrid))
                    },
                    setTranslate: function (e, t) {
                        function n(e) {
                            var t = a.rtlTranslate ? -a.translate : a.translate;
                            "slide" === a.params.controller.by && (a.controller.getInterpolateFunction(e), r = -a.controller.spline.interpolate(-t)), r && "container" !== a.params.controller.by || (i = (e.maxTranslate() - e.minTranslate()) / (a.maxTranslate() - a.minTranslate()), r = (t - a.minTranslate()) * i + e.minTranslate()), a.params.controller.inverse && (r = e.maxTranslate() - r), e.updateProgress(r), e.setTranslate(r, a), e.updateActiveIndex(), e.updateSlidesClasses()
                        }
                        var i, r, a = this,
                            o = a.controller.control;
                        if (Array.isArray(o))
                            for (var s = 0; s < o.length; s += 1) o[s] !== t && o[s] instanceof rt && n(o[s]);
                        else o instanceof rt && t !== o && n(o)
                    },
                    setTransition: function (e, t) {
                        function n(t) {
                            t.setTransition(e, r), 0 !== e && (t.transitionStart(), t.params.autoHeight && Be.nextTick(function () {
                                t.updateAutoHeight()
                            }), t.$wrapperEl.transitionEnd(function () {
                                a && (t.params.loop && "slide" === r.params.controller.by && t.loopFix(), t.transitionEnd())
                            }))
                        }
                        var i, r = this,
                            a = r.controller.control;
                        if (Array.isArray(a))
                            for (i = 0; i < a.length; i += 1) a[i] !== t && a[i] instanceof rt && n(a[i]);
                        else a instanceof rt && t !== a && n(a)
                    }
                },
                Lt = {
                    name: "controller",
                    params: {
                        controller: {
                            control: void 0,
                            inverse: !1,
                            by: "slide"
                        }
                    },
                    create: function () {
                        var e = this;
                        Be.extend(e, {
                            controller: {
                                control: e.params.controller.control,
                                getInterpolateFunction: At.getInterpolateFunction.bind(e),
                                setTranslate: At.setTranslate.bind(e),
                                setTransition: At.setTransition.bind(e)
                            }
                        })
                    },
                    on: {
                        update: function () {
                            var e = this;
                            e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline)
                        },
                        resize: function () {
                            var e = this;
                            e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline)
                        },
                        observerUpdate: function () {
                            var e = this;
                            e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline)
                        },
                        setTranslate: function (e, t) {
                            var n = this;
                            n.controller.control && n.controller.setTranslate(e, t)
                        },
                        setTransition: function (e, t) {
                            var n = this;
                            n.controller.control && n.controller.setTransition(e, t)
                        }
                    }
                },
                Rt = {
                    makeElFocusable: function (e) {
                        return e.attr("tabIndex", "0"), e
                    },
                    addElRole: function (e, t) {
                        return e.attr("role", t), e
                    },
                    addElLabel: function (e, t) {
                        return e.attr("aria-label", t), e
                    },
                    disableEl: function (e) {
                        return e.attr("aria-disabled", !0), e
                    },
                    enableEl: function (e) {
                        return e.attr("aria-disabled", !1), e
                    },
                    onEnterKey: function (t) {
                        var n = this,
                            i = n.params.a11y;
                        if (13 === t.keyCode) {
                            var r = e(t.target);
                            n.navigation && n.navigation.$nextEl && r.is(n.navigation.$nextEl) && (n.isEnd && !n.params.loop || n.slideNext(), n.isEnd ? n.a11y.notify(i.lastSlideMessage) : n.a11y.notify(i.nextSlideMessage)), n.navigation && n.navigation.$prevEl && r.is(n.navigation.$prevEl) && (n.isBeginning && !n.params.loop || n.slidePrev(), n.isBeginning ? n.a11y.notify(i.firstSlideMessage) : n.a11y.notify(i.prevSlideMessage)), n.pagination && r.is("." + n.params.pagination.bulletClass) && r[0].click()
                        }
                    },
                    notify: function (e) {
                        var t = this,
                            n = t.a11y.liveRegion;
                        0 !== n.length && (n.html(""), n.html(e))
                    },
                    updateNavigation: function () {
                        var e = this;
                        if (!e.params.loop) {
                            var t = e.navigation,
                                n = t.$nextEl,
                                i = t.$prevEl;
                            i && i.length > 0 && (e.isBeginning ? e.a11y.disableEl(i) : e.a11y.enableEl(i)), n && n.length > 0 && (e.isEnd ? e.a11y.disableEl(n) : e.a11y.enableEl(n))
                        }
                    },
                    updatePagination: function () {
                        var t = this,
                            n = t.params.a11y;
                        t.pagination && t.params.pagination.clickable && t.pagination.bullets && t.pagination.bullets.length && t.pagination.bullets.each(function (i, r) {
                            var a = e(r);
                            t.a11y.makeElFocusable(a), t.a11y.addElRole(a, "button"), t.a11y.addElLabel(a, n.paginationBulletMessage.replace(/{{index}}/, a.index() + 1))
                        })
                    },
                    init: function () {
                        var e = this;
                        e.$el.append(e.a11y.liveRegion);
                        var t, n, i = e.params.a11y;
                        e.navigation && e.navigation.$nextEl && (t = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (n = e.navigation.$prevEl), t && (e.a11y.makeElFocusable(t), e.a11y.addElRole(t, "button"), e.a11y.addElLabel(t, i.nextSlideMessage), t.on("keydown", e.a11y.onEnterKey)), n && (e.a11y.makeElFocusable(n), e.a11y.addElRole(n, "button"), e.a11y.addElLabel(n, i.prevSlideMessage), n.on("keydown", e.a11y.onEnterKey)), e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length && e.pagination.$el.on("keydown", "." + e.params.pagination.bulletClass, e.a11y.onEnterKey)
                    },
                    destroy: function () {
                        var e = this;
                        e.a11y.liveRegion && e.a11y.liveRegion.length > 0 && e.a11y.liveRegion.remove();
                        var t, n;
                        e.navigation && e.navigation.$nextEl && (t = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (n = e.navigation.$prevEl), t && t.off("keydown", e.a11y.onEnterKey), n && n.off("keydown", e.a11y.onEnterKey), e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length && e.pagination.$el.off("keydown", "." + e.params.pagination.bulletClass, e.a11y.onEnterKey)
                    }
                },
                It = {
                    name: "a11y",
                    params: {
                        a11y: {
                            enabled: !0,
                            notificationClass: "swiper-notification",
                            prevSlideMessage: "Previous slide",
                            nextSlideMessage: "Next slide",
                            firstSlideMessage: "This is the first slide",
                            lastSlideMessage: "This is the last slide",
                            paginationBulletMessage: "Go to slide {{index}}"
                        }
                    },
                    create: function () {
                        var t = this;
                        Be.extend(t, {
                            a11y: {
                                liveRegion: e('<span class="' + t.params.a11y.notificationClass + '" aria-live="assertive" aria-atomic="true"></span>')
                            }
                        }), Object.keys(Rt).forEach(function (e) {
                            t.a11y[e] = Rt[e].bind(t)
                        })
                    },
                    on: {
                        init: function () {
                            var e = this;
                            e.params.a11y.enabled && (e.a11y.init(), e.a11y.updateNavigation())
                        },
                        toEdge: function () {
                            var e = this;
                            e.params.a11y.enabled && e.a11y.updateNavigation()
                        },
                        fromEdge: function () {
                            var e = this;
                            e.params.a11y.enabled && e.a11y.updateNavigation()
                        },
                        paginationUpdate: function () {
                            var e = this;
                            e.params.a11y.enabled && e.a11y.updatePagination()
                        },
                        destroy: function () {
                            var e = this;
                            e.params.a11y.enabled && e.a11y.destroy()
                        }
                    }
                },
                Ot = {
                    init: function () {
                        var e = this;
                        if (e.params.history) {
                            if (!ke.history || !ke.history.pushState) return e.params.history.enabled = !1, void(e.params.hashNavigation.enabled = !0);
                            var t = e.history;
                            t.initialized = !0, t.paths = Ot.getPathValues(), (t.paths.key || t.paths.value) && (t.scrollToSlide(0, t.paths.value, e.params.runCallbacksOnInit), e.params.history.replaceState || ke.addEventListener("popstate", e.history.setHistoryPopState))
                        }
                    },
                    destroy: function () {
                        var e = this;
                        e.params.history.replaceState || ke.removeEventListener("popstate", e.history.setHistoryPopState)
                    },
                    setHistoryPopState: function () {
                        var e = this;
                        e.history.paths = Ot.getPathValues(), e.history.scrollToSlide(e.params.speed, e.history.paths.value, !1)
                    },
                    getPathValues: function () {
                        var e = ke.location.pathname.slice(1).split("/").filter(function (e) {
                                return "" !== e
                            }),
                            t = e.length,
                            n = e[t - 2],
                            i = e[t - 1];
                        return {
                            key: n,
                            value: i
                        }
                    },
                    setHistory: function (e, t) {
                        var n = this;
                        if (n.history.initialized && n.params.history.enabled) {
                            var i = n.slides.eq(t),
                                r = Ot.slugify(i.attr("data-history"));
                            ke.location.pathname.includes(e) || (r = e + "/" + r);
                            var a = ke.history.state;
                            a && a.value === r || (n.params.history.replaceState ? ke.history.replaceState({
                                value: r
                            }, null, r) : ke.history.pushState({
                                value: r
                            }, null, r))
                        }
                    },
                    slugify: function (e) {
                        return e.toString().toLowerCase().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, "")
                    },
                    scrollToSlide: function (e, t, n) {
                        var i = this;
                        if (t)
                            for (var r = 0, a = i.slides.length; r < a; r += 1) {
                                var o = i.slides.eq(r),
                                    s = Ot.slugify(o.attr("data-history"));
                                if (s === t && !o.hasClass(i.params.slideDuplicateClass)) {
                                    var l = o.index();
                                    i.slideTo(l, e, n)
                                }
                            } else i.slideTo(0, e, n)
                    }
                },
                kt = {
                    name: "history",
                    params: {
                        history: {
                            enabled: !1,
                            replaceState: !1,
                            key: "slides"
                        }
                    },
                    create: function () {
                        var e = this;
                        Be.extend(e, {
                            history: {
                                init: Ot.init.bind(e),
                                setHistory: Ot.setHistory.bind(e),
                                setHistoryPopState: Ot.setHistoryPopState.bind(e),
                                scrollToSlide: Ot.scrollToSlide.bind(e),
                                destroy: Ot.destroy.bind(e)
                            }
                        })
                    },
                    on: {
                        init: function () {
                            var e = this;
                            e.params.history.enabled && e.history.init()
                        },
                        destroy: function () {
                            var e = this;
                            e.params.history.enabled && e.history.destroy()
                        },
                        transitionEnd: function () {
                            var e = this;
                            e.history.initialized && e.history.setHistory(e.params.history.key, e.activeIndex)
                        }
                    }
                },
                Dt = {
                    onHashCange: function () {
                        var e = this,
                            t = Oe.location.hash.replace("#", ""),
                            n = e.slides.eq(e.activeIndex).attr("data-hash");
                        if (t !== n) {
                            var i = e.$wrapperEl.children("." + e.params.slideClass + '[data-hash="' + t + '"]').index();
                            if ("undefined" == typeof i) return;
                            e.slideTo(i)
                        }
                    },
                    setHash: function () {
                        var e = this;
                        if (e.hashNavigation.initialized && e.params.hashNavigation.enabled)
                            if (e.params.hashNavigation.replaceState && ke.history && ke.history.replaceState) ke.history.replaceState(null, null, "#" + e.slides.eq(e.activeIndex).attr("data-hash") || "");
                            else {
                                var t = e.slides.eq(e.activeIndex),
                                    n = t.attr("data-hash") || t.attr("data-history");
                                Oe.location.hash = n || ""
                            }
                    },
                    init: function () {
                        var t = this;
                        if (!(!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled)) {
                            t.hashNavigation.initialized = !0;
                            var n = Oe.location.hash.replace("#", "");
                            if (n)
                                for (var i = 0, r = 0, a = t.slides.length; r < a; r += 1) {
                                    var o = t.slides.eq(r),
                                        s = o.attr("data-hash") || o.attr("data-history");
                                    if (s === n && !o.hasClass(t.params.slideDuplicateClass)) {
                                        var l = o.index();
                                        t.slideTo(l, i, t.params.runCallbacksOnInit, !0)
                                    }
                                }
                            t.params.hashNavigation.watchState && e(ke).on("hashchange", t.hashNavigation.onHashCange)
                        }
                    },
                    destroy: function () {
                        var t = this;
                        t.params.hashNavigation.watchState && e(ke).off("hashchange", t.hashNavigation.onHashCange)
                    }
                },
                zt = {
                    name: "hash-navigation",
                    params: {
                        hashNavigation: {
                            enabled: !1,
                            replaceState: !1,
                            watchState: !1
                        }
                    },
                    create: function () {
                        var e = this;
                        Be.extend(e, {
                            hashNavigation: {
                                initialized: !1,
                                init: Dt.init.bind(e),
                                destroy: Dt.destroy.bind(e),
                                setHash: Dt.setHash.bind(e),
                                onHashCange: Dt.onHashCange.bind(e)
                            }
                        })
                    },
                    on: {
                        init: function () {
                            var e = this;
                            e.params.hashNavigation.enabled && e.hashNavigation.init()
                        },
                        destroy: function () {
                            var e = this;
                            e.params.hashNavigation.enabled && e.hashNavigation.destroy()
                        },
                        transitionEnd: function () {
                            var e = this;
                            e.hashNavigation.initialized && e.hashNavigation.setHash()
                        }
                    }
                },
                Bt = {
                    run: function () {
                        var e = this,
                            t = e.slides.eq(e.activeIndex),
                            n = e.params.autoplay.delay;
                        t.attr("data-swiper-autoplay") && (n = t.attr("data-swiper-autoplay") || e.params.autoplay.delay), e.autoplay.timeout = Be.nextTick(function () {
                            e.params.autoplay.reverseDirection ? e.params.loop ? (e.loopFix(), e.slidePrev(e.params.speed, !0, !0), e.emit("autoplay")) : e.isBeginning ? e.params.autoplay.stopOnLastSlide ? e.autoplay.stop() : (e.slideTo(e.slides.length - 1, e.params.speed, !0, !0), e.emit("autoplay")) : (e.slidePrev(e.params.speed, !0, !0), e.emit("autoplay")) : e.params.loop ? (e.loopFix(), e.slideNext(e.params.speed, !0, !0), e.emit("autoplay")) : e.isEnd ? e.params.autoplay.stopOnLastSlide ? e.autoplay.stop() : (e.slideTo(0, e.params.speed, !0, !0), e.emit("autoplay")) : (e.slideNext(e.params.speed, !0, !0), e.emit("autoplay"))
                        }, n)
                    },
                    start: function () {
                        var e = this;
                        return "undefined" == typeof e.autoplay.timeout && (!e.autoplay.running && (e.autoplay.running = !0, e.emit("autoplayStart"), e.autoplay.run(), !0))
                    },
                    stop: function () {
                        var e = this;
                        return !!e.autoplay.running && ("undefined" != typeof e.autoplay.timeout && (e.autoplay.timeout && (clearTimeout(e.autoplay.timeout), e.autoplay.timeout = void 0), e.autoplay.running = !1, e.emit("autoplayStop"), !0))
                    },
                    pause: function (e) {
                        var t = this;
                        t.autoplay.running && (t.autoplay.paused || (t.autoplay.timeout && clearTimeout(t.autoplay.timeout), t.autoplay.paused = !0, 0 !== e && t.params.autoplay.waitForTransition ? (t.$wrapperEl[0].addEventListener("transitionend", t.autoplay.onTransitionEnd), t.$wrapperEl[0].addEventListener("webkitTransitionEnd", t.autoplay.onTransitionEnd)) : (t.autoplay.paused = !1, t.autoplay.run())))
                    }
                },
                Nt = {
                    name: "autoplay",
                    params: {
                        autoplay: {
                            enabled: !1,
                            delay: 3e3,
                            waitForTransition: !0,
                            disableOnInteraction: !0,
                            stopOnLastSlide: !1,
                            reverseDirection: !1
                        }
                    },
                    create: function () {
                        var e = this;
                        Be.extend(e, {
                            autoplay: {
                                running: !1,
                                paused: !1,
                                run: Bt.run.bind(e),
                                start: Bt.start.bind(e),
                                stop: Bt.stop.bind(e),
                                pause: Bt.pause.bind(e),
                                onTransitionEnd: function (t) {
                                    e && !e.destroyed && e.$wrapperEl && t.target === this && (e.$wrapperEl[0].removeEventListener("transitionend", e.autoplay.onTransitionEnd), e.$wrapperEl[0].removeEventListener("webkitTransitionEnd", e.autoplay.onTransitionEnd), e.autoplay.paused = !1, e.autoplay.running ? e.autoplay.run() : e.autoplay.stop())
                                }
                            }
                        })
                    },
                    on: {
                        init: function () {
                            var e = this;
                            e.params.autoplay.enabled && e.autoplay.start()
                        },
                        beforeTransitionStart: function (e, t) {
                            var n = this;
                            n.autoplay.running && (t || !n.params.autoplay.disableOnInteraction ? n.autoplay.pause(e) : n.autoplay.stop())
                        },
                        sliderFirstMove: function () {
                            var e = this;
                            e.autoplay.running && (e.params.autoplay.disableOnInteraction ? e.autoplay.stop() : e.autoplay.pause())
                        },
                        destroy: function () {
                            var e = this;
                            e.autoplay.running && e.autoplay.stop()
                        }
                    }
                },
                Ut = {
                    setTranslate: function () {
                        for (var e = this, t = e.slides, n = 0; n < t.length; n += 1) {
                            var i = e.slides.eq(n),
                                r = i[0].swiperSlideOffset,
                                a = -r;
                            e.params.virtualTranslate || (a -= e.translate);
                            var o = 0;
                            e.isHorizontal() || (o = a, a = 0);
                            var s = e.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(i[0].progress), 0) : 1 + Math.min(Math.max(i[0].progress, -1), 0);
                            i.css({
                                opacity: s
                            }).transform("translate3d(" + a + "px, " + o + "px, 0px)")
                        }
                    },
                    setTransition: function (e) {
                        var t = this,
                            n = t.slides,
                            i = t.$wrapperEl;
                        if (n.transition(e), t.params.virtualTranslate && 0 !== e) {
                            var r = !1;
                            n.transitionEnd(function () {
                                if (!r && t && !t.destroyed) {
                                    r = !0, t.animating = !1;
                                    for (var e = ["webkitTransitionEnd", "transitionend"], n = 0; n < e.length; n += 1) i.trigger(e[n])
                                }
                            })
                        }
                    }
                },
                jt = {
                    name: "effect-fade",
                    params: {
                        fadeEffect: {
                            crossFade: !1
                        }
                    },
                    create: function () {
                        var e = this;
                        Be.extend(e, {
                            fadeEffect: {
                                setTranslate: Ut.setTranslate.bind(e),
                                setTransition: Ut.setTransition.bind(e)
                            }
                        })
                    },
                    on: {
                        beforeInit: function () {
                            var e = this;
                            if ("fade" === e.params.effect) {
                                e.classNames.push(e.params.containerModifierClass + "fade");
                                var t = {
                                    slidesPerView: 1,
                                    slidesPerColumn: 1,
                                    slidesPerGroup: 1,
                                    watchSlidesProgress: !0,
                                    spaceBetween: 0,
                                    virtualTranslate: !0
                                };
                                Be.extend(e.params, t), Be.extend(e.originalParams, t)
                            }
                        },
                        setTranslate: function () {
                            var e = this;
                            "fade" === e.params.effect && e.fadeEffect.setTranslate()
                        },
                        setTransition: function (e) {
                            var t = this;
                            "fade" === t.params.effect && t.fadeEffect.setTransition(e)
                        }
                    }
                },
                Ft = {
                    setTranslate: function () {
                        var t, n = this,
                            i = n.$el,
                            r = n.$wrapperEl,
                            a = n.slides,
                            o = n.width,
                            s = n.height,
                            l = n.rtlTranslate,
                            c = n.size,
                            u = n.params.cubeEffect,
                            h = n.isHorizontal(),
                            d = n.virtual && n.params.virtual.enabled,
                            p = 0;
                        u.shadow && (h ? (t = r.find(".swiper-cube-shadow"), 0 === t.length && (t = e('<div class="swiper-cube-shadow"></div>'), r.append(t)), t.css({
                            height: o + "px"
                        })) : (t = i.find(".swiper-cube-shadow"), 0 === t.length && (t = e('<div class="swiper-cube-shadow"></div>'), i.append(t))));
                        for (var f = 0; f < a.length; f += 1) {
                            var m = a.eq(f),
                                v = f;
                            d && (v = parseInt(m.attr("data-swiper-slide-index"), 10));
                            var g = 90 * v,
                                y = Math.floor(g / 360);
                            l && (g = -g, y = Math.floor(-g / 360));
                            var x = Math.max(Math.min(m[0].progress, 1), -1),
                                b = 0,
                                _ = 0,
                                w = 0;
                            v % 4 === 0 ? (b = 4 * -y * c, w = 0) : (v - 1) % 4 === 0 ? (b = 0, w = 4 * -y * c) : (v - 2) % 4 === 0 ? (b = c + 4 * y * c, w = c) : (v - 3) % 4 === 0 && (b = -c, w = 3 * c + 4 * c * y), l && (b = -b), h || (_ = b, b = 0);
                            var M = "rotateX(" + (h ? 0 : -g) + "deg) rotateY(" + (h ? g : 0) + "deg) translate3d(" + b + "px, " + _ + "px, " + w + "px)";
                            if (x <= 1 && x > -1 && (p = 90 * v + 90 * x, l && (p = 90 * -v - 90 * x)), m.transform(M), u.slideShadows) {
                                var T = h ? m.find(".swiper-slide-shadow-left") : m.find(".swiper-slide-shadow-top"),
                                    E = h ? m.find(".swiper-slide-shadow-right") : m.find(".swiper-slide-shadow-bottom");
                                0 === T.length && (T = e('<div class="swiper-slide-shadow-' + (h ? "left" : "top") + '"></div>'), m.append(T)), 0 === E.length && (E = e('<div class="swiper-slide-shadow-' + (h ? "right" : "bottom") + '"></div>'), m.append(E)), T.length && (T[0].style.opacity = Math.max(-x, 0)), E.length && (E[0].style.opacity = Math.max(x, 0))
                            }
                        }
                        if (r.css({
                                "-webkit-transform-origin": "50% 50% -" + c / 2 + "px",
                                "-moz-transform-origin": "50% 50% -" + c / 2 + "px",
                                "-ms-transform-origin": "50% 50% -" + c / 2 + "px",
                                "transform-origin": "50% 50% -" + c / 2 + "px"
                            }), u.shadow)
                            if (h) t.transform("translate3d(0px, " + (o / 2 + u.shadowOffset) + "px, " + -o / 2 + "px) rotateX(90deg) rotateZ(0deg) scale(" + u.shadowScale + ")");
                            else {
                                var S = Math.abs(p) - 90 * Math.floor(Math.abs(p) / 90),
                                    P = 1.5 - (Math.sin(2 * S * Math.PI / 360) / 2 + Math.cos(2 * S * Math.PI / 360) / 2),
                                    C = u.shadowScale,
                                    A = u.shadowScale / P,
                                    L = u.shadowOffset;
                                t.transform("scale3d(" + C + ", 1, " + A + ") translate3d(0px, " + (s / 2 + L) + "px, " + -s / 2 / A + "px) rotateX(-90deg)")
                            } var R = $e.isSafari || $e.isUiWebView ? -c / 2 : 0;
                        r.transform("translate3d(0px,0," + R + "px) rotateX(" + (n.isHorizontal() ? 0 : p) + "deg) rotateY(" + (n.isHorizontal() ? -p : 0) + "deg)")
                    },
                    setTransition: function (e) {
                        var t = this,
                            n = t.$el,
                            i = t.slides;
                        i.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), t.params.cubeEffect.shadow && !t.isHorizontal() && n.find(".swiper-cube-shadow").transition(e)
                    }
                },
                Gt = {
                    name: "effect-cube",
                    params: {
                        cubeEffect: {
                            slideShadows: !0,
                            shadow: !0,
                            shadowOffset: 20,
                            shadowScale: .94
                        }
                    },
                    create: function () {
                        var e = this;
                        Be.extend(e, {
                            cubeEffect: {
                                setTranslate: Ft.setTranslate.bind(e),
                                setTransition: Ft.setTransition.bind(e)
                            }
                        })
                    },
                    on: {
                        beforeInit: function () {
                            var e = this;
                            if ("cube" === e.params.effect) {
                                e.classNames.push(e.params.containerModifierClass + "cube"), e.classNames.push(e.params.containerModifierClass + "3d");
                                var t = {
                                    slidesPerView: 1,
                                    slidesPerColumn: 1,
                                    slidesPerGroup: 1,
                                    watchSlidesProgress: !0,
                                    resistanceRatio: 0,
                                    spaceBetween: 0,
                                    centeredSlides: !1,
                                    virtualTranslate: !0
                                };
                                Be.extend(e.params, t), Be.extend(e.originalParams, t)
                            }
                        },
                        setTranslate: function () {
                            var e = this;
                            "cube" === e.params.effect && e.cubeEffect.setTranslate()
                        },
                        setTransition: function (e) {
                            var t = this;
                            "cube" === t.params.effect && t.cubeEffect.setTransition(e)
                        }
                    }
                },
                Ht = {
                    setTranslate: function () {
                        for (var t = this, n = t.slides, i = t.rtlTranslate, r = 0; r < n.length; r += 1) {
                            var a = n.eq(r),
                                o = a[0].progress;
                            t.params.flipEffect.limitRotation && (o = Math.max(Math.min(a[0].progress, 1), -1));
                            var s = a[0].swiperSlideOffset,
                                l = -180 * o,
                                c = l,
                                u = 0,
                                h = -s,
                                d = 0;
                            if (t.isHorizontal() ? i && (c = -c) : (d = h, h = 0, u = -c, c = 0), a[0].style.zIndex = -Math.abs(Math.round(o)) + n.length, t.params.flipEffect.slideShadows) {
                                var p = t.isHorizontal() ? a.find(".swiper-slide-shadow-left") : a.find(".swiper-slide-shadow-top"),
                                    f = t.isHorizontal() ? a.find(".swiper-slide-shadow-right") : a.find(".swiper-slide-shadow-bottom");
                                0 === p.length && (p = e('<div class="swiper-slide-shadow-' + (t.isHorizontal() ? "left" : "top") + '"></div>'), a.append(p)), 0 === f.length && (f = e('<div class="swiper-slide-shadow-' + (t.isHorizontal() ? "right" : "bottom") + '"></div>'), a.append(f)), p.length && (p[0].style.opacity = Math.max(-o, 0)), f.length && (f[0].style.opacity = Math.max(o, 0))
                            }
                            a.transform("translate3d(" + h + "px, " + d + "px, 0px) rotateX(" + u + "deg) rotateY(" + c + "deg)")
                        }
                    },
                    setTransition: function (e) {
                        var t = this,
                            n = t.slides,
                            i = t.activeIndex,
                            r = t.$wrapperEl;
                        if (n.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), t.params.virtualTranslate && 0 !== e) {
                            var a = !1;
                            n.eq(i).transitionEnd(function () {
                                if (!a && t && !t.destroyed) {
                                    a = !0, t.animating = !1;
                                    for (var e = ["webkitTransitionEnd", "transitionend"], n = 0; n < e.length; n += 1) r.trigger(e[n])
                                }
                            })
                        }
                    }
                },
                Vt = {
                    name: "effect-flip",
                    params: {
                        flipEffect: {
                            slideShadows: !0,
                            limitRotation: !0
                        }
                    },
                    create: function () {
                        var e = this;
                        Be.extend(e, {
                            flipEffect: {
                                setTranslate: Ht.setTranslate.bind(e),
                                setTransition: Ht.setTransition.bind(e)
                            }
                        })
                    },
                    on: {
                        beforeInit: function () {
                            var e = this;
                            if ("flip" === e.params.effect) {
                                e.classNames.push(e.params.containerModifierClass + "flip"), e.classNames.push(e.params.containerModifierClass + "3d");
                                var t = {
                                    slidesPerView: 1,
                                    slidesPerColumn: 1,
                                    slidesPerGroup: 1,
                                    watchSlidesProgress: !0,
                                    spaceBetween: 0,
                                    virtualTranslate: !0
                                };
                                Be.extend(e.params, t), Be.extend(e.originalParams, t)
                            }
                        },
                        setTranslate: function () {
                            var e = this;
                            "flip" === e.params.effect && e.flipEffect.setTranslate()
                        },
                        setTransition: function (e) {
                            var t = this;
                            "flip" === t.params.effect && t.flipEffect.setTransition(e)
                        }
                    }
                },
                Wt = {
                    setTranslate: function () {
                        for (var t = this, n = t.width, i = t.height, r = t.slides, a = t.$wrapperEl, o = t.slidesSizesGrid, s = t.params.coverflowEffect, l = t.isHorizontal(), c = t.translate, u = l ? -c + n / 2 : -c + i / 2, h = l ? s.rotate : -s.rotate, d = s.depth, p = 0, f = r.length; p < f; p += 1) {
                            var m = r.eq(p),
                                v = o[p],
                                g = m[0].swiperSlideOffset,
                                y = (u - g - v / 2) / v * s.modifier,
                                x = l ? h * y : 0,
                                b = l ? 0 : h * y,
                                _ = -d * Math.abs(y),
                                w = l ? 0 : s.stretch * y,
                                M = l ? s.stretch * y : 0;
                            Math.abs(M) < .001 && (M = 0), Math.abs(w) < .001 && (w = 0), Math.abs(_) < .001 && (_ = 0), Math.abs(x) < .001 && (x = 0), Math.abs(b) < .001 && (b = 0);
                            var T = "translate3d(" + M + "px," + w + "px," + _ + "px)  rotateX(" + b + "deg) rotateY(" + x + "deg)";
                            if (m.transform(T), m[0].style.zIndex = -Math.abs(Math.round(y)) + 1, s.slideShadows) {
                                var E = l ? m.find(".swiper-slide-shadow-left") : m.find(".swiper-slide-shadow-top"),
                                    S = l ? m.find(".swiper-slide-shadow-right") : m.find(".swiper-slide-shadow-bottom");
                                0 === E.length && (E = e('<div class="swiper-slide-shadow-' + (l ? "left" : "top") + '"></div>'), m.append(E)), 0 === S.length && (S = e('<div class="swiper-slide-shadow-' + (l ? "right" : "bottom") + '"></div>'), m.append(S)), E.length && (E[0].style.opacity = y > 0 ? y : 0), S.length && (S[0].style.opacity = -y > 0 ? -y : 0)
                            }
                        }
                        if (Ne.pointerEvents || Ne.prefixedPointerEvents) {
                            var P = a[0].style;
                            P.perspectiveOrigin = u + "px 50%"
                        }
                    },
                    setTransition: function (e) {
                        var t = this;
                        t.slides.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e)
                    }
                },
                qt = {
                    name: "effect-coverflow",
                    params: {
                        coverflowEffect: {
                            rotate: 50,
                            stretch: 0,
                            depth: 100,
                            modifier: 1,
                            slideShadows: !0
                        }
                    },
                    create: function () {
                        var e = this;
                        Be.extend(e, {
                            coverflowEffect: {
                                setTranslate: Wt.setTranslate.bind(e),
                                setTransition: Wt.setTransition.bind(e)
                            }
                        })
                    },
                    on: {
                        beforeInit: function () {
                            var e = this;
                            "coverflow" === e.params.effect && (e.classNames.push(e.params.containerModifierClass + "coverflow"), e.classNames.push(e.params.containerModifierClass + "3d"),
                                e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0)
                        },
                        setTranslate: function () {
                            var e = this;
                            "coverflow" === e.params.effect && e.coverflowEffect.setTranslate()
                        },
                        setTransition: function (e) {
                            var t = this;
                            "coverflow" === t.params.effect && t.coverflowEffect.setTransition(e)
                        }
                    }
                },
                Xt = {
                    init: function () {
                        var e = this,
                            t = e.params,
                            n = t.thumbs,
                            i = e.constructor;
                        n.swiper instanceof i ? (e.thumbs.swiper = n.swiper, Be.extend(e.thumbs.swiper.originalParams, {
                            watchSlidesProgress: !0,
                            slideToClickedSlide: !1
                        }), Be.extend(e.thumbs.swiper.params, {
                            watchSlidesProgress: !0,
                            slideToClickedSlide: !1
                        })) : Be.isObject(n.swiper) && (e.thumbs.swiper = new i(Be.extend({}, n.swiper, {
                            watchSlidesVisibility: !0,
                            watchSlidesProgress: !0,
                            slideToClickedSlide: !1
                        })), e.thumbs.swiperCreated = !0), e.thumbs.swiper.$el.addClass(e.params.thumbs.thumbsContainerClass), e.thumbs.swiper.on("tap", e.thumbs.onThumbClick)
                    },
                    onThumbClick: function () {
                        var t = this,
                            n = t.thumbs.swiper;
                        if (n) {
                            var i = n.clickedIndex,
                                r = n.clickedSlide;
                            if (!(r && e(r).hasClass(t.params.thumbs.slideThumbActiveClass) || "undefined" == typeof i || null === i)) {
                                var a;
                                if (a = n.params.loop ? parseInt(e(n.clickedSlide).attr("data-swiper-slide-index"), 10) : i, t.params.loop) {
                                    var o = t.activeIndex;
                                    t.slides.eq(o).hasClass(t.params.slideDuplicateClass) && (t.loopFix(), t._clientLeft = t.$wrapperEl[0].clientLeft, o = t.activeIndex);
                                    var s = t.slides.eq(o).prevAll('[data-swiper-slide-index="' + a + '"]').eq(0).index(),
                                        l = t.slides.eq(o).nextAll('[data-swiper-slide-index="' + a + '"]').eq(0).index();
                                    a = "undefined" == typeof s ? l : "undefined" == typeof l ? s : l - o < o - s ? l : s
                                }
                                t.slideTo(a)
                            }
                        }
                    },
                    update: function (e) {
                        var t = this,
                            n = t.thumbs.swiper;
                        if (n) {
                            var i = "auto" === n.params.slidesPerView ? n.slidesPerViewDynamic() : n.params.slidesPerView;
                            if (t.realIndex !== n.realIndex) {
                                var r, a = n.activeIndex;
                                if (n.params.loop) {
                                    n.slides.eq(a).hasClass(n.params.slideDuplicateClass) && (n.loopFix(), n._clientLeft = n.$wrapperEl[0].clientLeft, a = n.activeIndex);
                                    var o = n.slides.eq(a).prevAll('[data-swiper-slide-index="' + t.realIndex + '"]').eq(0).index(),
                                        s = n.slides.eq(a).nextAll('[data-swiper-slide-index="' + t.realIndex + '"]').eq(0).index();
                                    r = "undefined" == typeof o ? s : "undefined" == typeof s ? o : s - a === a - o ? a : s - a < a - o ? s : o
                                } else r = t.realIndex;
                                n.visibleSlidesIndexes.indexOf(r) < 0 && (n.params.centeredSlides ? r = r > a ? r - Math.floor(i / 2) + 1 : r + Math.floor(i / 2) - 1 : r > a && (r = r - i + 1), n.slideTo(r, e ? 0 : void 0))
                            }
                            var l = 1,
                                c = t.params.thumbs.slideThumbActiveClass;
                            if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (l = t.params.slidesPerView), n.slides.removeClass(c), n.params.loop)
                                for (var u = 0; u < l; u += 1) n.$wrapperEl.children('[data-swiper-slide-index="' + (t.realIndex + u) + '"]').addClass(c);
                            else
                                for (var h = 0; h < l; h += 1) n.slides.eq(t.realIndex + h).addClass(c)
                        }
                    }
                },
                Yt = {
                    name: "thumbs",
                    params: {
                        thumbs: {
                            swiper: null,
                            slideThumbActiveClass: "swiper-slide-thumb-active",
                            thumbsContainerClass: "swiper-container-thumbs"
                        }
                    },
                    create: function () {
                        var e = this;
                        Be.extend(e, {
                            thumbs: {
                                swiper: null,
                                init: Xt.init.bind(e),
                                update: Xt.update.bind(e),
                                onThumbClick: Xt.onThumbClick.bind(e)
                            }
                        })
                    },
                    on: {
                        beforeInit: function () {
                            var e = this,
                                t = e.params,
                                n = t.thumbs;
                            n && n.swiper && (e.thumbs.init(), e.thumbs.update(!0))
                        },
                        slideChange: function () {
                            var e = this;
                            e.thumbs.swiper && e.thumbs.update()
                        },
                        update: function () {
                            var e = this;
                            e.thumbs.swiper && e.thumbs.update()
                        },
                        resize: function () {
                            var e = this;
                            e.thumbs.swiper && e.thumbs.update()
                        },
                        observerUpdate: function () {
                            var e = this;
                            e.thumbs.swiper && e.thumbs.update()
                        },
                        setTransition: function (e) {
                            var t = this,
                                n = t.thumbs.swiper;
                            n && n.setTransition(e)
                        },
                        beforeDestroy: function () {
                            var e = this,
                                t = e.thumbs.swiper;
                            t && e.thumbs.swiperCreated && t && t.destroy()
                        }
                    }
                },
                Zt = [at, ot, st, lt, ut, dt, ft, vt, yt, bt, wt, Tt, St, Ct, Lt, It, kt, zt, Nt, jt, Gt, Vt, qt, Yt];
            return "undefined" == typeof rt.use && (rt.use = rt.Class.use, rt.installModule = rt.Class.installModule), rt.use(Zt), rt
        })
    }, {}],
    47: [function (e, t, n) {
        ! function (i, r) {
            "object" == typeof n && "undefined" != typeof t ? r(n, e("three")) : "function" == typeof define && define.amd ? define(["exports", "three"], r) : r(i.BAS = {}, i.THREE)
        }(this, function (e, t) {
            "use strict";

            function n(e, n) {
                t.ShaderMaterial.call(this);
                var i = e.uniformValues;
                if (delete e.uniformValues, this.setValues(e), this.uniforms = t.UniformsUtils.merge([n, this.uniforms]), this.setUniformValues(i), i && (i.map && (this.defines.USE_MAP = ""), i.normalMap && (this.defines.USE_NORMALMAP = ""), i.envMap && (this.defines.USE_ENVMAP = ""), i.aoMap && (this.defines.USE_AOMAP = ""), i.specularMap && (this.defines.USE_SPECULARMAP = ""), i.alphaMap && (this.defines.USE_ALPHAMAP = ""), i.lightMap && (this.defines.USE_LIGHTMAP = ""), i.emissiveMap && (this.defines.USE_EMISSIVEMAP = ""), i.bumpMap && (this.defines.USE_BUMPMAP = ""), i.displacementMap && (this.defines.USE_DISPLACEMENTMAP = ""), i.roughnessMap && (this.defines.USE_DISPLACEMENTMAP = ""), i.roughnessMap && (this.defines.USE_ROUGHNESSMAP = ""), i.metalnessMap && (this.defines.USE_METALNESSMAP = ""), i.gradientMap && (this.defines.USE_GRADIENTMAP = ""), i.envMap)) {
                    this.defines.USE_ENVMAP = "";
                    var r = "ENVMAP_TYPE_CUBE",
                        a = "ENVMAP_MODE_REFLECTION",
                        o = "ENVMAP_BLENDING_MULTIPLY";
                    switch (i.envMap.mapping) {
                        case t.CubeReflectionMapping:
                        case t.CubeRefractionMapping:
                            r = "ENVMAP_TYPE_CUBE";
                            break;
                        case t.CubeUVReflectionMapping:
                        case t.CubeUVRefractionMapping:
                            r = "ENVMAP_TYPE_CUBE_UV";
                            break;
                        case t.EquirectangularReflectionMapping:
                        case t.EquirectangularRefractionMapping:
                            r = "ENVMAP_TYPE_EQUIREC";
                            break;
                        case t.SphericalReflectionMapping:
                            r = "ENVMAP_TYPE_SPHERE"
                    }
                    switch (i.envMap.mapping) {
                        case t.CubeRefractionMapping:
                        case t.EquirectangularRefractionMapping:
                            a = "ENVMAP_MODE_REFRACTION"
                    }
                    switch (i.combine) {
                        case t.MixOperation:
                            o = "ENVMAP_BLENDING_MIX";
                            break;
                        case t.AddOperation:
                            o = "ENVMAP_BLENDING_ADD";
                            break;
                        case t.MultiplyOperation:
                        default:
                            o = "ENVMAP_BLENDING_MULTIPLY"
                    }
                    this.defines[r] = "", this.defines[o] = "", this.defines[a] = ""
                }
            }

            function i(e) {
                this.varyingParameters = [], this.vertexParameters = [], this.vertexFunctions = [], this.vertexInit = [], this.vertexNormal = [], this.vertexPosition = [], this.vertexColor = [], this.vertexPostMorph = [], this.vertexPostSkinning = [], this.fragmentFunctions = [], this.fragmentParameters = [], this.fragmentInit = [], this.fragmentMap = [], this.fragmentDiffuse = [], n.call(this, e, t.ShaderLib.basic.uniforms), this.lights = !1, this.vertexShader = this.concatVertexShader(), this.fragmentShader = this.concatFragmentShader()
            }

            function r(e) {
                this.varyingParameters = [], this.vertexFunctions = [], this.vertexParameters = [], this.vertexInit = [], this.vertexNormal = [], this.vertexPosition = [], this.vertexColor = [], this.vertexPostMorph = [], this.vertexPostSkinning = [], this.fragmentFunctions = [], this.fragmentParameters = [], this.fragmentInit = [], this.fragmentMap = [], this.fragmentDiffuse = [], this.fragmentEmissive = [], this.fragmentSpecular = [], n.call(this, e, t.ShaderLib.lambert.uniforms), this.lights = !0, this.vertexShader = this.concatVertexShader(), this.fragmentShader = this.concatFragmentShader()
            }

            function a(e) {
                this.varyingParameters = [], this.vertexFunctions = [], this.vertexParameters = [], this.vertexInit = [], this.vertexNormal = [], this.vertexPosition = [], this.vertexColor = [], this.fragmentFunctions = [], this.fragmentParameters = [], this.fragmentInit = [], this.fragmentMap = [], this.fragmentDiffuse = [], this.fragmentEmissive = [], this.fragmentSpecular = [], n.call(this, e, t.ShaderLib.phong.uniforms), this.lights = !0, this.vertexShader = this.concatVertexShader(), this.fragmentShader = this.concatFragmentShader()
            }

            function o(e) {
                this.varyingParameters = [], this.vertexFunctions = [], this.vertexParameters = [], this.vertexInit = [], this.vertexNormal = [], this.vertexPosition = [], this.vertexColor = [], this.vertexPostMorph = [], this.vertexPostSkinning = [], this.fragmentFunctions = [], this.fragmentParameters = [], this.fragmentInit = [], this.fragmentMap = [], this.fragmentDiffuse = [], this.fragmentRoughness = [], this.fragmentMetalness = [], this.fragmentEmissive = [], n.call(this, e, t.ShaderLib.standard.uniforms), this.lights = !0, this.vertexShader = this.concatVertexShader(), this.fragmentShader = this.concatFragmentShader()
            }

            function s(e) {
                e.defines || (e.defines = {}), e.defines.TOON = "", a.call(this, e)
            }

            function l(e) {
                this.varyingParameters = [], this.vertexFunctions = [], this.vertexParameters = [], this.vertexInit = [], this.vertexPosition = [], this.vertexColor = [], this.fragmentFunctions = [], this.fragmentParameters = [], this.fragmentInit = [], this.fragmentMap = [], this.fragmentDiffuse = [], this.fragmentShape = [], n.call(this, e, t.ShaderLib.points.uniforms), this.vertexShader = this.concatVertexShader(), this.fragmentShader = this.concatFragmentShader()
            }

            function c(e) {
                this.depthPacking = t.RGBADepthPacking, this.clipping = !0, this.vertexFunctions = [], this.vertexParameters = [], this.vertexInit = [], this.vertexPosition = [], this.vertexPostMorph = [], this.vertexPostSkinning = [], n.call(this, e), this.uniforms = t.UniformsUtils.merge([t.ShaderLib.depth.uniforms, this.uniforms]), this.vertexShader = this.concatVertexShader(), this.fragmentShader = t.ShaderLib.depth.fragmentShader
            }

            function u(e) {
                this.depthPacking = t.RGBADepthPacking, this.clipping = !0, this.vertexFunctions = [], this.vertexParameters = [], this.vertexInit = [], this.vertexPosition = [], this.vertexPostMorph = [], this.vertexPostSkinning = [], n.call(this, e), this.uniforms = t.UniformsUtils.merge([t.ShaderLib.distanceRGBA.uniforms, this.uniforms]), this.vertexShader = this.concatVertexShader(), this.fragmentShader = t.ShaderLib.distanceRGBA.fragmentShader
            }

            function h(e, n) {
                t.BufferGeometry.call(this), this.prefabGeometry = e, this.isPrefabBufferGeometry = e.isBufferGeometry, this.prefabCount = n, this.isPrefabBufferGeometry ? this.prefabVertexCount = e.attributes.position.count : this.prefabVertexCount = e.vertices.length, this.bufferIndices(), this.bufferPositions()
            }

            function d(e, n) {
                t.BufferGeometry.call(this), Array.isArray(e) ? this.prefabGeometries = e : this.prefabGeometries = [e], this.prefabGeometriesCount = this.prefabGeometries.length, this.prefabCount = n * this.prefabGeometriesCount, this.repeatCount = n, this.prefabVertexCounts = this.prefabGeometries.map(function (e) {
                    return e.isBufferGeometry ? e.attributes.position.count : e.vertices.length
                }), this.repeatVertexCount = this.prefabVertexCounts.reduce(function (e, t) {
                    return e + t
                }, 0), this.bufferIndices(), this.bufferPositions()
            }

            function p(e, n) {
                e.isGeometry === !0 && console.error("InstancedPrefabBufferGeometry prefab must be a BufferGeometry."), t.InstancedBufferGeometry.call(this), this.prefabGeometry = e, this.copy(e), this.maxInstancedCount = n, this.prefabCount = n
            }

            function f(e, n) {
                t.BufferGeometry.call(this), this.modelGeometry = e, this.faceCount = this.modelGeometry.faces.length, this.vertexCount = this.modelGeometry.vertices.length, n = n || {}, n.computeCentroids && this.computeCentroids(), this.bufferIndices(), this.bufferPositions(n.localizeFaces)
            }

            function m(e) {
                t.BufferGeometry.call(this), this.pointCount = e, this.bufferPositions()
            }

            function v(e, t, n, i, r) {
                this.key = e, this.start = t, this.duration = n, this.transition = i, this.compiler = r, this.trail = 0
            }

            function g() {
                this.duration = 0, this.timeKey = "tTime", this.segments = {}, this.__key = 0
            }
            n.prototype = Object.assign(Object.create(t.ShaderMaterial.prototype), {
                constructor: n,
                setUniformValues: function (e) {
                    var t = this;
                    if (e) {
                        var n = Object.keys(e);
                        n.forEach(function (n) {
                            n in t.uniforms && (t.uniforms[n].value = e[n])
                        })
                    }
                },
                stringifyChunk: function (e) {
                    var t = void 0;
                    return t = this[e] ? "string" == typeof this[e] ? this[e] : this[e].join("\n") : ""
                },
                toJSON: function (e) {
                    var n = t.Material.prototype.toJSON.call(this, e);
                    n.uniforms = {};
                    for (var i in this.uniforms) {
                        var r = this.uniforms[i],
                            a = r.value;
                        null === a || void 0 === a ? n.uniforms[i] = {
                            value: a
                        } : a.isTexture ? n.uniforms[i] = {
                            type: "t",
                            value: a.toJSON(e).uuid
                        } : a.isColor ? n.uniforms[i] = {
                            type: "c",
                            value: a.getHex()
                        } : a.isVector2 ? n.uniforms[i] = {
                            type: "v2",
                            value: a.toArray()
                        } : a.isVector3 ? n.uniforms[i] = {
                            type: "v3",
                            value: a.toArray()
                        } : a.isVector4 ? n.uniforms[i] = {
                            type: "v4",
                            value: a.toArray()
                        } : a.isMatrix4 ? n.uniforms[i] = {
                            type: "m4",
                            value: a.toArray()
                        } : n.uniforms[i] = {
                            value: a
                        }
                    }
                    return Object.keys(this.defines).length > 0 && (n.defines = this.defines), n.vertexShader = this.vertexShader, n.fragmentShader = this.fragmentShader, n
                }
            }), i.prototype = Object.create(n.prototype), i.prototype.constructor = i, i.prototype.concatVertexShader = function () {
                return "\n  #include <common>\n  #include <uv_pars_vertex>\n  #include <uv2_pars_vertex>\n  #include <envmap_pars_vertex>\n  #include <color_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  " + this.stringifyChunk("vertexParameters") + "\n  " + this.stringifyChunk("varyingParameters") + "\n  " + this.stringifyChunk("vertexFunctions") + "\n  \n  void main() {\n\n    " + this.stringifyChunk("vertexInit") + "\n  \n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n    #include <skinbase_vertex>\n  \n    #ifdef USE_ENVMAP\n  \n    #include <beginnormal_vertex>\n    \n    " + this.stringifyChunk("vertexNormal") + "\n    \n    #include <morphnormal_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n  \n    #endif\n  \n    #include <begin_vertex>\n    \n    " + this.stringifyChunk("vertexPosition") + "\n    " + this.stringifyChunk("vertexColor") + "\n    \n    #include <morphtarget_vertex>\n    \n    " + this.stringifyChunk("vertexPostMorph") + "\n    \n    #include <skinning_vertex>\n\n    " + this.stringifyChunk("vertexPostSkinning") + "\n\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n  \n    #include <worldpos_vertex>\n    #include <clipping_planes_vertex>\n    #include <envmap_vertex>\n    #include <fog_vertex>\n  }"
            }, i.prototype.concatFragmentShader = function () {
                return "\n  uniform vec3 diffuse;\n  uniform float opacity;\n  \n  " + this.stringifyChunk("fragmentParameters") + "\n  " + this.stringifyChunk("varyingParameters") + "\n  " + this.stringifyChunk("fragmentFunctions") + "\n  \n  #ifndef FLAT_SHADED\n  \n    varying vec3 vNormal;\n  \n  #endif\n  \n  #include <common>\n  #include <color_pars_fragment>\n  #include <uv_pars_fragment>\n  #include <uv2_pars_fragment>\n  #include <map_pars_fragment>\n  #include <alphamap_pars_fragment>\n  #include <aomap_pars_fragment>\n  #include <lightmap_pars_fragment>\n  #include <envmap_pars_fragment>\n  #include <fog_pars_fragment>\n  #include <specularmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n  \n  void main() {\n  \n    " + this.stringifyChunk("fragmentInit") + "\n  \n    #include <clipping_planes_fragment>\n\n    vec4 diffuseColor = vec4( diffuse, opacity );\n\n    " + this.stringifyChunk("fragmentDiffuse") + "\n  \n    #include <logdepthbuf_fragment>\n    \n    " + (this.stringifyChunk("fragmentMap") || "#include <map_fragment>") + "\n    \n    #include <color_fragment>\n    #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n  \n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n  \n    // accumulation (baked indirect lighting only)\n    #ifdef USE_LIGHTMAP\n  \n      reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n  \n    #else\n  \n      reflectedLight.indirectDiffuse += vec3( 1.0 );\n  \n    #endif\n  \n    // modulation\n    #include <aomap_fragment>\n  \n    reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n  \n    vec3 outgoingLight = reflectedLight.indirectDiffuse;\n  \n    #include <envmap_fragment>\n  \n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n  \n    #include <premultiplied_alpha_fragment>\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n  }"
            }, r.prototype = Object.create(n.prototype), r.prototype.constructor = r, r.prototype.concatVertexShader = function () {
                return "\n  #define LAMBERT\n\n  varying vec3 vLightFront;\n  \n  #ifdef DOUBLE_SIDED\n  \n    varying vec3 vLightBack;\n  \n  #endif\n  \n  #include <common>\n  #include <uv_pars_vertex>\n  #include <uv2_pars_vertex>\n  #include <envmap_pars_vertex>\n  #include <bsdfs>\n  #include <lights_pars_begin>\n  #include <envmap_physical_pars_fragment>\n  #include <color_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <shadowmap_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  " + this.stringifyChunk("vertexParameters") + "\n  " + this.stringifyChunk("varyingParameters") + "\n  " + this.stringifyChunk("vertexFunctions") + "\n  \n  void main() {\n  \n    " + this.stringifyChunk("vertexInit") + "\n  \n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n  \n    #include <beginnormal_vertex>\n    \n    " + this.stringifyChunk("vertexNormal") + "\n    \n    #include <morphnormal_vertex>\n    #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n  \n    #include <begin_vertex>\n    \n    " + this.stringifyChunk("vertexPosition") + "\n    " + this.stringifyChunk("vertexColor") + "\n    \n    #include <morphtarget_vertex>\n    \n    " + this.stringifyChunk("vertexPostMorph") + "\n    \n    #include <skinning_vertex>\n\n    " + this.stringifyChunk("vertexPostSkinning") + "\n    \n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n  \n    #include <worldpos_vertex>\n    #include <envmap_vertex>\n    #include <lights_lambert_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n  }"
            }, r.prototype.concatFragmentShader = function () {
                return "\n  uniform vec3 diffuse;\n  uniform vec3 emissive;\n  uniform float opacity;\n  \n  varying vec3 vLightFront;\n  \n  #ifdef DOUBLE_SIDED\n  \n    varying vec3 vLightBack;\n  \n  #endif\n  \n  #include <common>\n  #include <packing>\n  #include <dithering_pars_fragment>\n  #include <color_pars_fragment>\n  #include <uv_pars_fragment>\n  #include <uv2_pars_fragment>\n  #include <map_pars_fragment>\n  #include <alphamap_pars_fragment>\n  #include <aomap_pars_fragment>\n  #include <lightmap_pars_fragment>\n  #include <emissivemap_pars_fragment>\n  #include <envmap_pars_fragment>\n  #include <bsdfs>\n  #include <lights_pars_begin>\n  #include <envmap_physical_pars_fragment>\n  #include <fog_pars_fragment>\n  #include <shadowmap_pars_fragment>\n  #include <shadowmask_pars_fragment>\n  #include <specularmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n  \n  " + this.stringifyChunk("fragmentParameters") + "\n  " + this.stringifyChunk("varyingParameters") + "\n  " + this.stringifyChunk("fragmentFunctions") + "\n  \n  void main() {\n  \n    " + this.stringifyChunk("fragmentInit") + "\n  \n    #include <clipping_planes_fragment>\n\n    vec4 diffuseColor = vec4( diffuse, opacity );\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    vec3 totalEmissiveRadiance = emissive;\n\t\n    " + this.stringifyChunk("fragmentDiffuse") + "\n  \n    #include <logdepthbuf_fragment>\n\n    " + (this.stringifyChunk("fragmentMap") || "#include <map_fragment>") + "\n\n    #include <color_fragment>\n    #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n\n    " + this.stringifyChunk("fragmentEmissive") + "\n\n    #include <emissivemap_fragment>\n  \n    // accumulation\n    reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n  \n    #include <lightmap_fragment>\n  \n    reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n  \n    #ifdef DOUBLE_SIDED\n  \n      reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n  \n    #else\n  \n      reflectedLight.directDiffuse = vLightFront;\n  \n    #endif\n  \n    reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n  \n    // modulation\n    #include <aomap_fragment>\n  \n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n  \n    #include <envmap_fragment>\n  \n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n  \n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n  }"
            }, a.prototype = Object.create(n.prototype), a.prototype.constructor = a, a.prototype.concatVertexShader = function () {
                return "\n  #define PHONG\n\n  varying vec3 vViewPosition;\n\n  #ifndef FLAT_SHADED\n\n    varying vec3 vNormal;\n\n  #endif\n\n  #include <common>\n  #include <uv_pars_vertex>\n  #include <uv2_pars_vertex>\n  #include <displacementmap_pars_vertex>\n  #include <envmap_pars_vertex>\n  #include <color_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <shadowmap_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n\n  " + this.stringifyChunk("vertexParameters") + "\n  " + this.stringifyChunk("varyingParameters") + "\n  " + this.stringifyChunk("vertexFunctions") + "\n\n  void main() {\n\n    " + this.stringifyChunk("vertexInit") + "\n\n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n\n    #include <beginnormal_vertex>\n\n    " + this.stringifyChunk("vertexNormal") + "\n\n    #include <morphnormal_vertex>\n    #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n\n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n    vNormal = normalize( transformedNormal );\n\n  #endif\n\n    #include <begin_vertex>\n\n    " + this.stringifyChunk("vertexPosition") + "\n    " + this.stringifyChunk("vertexColor") + "\n\n    #include <morphtarget_vertex>\n    #include <skinning_vertex>\n    #include <displacementmap_vertex>\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n\n    vViewPosition = - mvPosition.xyz;\n\n    #include <worldpos_vertex>\n    #include <envmap_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n  }"
            }, a.prototype.concatFragmentShader = function () {
                return "\n  #define PHONG\n\n  uniform vec3 diffuse;\n  uniform vec3 emissive;\n  uniform vec3 specular;\n  uniform float shininess;\n  uniform float opacity;\n\n  #include <common>\n  #include <packing>\n  #include <dithering_pars_fragment>\n  #include <color_pars_fragment>\n  #include <uv_pars_fragment>\n  #include <uv2_pars_fragment>\n  #include <map_pars_fragment>\n  #include <alphamap_pars_fragment>\n  #include <aomap_pars_fragment>\n  #include <lightmap_pars_fragment>\n  #include <emissivemap_pars_fragment>\n  #include <envmap_pars_fragment>\n  #include <gradientmap_pars_fragment>\n  #include <fog_pars_fragment>\n  #include <bsdfs>\n  #include <lights_pars_begin>\n  #include <envmap_physical_pars_fragment>\n  #include <lights_phong_pars_fragment>\n  #include <shadowmap_pars_fragment>\n  #include <bumpmap_pars_fragment>\n  #include <normalmap_pars_fragment>\n  #include <specularmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n\n  " + this.stringifyChunk("fragmentParameters") + "\n  " + this.stringifyChunk("varyingParameters") + "\n  " + this.stringifyChunk("fragmentFunctions") + "\n\n  void main() {\n\n    " + this.stringifyChunk("fragmentInit") + "\n\n    #include <clipping_planes_fragment>\n\n    vec4 diffuseColor = vec4( diffuse, opacity );\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    vec3 totalEmissiveRadiance = emissive;\n\n    " + this.stringifyChunk("fragmentDiffuse") + "\n\n    #include <logdepthbuf_fragment>\n\n    " + (this.stringifyChunk("fragmentMap") || "#include <map_fragment>") + "\n\n    #include <color_fragment>\n    #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n\n    " + this.stringifyChunk("fragmentEmissive") + "\n\n    #include <emissivemap_fragment>\n\n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n\n    " + this.stringifyChunk("fragmentSpecular") + "\n\n    // modulation\n    #include <aomap_fragment>\n\n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n    #include <envmap_fragment>\n\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n\n  }"
            }, o.prototype = Object.create(n.prototype), o.prototype.constructor = o, o.prototype.concatVertexShader = function () {
                return "\n  #define PHYSICAL\n\n  varying vec3 vViewPosition;\n  \n  #ifndef FLAT_SHADED\n  \n    varying vec3 vNormal;\n  \n  #endif\n  \n  #include <common>\n  #include <uv_pars_vertex>\n  #include <uv2_pars_vertex>\n  #include <displacementmap_pars_vertex>\n  #include <color_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <shadowmap_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  " + this.stringifyChunk("vertexParameters") + "\n  " + this.stringifyChunk("varyingParameters") + "\n  " + this.stringifyChunk("vertexFunctions") + "\n  \n  void main() {\n\n    " + this.stringifyChunk("vertexInit") + "\n\n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n  \n    #include <beginnormal_vertex>\n    \n    " + this.stringifyChunk("vertexNormal") + "\n    \n    #include <morphnormal_vertex>\n    #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n  \n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n  \n    vNormal = normalize( transformedNormal );\n  \n  #endif\n  \n    #include <begin_vertex>\n    \n    " + this.stringifyChunk("vertexPosition") + "\n    " + this.stringifyChunk("vertexColor") + "\n    \n    #include <morphtarget_vertex>\n    \n    " + this.stringifyChunk("vertexPostMorph") + "\n    \n    #include <skinning_vertex>\n\n    " + this.stringifyChunk("vertexPostSkinning") + "\n    \n    #include <displacementmap_vertex>\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n  \n    vViewPosition = - mvPosition.xyz;\n  \n    #include <worldpos_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n  }"
            }, o.prototype.concatFragmentShader = function () {
                return "\n  #define PHYSICAL\n  \n  uniform vec3 diffuse;\n  uniform vec3 emissive;\n  uniform float roughness;\n  uniform float metalness;\n  uniform float opacity;\n  \n  #ifndef STANDARD\n    uniform float clearCoat;\n    uniform float clearCoatRoughness;\n  #endif\n  \n  varying vec3 vViewPosition;\n  \n  #ifndef FLAT_SHADED\n  \n    varying vec3 vNormal;\n  \n  #endif\n  \n  #include <common>\n  #include <packing>\n  #include <dithering_pars_fragment>\n  #include <color_pars_fragment>\n  #include <uv_pars_fragment>\n  #include <uv2_pars_fragment>\n  #include <map_pars_fragment>\n  #include <alphamap_pars_fragment>\n  #include <aomap_pars_fragment>\n  #include <lightmap_pars_fragment>\n  #include <emissivemap_pars_fragment>\n  #include <envmap_pars_fragment>\n  #include <fog_pars_fragment>\n  #include <bsdfs>\n  #include <cube_uv_reflection_fragment>\n  #include <lights_pars_begin>\n  #include <envmap_physical_pars_fragment>\n  #include <lights_physical_pars_fragment>\n  #include <shadowmap_pars_fragment>\n  #include <bumpmap_pars_fragment>\n  #include <normalmap_pars_fragment>\n  #include <roughnessmap_pars_fragment>\n  #include <metalnessmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n  \n  " + this.stringifyChunk("fragmentParameters") + "\n  " + this.stringifyChunk("varyingParameters") + "\n  " + this.stringifyChunk("fragmentFunctions") + "\n  \n  void main() {\n  \n    " + this.stringifyChunk("fragmentInit") + "\n  \n    #include <clipping_planes_fragment>\n  \n    vec4 diffuseColor = vec4( diffuse, opacity );\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    vec3 totalEmissiveRadiance = emissive;\n  \n    " + this.stringifyChunk("fragmentDiffuse") + "\n  \n    #include <logdepthbuf_fragment>\n\n    " + (this.stringifyChunk("fragmentMap") || "#include <map_fragment>") + "\n\n    #include <color_fragment>\n    #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    \n    float roughnessFactor = roughness;\n    " + this.stringifyChunk("fragmentRoughness") + "\n    #ifdef USE_ROUGHNESSMAP\n    \n      vec4 texelRoughness = texture2D( roughnessMap, vUv );\n    \n      // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n      roughnessFactor *= texelRoughness.g;\n    \n    #endif\n    \n    float metalnessFactor = metalness;\n    " + this.stringifyChunk("fragmentMetalness") + "\n    #ifdef USE_METALNESSMAP\n    \n      vec4 texelMetalness = texture2D( metalnessMap, vUv );\n      metalnessFactor *= texelMetalness.b;\n    \n    #endif\n    \n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    \n    " + this.stringifyChunk("fragmentEmissive") + "\n    \n    #include <emissivemap_fragment>\n  \n    // accumulation\n    #include <lights_physical_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n  \n    // modulation\n    #include <aomap_fragment>\n  \n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n  \n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n  \n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n  \n  }"
            }, s.prototype = Object.create(a.prototype), s.prototype.constructor = s, l.prototype = Object.create(n.prototype), l.prototype.constructor = l, l.prototype.concatVertexShader = function () {
                return "\n  uniform float size;\n  uniform float scale;\n  \n  #include <common>\n  #include <color_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <shadowmap_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  " + this.stringifyChunk("vertexParameters") + "\n  " + this.stringifyChunk("varyingParameters") + "\n  " + this.stringifyChunk("vertexFunctions") + "\n  \n  void main() {\n  \n    " + this.stringifyChunk("vertexInit") + "\n  \n    #include <color_vertex>\n    #include <begin_vertex>\n    \n    " + this.stringifyChunk("vertexPosition") + "\n    " + this.stringifyChunk("vertexColor") + "\n    \n    #include <project_vertex>\n  \n    #ifdef USE_SIZEATTENUATION\n      gl_PointSize = size * ( scale / - mvPosition.z );\n    #else\n      gl_PointSize = size;\n    #endif\n  \n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n    #include <worldpos_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n  }"
            }, l.prototype.concatFragmentShader = function () {
                return "\n  uniform vec3 diffuse;\n  uniform float opacity;\n  \n  #include <common>\n  #include <packing>\n  #include <color_pars_fragment>\n  #include <map_particle_pars_fragment>\n  #include <fog_pars_fragment>\n  #include <shadowmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n  \n  " + this.stringifyChunk("fragmentParameters") + "\n  " + this.stringifyChunk("varyingParameters") + "\n  " + this.stringifyChunk("fragmentFunctions") + "\n  \n  void main() {\n  \n    " + this.stringifyChunk("fragmentInit") + "\n  \n    #include <clipping_planes_fragment>\n  \n    vec3 outgoingLight = vec3( 0.0 );\n    vec4 diffuseColor = vec4( diffuse, opacity );\n  \n    " + this.stringifyChunk("fragmentDiffuse") + "\n  \n    #include <logdepthbuf_fragment>\n\n    " + (this.stringifyChunk("fragmentMap") || "#include <map_particle_fragment>") + "\n\n    #include <color_fragment>\n    #include <alphatest_fragment>\n  \n    outgoingLight = diffuseColor.rgb;\n  \n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    \n    " + this.stringifyChunk("fragmentShape") + "\n  \n    #include <premultiplied_alpha_fragment>\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n  }";
            }, c.prototype = Object.create(n.prototype), c.prototype.constructor = c, c.prototype.concatVertexShader = function () {
                return "\n  #include <common>\n  #include <uv_pars_vertex>\n  #include <displacementmap_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  " + this.stringifyChunk("vertexParameters") + "\n  " + this.stringifyChunk("vertexFunctions") + "\n  \n  void main() {\n  \n    " + this.stringifyChunk("vertexInit") + "\n  \n    #include <uv_vertex>\n  \n    #include <skinbase_vertex>\n  \n    #ifdef USE_DISPLACEMENTMAP\n  \n      #include <beginnormal_vertex>\n      #include <morphnormal_vertex>\n      #include <skinnormal_vertex>\n  \n    #endif\n  \n    #include <begin_vertex>\n    \n    " + this.stringifyChunk("vertexPosition") + "\n\n    #include <morphtarget_vertex>\n    \n    " + this.stringifyChunk("vertexPostMorph") + "\n    \n    #include <skinning_vertex>\n\n    " + this.stringifyChunk("vertexPostSkinning") + "\n    \n    #include <displacementmap_vertex>\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n  }"
            }, u.prototype = Object.create(n.prototype), u.prototype.constructor = u, u.prototype.concatVertexShader = function () {
                return "\n  #define DISTANCE\n\n  varying vec3 vWorldPosition;\n  \n  #include <common>\n  #include <uv_pars_vertex>\n  #include <displacementmap_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  " + this.stringifyChunk("vertexParameters") + "\n  " + this.stringifyChunk("vertexFunctions") + "\n  \n  void main() {\n\n    " + this.stringifyChunk("vertexInit") + "\n  \n    #include <uv_vertex>\n  \n    #include <skinbase_vertex>\n  \n    #ifdef USE_DISPLACEMENTMAP\n  \n      #include <beginnormal_vertex>\n      #include <morphnormal_vertex>\n      #include <skinnormal_vertex>\n  \n    #endif\n  \n    #include <begin_vertex>\n    \n    " + this.stringifyChunk("vertexPosition") + "\n\n    #include <morphtarget_vertex>\n    \n    " + this.stringifyChunk("vertexPostMorph") + "\n    \n    #include <skinning_vertex>\n\n    " + this.stringifyChunk("vertexPostSkinning") + "\n    \n    #include <displacementmap_vertex>\n    #include <project_vertex>\n    #include <worldpos_vertex>\n    #include <clipping_planes_vertex>\n  \n    vWorldPosition = worldPosition.xyz;\n  \n  }"
            }, h.prototype = Object.create(t.BufferGeometry.prototype), h.prototype.constructor = h, h.prototype.bufferIndices = function () {
                var e = [],
                    n = void 0;
                if (this.isPrefabBufferGeometry)
                    if (this.prefabGeometry.index) n = this.prefabGeometry.index.count, e = this.prefabGeometry.index.array;
                    else {
                        n = this.prefabVertexCount;
                        for (var i = 0; i < n; i++) e.push(i)
                    }
                else {
                    var r = this.prefabGeometry.faces.length;
                    n = 3 * r;
                    for (var a = 0; a < r; a++) {
                        var o = this.prefabGeometry.faces[a];
                        e.push(o.a, o.b, o.c)
                    }
                }
                var s = new Uint32Array(this.prefabCount * n);
                this.setIndex(new t.BufferAttribute(s, 1));
                for (var l = 0; l < this.prefabCount; l++)
                    for (var c = 0; c < n; c++) s[l * n + c] = e[c] + l * this.prefabVertexCount
            }, h.prototype.bufferPositions = function () {
                var e = this.createAttribute("position", 3).array;
                if (this.isPrefabBufferGeometry)
                    for (var t = this.prefabGeometry.attributes.position.array, n = 0, i = 0; n < this.prefabCount; n++)
                        for (var r = 0; r < this.prefabVertexCount; r++, i += 3) e[i] = t[3 * r], e[i + 1] = t[3 * r + 1], e[i + 2] = t[3 * r + 2];
                else
                    for (var a = 0, o = 0; a < this.prefabCount; a++)
                        for (var s = 0; s < this.prefabVertexCount; s++, o += 3) {
                            var l = this.prefabGeometry.vertices[s];
                            e[o] = l.x, e[o + 1] = l.y, e[o + 2] = l.z
                        }
            }, h.prototype.bufferUvs = function () {
                var e = this.createAttribute("uv", 2).array;
                if (this.isPrefabBufferGeometry)
                    for (var t = this.prefabGeometry.attributes.uv.array, n = 0, i = 0; n < this.prefabCount; n++)
                        for (var r = 0; r < this.prefabVertexCount; r++, i += 2) e[i] = t[2 * r], e[i + 1] = t[2 * r + 1];
                else {
                    for (var a = this.prefabGeometry.faces.length, o = [], s = 0; s < a; s++) {
                        var l = this.prefabGeometry.faces[s],
                            c = this.prefabGeometry.faceVertexUvs[0][s];
                        o[l.a] = c[0], o[l.b] = c[1], o[l.c] = c[2]
                    }
                    for (var u = 0, h = 0; u < this.prefabCount; u++)
                        for (var d = 0; d < this.prefabVertexCount; d++, h += 2) {
                            var p = o[d];
                            e[h] = p.x, e[h + 1] = p.y
                        }
                }
            }, h.prototype.createAttribute = function (e, n, i) {
                var r = new Float32Array(this.prefabCount * this.prefabVertexCount * n),
                    a = new t.BufferAttribute(r, n);
                if (this.addAttribute(e, a), i)
                    for (var o = [], s = 0; s < this.prefabCount; s++) i(o, s, this.prefabCount), this.setPrefabData(a, s, o);
                return a
            }, h.prototype.setPrefabData = function (e, t, n) {
                e = "string" == typeof e ? this.attributes[e] : e;
                for (var i = t * this.prefabVertexCount * e.itemSize, r = 0; r < this.prefabVertexCount; r++)
                    for (var a = 0; a < e.itemSize; a++) e.array[i++] = n[a]
            }, d.prototype = Object.create(t.BufferGeometry.prototype), d.prototype.constructor = d, d.prototype.bufferIndices = function () {
                var e = 0;
                this.prefabIndices = this.prefabGeometries.map(function (t) {
                    var n = [];
                    if (t.isBufferGeometry)
                        if (t.index) n = t.index.array;
                        else
                            for (var i = 0; i < t.attributes.position.count; i++) n.push(i);
                    else
                        for (var r = 0; r < t.faces.length; r++) {
                            var a = t.faces[r];
                            n.push(a.a, a.b, a.c)
                        }
                    return e += n.length, n
                });
                for (var n = new Uint32Array(e * this.repeatCount), i = 0, r = 0, a = 0; a < this.prefabCount; a++) {
                    for (var o = a % this.prefabGeometriesCount, s = this.prefabIndices[o], l = this.prefabVertexCounts[o], c = 0; c < s.length; c++) n[i++] = s[c] + r;
                    r += l
                }
                this.setIndex(new t.BufferAttribute(n, 1))
            }, d.prototype.bufferPositions = function () {
                for (var e = this, t = this.createAttribute("position", 3).array, n = this.prefabGeometries.map(function (t, n) {
                        var i = void 0;
                        if (t.isBufferGeometry) i = t.attributes.position.array;
                        else {
                            var r = e.prefabVertexCounts[n];
                            i = [];
                            for (var a = 0, o = 0; a < r; a++) {
                                var s = t.vertices[a];
                                i[o++] = s.x, i[o++] = s.y, i[o++] = s.z
                            }
                        }
                        return i
                    }), i = 0, r = 0; i < this.prefabCount; i++)
                    for (var a = i % this.prefabGeometries.length, o = this.prefabVertexCounts[a], s = n[a], l = 0; l < o; l++) t[r++] = s[3 * l], t[r++] = s[3 * l + 1], t[r++] = s[3 * l + 2]
            }, d.prototype.bufferUvs = function () {
                for (var e = this, t = this.createAttribute("uv", 2).array, n = this.prefabGeometries.map(function (t, n) {
                        var i = void 0;
                        if (t.isBufferGeometry) t.attributes.uv || console.error("No UV found in prefab geometry", t), i = t.attributes.uv.array;
                        else {
                            for (var r = e.prefabIndices[n].length / 3, a = [], o = 0; o < r; o++) {
                                var s = t.faces[o],
                                    l = t.faceVertexUvs[0][o];
                                a[s.a] = l[0], a[s.b] = l[1], a[s.c] = l[2]
                            }
                            i = [];
                            for (var c = 0; c < a.length; c++) i[2 * c] = a[c].x, i[2 * c + 1] = a[c].y
                        }
                        return i
                    }), i = 0, r = 0; i < this.prefabCount; i++)
                    for (var a = i % this.prefabGeometries.length, o = this.prefabVertexCounts[a], s = n[a], l = 0; l < o; l++) t[r++] = s[2 * l], t[r++] = s[2 * l + 1]
            }, d.prototype.createAttribute = function (e, n, i) {
                var r = new Float32Array(this.repeatCount * this.repeatVertexCount * n),
                    a = new t.BufferAttribute(r, n);
                if (this.addAttribute(e, a), i)
                    for (var o = [], s = 0; s < this.prefabCount; s++) i(o, s, this.prefabCount), this.setPrefabData(a, s, o);
                return a
            }, d.prototype.setPrefabData = function (e, t, n) {
                e = "string" == typeof e ? this.attributes[e] : e;
                for (var i = t % this.prefabGeometriesCount, r = this.prefabVertexCounts[i], a = (t / this.prefabGeometriesCount | 0) * this.prefabGeometriesCount, o = a * this.repeatVertexCount, s = t - a, l = 0, c = 0; c < s;) l += this.prefabVertexCounts[c++];
                for (var u = (o + l) * e.itemSize, h = 0; h < r; h++)
                    for (var d = 0; d < e.itemSize; d++) e.array[u++] = n[d]
            }, p.prototype = Object.create(t.InstancedBufferGeometry.prototype), p.prototype.constructor = p, p.prototype.createAttribute = function (e, n, i) {
                var r = new Float32Array(this.prefabCount * n),
                    a = new t.InstancedBufferAttribute(r, n);
                if (this.addAttribute(e, a), i)
                    for (var o = [], s = 0; s < this.prefabCount; s++) i(o, s, this.prefabCount), this.setPrefabData(a, s, o);
                return a
            }, p.prototype.setPrefabData = function (e, t, n) {
                e = "string" == typeof e ? this.attributes[e] : e;
                for (var i = t * e.itemSize, r = 0; r < e.itemSize; r++) e.array[i++] = n[r]
            };
            var y = {
                separateFaces: function (e) {
                    for (var t = [], n = 0, i = e.faces.length; n < i; n++) {
                        var r = t.length,
                            a = e.faces[n],
                            o = a.a,
                            s = a.b,
                            l = a.c,
                            c = e.vertices[o],
                            u = e.vertices[s],
                            h = e.vertices[l];
                        t.push(c.clone()), t.push(u.clone()), t.push(h.clone()), a.a = r, a.b = r + 1, a.c = r + 2
                    }
                    e.vertices = t
                },
                computeCentroid: function (e, n, i) {
                    var r = e.vertices[n.a],
                        a = e.vertices[n.b],
                        o = e.vertices[n.c];
                    return i = i || new t.Vector3, i.x = (r.x + a.x + o.x) / 3, i.y = (r.y + a.y + o.y) / 3, i.z = (r.z + a.z + o.z) / 3, i
                },
                randomInBox: function (e, n) {
                    return n = n || new t.Vector3, n.x = t.Math.randFloat(e.min.x, e.max.x), n.y = t.Math.randFloat(e.min.y, e.max.y), n.z = t.Math.randFloat(e.min.z, e.max.z), n
                },
                randomAxis: function (e) {
                    return e = e || new t.Vector3, e.x = t.Math.randFloatSpread(2), e.y = t.Math.randFloatSpread(2), e.z = t.Math.randFloatSpread(2), e.normalize(), e
                },
                createDepthAnimationMaterial: function (e) {
                    return new c({
                        uniforms: e.uniforms,
                        defines: e.defines,
                        vertexFunctions: e.vertexFunctions,
                        vertexParameters: e.vertexParameters,
                        vertexInit: e.vertexInit,
                        vertexPosition: e.vertexPosition
                    })
                },
                createDistanceAnimationMaterial: function (e) {
                    return new u({
                        uniforms: e.uniforms,
                        defines: e.defines,
                        vertexFunctions: e.vertexFunctions,
                        vertexParameters: e.vertexParameters,
                        vertexInit: e.vertexInit,
                        vertexPosition: e.vertexPosition
                    })
                }
            };
            f.prototype = Object.create(t.BufferGeometry.prototype), f.prototype.constructor = f, f.prototype.computeCentroids = function () {
                this.centroids = [];
                for (var e = 0; e < this.faceCount; e++) this.centroids[e] = y.computeCentroid(this.modelGeometry, this.modelGeometry.faces[e])
            }, f.prototype.bufferIndices = function () {
                var e = new Uint32Array(3 * this.faceCount);
                this.setIndex(new t.BufferAttribute(e, 1));
                for (var n = 0, i = 0; n < this.faceCount; n++, i += 3) {
                    var r = this.modelGeometry.faces[n];
                    e[i] = r.a, e[i + 1] = r.b, e[i + 2] = r.c
                }
            }, f.prototype.bufferPositions = function (e) {
                var t = this.createAttribute("position", 3).array,
                    n = void 0,
                    i = void 0;
                if (e === !0)
                    for (n = 0; n < this.faceCount; n++) {
                        var r = this.modelGeometry.faces[n],
                            a = this.centroids ? this.centroids[n] : y.computeCentroid(this.modelGeometry, r),
                            o = this.modelGeometry.vertices[r.a],
                            s = this.modelGeometry.vertices[r.b],
                            l = this.modelGeometry.vertices[r.c];
                        t[3 * r.a] = o.x - a.x, t[3 * r.a + 1] = o.y - a.y, t[3 * r.a + 2] = o.z - a.z, t[3 * r.b] = s.x - a.x, t[3 * r.b + 1] = s.y - a.y, t[3 * r.b + 2] = s.z - a.z, t[3 * r.c] = l.x - a.x, t[3 * r.c + 1] = l.y - a.y, t[3 * r.c + 2] = l.z - a.z
                    } else
                        for (n = 0, i = 0; n < this.vertexCount; n++, i += 3) {
                            var c = this.modelGeometry.vertices[n];
                            t[i] = c.x, t[i + 1] = c.y, t[i + 2] = c.z
                        }
            }, f.prototype.bufferUvs = function () {
                for (var e = this.createAttribute("uv", 2).array, t = 0; t < this.faceCount; t++) {
                    var n = this.modelGeometry.faces[t],
                        i = void 0;
                    i = this.modelGeometry.faceVertexUvs[0][t][0], e[2 * n.a] = i.x, e[2 * n.a + 1] = i.y, i = this.modelGeometry.faceVertexUvs[0][t][1], e[2 * n.b] = i.x, e[2 * n.b + 1] = i.y, i = this.modelGeometry.faceVertexUvs[0][t][2], e[2 * n.c] = i.x, e[2 * n.c + 1] = i.y
                }
            }, f.prototype.bufferSkinning = function () {
                for (var e = this.createAttribute("skinIndex", 4).array, t = this.createAttribute("skinWeight", 4).array, n = 0; n < this.vertexCount; n++) {
                    var i = this.modelGeometry.skinIndices[n],
                        r = this.modelGeometry.skinWeights[n];
                    e[4 * n] = i.x, e[4 * n + 1] = i.y, e[4 * n + 2] = i.z, e[4 * n + 3] = i.w, t[4 * n] = r.x, t[4 * n + 1] = r.y, t[4 * n + 2] = r.z, t[4 * n + 3] = r.w
                }
            }, f.prototype.createAttribute = function (e, n, i) {
                var r = new Float32Array(this.vertexCount * n),
                    a = new t.BufferAttribute(r, n);
                if (this.addAttribute(e, a), i)
                    for (var o = [], s = 0; s < this.faceCount; s++) i(o, s, this.faceCount), this.setFaceData(a, s, o);
                return a
            }, f.prototype.setFaceData = function (e, t, n) {
                e = "string" == typeof e ? this.attributes[e] : e;
                for (var i = 3 * t * e.itemSize, r = 0; r < 3; r++)
                    for (var a = 0; a < e.itemSize; a++) e.array[i++] = n[a]
            }, m.prototype = Object.create(t.BufferGeometry.prototype), m.prototype.constructor = m, m.prototype.bufferPositions = function () {
                this.createAttribute("position", 3)
            }, m.prototype.createAttribute = function (e, n, i) {
                var r = new Float32Array(this.pointCount * n),
                    a = new t.BufferAttribute(r, n);
                if (this.addAttribute(e, a), i)
                    for (var o = [], s = 0; s < this.pointCount; s++) i(o, s, this.pointCount), this.setPointData(a, s, o);
                return a
            }, m.prototype.setPointData = function (e, t, n) {
                e = "string" == typeof e ? this.attributes[e] : e;
                for (var i = t * e.itemSize, r = 0; r < e.itemSize; r++) e.array[i++] = n[r]
            };
            var x = "vec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, vec2 c) {\n    vec4 v0 = (p2 - p0) * c.x;\n    vec4 v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    return vec4((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\nvec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t) {\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n}\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t, vec2 c) {\n    vec3 v0 = (p2 - p0) * c.x;\n    vec3 v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    return vec3((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n}\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t, vec2 c) {\n    vec2 v0 = (p2 - p0) * c.x;\n    vec2 v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    return vec2((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n}\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t, vec2 c) {\n    float v0 = (p2 - p0) * c.x;\n    float v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n    return float((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t) {\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\n}\nivec4 getCatmullRomSplineIndices(float l, float p) {\n    float index = floor(p);\n    int i0 = int(max(0.0, index - 1.0));\n    int i1 = int(index);\n    int i2 = int(min(index + 1.0, l));\n    int i3 = int(min(index + 2.0, l));\n    return ivec4(i0, i1, i2, i3);\n}\nivec4 getCatmullRomSplineIndicesClosed(float l, float p) {\n    float index = floor(p);\n    int i0 = int(index == 0.0 ? l : index - 1.0);\n    int i1 = int(index);\n    int i2 = int(mod(index + 1.0, l));\n    int i3 = int(mod(index + 2.0, l));\n    return ivec4(i0, i1, i2, i3);\n}\n",
                b = "vec3 cubicBezier(vec3 p0, vec3 c0, vec3 c1, vec3 p1, float t) {\n    float tn = 1.0 - t;\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\n}\nvec2 cubicBezier(vec2 p0, vec2 c0, vec2 c1, vec2 p1, float t) {\n    float tn = 1.0 - t;\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\n}\n",
                _ = "float easeBackIn(float p, float amplitude) {\n    return p * p * ((amplitude + 1.0) * p - amplitude);\n}\nfloat easeBackIn(float p) {\n    return easeBackIn(p, 1.70158);\n}\nfloat easeBackIn(float t, float b, float c, float d, float amplitude) {\n    return b + easeBackIn(t / d, amplitude) * c;\n}\nfloat easeBackIn(float t, float b, float c, float d) {\n    return b + easeBackIn(t / d) * c;\n}\n",
                w = "float easeBackInOut(float p, float amplitude) {\n    amplitude *= 1.525;\n    return ((p *= 2.0) < 1.0) ? 0.5 * p * p * ((amplitude + 1.0) * p - amplitude) : 0.5 * ((p -= 2.0) * p * ((amplitude + 1.0) * p + amplitude) + 2.0);\n}\nfloat easeBackInOut(float p) {\n    return easeBackInOut(p, 1.70158);\n}\nfloat easeBackInOut(float t, float b, float c, float d, float amplitude) {\n    return b + easeBackInOut(t / d, amplitude) * c;\n}\nfloat easeBackInOut(float t, float b, float c, float d) {\n    return b + easeBackInOut(t / d) * c;\n}\n",
                M = "float easeBackOut(float p, float amplitude) {\n    return ((p = p - 1.0) * p * ((amplitude + 1.0) * p + amplitude) + 1.0);\n}\nfloat easeBackOut(float p) {\n    return easeBackOut(p, 1.70158);\n}\nfloat easeBackOut(float t, float b, float c, float d, float amplitude) {\n    return b + easeBackOut(t / d, amplitude) * c;\n}\nfloat easeBackOut(float t, float b, float c, float d) {\n    return b + easeBackOut(t / d) * c;\n}\n",
                T = "float easeBezier(float p, vec4 curve) {\n    float ip = 1.0 - p;\n    return (3.0 * ip * ip * p * curve.xy + 3.0 * ip * p * p * curve.zw + p * p * p).y;\n}\nfloat easeBezier(float t, float b, float c, float d, vec4 curve) {\n    return b + easeBezier(t / d, curve) * c;\n}\n",
                E = "float easeBounceIn(float p) {\n    if ((p = 1.0 - p) < 1.0 / 2.75) {\n        return 1.0 - (7.5625 * p * p);\n    } else if (p < 2.0 / 2.75) {\n        return 1.0 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);\n    } else if (p < 2.5 / 2.75) {\n        return 1.0 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);\n    }\n    return 1.0 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);\n}\nfloat easeBounceIn(float t, float b, float c, float d) {\n    return b + easeBounceIn(t / d) * c;\n}\n",
                S = "float easeBounceInOut(float p) {\n    bool invert = (p < 0.5);\n    p = invert ? (1.0 - (p * 2.0)) : ((p * 2.0) - 1.0);\n    if (p < 1.0 / 2.75) {\n        p = 7.5625 * p * p;\n    } else if (p < 2.0 / 2.75) {\n        p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\n    } else if (p < 2.5 / 2.75) {\n        p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\n    } else {\n        p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\n    }\n    return invert ? (1.0 - p) * 0.5 : p * 0.5 + 0.5;\n}\nfloat easeBounceInOut(float t, float b, float c, float d) {\n    return b + easeBounceInOut(t / d) * c;\n}\n",
                P = "float easeBounceOut(float p) {\n    if (p < 1.0 / 2.75) {\n        return 7.5625 * p * p;\n    } else if (p < 2.0 / 2.75) {\n        return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\n    } else if (p < 2.5 / 2.75) {\n        return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\n    }\n    return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\n}\nfloat easeBounceOut(float t, float b, float c, float d) {\n    return b + easeBounceOut(t / d) * c;\n}\n",
                C = "float easeCircIn(float p) {\n    return -(sqrt(1.0 - p * p) - 1.0);\n}\nfloat easeCircIn(float t, float b, float c, float d) {\n    return b + easeCircIn(t / d) * c;\n}\n",
                A = "float easeCircInOut(float p) {\n    return ((p *= 2.0) < 1.0) ? -0.5 * (sqrt(1.0 - p * p) - 1.0) : 0.5 * (sqrt(1.0 - (p -= 2.0) * p) + 1.0);\n}\nfloat easeCircInOut(float t, float b, float c, float d) {\n    return b + easeCircInOut(t / d) * c;\n}\n",
                L = "float easeCircOut(float p) {\n  return sqrt(1.0 - (p = p - 1.0) * p);\n}\nfloat easeCircOut(float t, float b, float c, float d) {\n  return b + easeCircOut(t / d) * c;\n}\n",
                R = "float easeCubicIn(float t) {\n  return t * t * t;\n}\nfloat easeCubicIn(float t, float b, float c, float d) {\n  return b + easeCubicIn(t / d) * c;\n}\n",
                I = "float easeCubicInOut(float t) {\n  return (t /= 0.5) < 1.0 ? 0.5 * t * t * t : 0.5 * ((t-=2.0) * t * t + 2.0);\n}\nfloat easeCubicInOut(float t, float b, float c, float d) {\n  return b + easeCubicInOut(t / d) * c;\n}\n",
                O = "float easeCubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\nfloat easeCubicOut(float t, float b, float c, float d) {\n  return b + easeCubicOut(t / d) * c;\n}\n",
                k = "float easeElasticIn(float p, float amplitude, float period) {\n    float p1 = max(amplitude, 1.0);\n    float p2 = period / min(amplitude, 1.0);\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\n    return -(p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2));\n}\nfloat easeElasticIn(float p) {\n    return easeElasticIn(p, 1.0, 0.3);\n}\nfloat easeElasticIn(float t, float b, float c, float d, float amplitude, float period) {\n    return b + easeElasticIn(t / d, amplitude, period) * c;\n}\nfloat easeElasticIn(float t, float b, float c, float d) {\n    return b + easeElasticIn(t / d) * c;\n}\n",
                D = "float easeElasticInOut(float p, float amplitude, float period) {\n    float p1 = max(amplitude, 1.0);\n    float p2 = period / min(amplitude, 1.0);\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\n    return ((p *= 2.0) < 1.0) ? -0.5 * (p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2)) : p1 * pow(2.0, -10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2) * 0.5 + 1.0;\n}\nfloat easeElasticInOut(float p) {\n    return easeElasticInOut(p, 1.0, 0.3);\n}\nfloat easeElasticInOut(float t, float b, float c, float d, float amplitude, float period) {\n    return b + easeElasticInOut(t / d, amplitude, period) * c;\n}\nfloat easeElasticInOut(float t, float b, float c, float d) {\n    return b + easeElasticInOut(t / d) * c;\n}\n",
                z = "float easeElasticOut(float p, float amplitude, float period) {\n    float p1 = max(amplitude, 1.0);\n    float p2 = period / min(amplitude, 1.0);\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\n    return p1 * pow(2.0, -10.0 * p) * sin((p - p3) * PI2 / p2) + 1.0;\n}\nfloat easeElasticOut(float p) {\n    return easeElasticOut(p, 1.0, 0.3);\n}\nfloat easeElasticOut(float t, float b, float c, float d, float amplitude, float period) {\n    return b + easeElasticOut(t / d, amplitude, period) * c;\n}\nfloat easeElasticOut(float t, float b, float c, float d) {\n    return b + easeElasticOut(t / d) * c;\n}\n",
                B = "float easeExpoIn(float p) {\n    return pow(2.0, 10.0 * (p - 1.0));\n}\nfloat easeExpoIn(float t, float b, float c, float d) {\n    return b + easeExpoIn(t / d) * c;\n}\n",
                N = "float easeExpoInOut(float p) {\n    return ((p *= 2.0) < 1.0) ? 0.5 * pow(2.0, 10.0 * (p - 1.0)) : 0.5 * (2.0 - pow(2.0, -10.0 * (p - 1.0)));\n}\nfloat easeExpoInOut(float t, float b, float c, float d) {\n    return b + easeExpoInOut(t / d) * c;\n}\n",
                U = "float easeExpoOut(float p) {\n  return 1.0 - pow(2.0, -10.0 * p);\n}\nfloat easeExpoOut(float t, float b, float c, float d) {\n  return b + easeExpoOut(t / d) * c;\n}\n",
                j = "float easeQuadIn(float t) {\n    return t * t;\n}\nfloat easeQuadIn(float t, float b, float c, float d) {\n  return b + easeQuadIn(t / d) * c;\n}\n",
                F = "float easeQuadInOut(float t) {\n    float p = 2.0 * t * t;\n    return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\nfloat easeQuadInOut(float t, float b, float c, float d) {\n    return b + easeQuadInOut(t / d) * c;\n}\n",
                G = "float easeQuadOut(float t) {\n  return -t * (t - 2.0);\n}\nfloat easeQuadOut(float t, float b, float c, float d) {\n  return b + easeQuadOut(t / d) * c;\n}\n",
                H = "float easeQuartIn(float t) {\n  return t * t * t * t;\n}\nfloat easeQuartIn(float t, float b, float c, float d) {\n  return b + easeQuartIn(t / d) * c;\n}\n",
                V = "float easeQuartInOut(float t) {\n    return t < 0.5 ? 8.0 * pow(t, 4.0) : -8.0 * pow(t - 1.0, 4.0) + 1.0;\n}\nfloat easeQuartInOut(float t, float b, float c, float d) {\n    return b + easeQuartInOut(t / d) * c;\n}\n",
                W = "float easeQuartOut(float t) {\n  return 1.0 - pow(1.0 - t, 4.0);\n}\nfloat easeQuartOut(float t, float b, float c, float d) {\n  return b + easeQuartOut(t / d) * c;\n}\n",
                q = "float easeQuintIn(float t) {\n    return pow(t, 5.0);\n}\nfloat easeQuintIn(float t, float b, float c, float d) {\n    return b + easeQuintIn(t / d) * c;\n}\n",
                X = "float easeQuintInOut(float t) {\n    return (t /= 0.5) < 1.0 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2.0) * t * t * t * t + 2.0);\n}\nfloat easeQuintInOut(float t, float b, float c, float d) {\n    return b + easeQuintInOut(t / d) * c;\n}\n",
                Y = "float easeQuintOut(float t) {\n    return (t -= 1.0) * t * t * t * t + 1.0;\n}\nfloat easeQuintOut(float t, float b, float c, float d) {\n    return b + easeQuintOut(t / d) * c;\n}\n",
                Z = "float easeSineIn(float p) {\n  return -cos(p * 1.57079632679) + 1.0;\n}\nfloat easeSineIn(float t, float b, float c, float d) {\n  return b + easeSineIn(t / d) * c;\n}\n",
                J = "float easeSineInOut(float p) {\n  return -0.5 * (cos(PI * p) - 1.0);\n}\nfloat easeSineInOut(float t, float b, float c, float d) {\n  return b + easeSineInOut(t / d) * c;\n}\n",
                $ = "float easeSineOut(float p) {\n  return sin(p * 1.57079632679);\n}\nfloat easeSineOut(float t, float b, float c, float d) {\n  return b + easeSineOut(t / d) * c;\n}\n",
                Q = "vec3 quadraticBezier(vec3 p0, vec3 c0, vec3 p1, float t) {\n    float tn = 1.0 - t;\n    return tn * tn * p0 + 2.0 * tn * t * c0 + t * t * p1;\n}\nvec2 quadraticBezier(vec2 p0, vec2 c0, vec2 p1, float t) {\n    float tn = 1.0 - t;\n    return tn * tn * p0 + 2.0 * tn * t * c0 + t * t * p1;\n}",
                K = "vec3 rotateVector(vec4 q, vec3 v) {\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\nvec4 quatFromAxisAngle(vec3 axis, float angle) {\n    float halfAngle = angle * 0.5;\n    return vec4(axis.xyz * sin(halfAngle), cos(halfAngle));\n}\n",
                ee = "vec4 quatSlerp(vec4 q0, vec4 q1, float t) {\n    float s = 1.0 - t;\n    float c = dot(q0, q1);\n    float dir = -1.0;    float sqrSn = 1.0 - c * c;\n    if (sqrSn > 2.220446049250313e-16) {\n        float sn = sqrt(sqrSn);\n        float len = atan(sn, c * dir);\n        s = sin(s * len) / sn;\n        t = sin(t * len) / sn;\n    }\n    float tDir = t * dir;\n    return normalize(q0 * s + q1 * tDir);\n}\n",
                te = {
                    catmull_rom_spline: x,
                    cubic_bezier: b,
                    ease_back_in: _,
                    ease_back_in_out: w,
                    ease_back_out: M,
                    ease_bezier: T,
                    ease_bounce_in: E,
                    ease_bounce_in_out: S,
                    ease_bounce_out: P,
                    ease_circ_in: C,
                    ease_circ_in_out: A,
                    ease_circ_out: L,
                    ease_cubic_in: R,
                    ease_cubic_in_out: I,
                    ease_cubic_out: O,
                    ease_elastic_in: k,
                    ease_elastic_in_out: D,
                    ease_elastic_out: z,
                    ease_expo_in: B,
                    ease_expo_in_out: N,
                    ease_expo_out: U,
                    ease_quad_in: j,
                    ease_quad_in_out: F,
                    ease_quad_out: G,
                    ease_quart_in: H,
                    ease_quart_in_out: V,
                    ease_quart_out: W,
                    ease_quint_in: q,
                    ease_quint_in_out: X,
                    ease_quint_out: Y,
                    ease_sine_in: Z,
                    ease_sine_in_out: J,
                    ease_sine_out: $,
                    quadratic_bezier: Q,
                    quaternion_rotation: K,
                    quaternion_slerp: ee
                };
            v.prototype.compile = function () {
                return this.compiler(this)
            }, Object.defineProperty(v.prototype, "end", {
                get: function () {
                    return this.start + this.duration
                }
            }), g.segmentDefinitions = {}, g.register = function (e, t) {
                return g.segmentDefinitions[e] = t, t
            }, g.prototype.add = function (e, t, n) {
                var i = eval,
                    r = this.duration;
                void 0 !== n ? ("number" == typeof n ? r = n : "string" == typeof n && i("start" + n), this.duration = Math.max(this.duration, r + e)) : this.duration += e;
                for (var a = Object.keys(t), o = void 0, s = 0; s < a.length; s++) o = a[s], this.processTransition(o, t[o], r, e)
            }, g.prototype.processTransition = function (e, t, n, i) {
                var r = g.segmentDefinitions[e],
                    a = this.segments[e];
                a || (a = this.segments[e] = []), void 0 === t.from && (0 === a.length ? t.from = r.defaultFrom : t.from = a[a.length - 1].transition.to), a.push(new v((this.__key++).toString(), n, i, t, r.compiler))
            }, g.prototype.compile = function () {
                for (var e = [], t = Object.keys(this.segments), n = void 0, i = 0; i < t.length; i++) n = this.segments[t[i]], this.fillGaps(n), n.forEach(function (t) {
                    e.push(t.compile())
                });
                return e
            }, g.prototype.fillGaps = function (e) {
                if (0 !== e.length) {
                    for (var t = void 0, n = void 0, i = 0; i < e.length - 1; i++) t = e[i], n = e[i + 1], t.trail = n.start - t.end;
                    t = e[e.length - 1], t.trail = this.duration - t.end
                }
            }, g.prototype.getTransformCalls = function (e) {
                var t = this.timeKey;
                return this.segments[e] ? this.segments[e].map(function (e) {
                    return "applyTransform" + e.key + "(" + t + ", transformed);"
                }).join("\n") : ""
            };
            var ne = {
                    vec3: function (e, t, n) {
                        var i = (t.x || 0).toPrecision(n),
                            r = (t.y || 0).toPrecision(n),
                            a = (t.z || 0).toPrecision(n);
                        return "vec3 " + e + " = vec3(" + i + ", " + r + ", " + a + ");"
                    },
                    vec4: function (e, t, n) {
                        var i = (t.x || 0).toPrecision(n),
                            r = (t.y || 0).toPrecision(n),
                            a = (t.z || 0).toPrecision(n),
                            o = (t.w || 0).toPrecision(n);
                        return "vec4 " + e + " = vec4(" + i + ", " + r + ", " + a + ", " + o + ");"
                    },
                    delayDuration: function (e) {
                        return "\n    float cDelay" + e.key + " = " + e.start.toPrecision(4) + ";\n    float cDuration" + e.key + " = " + e.duration.toPrecision(4) + ";\n    "
                    },
                    progress: function (e) {
                        return 0 === e.duration ? "float progress = 1.0;" : "\n      float progress = clamp(time - cDelay" + e.key + ", 0.0, cDuration" + e.key + ") / cDuration" + e.key + ";\n      " + (e.transition.ease ? "progress = " + e.transition.ease + "(progress" + (e.transition.easeParams ? ", " + e.transition.easeParams.map(function (e) {
                            return e.toPrecision(4)
                        }).join(", ") : "") + ");" : "") + "\n      "
                    },
                    renderCheck: function (e) {
                        var t = e.start.toPrecision(4),
                            n = (e.end + e.trail).toPrecision(4);
                        return "if (time < " + t + " || time > " + n + ") return;"
                    }
                },
                ie = {
                    compiler: function (e) {
                        return "\n    " + ne.delayDuration(e) + "\n    " + ne.vec3("cTranslateFrom" + e.key, e.transition.from, 2) + "\n    " + ne.vec3("cTranslateTo" + e.key, e.transition.to, 2) + "\n    \n    void applyTransform" + e.key + "(float time, inout vec3 v) {\n    \n      " + ne.renderCheck(e) + "\n      " + ne.progress(e) + "\n    \n      v += mix(cTranslateFrom" + e.key + ", cTranslateTo" + e.key + ", progress);\n    }\n    "
                    },
                    defaultFrom: new t.Vector3(0, 0, 0)
                };
            g.register("translate", ie);
            var re = {
                compiler: function (e) {
                    var t = e.transition.origin;
                    return "\n    " + ne.delayDuration(e) + "\n    " + ne.vec3("cScaleFrom" + e.key, e.transition.from, 2) + "\n    " + ne.vec3("cScaleTo" + e.key, e.transition.to, 2) + "\n    " + (t ? ne.vec3("cOrigin" + e.key, t, 2) : "") + "\n    \n    void applyTransform" + e.key + "(float time, inout vec3 v) {\n    \n      " + ne.renderCheck(e) + "\n      " + ne.progress(e) + "\n    \n      " + (t ? "v -= cOrigin" + e.key + ";" : "") + "\n      v *= mix(cScaleFrom" + e.key + ", cScaleTo" + e.key + ", progress);\n      " + (t ? "v += cOrigin" + e.key + ";" : "") + "\n    }\n    "
                },
                defaultFrom: new t.Vector3(1, 1, 1)
            };
            g.register("scale", re);
            var ae = {
                compiler: function (e) {
                    var n = new t.Vector4(e.transition.from.axis.x, e.transition.from.axis.y, e.transition.from.axis.z, e.transition.from.angle),
                        i = e.transition.to.axis || e.transition.from.axis,
                        r = new t.Vector4(i.x, i.y, i.z, e.transition.to.angle),
                        a = e.transition.origin;
                    return "\n    " + ne.delayDuration(e) + "\n    " + ne.vec4("cRotationFrom" + e.key, n, 8) + "\n    " + ne.vec4("cRotationTo" + e.key, r, 8) + "\n    " + (a ? ne.vec3("cOrigin" + e.key, a, 2) : "") + "\n    \n    void applyTransform" + e.key + "(float time, inout vec3 v) {\n      " + ne.renderCheck(e) + "\n      " + ne.progress(e) + "\n\n      " + (a ? "v -= cOrigin" + e.key + ";" : "") + "\n      vec3 axis = normalize(mix(cRotationFrom" + e.key + ".xyz, cRotationTo" + e.key + ".xyz, progress));\n      float angle = mix(cRotationFrom" + e.key + ".w, cRotationTo" + e.key + ".w, progress);\n      vec4 q = quatFromAxisAngle(axis, angle);\n      v = rotateVector(q, v);\n      " + (a ? "v += cOrigin" + e.key + ";" : "") + "\n    }\n    "
                },
                defaultFrom: {
                    axis: new t.Vector3,
                    angle: 0
                }
            };
            g.register("rotate", ae), e.BasicAnimationMaterial = i, e.LambertAnimationMaterial = r, e.PhongAnimationMaterial = a, e.StandardAnimationMaterial = o, e.ToonAnimationMaterial = s, e.PointsAnimationMaterial = l, e.DepthAnimationMaterial = c, e.DistanceAnimationMaterial = u, e.PrefabBufferGeometry = h, e.MultiPrefabBufferGeometry = d, e.InstancedPrefabBufferGeometry = p, e.ModelBufferGeometry = f, e.PointBufferGeometry = m, e.ShaderChunk = te, e.Timeline = g, e.TimelineSegment = v, e.TimelineChunks = ne, e.TranslationSegment = ie, e.ScaleSegment = re, e.RotationSegment = ae, e.Utils = y, Object.defineProperty(e, "__esModule", {
                value: !0
            })
        })
    }, {
        three: 48
    }],
    48: [function (e, t, n) {
        ! function (e, i) {
            "object" == typeof n && "undefined" != typeof t ? i(n) : "function" == typeof define && define.amd ? define(["exports"], i) : i(e.THREE = {})
        }(this, function (e) {
            "use strict";

            function t() {}

            function n(e, t) {
                this.x = e || 0, this.y = t || 0
            }

            function i() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }

            function r(e, t, n, i) {
                this._x = e || 0, this._y = t || 0, this._z = n || 0, this._w = void 0 !== i ? i : 1
            }

            function a(e, t, n) {
                this.x = e || 0, this.y = t || 0, this.z = n || 0
            }

            function o() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }

            function s(e, t, i, r, a, l, c, u, h, d) {
                Object.defineProperty(this, "id", {
                    value: Gl++
                }), this.uuid = jl.generateUUID(), this.name = "", this.image = void 0 !== e ? e : s.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : s.DEFAULT_MAPPING, this.wrapS = void 0 !== i ? i : ys, this.wrapT = void 0 !== r ? r : ys, this.magFilter = void 0 !== a ? a : Ms, this.minFilter = void 0 !== l ? l : Es, this.anisotropy = void 0 !== h ? h : 1, this.format = void 0 !== c ? c : js, this.type = void 0 !== u ? u : Ss, this.offset = new n(0, 0), this.repeat = new n(1, 1), this.center = new n(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new o, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== d ? d : Cl, this.version = 0, this.onUpdate = null
            }

            function l(e, t, n, i) {
                this.x = e || 0, this.y = t || 0, this.z = n || 0, this.w = void 0 !== i ? i : 1
            }

            function c(e, t, n) {
                this.width = e, this.height = t, this.scissor = new l(0, 0, e, t), this.scissorTest = !1, this.viewport = new l(0, 0, e, t), n = n || {}, void 0 === n.minFilter && (n.minFilter = Ms), this.texture = new s((void 0), (void 0), n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.generateMipmaps = void 0 === n.generateMipmaps || n.generateMipmaps, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
            }

            function u(e, t, n) {
                c.call(this, e, t, n),
                    this.activeCubeFace = 0, this.activeMipMapLevel = 0
            }

            function h(e, t, n, i, r, a, o, l, c, u, h, d) {
                s.call(this, null, a, o, l, c, u, i, r, h, d), this.image = {
                    data: e,
                    width: t,
                    height: n
                }, this.magFilter = void 0 !== c ? c : bs, this.minFilter = void 0 !== u ? u : bs, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }

            function d(e, t) {
                this.min = void 0 !== e ? e : new a((+(1 / 0)), (+(1 / 0)), (+(1 / 0))), this.max = void 0 !== t ? t : new a((-(1 / 0)), (-(1 / 0)), (-(1 / 0)))
            }

            function p(e, t) {
                this.center = void 0 !== e ? e : new a, this.radius = void 0 !== t ? t : 0
            }

            function f(e, t) {
                this.normal = void 0 !== e ? e : new a(1, 0, 0), this.constant = void 0 !== t ? t : 0
            }

            function m(e, t, n, i, r, a) {
                this.planes = [void 0 !== e ? e : new f, void 0 !== t ? t : new f, void 0 !== n ? n : new f, void 0 !== i ? i : new f, void 0 !== r ? r : new f, void 0 !== a ? a : new f]
            }

            function v(e, t, n) {
                return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
            }

            function g() {
                function e(r, a) {
                    n !== !1 && (i(r, a), t.requestAnimationFrame(e))
                }
                var t = null,
                    n = !1,
                    i = null;
                return {
                    start: function () {
                        n !== !0 && null !== i && (t.requestAnimationFrame(e), n = !0)
                    },
                    stop: function () {
                        n = !1
                    },
                    setAnimationLoop: function (e) {
                        i = e
                    },
                    setContext: function (e) {
                        t = e
                    }
                }
            }

            function y(e) {
                function t(t, n) {
                    var i = t.array,
                        r = t.dynamic ? 35048 : 35044,
                        a = e.createBuffer();
                    e.bindBuffer(n, a), e.bufferData(n, i, r), t.onUploadCallback();
                    var o = 5126;
                    return i instanceof Float32Array ? o = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? o = 5123 : i instanceof Int16Array ? o = 5122 : i instanceof Uint32Array ? o = 5125 : i instanceof Int32Array ? o = 5124 : i instanceof Int8Array ? o = 5120 : i instanceof Uint8Array && (o = 5121), {
                        buffer: a,
                        type: o,
                        bytesPerElement: i.BYTES_PER_ELEMENT,
                        version: t.version
                    }
                }

                function n(t, n, i) {
                    var r = n.array,
                        a = n.updateRange;
                    e.bindBuffer(i, t), n.dynamic === !1 ? e.bufferData(i, r, 35044) : a.count === -1 ? e.bufferSubData(i, 0, r) : 0 === a.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (e.bufferSubData(i, a.offset * r.BYTES_PER_ELEMENT, r.subarray(a.offset, a.offset + a.count)), a.count = -1)
                }

                function i(e) {
                    return e.isInterleavedBufferAttribute && (e = e.data), o.get(e)
                }

                function r(t) {
                    t.isInterleavedBufferAttribute && (t = t.data);
                    var n = o.get(t);
                    n && (e.deleteBuffer(n.buffer), o["delete"](t))
                }

                function a(e, i) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    var r = o.get(e);
                    void 0 === r ? o.set(e, t(e, i)) : r.version < e.version && (n(r.buffer, e, i), r.version = e.version)
                }
                var o = new WeakMap;
                return {
                    get: i,
                    remove: r,
                    update: a
                }
            }

            function x(e, t, n, i, r, o) {
                this.a = e, this.b = t, this.c = n, this.normal = i && i.isVector3 ? i : new a, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new v, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== o ? o : 0
            }

            function b(e, t, n, i) {
                this._x = e || 0, this._y = t || 0, this._z = n || 0, this._order = i || b.DefaultOrder
            }

            function _() {
                this.mask = 1
            }

            function w() {
                function e() {
                    l.setFromEuler(s, !1)
                }

                function t() {
                    s.setFromQuaternion(l, void 0, !1)
                }
                Object.defineProperty(this, "id", {
                    value: ah++
                }), this.uuid = jl.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = w.DefaultUp.clone();
                var n = new a,
                    s = new b,
                    l = new r,
                    c = new a(1, 1, 1);
                s.onChange(e), l.onChange(t), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: s
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: l
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: c
                    },
                    modelViewMatrix: {
                        value: new i
                    },
                    normalMatrix: {
                        value: new o
                    }
                }), this.matrix = new i, this.matrixWorld = new i, this.matrixAutoUpdate = w.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new _, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
            }

            function M() {
                Object.defineProperty(this, "id", {
                    value: oh += 2
                }), this.uuid = jl.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function T(e, t, n) {
                if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = n === !0, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function E(e, t, n) {
                T.call(this, new Int8Array(e), t, n)
            }

            function S(e, t, n) {
                T.call(this, new Uint8Array(e), t, n)
            }

            function P(e, t, n) {
                T.call(this, new Uint8ClampedArray(e), t, n)
            }

            function C(e, t, n) {
                T.call(this, new Int16Array(e), t, n)
            }

            function A(e, t, n) {
                T.call(this, new Uint16Array(e), t, n)
            }

            function L(e, t, n) {
                T.call(this, new Int32Array(e), t, n)
            }

            function R(e, t, n) {
                T.call(this, new Uint32Array(e), t, n)
            }

            function I(e, t, n) {
                T.call(this, new Float32Array(e), t, n)
            }

            function O(e, t, n) {
                T.call(this, new Float64Array(e), t, n)
            }

            function k() {
                this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function D(e) {
                if (0 === e.length) return -(1 / 0);
                for (var t = e[0], n = 1, i = e.length; n < i; ++n) e[n] > t && (t = e[n]);
                return t
            }

            function z() {
                Object.defineProperty(this, "id", {
                    value: sh += 2
                }), this.uuid = jl.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }

            function B(e, t, n, i, r, a) {
                M.call(this), this.type = "BoxGeometry", this.parameters = {
                    width: e,
                    height: t,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: a
                }, this.fromBufferGeometry(new N(e, t, n, i, r, a)), this.mergeVertices()
            }

            function N(e, t, n, i, r, o) {
                function s(e, t, n, i, r, o, s, m, v, g, y) {
                    var x, b, _ = o / v,
                        w = s / g,
                        M = o / 2,
                        T = s / 2,
                        E = m / 2,
                        S = v + 1,
                        P = g + 1,
                        C = 0,
                        A = 0,
                        L = new a;
                    for (b = 0; b < P; b++) {
                        var R = b * w - T;
                        for (x = 0; x < S; x++) {
                            var I = x * _ - M;
                            L[e] = I * i, L[t] = R * r, L[n] = E, u.push(L.x, L.y, L.z), L[e] = 0, L[t] = 0, L[n] = m > 0 ? 1 : -1, h.push(L.x, L.y, L.z), d.push(x / v), d.push(1 - b / g), C += 1
                        }
                    }
                    for (b = 0; b < g; b++)
                        for (x = 0; x < v; x++) {
                            var O = p + x + S * b,
                                k = p + x + S * (b + 1),
                                D = p + (x + 1) + S * (b + 1),
                                z = p + (x + 1) + S * b;
                            c.push(O, k, z), c.push(k, D, z), A += 6
                        }
                    l.addGroup(f, A, y), f += A, p += C
                }
                z.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                    width: e,
                    height: t,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: o
                };
                var l = this;
                e = e || 1, t = t || 1, n = n || 1, i = Math.floor(i) || 1, r = Math.floor(r) || 1, o = Math.floor(o) || 1;
                var c = [],
                    u = [],
                    h = [],
                    d = [],
                    p = 0,
                    f = 0;
                s("z", "y", "x", -1, -1, n, t, e, o, r, 0), s("z", "y", "x", 1, -1, n, t, -e, o, r, 1), s("x", "z", "y", 1, 1, e, n, t, i, o, 2), s("x", "z", "y", 1, -1, e, n, -t, i, o, 3), s("x", "y", "z", 1, -1, e, t, n, i, r, 4), s("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(c), this.addAttribute("position", new I(u, 3)), this.addAttribute("normal", new I(h, 3)), this.addAttribute("uv", new I(d, 2))
            }

            function U(e, t, n, i) {
                M.call(this), this.type = "PlaneGeometry", this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: n,
                    heightSegments: i
                }, this.fromBufferGeometry(new j(e, t, n, i)), this.mergeVertices()
            }

            function j(e, t, n, i) {
                z.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: n,
                    heightSegments: i
                }, e = e || 1, t = t || 1;
                var r, a, o = e / 2,
                    s = t / 2,
                    l = Math.floor(n) || 1,
                    c = Math.floor(i) || 1,
                    u = l + 1,
                    h = c + 1,
                    d = e / l,
                    p = t / c,
                    f = [],
                    m = [],
                    v = [],
                    g = [];
                for (a = 0; a < h; a++) {
                    var y = a * p - s;
                    for (r = 0; r < u; r++) {
                        var x = r * d - o;
                        m.push(x, -y, 0), v.push(0, 0, 1), g.push(r / l), g.push(1 - a / c)
                    }
                }
                for (a = 0; a < c; a++)
                    for (r = 0; r < l; r++) {
                        var b = r + u * a,
                            _ = r + u * (a + 1),
                            w = r + 1 + u * (a + 1),
                            M = r + 1 + u * a;
                        f.push(b, _, M), f.push(_, w, M)
                    }
                this.setIndex(f), this.addAttribute("position", new I(m, 3)), this.addAttribute("normal", new I(v, 3)), this.addAttribute("uv", new I(g, 2))
            }

            function F() {
                Object.defineProperty(this, "id", {
                    value: lh++
                }), this.uuid = jl.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = So, this.side = go, this.flatShading = !1, this.vertexColors = wo, this.opacity = 1, this.transparent = !1, this.blendSrc = jo, this.blendDst = Fo, this.blendEquation = Ro, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = Jo, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0
            }

            function G(e) {
                F.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
            }

            function H(e, t) {
                this.origin = void 0 !== e ? e : new a, this.direction = void 0 !== t ? t : new a
            }

            function V(e, t, n) {
                this.a = void 0 !== e ? e : new a, this.b = void 0 !== t ? t : new a, this.c = void 0 !== n ? n : new a
            }

            function W(e) {
                F.call(this), this.type = "MeshBasicMaterial", this.color = new v(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ts, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(e)
            }

            function q(e, t) {
                w.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new z, this.material = void 0 !== t ? t : new W({
                    color: 16777215 * Math.random()
                }), this.drawMode = El, this.updateMorphTargets()
            }

            function X(e, t, n, i) {
                function r(t, i, r, u) {
                    var h = i.background;
                    null === h ? a(l, c) : h && h.isColor && (a(h, 1), u = !0), (e.autoClear || u) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), h && (h.isCubeTexture || h.isWebGLRenderTargetCube) ? (void 0 === s && (s = new q(new N(1, 1, 1), new G({
                        type: "BackgroundCubeMaterial",
                        uniforms: th.clone(rh.cube.uniforms),
                        vertexShader: rh.cube.vertexShader,
                        fragmentShader: rh.cube.fragmentShader,
                        side: yo,
                        depthTest: !0,
                        depthWrite: !1,
                        fog: !1
                    })), s.geometry.removeAttribute("normal"), s.geometry.removeAttribute("uv"), s.onBeforeRender = function (e, t, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }, n.update(s)), s.material.uniforms.tCube.value = h.isWebGLRenderTargetCube ? h.texture : h, s.material.uniforms.tFlip.value = h.isWebGLRenderTargetCube ? 1 : -1, t.push(s, s.geometry, s.material, 0, null)) : h && h.isTexture && (void 0 === o && (o = new q(new j(2, 2), new G({
                        type: "BackgroundMaterial",
                        uniforms: th.clone(rh.background.uniforms),
                        vertexShader: rh.background.vertexShader,
                        fragmentShader: rh.background.fragmentShader,
                        side: go,
                        depthTest: !0,
                        depthWrite: !1,
                        fog: !1
                    })), o.geometry.removeAttribute("normal"), n.update(o)), o.material.uniforms.t2D.value = h, h.matrixAutoUpdate === !0 && h.updateMatrix(), o.material.uniforms.uvTransform.value.copy(h.matrix), t.push(o, o.geometry, o.material, 0, null))
                }

                function a(e, n) {
                    t.buffers.color.setClear(e.r, e.g, e.b, n, i)
                }
                var o, s, l = new v(0),
                    c = 0;
                return {
                    getClearColor: function () {
                        return l
                    },
                    setClearColor: function (e, t) {
                        l.set(e), c = void 0 !== t ? t : 1, a(l, c)
                    },
                    getClearAlpha: function () {
                        return c
                    },
                    setClearAlpha: function (e) {
                        c = e, a(l, c)
                    },
                    render: r
                }
            }

            function Y(e, t, n, i) {
                function r(e) {
                    s = e
                }

                function a(t, i) {
                    e.drawArrays(s, t, i), n.update(i, s)
                }

                function o(r, a, o) {
                    var l;
                    if (i.isWebGL2) l = e;
                    else if (l = t.get("ANGLE_instanced_arrays"), null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    l[i.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](s, a, o, r.maxInstancedCount), n.update(o, s, r.maxInstancedCount)
                }
                var s;
                this.setMode = r, this.render = a, this.renderInstances = o
            }

            function Z(e, t, n) {
                function i() {
                    if (void 0 !== a) return a;
                    var n = t.get("EXT_texture_filter_anisotropic");
                    return a = null !== n ? e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                }

                function r(t) {
                    if ("highp" === t) {
                        if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                        t = "mediump"
                    }
                    return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                }
                var a, o = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext,
                    s = void 0 !== n.precision ? n.precision : "highp",
                    l = r(s);
                l !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", l, "instead."), s = l);
                var c = n.logarithmicDepthBuffer === !0,
                    u = e.getParameter(34930),
                    h = e.getParameter(35660),
                    d = e.getParameter(3379),
                    p = e.getParameter(34076),
                    f = e.getParameter(34921),
                    m = e.getParameter(36347),
                    v = e.getParameter(36348),
                    g = e.getParameter(36349),
                    y = h > 0,
                    x = o || !!t.get("OES_texture_float"),
                    b = y && x;
                return {
                    isWebGL2: o,
                    getMaxAnisotropy: i,
                    getMaxPrecision: r,
                    precision: s,
                    logarithmicDepthBuffer: c,
                    maxTextures: u,
                    maxVertexTextures: h,
                    maxTextureSize: d,
                    maxCubemapSize: p,
                    maxAttributes: f,
                    maxVertexUniforms: m,
                    maxVaryings: v,
                    maxFragmentUniforms: g,
                    vertexTextures: y,
                    floatFragmentTextures: x,
                    floatVertexTextures: b
                }
            }

            function J() {
                function e() {
                    u.value !== i && (u.value = i, u.needsUpdate = r > 0), n.numPlanes = r, n.numIntersection = 0
                }

                function t(e, t, i, r) {
                    var a = null !== e ? e.length : 0,
                        o = null;
                    if (0 !== a) {
                        if (o = u.value, r !== !0 || null === o) {
                            var s = i + 4 * a,
                                h = t.matrixWorldInverse;
                            c.getNormalMatrix(h), (null === o || o.length < s) && (o = new Float32Array(s));
                            for (var d = 0, p = i; d !== a; ++d, p += 4) l.copy(e[d]).applyMatrix4(h, c), l.normal.toArray(o, p), o[p + 3] = l.constant
                        }
                        u.value = o, u.needsUpdate = !0
                    }
                    return n.numPlanes = a, o
                }
                var n = this,
                    i = null,
                    r = 0,
                    a = !1,
                    s = !1,
                    l = new f,
                    c = new o,
                    u = {
                        value: null,
                        needsUpdate: !1
                    };
                this.uniform = u, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, n, o) {
                    var s = 0 !== e.length || n || 0 !== r || a;
                    return a = n, i = t(e, o, 0), r = e.length, s
                }, this.beginShadows = function () {
                    s = !0, t(null)
                }, this.endShadows = function () {
                    s = !1, e()
                }, this.setState = function (n, o, l, c, h, d) {
                    if (!a || null === n || 0 === n.length || s && !l) s ? t(null) : e();
                    else {
                        var p = s ? 0 : r,
                            f = 4 * p,
                            m = h.clippingState || null;
                        u.value = m, m = t(n, c, f, d);
                        for (var v = 0; v !== f; ++v) m[v] = i[v];
                        h.clippingState = m, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += p
                    }
                }
            }

            function $(e) {
                var t = {};
                return {
                    get: function (n) {
                        if (void 0 !== t[n]) return t[n];
                        var i;
                        switch (n) {
                            case "WEBGL_depth_texture":
                                i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            default:
                                i = e.getExtension(n)
                        }
                        return null === i && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), t[n] = i, i
                    }
                }
            }

            function Q(e, t, n) {
                function i(e) {
                    var r = e.target,
                        a = s[r.id];
                    null !== a.index && t.remove(a.index);
                    for (var o in a.attributes) t.remove(a.attributes[o]);
                    r.removeEventListener("dispose", i), delete s[r.id];
                    var c = l[a.id];
                    c && (t.remove(c), delete l[a.id]), n.memory.geometries--
                }

                function r(e, t) {
                    var r = s[t.id];
                    return r ? r : (t.addEventListener("dispose", i), t.isBufferGeometry ? r = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new z).setFromObject(e)), r = t._bufferGeometry), s[t.id] = r, n.memory.geometries++, r)
                }

                function a(e) {
                    var n = e.index,
                        i = e.attributes;
                    null !== n && t.update(n, 34963);
                    for (var r in i) t.update(i[r], 34962);
                    var a = e.morphAttributes;
                    for (var r in a)
                        for (var o = a[r], s = 0, l = o.length; s < l; s++) t.update(o[s], 34962)
                }

                function o(e) {
                    var n = l[e.id];
                    if (n) return n;
                    var i = [],
                        r = e.index,
                        a = e.attributes;
                    if (null !== r)
                        for (var o = r.array, s = 0, c = o.length; s < c; s += 3) {
                            var u = o[s + 0],
                                h = o[s + 1],
                                d = o[s + 2];
                            i.push(u, h, h, d, d, u)
                        } else
                            for (var o = a.position.array, s = 0, c = o.length / 3 - 1; s < c; s += 3) {
                                var u = s + 0,
                                    h = s + 1,
                                    d = s + 2;
                                i.push(u, h, h, d, d, u)
                            }
                    return n = new(D(i) > 65535 ? R : A)(i, 1), t.update(n, 34963), l[e.id] = n, n
                }
                var s = {},
                    l = {};
                return {
                    get: r,
                    update: a,
                    getWireframeAttribute: o
                }
            }

            function K(e, t, n, i) {
                function r(e) {
                    l = e
                }

                function a(e) {
                    c = e.type, u = e.bytesPerElement
                }

                function o(t, i) {
                    e.drawElements(l, i, c, t * u), n.update(i, l)
                }

                function s(r, a, o) {
                    var s;
                    if (i.isWebGL2) s = e;
                    else {
                        var s = t.get("ANGLE_instanced_arrays");
                        if (null === s) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.")
                    }
                    s[i.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](l, o, c, a * u, r.maxInstancedCount), n.update(o, l, r.maxInstancedCount)
                }
                var l, c, u;
                this.setMode = r, this.setIndex = a, this.render = o, this.renderInstances = s
            }

            function ee(e) {
                function t(e, t, n) {
                    switch (n = n || 1, r.calls++, t) {
                        case 4:
                            r.triangles += n * (e / 3);
                            break;
                        case 5:
                        case 6:
                            r.triangles += n * (e - 2);
                            break;
                        case 1:
                            r.lines += n * (e / 2);
                            break;
                        case 3:
                            r.lines += n * (e - 1);
                            break;
                        case 2:
                            r.lines += n * e;
                            break;
                        case 0:
                            r.points += n * e;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", t)
                    }
                }

                function n() {
                    r.frame++, r.calls = 0, r.triangles = 0, r.points = 0, r.lines = 0
                }
                var i = {
                        geometries: 0,
                        textures: 0
                    },
                    r = {
                        frame: 0,
                        calls: 0,
                        triangles: 0,
                        points: 0,
                        lines: 0
                    };
                return {
                    memory: i,
                    render: r,
                    programs: null,
                    autoReset: !0,
                    reset: n,
                    update: t
                }
            }

            function te(e, t) {
                return Math.abs(t[1]) - Math.abs(e[1])
            }

            function ne(e) {
                function t(t, r, a, o) {
                    var s = t.morphTargetInfluences,
                        l = s.length,
                        c = n[r.id];
                    if (void 0 === c) {
                        c = [];
                        for (var u = 0; u < l; u++) c[u] = [u, 0];
                        n[r.id] = c
                    }
                    for (var h = a.morphTargets && r.morphAttributes.position, d = a.morphNormals && r.morphAttributes.normal, u = 0; u < l; u++) {
                        var p = c[u];
                        0 !== p[1] && (h && r.removeAttribute("morphTarget" + u), d && r.removeAttribute("morphNormal" + u))
                    }
                    for (var u = 0; u < l; u++) {
                        var p = c[u];
                        p[0] = u, p[1] = s[u]
                    }
                    c.sort(te);
                    for (var u = 0; u < 8; u++) {
                        var p = c[u];
                        if (p) {
                            var f = p[0],
                                m = p[1];
                            if (m) {
                                h && r.addAttribute("morphTarget" + u, h[f]), d && r.addAttribute("morphNormal" + u, d[f]), i[u] = m;
                                continue
                            }
                        }
                        i[u] = 0
                    }
                    o.getUniforms().setValue(e, "morphTargetInfluences", i)
                }
                var n = {},
                    i = new Float32Array(8);
                return {
                    update: t
                }
            }

            function ie(e, t) {
                function n(n) {
                    var i = t.render.frame,
                        a = n.geometry,
                        o = e.get(n, a);
                    return r[o.id] !== i && (a.isGeometry && o.updateFromObject(n), e.update(o), r[o.id] = i), o
                }

                function i() {
                    r = {}
                }
                var r = {};
                return {
                    update: n,
                    dispose: i
                }
            }

            function re(e, t, n, i, r, a, o, l, c, u) {
                e = void 0 !== e ? e : [], t = void 0 !== t ? t : us, s.call(this, e, t, n, i, r, a, o, l, c, u), this.flipY = !1
            }

            function ae(e, t, n, i) {
                s.call(this, null), this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: i
                }, this.magFilter = bs, this.minFilter = bs, this.generateMipmaps = !1, this.flipY = !1
            }

            function oe() {
                this.seq = [], this.map = {}
            }

            function se(e, t, n) {
                var i = e[0];
                if (i <= 0 || i > 0) return e;
                var r = t * n,
                    a = dh[r];
                if (void 0 === a && (a = new Float32Array(r), dh[r] = a), 0 !== t) {
                    i.toArray(a, 0);
                    for (var o = 1, s = 0; o !== t; ++o) s += n, e[o].toArray(a, s)
                }
                return a
            }

            function le(e, t) {
                if (e.length !== t.length) return !1;
                for (var n = 0, i = e.length; n < i; n++)
                    if (e[n] !== t[n]) return !1;
                return !0
            }

            function ce(e, t) {
                for (var n = 0, i = t.length; n < i; n++) e[n] = t[n]
            }

            function ue(e, t) {
                var n = ph[t];
                void 0 === n && (n = new Int32Array(t), ph[t] = n);
                for (var i = 0; i !== t; ++i) n[i] = e.allocTextureUnit();
                return n
            }

            function he(e, t) {
                var n = this.cache;
                n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
            }

            function de(e, t) {
                var n = this.cache;
                n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
            }

            function pe(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
                else {
                    if (le(n, t)) return;
                    e.uniform2fv(this.addr, t), ce(n, t)
                }
            }

            function fe(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
                else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
                else {
                    if (le(n, t)) return;
                    e.uniform3fv(this.addr, t), ce(n, t)
                }
            }

            function me(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
                else {
                    if (le(n, t)) return;
                    e.uniform4fv(this.addr, t), ce(n, t)
                }
            }

            function ve(e, t) {
                var n = this.cache,
                    i = t.elements;
                if (void 0 === i) {
                    if (le(n, t)) return;
                    e.uniformMatrix2fv(this.addr, !1, t), ce(n, t)
                } else {
                    if (le(n, i)) return;
                    vh.set(i), e.uniformMatrix2fv(this.addr, !1, vh), ce(n, i)
                }
            }

            function ge(e, t) {
                var n = this.cache,
                    i = t.elements;
                if (void 0 === i) {
                    if (le(n, t)) return;
                    e.uniformMatrix3fv(this.addr, !1, t), ce(n, t)
                } else {
                    if (le(n, i)) return;
                    mh.set(i), e.uniformMatrix3fv(this.addr, !1, mh), ce(n, i)
                }
            }

            function ye(e, t) {
                var n = this.cache,
                    i = t.elements;
                if (void 0 === i) {
                    if (le(n, t)) return;
                    e.uniformMatrix4fv(this.addr, !1, t), ce(n, t)
                } else {
                    if (le(n, i)) return;
                    fh.set(i), e.uniformMatrix4fv(this.addr, !1, fh), ce(n, i)
                }
            }

            function xe(e, t, n) {
                var i = this.cache,
                    r = n.allocTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture2D(t || ch, r)
            }

            function be(e, t, n) {
                var i = this.cache,
                    r = n.allocTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(t || uh, r)
            }

            function _e(e, t, n) {
                var i = this.cache,
                    r = n.allocTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(t || hh, r)
            }

            function we(e, t) {
                var n = this.cache;
                le(n, t) || (e.uniform2iv(this.addr, t), ce(n, t))
            }

            function Me(e, t) {
                var n = this.cache;
                le(n, t) || (e.uniform3iv(this.addr, t), ce(n, t))
            }

            function Te(e, t) {
                var n = this.cache;
                le(n, t) || (e.uniform4iv(this.addr, t), ce(n, t))
            }

            function Ee(e) {
                switch (e) {
                    case 5126:
                        return he;
                    case 35664:
                        return pe;
                    case 35665:
                        return fe;
                    case 35666:
                        return me;
                    case 35674:
                        return ve;
                    case 35675:
                        return ge;
                    case 35676:
                        return ye;
                    case 35678:
                    case 36198:
                        return xe;
                    case 35679:
                        return be;
                    case 35680:
                        return _e;
                    case 5124:
                    case 35670:
                        return de;
                    case 35667:
                    case 35671:
                        return we;
                    case 35668:
                    case 35672:
                        return Me;
                    case 35669:
                    case 35673:
                        return Te
                }
            }

            function Se(e, t) {
                var n = this.cache;
                le(n, t) || (e.uniform1fv(this.addr, t), ce(n, t))
            }

            function Pe(e, t) {
                var n = this.cache;
                le(n, t) || (e.uniform1iv(this.addr, t), ce(n, t))
            }

            function Ce(e, t) {
                var n = this.cache,
                    i = se(t, this.size, 2);
                le(n, i) || (e.uniform2fv(this.addr, i), this.updateCache(i))
            }

            function Ae(e, t) {
                var n = this.cache,
                    i = se(t, this.size, 3);
                le(n, i) || (e.uniform3fv(this.addr, i), this.updateCache(i))
            }

            function Le(e, t) {
                var n = this.cache,
                    i = se(t, this.size, 4);
                le(n, i) || (e.uniform4fv(this.addr, i), this.updateCache(i))
            }

            function Re(e, t) {
                var n = this.cache,
                    i = se(t, this.size, 4);
                le(n, i) || (e.uniformMatrix2fv(this.addr, !1, i), this.updateCache(i))
            }

            function Ie(e, t) {
                var n = this.cache,
                    i = se(t, this.size, 9);
                le(n, i) || (e.uniformMatrix3fv(this.addr, !1, i), this.updateCache(i))
            }

            function Oe(e, t) {
                var n = this.cache,
                    i = se(t, this.size, 16);
                le(n, i) || (e.uniformMatrix4fv(this.addr, !1, i), this.updateCache(i))
            }

            function ke(e, t, n) {
                var i = this.cache,
                    r = t.length,
                    a = ue(n, r);
                le(i, a) === !1 && (e.uniform1iv(this.addr, a), ce(i, a));
                for (var o = 0; o !== r; ++o) n.setTexture2D(t[o] || ch, a[o])
            }

            function De(e, t, n) {
                var i = this.cache,
                    r = t.length,
                    a = ue(n, r);
                le(i, a) === !1 && (e.uniform1iv(this.addr, a), ce(i, a));
                for (var o = 0; o !== r; ++o) n.setTextureCube(t[o] || hh, a[o])
            }

            function ze(e) {
                switch (e) {
                    case 5126:
                        return Se;
                    case 35664:
                        return Ce;
                    case 35665:
                        return Ae;
                    case 35666:
                        return Le;
                    case 35674:
                        return Re;
                    case 35675:
                        return Ie;
                    case 35676:
                        return Oe;
                    case 35678:
                        return ke;
                    case 35680:
                        return De;
                    case 5124:
                    case 35670:
                        return Pe;
                    case 35667:
                    case 35671:
                        return we;
                    case 35668:
                    case 35672:
                        return Me;
                    case 35669:
                    case 35673:
                        return Te
                }
            }

            function Be(e, t, n) {
                this.id = e, this.addr = n, this.cache = [], this.setValue = Ee(t.type)
            }

            function Ne(e, t, n) {
                this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = ze(t.type)
            }

            function Ue(e) {
                this.id = e, oe.call(this)
            }

            function je(e, t) {
                e.seq.push(t), e.map[t.id] = t
            }

            function Fe(e, t, n) {
                var i = e.name,
                    r = i.length;
                for (gh.lastIndex = 0;;) {
                    var a = gh.exec(i),
                        o = gh.lastIndex,
                        s = a[1],
                        l = "]" === a[2],
                        c = a[3];
                    if (l && (s = 0 | s), void 0 === c || "[" === c && o + 2 === r) {
                        je(n, void 0 === c ? new Be(s, e, t) : new Ne(s, e, t));
                        break
                    }
                    var u = n.map,
                        h = u[s];
                    void 0 === h && (h = new Ue(s), je(n, h)), n = h
                }
            }

            function Ge(e, t, n) {
                oe.call(this), this.renderer = n;
                for (var i = e.getProgramParameter(t, 35718), r = 0; r < i; ++r) {
                    var a = e.getActiveUniform(t, r),
                        o = e.getUniformLocation(t, a.name);
                    Fe(a, o, this)
                }
            }

            function He(e) {
                for (var t = e.split("\n"), n = 0; n < t.length; n++) t[n] = n + 1 + ": " + t[n];
                return t.join("\n")
            }

            function Ve(e, t, n) {
                var i = e.createShader(t);
                return e.shaderSource(i, n), e.compileShader(i), e.getShaderParameter(i, 35713) === !1 && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== e.getShaderInfoLog(i) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === t ? "vertex" : "fragment", e.getShaderInfoLog(i), He(n)), i
            }

            function We(e) {
                switch (e) {
                    case Cl:
                        return ["Linear", "( value )"];
                    case Al:
                        return ["sRGB", "( value )"];
                    case Rl:
                        return ["RGBE", "( value )"];
                    case Ol:
                        return ["RGBM", "( value, 7.0 )"];
                    case kl:
                        return ["RGBM", "( value, 16.0 )"];
                    case Dl:
                        return ["RGBD", "( value, 256.0 )"];
                    case Ll:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    default:
                        throw new Error("unsupported encoding: " + e)
                }
            }

            function qe(e, t) {
                var n = We(t);
                return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
            }

            function Xe(e, t) {
                var n = We(t);
                return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
            }

            function Ye(e, t) {
                var n;
                switch (t) {
                    case as:
                        n = "Linear";
                        break;
                    case os:
                        n = "Reinhard";
                        break;
                    case ss:
                        n = "Uncharted2";
                        break;
                    case ls:
                        n = "OptimizedCineon";
                        break;
                    default:
                        throw new Error("unsupported toneMapping: " + t)
                }
                return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
            }

            function Ze(e, t, n) {
                e = e || {};
                var i = [e.derivatives || t.envMapCubeUV || t.bumpMap || t.normalMap && !t.objectSpaceNormalMap || t.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (e.fragDepth || t.logarithmicDepthBuffer) && n.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", e.drawBuffers && n.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (e.shaderTextureLOD || t.envMap) && n.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
                return i.filter(Qe).join("\n")
            }

            function Je(e) {
                var t = [];
                for (var n in e) {
                    var i = e[n];
                    i !== !1 && t.push("#define " + n + " " + i)
                }
                return t.join("\n")
            }

            function $e(e, t) {
                for (var n = {}, i = e.getProgramParameter(t, 35721), r = 0; r < i; r++) {
                    var a = e.getActiveAttrib(t, r),
                        o = a.name;
                    n[o] = e.getAttribLocation(t, o)
                }
                return n
            }

            function Qe(e) {
                return "" !== e
            }

            function Ke(e, t) {
                return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
            }

            function et(e, t) {
                return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
            }

            function tt(e) {
                function t(e, t) {
                    var n = eh[t];
                    if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
                    return tt(n)
                }
                var n = /^[ \t]*#include +<([\w\d.\/]+)>/gm;
                return e.replace(n, t)
            }

            function nt(e) {
                function t(e, t, n, i) {
                    for (var r = "", a = parseInt(t); a < parseInt(n); a++) r += i.replace(/\[ i \]/g, "[ " + a + " ]");
                    return r
                }
                var n = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
                return e.replace(n, t)
            }

            function it(e, t, n, i, r, a, o) {
                var s = e.context,
                    l = i.defines,
                    c = r.vertexShader,
                    u = r.fragmentShader,
                    h = "SHADOWMAP_TYPE_BASIC";
                a.shadowMapType === mo ? h = "SHADOWMAP_TYPE_PCF" : a.shadowMapType === vo && (h = "SHADOWMAP_TYPE_PCF_SOFT");
                var d = "ENVMAP_TYPE_CUBE",
                    p = "ENVMAP_MODE_REFLECTION",
                    f = "ENVMAP_BLENDING_MULTIPLY";
                if (a.envMap) {
                    switch (i.envMap.mapping) {
                        case us:
                        case hs:
                            d = "ENVMAP_TYPE_CUBE";
                            break;
                        case ms:
                        case vs:
                            d = "ENVMAP_TYPE_CUBE_UV";
                            break;
                        case ds:
                        case ps:
                            d = "ENVMAP_TYPE_EQUIREC";
                            break;
                        case fs:
                            d = "ENVMAP_TYPE_SPHERE"
                    }
                    switch (i.envMap.mapping) {
                        case hs:
                        case ps:
                            p = "ENVMAP_MODE_REFRACTION"
                    }
                    switch (i.combine) {
                        case ts:
                            f = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case ns:
                            f = "ENVMAP_BLENDING_MIX";
                            break;
                        case is:
                            f = "ENVMAP_BLENDING_ADD"
                    }
                }
                var m, v, g = e.gammaFactor > 0 ? e.gammaFactor : 1,
                    y = o.isWebGL2 ? "" : Ze(i.extensions, a, t),
                    x = Je(l),
                    b = s.createProgram();
                if (i.isRawShaderMaterial ? (m = [x].filter(Qe).join("\n"), m.length > 0 && (m += "\n"), v = [y, x].filter(Qe).join("\n"), v.length > 0 && (v += "\n")) : (m = ["precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, x, a.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + g, "#define MAX_BONES " + a.maxBones, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + p : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.displacementMap && a.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexColors ? "#define USE_COLOR" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.skinning ? "#define USE_SKINNING" : "", a.useVertexTexture ? "#define BONE_TEXTURE" : "", a.morphTargets ? "#define USE_MORPHTARGETS" : "", a.morphNormals && a.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + h : "", a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Qe).join("\n"), v = [y, "precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, x, a.alphaTest ? "#define ALPHATEST " + a.alphaTest + (a.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + g, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + d : "", a.envMap ? "#define " + p : "", a.envMap ? "#define " + f : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexColors ? "#define USE_COLOR" : "", a.gradientMap ? "#define USE_GRADIENTMAP" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + h : "", a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", a.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", a.envMap && (o.isWebGL2 || t.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", a.toneMapping !== rs ? "#define TONE_MAPPING" : "", a.toneMapping !== rs ? eh.tonemapping_pars_fragment : "", a.toneMapping !== rs ? Ye("toneMapping", a.toneMapping) : "", a.dithering ? "#define DITHERING" : "", a.outputEncoding || a.mapEncoding || a.matcapEncoding || a.envMapEncoding || a.emissiveMapEncoding ? eh.encodings_pars_fragment : "", a.mapEncoding ? qe("mapTexelToLinear", a.mapEncoding) : "", a.matcapEncoding ? qe("matcapTexelToLinear", a.matcapEncoding) : "", a.envMapEncoding ? qe("envMapTexelToLinear", a.envMapEncoding) : "", a.emissiveMapEncoding ? qe("emissiveMapTexelToLinear", a.emissiveMapEncoding) : "", a.outputEncoding ? Xe("linearToOutputTexel", a.outputEncoding) : "", a.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(Qe).join("\n")),
                    c = tt(c), c = Ke(c, a), c = et(c, a), u = tt(u), u = Ke(u, a), u = et(u, a), c = nt(c), u = nt(u), o.isWebGL2 && !i.isRawShaderMaterial) {
                    var _ = !1,
                        w = /^\s*#version\s+300\s+es\s*\n/;
                    i.isShaderMaterial && null !== c.match(w) && null !== u.match(w) && (_ = !0, c = c.replace(w, ""), u = u.replace(w, "")), m = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + m, v = ["#version 300 es\n", "#define varying in", _ ? "" : "out highp vec4 pc_fragColor;", _ ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v
                }
                var M = m + c,
                    T = v + u,
                    E = Ve(s, 35633, M),
                    S = Ve(s, 35632, T);
                s.attachShader(b, E), s.attachShader(b, S), void 0 !== i.index0AttributeName ? s.bindAttribLocation(b, 0, i.index0AttributeName) : a.morphTargets === !0 && s.bindAttribLocation(b, 0, "position"), s.linkProgram(b);
                var P = s.getProgramInfoLog(b).trim(),
                    C = s.getShaderInfoLog(E).trim(),
                    A = s.getShaderInfoLog(S).trim(),
                    L = !0,
                    R = !0;
                s.getProgramParameter(b, 35714) === !1 ? (L = !1, console.error("THREE.WebGLProgram: shader error: ", s.getError(), "35715", s.getProgramParameter(b, 35715), "gl.getProgramInfoLog", P, C, A)) : "" !== P ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", P) : "" !== C && "" !== A || (R = !1), R && (this.diagnostics = {
                    runnable: L,
                    material: i,
                    programLog: P,
                    vertexShader: {
                        log: C,
                        prefix: m
                    },
                    fragmentShader: {
                        log: A,
                        prefix: v
                    }
                }), s.deleteShader(E), s.deleteShader(S);
                var I;
                this.getUniforms = function () {
                    return void 0 === I && (I = new Ge(s, b, e)), I
                };
                var O;
                return this.getAttributes = function () {
                    return void 0 === O && (O = $e(s, b)), O
                }, this.destroy = function () {
                    s.deleteProgram(b), this.program = void 0
                }, Object.defineProperties(this, {
                    uniforms: {
                        get: function () {
                            return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                        }
                    },
                    attributes: {
                        get: function () {
                            return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                        }
                    }
                }), this.name = r.name, this.id = yh++, this.code = n, this.usedTimes = 1, this.program = b, this.vertexShader = E, this.fragmentShader = S, this
            }

            function rt(e, t, n) {
                function i(e) {
                    var t = e.skeleton,
                        i = t.bones;
                    if (n.floatVertexTextures) return 1024;
                    var r = n.maxVertexUniforms,
                        a = Math.floor((r - 20) / 4),
                        o = Math.min(a, i.length);
                    return o < i.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + i.length + " bones. This GPU supports " + o + "."), 0) : o
                }

                function r(e, t) {
                    var n;
                    return e ? e.isTexture ? n = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), n = e.texture.encoding) : n = Cl, n === Cl && t && (n = Ll), n
                }
                var a = [],
                    o = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "phong",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    },
                    s = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];
                this.getParameters = function (t, a, s, l, c, u, h) {
                    var d = o[t.type],
                        p = h.isSkinnedMesh ? i(h) : 0,
                        f = n.precision;
                    null !== t.precision && (f = n.getMaxPrecision(t.precision), f !== t.precision && console.warn("THREE.WebGLProgram.getParameters:", t.precision, "not supported, using", f, "instead."));
                    var m = e.getRenderTarget(),
                        v = {
                            shaderID: d,
                            precision: f,
                            supportsVertexTextures: n.vertexTextures,
                            outputEncoding: r(m ? m.texture : null, e.gammaOutput),
                            map: !!t.map,
                            mapEncoding: r(t.map, e.gammaInput),
                            matcap: !!t.matcap,
                            matcapEncoding: r(t.matcap, e.gammaInput),
                            envMap: !!t.envMap,
                            envMapMode: t.envMap && t.envMap.mapping,
                            envMapEncoding: r(t.envMap, e.gammaInput),
                            envMapCubeUV: !!t.envMap && (t.envMap.mapping === ms || t.envMap.mapping === vs),
                            lightMap: !!t.lightMap,
                            aoMap: !!t.aoMap,
                            emissiveMap: !!t.emissiveMap,
                            emissiveMapEncoding: r(t.emissiveMap, e.gammaInput),
                            bumpMap: !!t.bumpMap,
                            normalMap: !!t.normalMap,
                            objectSpaceNormalMap: t.normalMapType === Ul,
                            displacementMap: !!t.displacementMap,
                            roughnessMap: !!t.roughnessMap,
                            metalnessMap: !!t.metalnessMap,
                            specularMap: !!t.specularMap,
                            alphaMap: !!t.alphaMap,
                            gradientMap: !!t.gradientMap,
                            combine: t.combine,
                            vertexColors: t.vertexColors,
                            fog: !!l,
                            useFog: t.fog,
                            fogExp: l && l.isFogExp2,
                            flatShading: t.flatShading,
                            sizeAttenuation: t.sizeAttenuation,
                            logarithmicDepthBuffer: n.logarithmicDepthBuffer,
                            skinning: t.skinning && p > 0,
                            maxBones: p,
                            useVertexTexture: n.floatVertexTextures,
                            morphTargets: t.morphTargets,
                            morphNormals: t.morphNormals,
                            maxMorphTargets: e.maxMorphTargets,
                            maxMorphNormals: e.maxMorphNormals,
                            numDirLights: a.directional.length,
                            numPointLights: a.point.length,
                            numSpotLights: a.spot.length,
                            numRectAreaLights: a.rectArea.length,
                            numHemiLights: a.hemi.length,
                            numClippingPlanes: c,
                            numClipIntersection: u,
                            dithering: t.dithering,
                            shadowMapEnabled: e.shadowMap.enabled && h.receiveShadow && s.length > 0,
                            shadowMapType: e.shadowMap.type,
                            toneMapping: e.toneMapping,
                            physicallyCorrectLights: e.physicallyCorrectLights,
                            premultipliedAlpha: t.premultipliedAlpha,
                            alphaTest: t.alphaTest,
                            doubleSided: t.side === xo,
                            flipSided: t.side === yo,
                            depthPacking: void 0 !== t.depthPacking && t.depthPacking
                        };
                    return v
                }, this.getProgramCode = function (t, n) {
                    var i = [];
                    if (n.shaderID ? i.push(n.shaderID) : (i.push(t.fragmentShader), i.push(t.vertexShader)), void 0 !== t.defines)
                        for (var r in t.defines) i.push(r), i.push(t.defines[r]);
                    for (var a = 0; a < s.length; a++) i.push(n[s[a]]);
                    return i.push(t.onBeforeCompile.toString()), i.push(e.gammaOutput), i.push(e.gammaFactor), i.join()
                }, this.acquireProgram = function (i, r, o, s) {
                    for (var l, c = 0, u = a.length; c < u; c++) {
                        var h = a[c];
                        if (h.code === s) {
                            l = h, ++l.usedTimes;
                            break
                        }
                    }
                    return void 0 === l && (l = new it(e, t, s, i, r, o, n), a.push(l)), l
                }, this.releaseProgram = function (e) {
                    if (0 === --e.usedTimes) {
                        var t = a.indexOf(e);
                        a[t] = a[a.length - 1], a.pop(), e.destroy()
                    }
                }, this.programs = a
            }

            function at() {
                function e(e) {
                    var t = r.get(e);
                    return void 0 === t && (t = {}, r.set(e, t)), t
                }

                function t(e) {
                    r["delete"](e)
                }

                function n(e, t, n) {
                    r.get(e)[t] = n
                }

                function i() {
                    r = new WeakMap
                }
                var r = new WeakMap;
                return {
                    get: e,
                    remove: t,
                    update: n,
                    dispose: i
                }
            }

            function ot(e, t) {
                return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program && t.program && e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
            }

            function st(e, t) {
                return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
            }

            function lt() {
                function e() {
                    r = 0, a.length = 0, o.length = 0
                }

                function t(e, t, n, s, l) {
                    var c = i[r];
                    void 0 === c ? (c = {
                        id: e.id,
                        object: e,
                        geometry: t,
                        material: n,
                        program: n.program,
                        renderOrder: e.renderOrder,
                        z: s,
                        group: l
                    }, i[r] = c) : (c.id = e.id, c.object = e, c.geometry = t, c.material = n, c.program = n.program, c.renderOrder = e.renderOrder, c.z = s, c.group = l), (n.transparent === !0 ? o : a).push(c), r++
                }

                function n() {
                    a.length > 1 && a.sort(ot), o.length > 1 && o.sort(st)
                }
                var i = [],
                    r = 0,
                    a = [],
                    o = [];
                return {
                    opaque: a,
                    transparent: o,
                    init: e,
                    push: t,
                    sort: n
                }
            }

            function ct() {
                function e(e, t) {
                    var i = e.id + "," + t.id,
                        r = n[i];
                    return void 0 === r && (r = new lt, n[i] = r), r
                }

                function t() {
                    n = {}
                }
                var n = {};
                return {
                    get: e,
                    dispose: t
                }
            }

            function ut() {
                var e = {};
                return {
                    get: function (t) {
                        if (void 0 !== e[t.id]) return e[t.id];
                        var i;
                        switch (t.type) {
                            case "DirectionalLight":
                                i = {
                                    direction: new a,
                                    color: new v,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new n
                                };
                                break;
                            case "SpotLight":
                                i = {
                                    position: new a,
                                    direction: new a,
                                    color: new v,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new n
                                };
                                break;
                            case "PointLight":
                                i = {
                                    position: new a,
                                    color: new v,
                                    distance: 0,
                                    decay: 0,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new n,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                };
                                break;
                            case "HemisphereLight":
                                i = {
                                    direction: new a,
                                    skyColor: new v,
                                    groundColor: new v
                                };
                                break;
                            case "RectAreaLight":
                                i = {
                                    color: new v,
                                    position: new a,
                                    halfWidth: new a,
                                    halfHeight: new a
                                }
                        }
                        return e[t.id] = i, i
                    }
                }
            }

            function ht() {
                function e(e, i, a) {
                    for (var l = 0, c = 0, u = 0, h = 0, d = 0, p = 0, f = 0, m = 0, v = a.matrixWorldInverse, g = 0, y = e.length; g < y; g++) {
                        var x = e[g],
                            b = x.color,
                            _ = x.intensity,
                            w = x.distance,
                            M = x.shadow && x.shadow.map ? x.shadow.map.texture : null;
                        if (x.isAmbientLight) l += b.r * _, c += b.g * _, u += b.b * _;
                        else if (x.isDirectionalLight) {
                            var T = t.get(x);
                            if (T.color.copy(x.color).multiplyScalar(x.intensity), T.direction.setFromMatrixPosition(x.matrixWorld), r.setFromMatrixPosition(x.target.matrixWorld), T.direction.sub(r), T.direction.transformDirection(v), T.shadow = x.castShadow, x.castShadow) {
                                var E = x.shadow;
                                T.shadowBias = E.bias, T.shadowRadius = E.radius, T.shadowMapSize = E.mapSize
                            }
                            n.directionalShadowMap[h] = M, n.directionalShadowMatrix[h] = x.shadow.matrix, n.directional[h] = T, h++
                        } else if (x.isSpotLight) {
                            var T = t.get(x);
                            if (T.position.setFromMatrixPosition(x.matrixWorld), T.position.applyMatrix4(v), T.color.copy(b).multiplyScalar(_), T.distance = w, T.direction.setFromMatrixPosition(x.matrixWorld), r.setFromMatrixPosition(x.target.matrixWorld), T.direction.sub(r), T.direction.transformDirection(v), T.coneCos = Math.cos(x.angle), T.penumbraCos = Math.cos(x.angle * (1 - x.penumbra)), T.decay = x.decay, T.shadow = x.castShadow, x.castShadow) {
                                var E = x.shadow;
                                T.shadowBias = E.bias, T.shadowRadius = E.radius, T.shadowMapSize = E.mapSize
                            }
                            n.spotShadowMap[p] = M, n.spotShadowMatrix[p] = x.shadow.matrix, n.spot[p] = T, p++
                        } else if (x.isRectAreaLight) {
                            var T = t.get(x);
                            T.color.copy(b).multiplyScalar(_), T.position.setFromMatrixPosition(x.matrixWorld), T.position.applyMatrix4(v), s.identity(), o.copy(x.matrixWorld), o.premultiply(v), s.extractRotation(o), T.halfWidth.set(.5 * x.width, 0, 0), T.halfHeight.set(0, .5 * x.height, 0), T.halfWidth.applyMatrix4(s), T.halfHeight.applyMatrix4(s), n.rectArea[f] = T, f++
                        } else if (x.isPointLight) {
                            var T = t.get(x);
                            if (T.position.setFromMatrixPosition(x.matrixWorld), T.position.applyMatrix4(v), T.color.copy(x.color).multiplyScalar(x.intensity), T.distance = x.distance, T.decay = x.decay, T.shadow = x.castShadow, x.castShadow) {
                                var E = x.shadow;
                                T.shadowBias = E.bias, T.shadowRadius = E.radius, T.shadowMapSize = E.mapSize, T.shadowCameraNear = E.camera.near, T.shadowCameraFar = E.camera.far
                            }
                            n.pointShadowMap[d] = M, n.pointShadowMatrix[d] = x.shadow.matrix, n.point[d] = T, d++
                        } else if (x.isHemisphereLight) {
                            var T = t.get(x);
                            T.direction.setFromMatrixPosition(x.matrixWorld), T.direction.transformDirection(v), T.direction.normalize(), T.skyColor.copy(x.color).multiplyScalar(_), T.groundColor.copy(x.groundColor).multiplyScalar(_), n.hemi[m] = T, m++
                        }
                    }
                    n.ambient[0] = l, n.ambient[1] = c, n.ambient[2] = u, n.directional.length = h, n.spot.length = p, n.rectArea.length = f, n.point.length = d, n.hemi.length = m, n.hash.stateID = n.id, n.hash.directionalLength = h, n.hash.pointLength = d, n.hash.spotLength = p, n.hash.rectAreaLength = f, n.hash.hemiLength = m, n.hash.shadowsLength = i.length
                }
                var t = new ut,
                    n = {
                        id: xh++,
                        hash: {
                            stateID: -1,
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            shadowsLength: -1
                        },
                        ambient: [0, 0, 0],
                        directional: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        point: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    },
                    r = new a,
                    o = new i,
                    s = new i;
                return {
                    setup: e,
                    state: n
                }
            }

            function dt() {
                function e() {
                    a.length = 0, o.length = 0
                }

                function t(e) {
                    a.push(e)
                }

                function n(e) {
                    o.push(e)
                }

                function i(e) {
                    r.setup(a, o, e)
                }
                var r = new ht,
                    a = [],
                    o = [],
                    s = {
                        lightsArray: a,
                        shadowsArray: o,
                        lights: r
                    };
                return {
                    init: e,
                    state: s,
                    setupLights: i,
                    pushLight: t,
                    pushShadow: n
                }
            }

            function pt() {
                function e(e, t) {
                    var i;
                    return void 0 === n[e.id] ? (i = new dt, n[e.id] = {}, n[e.id][t.id] = i) : void 0 === n[e.id][t.id] ? (i = new dt, n[e.id][t.id] = i) : i = n[e.id][t.id], i
                }

                function t() {
                    n = {}
                }
                var n = {};
                return {
                    get: e,
                    dispose: t
                }
            }

            function ft(e) {
                F.call(this), this.type = "MeshDepthMaterial", this.depthPacking = zl, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(e)
            }

            function mt(e) {
                F.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new a, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(e)
            }

            function vt(e, t, r) {
                function o(t, n, i, r, a, o) {
                    var s = t.geometry,
                        l = null,
                        c = b,
                        u = t.customDepthMaterial;
                    if (i && (c = _, u = t.customDistanceMaterial), u) l = u;
                    else {
                        var h = !1;
                        n.morphTargets && (s && s.isBufferGeometry ? h = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0 : s && s.isGeometry && (h = s.morphTargets && s.morphTargets.length > 0)), t.isSkinnedMesh && n.skinning === !1 && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t);
                        var d = t.isSkinnedMesh && n.skinning,
                            p = 0;
                        h && (p |= g), d && (p |= y), l = c[p]
                    }
                    if (e.localClippingEnabled && n.clipShadows === !0 && 0 !== n.clippingPlanes.length) {
                        var f = l.uuid,
                            m = n.uuid,
                            v = w[f];
                        void 0 === v && (v = {}, w[f] = v);
                        var x = v[m];
                        void 0 === x && (x = l.clone(), v[m] = x), l = x
                    }
                    return l.visible = n.visible, l.wireframe = n.wireframe, l.side = null != n.shadowSide ? n.shadowSide : M[n.side], l.clipShadows = n.clipShadows, l.clippingPlanes = n.clippingPlanes, l.clipIntersection = n.clipIntersection, l.wireframeLinewidth = n.wireframeLinewidth, l.linewidth = n.linewidth, i && l.isMeshDistanceMaterial && (l.referencePosition.copy(r), l.nearDistance = a, l.farDistance = o), l
                }

                function s(n, i, r, a) {
                    if (n.visible !== !1) {
                        var l = n.layers.test(i.layers);
                        if (l && (n.isMesh || n.isLine || n.isPoints) && n.castShadow && (!n.frustumCulled || u.intersectsObject(n))) {
                            n.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, n.matrixWorld);
                            var c = t.update(n),
                                h = n.material;
                            if (Array.isArray(h))
                                for (var d = c.groups, p = 0, f = d.length; p < f; p++) {
                                    var m = d[p],
                                        g = h[m.materialIndex];
                                    if (g && g.visible) {
                                        var y = o(n, g, a, v, r.near, r.far);
                                        e.renderBufferDirect(r, null, c, y, n, m)
                                    }
                                } else if (h.visible) {
                                    var y = o(n, h, a, v, r.near, r.far);
                                    e.renderBufferDirect(r, null, c, y, n, null)
                                }
                        }
                        for (var x = n.children, b = 0, _ = x.length; b < _; b++) s(x[b], i, r, a)
                    }
                }
                for (var u = new m, h = new i, d = new n, p = new n(r, r), f = new a, v = new a, g = 1, y = 2, x = (g | y) + 1, b = new Array(x), _ = new Array(x), w = {}, M = {
                        0: yo,
                        1: go,
                        2: xo
                    }, T = [new a(1, 0, 0), new a((-1), 0, 0), new a(0, 0, 1), new a(0, 0, (-1)), new a(0, 1, 0), new a(0, (-1), 0)], E = [new a(0, 1, 0), new a(0, 1, 0), new a(0, 1, 0), new a(0, 1, 0), new a(0, 0, 1), new a(0, 0, (-1))], S = [new l, new l, new l, new l, new l, new l], P = 0; P !== x; ++P) {
                    var C = 0 !== (P & g),
                        A = 0 !== (P & y),
                        L = new ft({
                            depthPacking: Bl,
                            morphTargets: C,
                            skinning: A
                        });
                    b[P] = L;
                    var R = new mt({
                        morphTargets: C,
                        skinning: A
                    });
                    _[P] = R
                }
                var I = this;
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = mo, this.render = function (t, n, i) {
                    if (I.enabled !== !1 && (I.autoUpdate !== !1 || I.needsUpdate !== !1) && 0 !== t.length) {
                        var r = (e.context, e.state);
                        r.disable(3042), r.buffers.color.setClear(1, 1, 1, 1), r.buffers.depth.setTest(!0), r.setScissorTest(!1);
                        for (var a, o = 0, l = t.length; o < l; o++) {
                            var m = t[o],
                                g = m.shadow,
                                y = m && m.isPointLight;
                            if (void 0 !== g) {
                                var x = g.camera;
                                if (d.copy(g.mapSize), d.min(p), y) {
                                    var b = d.x,
                                        _ = d.y;
                                    S[0].set(2 * b, _, b, _), S[1].set(0, _, b, _), S[2].set(3 * b, _, b, _), S[3].set(b, _, b, _), S[4].set(3 * b, 0, b, _), S[5].set(b, 0, b, _), d.x *= 4, d.y *= 2
                                }
                                if (null === g.map) {
                                    var w = {
                                        minFilter: bs,
                                        magFilter: bs,
                                        format: js
                                    };
                                    g.map = new c(d.x, d.y, w), g.map.texture.name = m.name + ".shadowMap", x.updateProjectionMatrix()
                                }
                                g.isSpotLightShadow && g.update(m);
                                var M = g.map,
                                    P = g.matrix;
                                v.setFromMatrixPosition(m.matrixWorld), x.position.copy(v), y ? (a = 6, P.makeTranslation(-v.x, -v.y, -v.z)) : (a = 1, f.setFromMatrixPosition(m.target.matrixWorld), x.lookAt(f), x.updateMatrixWorld(), P.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), P.multiply(x.projectionMatrix), P.multiply(x.matrixWorldInverse)), e.setRenderTarget(M), e.clear();
                                for (var C = 0; C < a; C++) {
                                    if (y) {
                                        f.copy(x.position), f.add(T[C]), x.up.copy(E[C]), x.lookAt(f), x.updateMatrixWorld();
                                        var A = S[C];
                                        r.viewport(A)
                                    }
                                    h.multiplyMatrices(x.projectionMatrix, x.matrixWorldInverse), u.setFromMatrix(h), s(n, i, x, y)
                                }
                            } else console.warn("THREE.WebGLShadowMap:", m, "has no shadow.")
                        }
                        I.needsUpdate = !1
                    }
                }
            }

            function gt(e, t, n, i) {
                function r() {
                    var t = !1,
                        n = new l,
                        i = null,
                        r = new l(0, 0, 0, 0);
                    return {
                        setMask: function (n) {
                            i === n || t || (e.colorMask(n, n, n, n), i = n)
                        },
                        setLocked: function (e) {
                            t = e
                        },
                        setClear: function (t, i, a, o, s) {
                            s === !0 && (t *= o, i *= o, a *= o), n.set(t, i, a, o), r.equals(n) === !1 && (e.clearColor(t, i, a, o), r.copy(n))
                        },
                        reset: function () {
                            t = !1, i = null, r.set(-1, 0, 0, 0)
                        }
                    }
                }

                function a() {
                    var t = !1,
                        n = null,
                        i = null,
                        r = null;
                    return {
                        setTest: function (e) {
                            e ? p(2929) : f(2929)
                        },
                        setMask: function (i) {
                            n === i || t || (e.depthMask(i), n = i)
                        },
                        setFunc: function (t) {
                            if (i !== t) {
                                if (t) switch (t) {
                                    case Xo:
                                        e.depthFunc(512);
                                        break;
                                    case Yo:
                                        e.depthFunc(519);
                                        break;
                                    case Zo:
                                        e.depthFunc(513);
                                        break;
                                    case Jo:
                                        e.depthFunc(515);
                                        break;
                                    case $o:
                                        e.depthFunc(514);
                                        break;
                                    case Qo:
                                        e.depthFunc(518);
                                        break;
                                    case Ko:
                                        e.depthFunc(516);
                                        break;
                                    case es:
                                        e.depthFunc(517);
                                        break;
                                    default:
                                        e.depthFunc(515)
                                } else e.depthFunc(515);
                                i = t
                            }
                        },
                        setLocked: function (e) {
                            t = e
                        },
                        setClear: function (t) {
                            r !== t && (e.clearDepth(t), r = t)
                        },
                        reset: function () {
                            t = !1, n = null, i = null, r = null
                        }
                    }
                }

                function o() {
                    var t = !1,
                        n = null,
                        i = null,
                        r = null,
                        a = null,
                        o = null,
                        s = null,
                        l = null,
                        c = null;
                    return {
                        setTest: function (e) {
                            e ? p(2960) : f(2960)
                        },
                        setMask: function (i) {
                            n === i || t || (e.stencilMask(i), n = i)
                        },
                        setFunc: function (t, n, o) {
                            i === t && r === n && a === o || (e.stencilFunc(t, n, o), i = t, r = n, a = o)
                        },
                        setOp: function (t, n, i) {
                            o === t && s === n && l === i || (e.stencilOp(t, n, i), o = t, s = n, l = i)
                        },
                        setLocked: function (e) {
                            t = e
                        },
                        setClear: function (t) {
                            c !== t && (e.clearStencil(t), c = t)
                        },
                        reset: function () {
                            t = !1, n = null, i = null, r = null, a = null, o = null, s = null, l = null, c = null
                        }
                    }
                }

                function s(t, n, i) {
                    var r = new Uint8Array(4),
                        a = e.createTexture();
                    e.bindTexture(t, a), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728);
                    for (var o = 0; o < i; o++) e.texImage2D(n + o, 0, 6408, 1, 1, 0, 6408, 5121, r);
                    return a
                }

                function c() {
                    for (var e = 0, t = z.length; e < t; e++) z[e] = 0
                }

                function u(e) {
                    h(e, 0)
                }

                function h(n, r) {
                    if (z[n] = 1, 0 === B[n] && (e.enableVertexAttribArray(n), B[n] = 1), N[n] !== r) {
                        var a = i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays");
                        a[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), N[n] = r
                    }
                }

                function d() {
                    for (var t = 0, n = B.length; t !== n; ++t) B[t] !== z[t] && (e.disableVertexAttribArray(t), B[t] = 0)
                }

                function p(t) {
                    U[t] !== !0 && (e.enable(t), U[t] = !0)
                }

                function f(t) {
                    U[t] !== !1 && (e.disable(t), U[t] = !1)
                }

                function m() {
                    if (null === j && (j = [], t.get("WEBGL_compressed_texture_pvrtc") || t.get("WEBGL_compressed_texture_s3tc") || t.get("WEBGL_compressed_texture_etc1") || t.get("WEBGL_compressed_texture_astc")))
                        for (var n = e.getParameter(34467), i = 0; i < n.length; i++) j.push(n[i]);
                    return j
                }

                function v(t) {
                    return F !== t && (e.useProgram(t), F = t, !0)
                }

                function g(t, i, r, a, o, s, l, c) {
                    if (t === Eo) return void(G && (f(3042), G = !1));
                    if (G || (p(3042), G = !0), t === Lo) o = o || i, s = s || r, l = l || a, i === V && o === X || (e.blendEquationSeparate(n.convert(i), n.convert(o)), V = i, X = o), r === W && a === q && s === Y && l === Z || (e.blendFuncSeparate(n.convert(r), n.convert(a), n.convert(s), n.convert(l)), W = r, q = a, Y = s, Z = l), H = t, J = null;
                    else if (t !== H || c !== J) {
                        if (V === Ro && X === Ro || (e.blendEquation(32774), V = Ro, X = Ro), c) switch (t) {
                            case So:
                                e.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case Po:
                                e.blendFunc(1, 1);
                                break;
                            case Co:
                                e.blendFuncSeparate(0, 0, 769, 771);
                                break;
                            case Ao:
                                e.blendFuncSeparate(0, 768, 0, 770);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                        } else switch (t) {
                            case So:
                                e.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case Po:
                                e.blendFunc(770, 1);
                                break;
                            case Co:
                                e.blendFunc(0, 769);
                                break;
                            case Ao:
                                e.blendFunc(0, 768);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                        }
                        W = null, q = null, Y = null, Z = null, H = t, J = c
                    }
                }

                function y(e, t) {
                    e.side === xo ? f(2884) : p(2884);
                    var n = e.side === yo;
                    t && (n = !n), x(n), e.blending === So && e.transparent === !1 ? g(Eo) : g(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), O.setFunc(e.depthFunc), O.setTest(e.depthTest), O.setMask(e.depthWrite), I.setMask(e.colorWrite), w(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
                }

                function x(t) {
                    $ !== t && (t ? e.frontFace(2304) : e.frontFace(2305), $ = t)
                }

                function b(t) {
                    t !== so ? (p(2884), t !== Q && (t === lo ? e.cullFace(1029) : t === co ? e.cullFace(1028) : e.cullFace(1032))) : f(2884), Q = t
                }

                function _(t) {
                    t !== K && (ie && e.lineWidth(t), K = t)
                }

                function w(t, n, i) {
                    t ? (p(32823), ee === n && te === i || (e.polygonOffset(n, i), ee = n, te = i)) : f(32823)
                }

                function M(e) {
                    e ? p(3089) : f(3089)
                }

                function T(t) {
                    void 0 === t && (t = 33984 + ne - 1), oe !== t && (e.activeTexture(t), oe = t)
                }

                function E(t, n) {
                    null === oe && T();
                    var i = se[oe];
                    void 0 === i && (i = {
                        type: void 0,
                        texture: void 0
                    }, se[oe] = i), i.type === t && i.texture === n || (e.bindTexture(t, n || ue[t]), i.type = t, i.texture = n)
                }

                function S() {
                    try {
                        e.compressedTexImage2D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                }

                function P() {
                    try {
                        e.texImage2D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                }

                function C() {
                    try {
                        e.texImage3D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                }

                function A(t) {
                    le.equals(t) === !1 && (e.scissor(t.x, t.y, t.z, t.w), le.copy(t))
                }

                function L(t) {
                    ce.equals(t) === !1 && (e.viewport(t.x, t.y, t.z, t.w), ce.copy(t))
                }

                function R() {
                    for (var t = 0; t < B.length; t++) 1 === B[t] && (e.disableVertexAttribArray(t), B[t] = 0);
                    U = {}, j = null, oe = null, se = {}, F = null, H = null, $ = null, Q = null, I.reset(), O.reset(), k.reset()
                }
                var I = new r,
                    O = new a,
                    k = new o,
                    D = e.getParameter(34921),
                    z = new Uint8Array(D),
                    B = new Uint8Array(D),
                    N = new Uint8Array(D),
                    U = {},
                    j = null,
                    F = null,
                    G = null,
                    H = null,
                    V = null,
                    W = null,
                    q = null,
                    X = null,
                    Y = null,
                    Z = null,
                    J = !1,
                    $ = null,
                    Q = null,
                    K = null,
                    ee = null,
                    te = null,
                    ne = e.getParameter(35661),
                    ie = !1,
                    re = 0,
                    ae = e.getParameter(7938);
                ae.indexOf("WebGL") !== -1 ? (re = parseFloat(/^WebGL\ ([0-9])/.exec(ae)[1]), ie = re >= 1) : ae.indexOf("OpenGL ES") !== -1 && (re = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(ae)[1]), ie = re >= 2);
                var oe = null,
                    se = {},
                    le = new l,
                    ce = new l,
                    ue = {};
                return ue[3553] = s(3553, 3553, 1), ue[34067] = s(34067, 34069, 6), I.setClear(0, 0, 0, 1), O.setClear(1), k.setClear(0), p(2929), O.setFunc(Jo), x(!1), b(lo), p(2884), g(Eo), {
                    buffers: {
                        color: I,
                        depth: O,
                        stencil: k
                    },
                    initAttributes: c,
                    enableAttribute: u,
                    enableAttributeAndDivisor: h,
                    disableUnusedAttributes: d,
                    enable: p,
                    disable: f,
                    getCompressedTextureFormats: m,
                    useProgram: v,
                    setBlending: g,
                    setMaterial: y,
                    setFlipSided: x,
                    setCullFace: b,
                    setLineWidth: _,
                    setPolygonOffset: w,
                    setScissorTest: M,
                    activeTexture: T,
                    bindTexture: E,
                    compressedTexImage2D: S,
                    texImage2D: P,
                    texImage3D: C,
                    scissor: A,
                    viewport: L,
                    reset: R
                }
            }

            function yt(e, t, n, i, r, a, o) {
                function s(e, t) {
                    if (e.width > t || e.height > t) {
                        if ("data" in e) return void console.warn("THREE.WebGLRenderer: image in DataTexture is too big (" + e.width + "x" + e.height + ").");
                        var n = t / Math.max(e.width, e.height),
                            i = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                        i.width = Math.floor(e.width * n), i.height = Math.floor(e.height * n);
                        var r = i.getContext("2d");
                        return r.drawImage(e, 0, 0, e.width, e.height, 0, 0, i.width, i.height), console.warn("THREE.WebGLRenderer: image is too big (" + e.width + "x" + e.height + "). Resized to " + i.width + "x" + i.height), i
                    }
                    return e
                }

                function l(e) {
                    return jl.isPowerOfTwo(e.width) && jl.isPowerOfTwo(e.height)
                }

                function c(e) {
                    if (e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof ImageBitmap) {
                        void 0 === I && (I = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), I.width = jl.floorPowerOfTwo(e.width), I.height = jl.floorPowerOfTwo(e.height);
                        var t = I.getContext("2d");
                        return t.drawImage(e, 0, 0, I.width, I.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + e.width + "x" + e.height + "). Resized to " + I.width + "x" + I.height), I
                    }
                    return e
                }

                function u(e) {
                    return !r.isWebGL2 && (e.wrapS !== ys || e.wrapT !== ys || e.minFilter !== bs && e.minFilter !== Ms)
                }

                function h(e, t) {
                    return e.generateMipmaps && t && e.minFilter !== bs && e.minFilter !== Ms
                }

                function d(t, n, r, a) {
                    e.generateMipmap(t);
                    var o = i.get(n);
                    o.__maxMipLevel = Math.log(Math.max(r, a)) * Math.LOG2E
                }

                function p(e, t) {
                    if (!r.isWebGL2) return e;
                    if (6403 === e) {
                        if (5126 === t) return 33326;
                        if (5131 === t) return 33325;
                        if (5121 === t) return 33321
                    }
                    if (6407 === e) {
                        if (5126 === t) return 34837;
                        if (5131 === t) return 34843;
                        if (5121 === t) return 32849
                    }
                    if (6408 === e) {
                        if (5126 === t) return 34836;
                        if (5131 === t) return 34842;
                        if (5121 === t) return 32856
                    }
                    return e
                }

                function f(e) {
                    return e === bs || e === _s || e === ws ? 9728 : 9729
                }

                function m(e) {
                    var t = e.target;
                    t.removeEventListener("dispose", m), g(t), t.isVideoTexture && delete O[t.id], o.memory.textures--
                }

                function v(e) {
                    var t = e.target;
                    t.removeEventListener("dispose", v), y(t), o.memory.textures--
                }

                function g(t) {
                    var n = i.get(t);
                    if (t.image && n.__image__webglTextureCube) e.deleteTexture(n.__image__webglTextureCube);
                    else {
                        if (void 0 === n.__webglInit) return;
                        e.deleteTexture(n.__webglTexture)
                    }
                    i.remove(t)
                }

                function y(t) {
                    var n = i.get(t),
                        r = i.get(t.texture);
                    if (t) {
                        if (void 0 !== r.__webglTexture && e.deleteTexture(r.__webglTexture), t.depthTexture && t.depthTexture.dispose(), t.isWebGLRenderTargetCube)
                            for (var a = 0; a < 6; a++) e.deleteFramebuffer(n.__webglFramebuffer[a]), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[a]);
                        else e.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer);
                        i.remove(t.texture), i.remove(t)
                    }
                }

                function x(e, t) {
                    var r = i.get(e);
                    if (e.isVideoTexture && R(e), e.version > 0 && r.__version !== e.version) {
                        var a = e.image;
                        if (void 0 === a) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                        else {
                            if (a.complete !== !1) return void T(r, e, t);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    n.activeTexture(33984 + t), n.bindTexture(3553, r.__webglTexture)
                }

                function b(e, t) {
                    var r = i.get(e);
                    return e.version > 0 && r.__version !== e.version ? void T(r, e, t) : (n.activeTexture(33984 + t), void n.bindTexture(32879, r.__webglTexture))
                }

                function _(t, c) {
                    var u = i.get(t);
                    if (6 === t.image.length)
                        if (t.version > 0 && u.__version !== t.version) {
                            u.__image__webglTextureCube || (t.addEventListener("dispose", m), u.__image__webglTextureCube = e.createTexture(), o.memory.textures++), n.activeTexture(33984 + c), n.bindTexture(34067, u.__image__webglTextureCube), e.pixelStorei(37440, t.flipY);
                            for (var f = t && t.isCompressedTexture, v = t.image[0] && t.image[0].isDataTexture, g = [], y = 0; y < 6; y++) f || v ? g[y] = v ? t.image[y].image : t.image[y] : g[y] = s(t.image[y], r.maxCubemapSize);
                            var x = g[0],
                                b = l(x),
                                _ = a.convert(t.format),
                                w = a.convert(t.type),
                                T = p(_, w);
                            M(34067, t, b);
                            for (var y = 0; y < 6; y++)
                                if (f)
                                    for (var E, S = g[y].mipmaps, P = 0, C = S.length; P < C; P++) E = S[P], t.format !== js && t.format !== Us ? n.getCompressedTextureFormats().indexOf(_) > -1 ? n.compressedTexImage2D(34069 + y, P, T, E.width, E.height, 0, E.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + y, P, T, E.width, E.height, 0, _, w, E.data);
                                else v ? n.texImage2D(34069 + y, 0, T, g[y].width, g[y].height, 0, _, w, g[y].data) : n.texImage2D(34069 + y, 0, T, _, w, g[y]);
                            f ? u.__maxMipLevel = S.length - 1 : u.__maxMipLevel = 0, h(t, b) && d(34067, t, x.width, x.height), u.__version = t.version, t.onUpdate && t.onUpdate(t)
                        } else n.activeTexture(33984 + c), n.bindTexture(34067, u.__image__webglTextureCube)
                }

                function w(e, t) {
                    n.activeTexture(33984 + t), n.bindTexture(34067, i.get(e).__webglTexture)
                }

                function M(n, o, s) {
                    var l;
                    if (s ? (e.texParameteri(n, 10242, a.convert(o.wrapS)), e.texParameteri(n, 10243, a.convert(o.wrapT)), e.texParameteri(n, 10240, a.convert(o.magFilter)), e.texParameteri(n, 10241, a.convert(o.minFilter))) : (e.texParameteri(n, 10242, 33071), e.texParameteri(n, 10243, 33071), o.wrapS === ys && o.wrapT === ys || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, 10240, f(o.magFilter)), e.texParameteri(n, 10241, f(o.minFilter)), o.minFilter !== bs && o.minFilter !== Ms && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), l = t.get("EXT_texture_filter_anisotropic")) {
                        if (o.type === Is && null === t.get("OES_texture_float_linear")) return;
                        if (o.type === Os && null === (r.isWebGL2 || t.get("OES_texture_half_float_linear"))) return;
                        (o.anisotropy > 1 || i.get(o).__currentAnisotropy) && (e.texParameterf(n, l.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), i.get(o).__currentAnisotropy = o.anisotropy)
                    }
                }

                function T(t, i, f) {
                    var v;
                    v = i.isDataTexture3D ? 32879 : 3553, void 0 === t.__webglInit && (t.__webglInit = !0, i.addEventListener("dispose", m), t.__webglTexture = e.createTexture(), o.memory.textures++), n.activeTexture(33984 + f), n.bindTexture(v, t.__webglTexture), e.pixelStorei(37440, i.flipY), e.pixelStorei(37441, i.premultiplyAlpha), e.pixelStorei(3317, i.unpackAlignment);
                    var g = s(i.image, r.maxTextureSize);
                    u(i) && l(g) === !1 && (g = c(g));
                    var y = l(g),
                        x = a.convert(i.format),
                        b = a.convert(i.type),
                        _ = p(x, b);
                    M(v, i, y);
                    var w, T = i.mipmaps;
                    if (i.isDepthTexture) {
                        if (_ = 6402, i.type === Is) {
                            if (!r.isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
                            _ = 36012
                        } else r.isWebGL2 && (_ = 33189);
                        i.format === Vs && 6402 === _ && i.type !== As && i.type !== Rs && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = As, b = a.convert(i.type)), i.format === Ws && (_ = 34041, i.type !== Bs && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = Bs, b = a.convert(i.type))), n.texImage2D(3553, 0, _, g.width, g.height, 0, x, b, null)
                    } else if (i.isDataTexture)
                        if (T.length > 0 && y) {
                            for (var E = 0, S = T.length; E < S; E++) w = T[E], n.texImage2D(3553, E, _, w.width, w.height, 0, x, b, w.data);
                            i.generateMipmaps = !1, t.__maxMipLevel = T.length - 1
                        } else n.texImage2D(3553, 0, _, g.width, g.height, 0, x, b, g.data), t.__maxMipLevel = 0;
                    else if (i.isCompressedTexture) {
                        for (var E = 0, S = T.length; E < S; E++) w = T[E], i.format !== js && i.format !== Us ? n.getCompressedTextureFormats().indexOf(x) > -1 ? n.compressedTexImage2D(3553, E, _, w.width, w.height, 0, w.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, E, _, w.width, w.height, 0, x, b, w.data);
                        t.__maxMipLevel = T.length - 1
                    } else if (i.isDataTexture3D) n.texImage3D(32879, 0, _, g.width, g.height, g.depth, 0, x, b, g.data), t.__maxMipLevel = 0;
                    else if (T.length > 0 && y) {
                        for (var E = 0, S = T.length; E < S; E++) w = T[E], n.texImage2D(3553, E, _, x, b, w);
                        i.generateMipmaps = !1, t.__maxMipLevel = T.length - 1
                    } else n.texImage2D(3553, 0, _, x, b, g), t.__maxMipLevel = 0;
                    h(i, y) && d(3553, i, g.width, g.height), t.__version = i.version, i.onUpdate && i.onUpdate(i)
                }

                function E(t, r, o, s) {
                    var l = a.convert(r.texture.format),
                        c = a.convert(r.texture.type),
                        u = p(l, c);
                    n.texImage2D(s, 0, u, r.width, r.height, 0, l, c, null), e.bindFramebuffer(36160, t), e.framebufferTexture2D(36160, o, s, i.get(r.texture).__webglTexture, 0), e.bindFramebuffer(36160, null)
                }

                function S(t, n) {
                    e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer ? (e.renderbufferStorage(36161, 33189, n.width, n.height), e.framebufferRenderbuffer(36160, 36096, 36161, t)) : n.depthBuffer && n.stencilBuffer ? (e.renderbufferStorage(36161, 34041, n.width, n.height), e.framebufferRenderbuffer(36160, 33306, 36161, t)) : e.renderbufferStorage(36161, 32854, n.width, n.height), e.bindRenderbuffer(36161, null)
                }

                function P(t, n) {
                    var r = n && n.isWebGLRenderTargetCube;
                    if (r) throw new Error("Depth Texture with cube render targets is not supported");
                    if (e.bindFramebuffer(36160, t), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), x(n.depthTexture, 0);
                    var a = i.get(n.depthTexture).__webglTexture;
                    if (n.depthTexture.format === Vs) e.framebufferTexture2D(36160, 36096, 3553, a, 0);
                    else {
                        if (n.depthTexture.format !== Ws) throw new Error("Unknown depthTexture format");
                        e.framebufferTexture2D(36160, 33306, 3553, a, 0)
                    }
                }

                function C(t) {
                    var n = i.get(t),
                        r = t.isWebGLRenderTargetCube === !0;
                    if (t.depthTexture) {
                        if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                        P(n.__webglFramebuffer, t)
                    } else if (r) {
                        n.__webglDepthbuffer = [];
                        for (var a = 0; a < 6; a++) e.bindFramebuffer(36160, n.__webglFramebuffer[a]),
                            n.__webglDepthbuffer[a] = e.createRenderbuffer(), S(n.__webglDepthbuffer[a], t)
                    } else e.bindFramebuffer(36160, n.__webglFramebuffer), n.__webglDepthbuffer = e.createRenderbuffer(), S(n.__webglDepthbuffer, t);
                    e.bindFramebuffer(36160, null)
                }

                function A(t) {
                    var r = i.get(t),
                        a = i.get(t.texture);
                    t.addEventListener("dispose", v), a.__webglTexture = e.createTexture(), o.memory.textures++;
                    var s = t.isWebGLRenderTargetCube === !0,
                        c = l(t);
                    if (s) {
                        r.__webglFramebuffer = [];
                        for (var u = 0; u < 6; u++) r.__webglFramebuffer[u] = e.createFramebuffer()
                    } else r.__webglFramebuffer = e.createFramebuffer();
                    if (s) {
                        n.bindTexture(34067, a.__webglTexture), M(34067, t.texture, c);
                        for (var u = 0; u < 6; u++) E(r.__webglFramebuffer[u], t, 36064, 34069 + u);
                        h(t.texture, c) && d(34067, t.texture, t.width, t.height), n.bindTexture(34067, null)
                    } else n.bindTexture(3553, a.__webglTexture), M(3553, t.texture, c), E(r.__webglFramebuffer, t, 36064, 3553), h(t.texture, c) && d(3553, t.texture, t.width, t.height), n.bindTexture(3553, null);
                    t.depthBuffer && C(t)
                }

                function L(e) {
                    var t = e.texture,
                        r = l(e);
                    if (h(t, r)) {
                        var a = e.isWebGLRenderTargetCube ? 34067 : 3553,
                            o = i.get(t).__webglTexture;
                        n.bindTexture(a, o), d(a, t, e.width, e.height), n.bindTexture(a, null)
                    }
                }

                function R(e) {
                    var t = e.id,
                        n = o.render.frame;
                    O[t] !== n && (O[t] = n, e.update())
                }
                var I, O = {};
                this.setTexture2D = x, this.setTexture3D = b, this.setTextureCube = _, this.setTextureCubeDynamic = w, this.setupRenderTarget = A, this.updateRenderTargetMipmap = L
            }

            function xt(e, t, n) {
                function i(e) {
                    var i;
                    if (e === gs) return 10497;
                    if (e === ys) return 33071;
                    if (e === xs) return 33648;
                    if (e === bs) return 9728;
                    if (e === _s) return 9984;
                    if (e === ws) return 9986;
                    if (e === Ms) return 9729;
                    if (e === Ts) return 9985;
                    if (e === Es) return 9987;
                    if (e === Ss) return 5121;
                    if (e === ks) return 32819;
                    if (e === Ds) return 32820;
                    if (e === zs) return 33635;
                    if (e === Ps) return 5120;
                    if (e === Cs) return 5122;
                    if (e === As) return 5123;
                    if (e === Ls) return 5124;
                    if (e === Rs) return 5125;
                    if (e === Is) return 5126;
                    if (e === Os) {
                        if (n.isWebGL2) return 5131;
                        if (i = t.get("OES_texture_half_float"), null !== i) return i.HALF_FLOAT_OES
                    }
                    if (e === Ns) return 6406;
                    if (e === Us) return 6407;
                    if (e === js) return 6408;
                    if (e === Fs) return 6409;
                    if (e === Gs) return 6410;
                    if (e === Vs) return 6402;
                    if (e === Ws) return 34041;
                    if (e === qs) return 6403;
                    if (e === Ro) return 32774;
                    if (e === Io) return 32778;
                    if (e === Oo) return 32779;
                    if (e === zo) return 0;
                    if (e === Bo) return 1;
                    if (e === No) return 768;
                    if (e === Uo) return 769;
                    if (e === jo) return 770;
                    if (e === Fo) return 771;
                    if (e === Go) return 772;
                    if (e === Ho) return 773;
                    if (e === Vo) return 774;
                    if (e === Wo) return 775;
                    if (e === qo) return 776;
                    if ((e === Xs || e === Ys || e === Zs || e === Js) && (i = t.get("WEBGL_compressed_texture_s3tc"), null !== i)) {
                        if (e === Xs) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (e === Ys) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (e === Zs) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (e === Js) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if ((e === $s || e === Qs || e === Ks || e === el) && (i = t.get("WEBGL_compressed_texture_pvrtc"), null !== i)) {
                        if (e === $s) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (e === Qs) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (e === Ks) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (e === el) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (e === tl && (i = t.get("WEBGL_compressed_texture_etc1"), null !== i)) return i.COMPRESSED_RGB_ETC1_WEBGL;
                    if ((e === nl || e === il || e === rl || e === al || e === ol || e === sl || e === ll || e === cl || e === ul || e === hl || e === dl || e === pl || e === fl || e === ml) && (i = t.get("WEBGL_compressed_texture_astc"), null !== i)) return e;
                    if (e === ko || e === Do) {
                        if (n.isWebGL2) {
                            if (e === ko) return 32775;
                            if (e === Do) return 32776
                        }
                        if (i = t.get("EXT_blend_minmax"), null !== i) {
                            if (e === ko) return i.MIN_EXT;
                            if (e === Do) return i.MAX_EXT
                        }
                    }
                    if (e === Bs) {
                        if (n.isWebGL2) return 34042;
                        if (i = t.get("WEBGL_depth_texture"), null !== i) return i.UNSIGNED_INT_24_8_WEBGL
                    }
                    return 0
                }
                return {
                    convert: i
                }
            }

            function bt() {
                w.call(this), this.type = "Group"
            }

            function _t() {
                w.call(this), this.type = "Camera", this.matrixWorldInverse = new i, this.projectionMatrix = new i, this.projectionMatrixInverse = new i
            }

            function wt(e, t, n, i) {
                _t.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== i ? i : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }

            function Mt(e) {
                wt.call(this), this.cameras = e || []
            }

            function Tt(e, t, n) {
                bh.setFromMatrixPosition(t.matrixWorld), _h.setFromMatrixPosition(n.matrixWorld);
                var i = bh.distanceTo(_h),
                    r = t.projectionMatrix.elements,
                    a = n.projectionMatrix.elements,
                    o = r[14] / (r[10] - 1),
                    s = r[14] / (r[10] + 1),
                    l = (r[9] + 1) / r[5],
                    c = (r[9] - 1) / r[5],
                    u = (r[8] - 1) / r[0],
                    h = (a[8] + 1) / a[0],
                    d = o * u,
                    p = o * h,
                    f = i / (-u + h),
                    m = f * -u;
                t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.getInverse(e.matrixWorld);
                var v = o + f,
                    g = s + f,
                    y = d - m,
                    x = p + (i - m),
                    b = l * s / g * v,
                    _ = c * s / g * v;
                e.projectionMatrix.makePerspective(y, x, b, _, v, g)
            }

            function Et(e) {
                function t() {
                    return null !== u && u.isPresenting === !0
                }

                function n() {
                    if (t()) {
                        var n = u.getEyeParameters("left"),
                            i = n.renderWidth * v,
                            r = n.renderHeight * v;
                        S = e.getPixelRatio(), E = e.getSize(), e.setDrawingBufferSize(2 * i, r, 1), C.start()
                    } else c.enabled && e.setDrawingBufferSize(E.width, E.height, S), C.stop()
                }

                function o(e) {
                    for (var t = navigator.getGamepads && navigator.getGamepads(), n = 0, i = 0, r = t.length; n < r; n++) {
                        var a = t[n];
                        if (a && ("Daydream Controller" === a.id || "Gear VR Controller" === a.id || "Oculus Go Controller" === a.id || "OpenVR Gamepad" === a.id || a.id.startsWith("Oculus Touch") || a.id.startsWith("Spatial Controller"))) {
                            if (i === e) return a;
                            i++
                        }
                    }
                }

                function s() {
                    for (var e = 0; e < p.length; e++) {
                        var t = p[e],
                            n = o(e);
                        if (void 0 !== n && void 0 !== n.pose) {
                            if (null === n.pose) return;
                            var i = n.pose;
                            i.hasPosition === !1 && t.position.set(.2, -.6, -.05), null !== i.position && t.position.fromArray(i.position), null !== i.orientation && t.quaternion.fromArray(i.orientation), t.matrix.compose(t.position, t.quaternion, t.scale), t.matrix.premultiply(f), t.matrix.decompose(t.position, t.quaternion, t.scale), t.matrixWorldNeedsUpdate = !0, t.visible = !0;
                            var r = "Daydream Controller" === n.id ? 0 : 1;
                            P[e] !== n.buttons[r].pressed && (P[e] = n.buttons[r].pressed, P[e] === !0 ? t.dispatchEvent({
                                type: "selectstart"
                            }) : (t.dispatchEvent({
                                type: "selectend"
                            }), t.dispatchEvent({
                                type: "select"
                            })))
                        } else t.visible = !1
                    }
                }
                var c = this,
                    u = null,
                    h = null,
                    d = null,
                    p = [],
                    f = new i,
                    m = new i,
                    v = 1,
                    y = "stage";
                "undefined" != typeof window && "VRFrameData" in window && (h = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", n, !1));
                var x = new i,
                    b = new r,
                    _ = new a,
                    w = new wt;
                w.bounds = new l(0, 0, .5, 1), w.layers.enable(1);
                var M = new wt;
                M.bounds = new l(.5, 0, .5, 1), M.layers.enable(2);
                var T = new Mt([w, M]);
                T.layers.enable(1), T.layers.enable(2);
                var E, S, P = [];
                this.enabled = !1, this.getController = function (e) {
                    var t = p[e];
                    return void 0 === t && (t = new bt, t.matrixAutoUpdate = !1, t.visible = !1, p[e] = t), t
                }, this.getDevice = function () {
                    return u
                }, this.setDevice = function (e) {
                    void 0 !== e && (u = e), C.setContext(e)
                }, this.setFramebufferScaleFactor = function (e) {
                    v = e
                }, this.setFrameOfReferenceType = function (e) {
                    y = e
                }, this.setPoseTarget = function (e) {
                    void 0 !== e && (d = e)
                }, this.getCamera = function (e) {
                    var t = "stage" === y ? 1.6 : 0;
                    if (null === u) return e.position.set(0, t, 0), e;
                    if (u.depthNear = e.near, u.depthFar = e.far, u.getFrameData(h), "stage" === y) {
                        var n = u.stageParameters;
                        n ? f.fromArray(n.sittingToStandingTransform) : f.makeTranslation(0, t, 0)
                    }
                    var i = h.pose,
                        r = null !== d ? d : e;
                    if (r.matrix.copy(f), r.matrix.decompose(r.position, r.quaternion, r.scale), null !== i.orientation && (b.fromArray(i.orientation), r.quaternion.multiply(b)), null !== i.position && (b.setFromRotationMatrix(f), _.fromArray(i.position), _.applyQuaternion(b), r.position.add(_)), r.updateMatrixWorld(), u.isPresenting === !1) return e;
                    w.near = e.near, M.near = e.near, w.far = e.far, M.far = e.far, w.matrixWorldInverse.fromArray(h.leftViewMatrix), M.matrixWorldInverse.fromArray(h.rightViewMatrix), m.getInverse(f), "stage" === y && (w.matrixWorldInverse.multiply(m), M.matrixWorldInverse.multiply(m));
                    var a = r.parent;
                    null !== a && (x.getInverse(a.matrixWorld), w.matrixWorldInverse.multiply(x), M.matrixWorldInverse.multiply(x)), w.matrixWorld.getInverse(w.matrixWorldInverse), M.matrixWorld.getInverse(M.matrixWorldInverse), w.projectionMatrix.fromArray(h.leftProjectionMatrix), M.projectionMatrix.fromArray(h.rightProjectionMatrix), Tt(T, w, M);
                    var o = u.getLayers();
                    if (o.length) {
                        var l = o[0];
                        null !== l.leftBounds && 4 === l.leftBounds.length && w.bounds.fromArray(l.leftBounds), null !== l.rightBounds && 4 === l.rightBounds.length && M.bounds.fromArray(l.rightBounds)
                    }
                    return s(), T
                }, this.getStandingMatrix = function () {
                    return f
                }, this.isPresenting = t;
                var C = new g;
                this.setAnimationLoop = function (e) {
                    C.setAnimationLoop(e)
                }, this.submitFrame = function () {
                    t() && u.submitFrame()
                }, this.dispose = function () {
                    "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", n)
                }
            }

            function St(e) {
                function t() {
                    return null !== c && null !== h
                }

                function n(e) {
                    var t = f[m.indexOf(e.inputSource)];
                    t && t.dispatchEvent({
                        type: e.type
                    })
                }

                function i() {
                    e.setFramebuffer(null), _.stop()
                }

                function r(e, t) {
                    null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.getInverse(e.matrixWorld)
                }

                function a(e, t) {
                    if (p = t.getDevicePose(h), null !== p)
                        for (var n = c.baseLayer, i = t.views, r = 0; r < i.length; r++) {
                            var a = i[r],
                                o = n.getViewport(a),
                                s = p.getViewMatrix(a),
                                l = x.cameras[r];
                            l.matrix.fromArray(s).getInverse(l.matrix), l.projectionMatrix.fromArray(a.projectionMatrix), l.viewport.set(o.x, o.y, o.width, o.height), 0 === r && x.matrix.copy(l.matrix)
                        }
                    for (var r = 0; r < f.length; r++) {
                        var u = f[r],
                            d = m[r];
                        if (d) {
                            var v = t.getInputPose(d, h);
                            if (null !== v) {
                                "targetRay" in v ? u.matrix.elements = v.targetRay.transformMatrix : "pointerMatrix" in v && (u.matrix.elements = v.pointerMatrix), u.matrix.decompose(u.position, u.rotation, u.scale), u.visible = !0;
                                continue
                            }
                        }
                        u.visible = !1
                    }
                    b && b(e)
                }
                var o = e.context,
                    s = null,
                    c = null,
                    u = 1,
                    h = null,
                    d = "stage",
                    p = null,
                    f = [],
                    m = [],
                    v = new wt;
                v.layers.enable(1), v.viewport = new l;
                var y = new wt;
                y.layers.enable(2), y.viewport = new l;
                var x = new Mt([v, y]);
                x.layers.enable(1), x.layers.enable(2), this.enabled = !1, this.getController = function (e) {
                    var t = f[e];
                    return void 0 === t && (t = new bt, t.matrixAutoUpdate = !1, t.visible = !1, f[e] = t), t
                }, this.getDevice = function () {
                    return s
                }, this.setDevice = function (e) {
                    void 0 !== e && (s = e), e instanceof XRDevice && o.setCompatibleXRDevice(e)
                }, this.setFramebufferScaleFactor = function (e) {
                    u = e
                }, this.setFrameOfReferenceType = function (e) {
                    d = e
                }, this.setSession = function (t) {
                    c = t, null !== c && (c.addEventListener("select", n), c.addEventListener("selectstart", n), c.addEventListener("selectend", n), c.addEventListener("end", i), c.baseLayer = new XRWebGLLayer(c, o, {
                        framebufferScaleFactor: u
                    }), c.requestFrameOfReference(d).then(function (t) {
                        h = t, e.setFramebuffer(c.baseLayer.framebuffer), _.setContext(c), _.start()
                    }), m = c.getInputSources(), c.addEventListener("inputsourceschange", function () {
                        m = c.getInputSources(), console.log(m);
                        for (var e = 0; e < f.length; e++) {
                            var t = f[e];
                            t.userData.inputSource = m[e]
                        }
                    }))
                }, this.getCamera = function (e) {
                    if (t()) {
                        var n = e.parent,
                            i = x.cameras;
                        r(x, n);
                        for (var a = 0; a < i.length; a++) r(i[a], n);
                        e.matrixWorld.copy(x.matrixWorld);
                        for (var o = e.children, a = 0, s = o.length; a < s; a++) o[a].updateMatrixWorld(!0);
                        return Tt(x, v, y), x
                    }
                    return e
                }, this.isPresenting = t;
                var b = null,
                    _ = new g;
                _.setAnimationLoop(a), this.setAnimationLoop = function (e) {
                    b = e
                }, this.dispose = function () {}, this.getStandingMatrix = function () {
                    return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new THREE.Matrix4
                }, this.submitFrame = function () {}
            }

            function Pt(e) {
                function t() {
                    return null === he ? Me : 1
                }

                function n() {
                    De = new $(se), ze = new Z(se, De, e), ze.isWebGL2 || (De.get("WEBGL_depth_texture"), De.get("OES_texture_float"), De.get("OES_texture_half_float"), De.get("OES_texture_half_float_linear"), De.get("OES_standard_derivatives"), De.get("OES_element_index_uint"), De.get("ANGLE_instanced_arrays")), De.get("OES_texture_float_linear"), Qe = new xt(se, De, ze), Be = new gt(se, De, Qe, ze), Be.scissor(ye.copy(Ee).multiplyScalar(Me)), Be.viewport(ge.copy(Te).multiplyScalar(Me)), Ne = new ee(se), Ue = new at, je = new yt(se, De, Be, Ue, ze, Qe, Ne), Fe = new y(se), He = new Q(se, Fe, Ne), Ve = new ie(He, Ne), Ze = new ne(se), We = new rt(le, De, ze), qe = new ct, Xe = new pt, Ye = new X(le, Be, Ve, q), Je = new Y(se, De, Ne, ze), $e = new K(se, De, Ne, ze), Ne.programs = We.programs, le.context = se, le.capabilities = ze, le.extensions = De, le.properties = Ue, le.renderLists = qe, le.state = Be, le.info = Ne
                }

                function r(e) {
                    e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), ce = !0
                }

                function o() {
                    console.log("THREE.WebGLRenderer: Context Restored."), ce = !1, n()
                }

                function s(e) {
                    var t = e.target;
                    t.removeEventListener("dispose", s), c(t)
                }

                function c(e) {
                    u(e), Ue.remove(e)
                }

                function u(e) {
                    var t = Ue.get(e).program;
                    e.program = void 0, void 0 !== t && We.releaseProgram(t)
                }

                function d(e, t) {
                    e.render(function (e) {
                        le.renderBufferImmediate(e, t)
                    })
                }

                function p(e, t, n) {
                    if (n && n.isInstancedBufferGeometry & !ze.isWebGL2 && null === De.get("ANGLE_instanced_arrays")) return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    Be.initAttributes();
                    var i = n.attributes,
                        r = t.getAttributes(),
                        a = e.defaultAttributeValues;
                    for (var o in r) {
                        var s = r[o];
                        if (s >= 0) {
                            var l = i[o];
                            if (void 0 !== l) {
                                var c = l.normalized,
                                    u = l.itemSize,
                                    h = Fe.get(l);
                                if (void 0 === h) continue;
                                var d = h.buffer,
                                    p = h.type,
                                    f = h.bytesPerElement;
                                if (l.isInterleavedBufferAttribute) {
                                    var m = l.data,
                                        v = m.stride,
                                        g = l.offset;
                                    m && m.isInstancedInterleavedBuffer ? (Be.enableAttributeAndDivisor(s, m.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = m.meshPerAttribute * m.count)) : Be.enableAttribute(s), se.bindBuffer(34962, d), se.vertexAttribPointer(s, u, p, c, v * f, g * f)
                                } else l.isInstancedBufferAttribute ? (Be.enableAttributeAndDivisor(s, l.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = l.meshPerAttribute * l.count)) : Be.enableAttribute(s), se.bindBuffer(34962, d), se.vertexAttribPointer(s, u, p, c, 0, 0)
                            } else if (void 0 !== a) {
                                var y = a[o];
                                if (void 0 !== y) switch (y.length) {
                                    case 2:
                                        se.vertexAttrib2fv(s, y);
                                        break;
                                    case 3:
                                        se.vertexAttrib3fv(s, y);
                                        break;
                                    case 4:
                                        se.vertexAttrib4fv(s, y);
                                        break;
                                    default:
                                        se.vertexAttrib1fv(s, y)
                                }
                            }
                        }
                    }
                    Be.disableUnusedAttributes()
                }

                function f(e) {
                    Ke.isPresenting() || tt && tt(e)
                }

                function v(e, t, n) {
                    if (e.visible !== !1) {
                        var i = e.layers.test(t.layers);
                        if (i)
                            if (e.isLight) oe.pushLight(e), e.castShadow && oe.pushShadow(e);
                            else if (e.isSprite) {
                            if (!e.frustumCulled || Pe.intersectsSprite(e)) {
                                n && Ie.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Re);
                                var r = Ve.update(e),
                                    a = e.material;
                                ae.push(e, r, a, Ie.z, null)
                            }
                        } else if (e.isImmediateRenderObject) n && Ie.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Re), ae.push(e, null, e.material, Ie.z, null);
                        else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(), !e.frustumCulled || Pe.intersectsObject(e))) {
                            n && Ie.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Re);
                            var r = Ve.update(e),
                                a = e.material;
                            if (Array.isArray(a))
                                for (var o = r.groups, s = 0, l = o.length; s < l; s++) {
                                    var c = o[s],
                                        u = a[c.materialIndex];
                                    u && u.visible && ae.push(e, r, u, Ie.z, c)
                                } else a.visible && ae.push(e, r, a, Ie.z, null)
                        }
                        for (var h = e.children, s = 0, l = h.length; s < l; s++) v(h[s], t, n)
                    }
                }

                function x(e, t, n, i) {
                    for (var r = 0, a = e.length; r < a; r++) {
                        var o = e[r],
                            s = o.object,
                            l = o.geometry,
                            c = void 0 === i ? o.material : i,
                            u = o.group;
                        if (n.isArrayCamera) {
                            ve = n;
                            for (var h = n.cameras, d = 0, p = h.length; d < p; d++) {
                                var f = h[d];
                                if (s.layers.test(f.layers)) {
                                    if ("viewport" in f) Be.viewport(ge.copy(f.viewport));
                                    else {
                                        var m = f.bounds,
                                            v = m.x * _e,
                                            g = m.y * we,
                                            y = m.z * _e,
                                            x = m.w * we;
                                        Be.viewport(ge.set(v, g, y, x).multiplyScalar(Me))
                                    }
                                    oe.setupLights(f), b(s, t, f, l, c, u)
                                }
                            }
                        } else ve = null, b(s, t, n, l, c, u)
                    }
                }

                function b(e, t, n, i, r, a) {
                    if (e.onBeforeRender(le, t, n, i, r, a), oe = Xe.get(t, ve || n), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) {
                        Be.setMaterial(r);
                        var o = w(n, t.fog, r, e);
                        fe.geometry = null, fe.program = null, fe.wireframe = !1, d(e, o)
                    } else le.renderBufferDirect(n, t.fog, i, r, e, a);
                    e.onAfterRender(le, t, n, i, r, a), oe = Xe.get(t, ve || n)
                }

                function _(e, t, n) {
                    var i = Ue.get(e),
                        r = oe.state.lights,
                        a = oe.state.shadowsArray,
                        o = i.lightsHash,
                        l = r.state.hash,
                        c = We.getParameters(e, r.state, a, t, Ce.numPlanes, Ce.numIntersection, n),
                        h = We.getProgramCode(e, c),
                        d = i.program,
                        p = !0;
                    if (void 0 === d) e.addEventListener("dispose", s);
                    else if (d.code !== h) u(e);
                    else if (o.stateID !== l.stateID || o.directionalLength !== l.directionalLength || o.pointLength !== l.pointLength || o.spotLength !== l.spotLength || o.rectAreaLength !== l.rectAreaLength || o.hemiLength !== l.hemiLength || o.shadowsLength !== l.shadowsLength) o.stateID = l.stateID, o.directionalLength = l.directionalLength, o.pointLength = l.pointLength, o.spotLength = l.spotLength, o.rectAreaLength = l.rectAreaLength, o.hemiLength = l.hemiLength, o.shadowsLength = l.shadowsLength, p = !1;
                    else {
                        if (void 0 !== c.shaderID) return;
                        p = !1
                    }
                    if (p) {
                        if (c.shaderID) {
                            var f = rh[c.shaderID];
                            i.shader = {
                                name: e.type,
                                uniforms: th.clone(f.uniforms),
                                vertexShader: f.vertexShader,
                                fragmentShader: f.fragmentShader
                            }
                        } else i.shader = {
                            name: e.type,
                            uniforms: e.uniforms,
                            vertexShader: e.vertexShader,
                            fragmentShader: e.fragmentShader
                        };
                        e.onBeforeCompile(i.shader, le), h = We.getProgramCode(e, c), d = We.acquireProgram(e, i.shader, c, h), i.program = d, e.program = d
                    }
                    var m = d.getAttributes();
                    if (e.morphTargets) {
                        e.numSupportedMorphTargets = 0;
                        for (var v = 0; v < le.maxMorphTargets; v++) m["morphTarget" + v] >= 0 && e.numSupportedMorphTargets++
                    }
                    if (e.morphNormals) {
                        e.numSupportedMorphNormals = 0;
                        for (var v = 0; v < le.maxMorphNormals; v++) m["morphNormal" + v] >= 0 && e.numSupportedMorphNormals++
                    }
                    var g = i.shader.uniforms;
                    (e.isShaderMaterial || e.isRawShaderMaterial) && e.clipping !== !0 || (i.numClippingPlanes = Ce.numPlanes, i.numIntersection = Ce.numIntersection, g.clippingPlanes = Ce.uniform), i.fog = t, void 0 === o && (i.lightsHash = o = {}), o.stateID = l.stateID, o.directionalLength = l.directionalLength, o.pointLength = l.pointLength, o.spotLength = l.spotLength, o.rectAreaLength = l.rectAreaLength, o.hemiLength = l.hemiLength, o.shadowsLength = l.shadowsLength, e.lights && (g.ambientLightColor.value = r.state.ambient, g.directionalLights.value = r.state.directional, g.spotLights.value = r.state.spot, g.rectAreaLights.value = r.state.rectArea, g.pointLights.value = r.state.point, g.hemisphereLights.value = r.state.hemi, g.directionalShadowMap.value = r.state.directionalShadowMap, g.directionalShadowMatrix.value = r.state.directionalShadowMatrix, g.spotShadowMap.value = r.state.spotShadowMap, g.spotShadowMatrix.value = r.state.spotShadowMatrix, g.pointShadowMap.value = r.state.pointShadowMap, g.pointShadowMatrix.value = r.state.pointShadowMatrix);
                    var y = i.program.getUniforms(),
                        x = Ge.seqWithValue(y.seq, g);
                    i.uniformsList = x
                }

                function w(e, t, n, i) {
                    be = 0;
                    var r = Ue.get(n),
                        a = oe.state.lights,
                        o = r.lightsHash,
                        s = a.state.hash;
                    if (Ae && (Le || e !== me)) {
                        var l = e === me && n.id === pe;
                        Ce.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, e, r, l)
                    }
                    n.needsUpdate === !1 && (void 0 === r.program ? n.needsUpdate = !0 : n.fog && r.fog !== t ? n.needsUpdate = !0 : !n.lights || o.stateID === s.stateID && o.directionalLength === s.directionalLength && o.pointLength === s.pointLength && o.spotLength === s.spotLength && o.rectAreaLength === s.rectAreaLength && o.hemiLength === s.hemiLength && o.shadowsLength === s.shadowsLength ? void 0 === r.numClippingPlanes || r.numClippingPlanes === Ce.numPlanes && r.numIntersection === Ce.numIntersection || (n.needsUpdate = !0) : n.needsUpdate = !0), n.needsUpdate && (_(n, t, i), n.needsUpdate = !1);
                    var c = !1,
                        u = !1,
                        d = !1,
                        p = r.program,
                        f = p.getUniforms(),
                        m = r.shader.uniforms;
                    if (Be.useProgram(p.program) && (c = !0, u = !0, d = !0), n.id !== pe && (pe = n.id, u = !0), c || me !== e) {
                        if (f.setValue(se, "projectionMatrix", e.projectionMatrix), ze.logarithmicDepthBuffer && f.setValue(se, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), me !== e && (me = e, u = !0, d = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) {
                            var v = f.map.cameraPosition;
                            void 0 !== v && v.setValue(se, Ie.setFromMatrixPosition(e.matrixWorld))
                        }(n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && f.setValue(se, "viewMatrix", e.matrixWorldInverse)
                    }
                    if (n.skinning) {
                        f.setOptional(se, i, "bindMatrix"), f.setOptional(se, i, "bindMatrixInverse");
                        var g = i.skeleton;
                        if (g) {
                            var y = g.bones;
                            if (ze.floatVertexTextures) {
                                if (void 0 === g.boneTexture) {
                                    var x = Math.sqrt(4 * y.length);
                                    x = jl.ceilPowerOfTwo(x), x = Math.max(x, 4);
                                    var b = new Float32Array(x * x * 4);
                                    b.set(g.boneMatrices);
                                    var w = new h(b, x, x, js, Is);
                                    w.needsUpdate = !0, g.boneMatrices = b, g.boneTexture = w, g.boneTextureSize = x
                                }
                                f.setValue(se, "boneTexture", g.boneTexture), f.setValue(se, "boneTextureSize", g.boneTextureSize)
                            } else f.setOptional(se, g, "boneMatrices")
                        }
                    }
                    return u && (f.setValue(se, "toneMappingExposure", le.toneMappingExposure), f.setValue(se, "toneMappingWhitePoint", le.toneMappingWhitePoint), n.lights && N(m, d), t && n.fog && C(m, t), n.isMeshBasicMaterial ? M(m, n) : n.isMeshLambertMaterial ? (M(m, n), A(m, n)) : n.isMeshPhongMaterial ? (M(m, n), n.isMeshToonMaterial ? R(m, n) : L(m, n)) : n.isMeshStandardMaterial ? (M(m, n), n.isMeshPhysicalMaterial ? O(m, n) : I(m, n)) : n.isMeshMatcapMaterial ? (M(m, n), k(m, n)) : n.isMeshDepthMaterial ? (M(m, n), D(m, n)) : n.isMeshDistanceMaterial ? (M(m, n), z(m, n)) : n.isMeshNormalMaterial ? (M(m, n), B(m, n)) : n.isLineBasicMaterial ? (T(m, n), n.isLineDashedMaterial && E(m, n)) : n.isPointsMaterial ? S(m, n) : n.isSpriteMaterial ? P(m, n) : n.isShadowMaterial && (m.color.value = n.color, m.opacity.value = n.opacity), void 0 !== m.ltc_1 && (m.ltc_1.value = ih.LTC_1), void 0 !== m.ltc_2 && (m.ltc_2.value = ih.LTC_2), Ge.upload(se, r.uniformsList, m, le)), n.isShaderMaterial && n.uniformsNeedUpdate === !0 && (Ge.upload(se, r.uniformsList, m, le), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && f.setValue(se, "center", i.center), f.setValue(se, "modelViewMatrix", i.modelViewMatrix), f.setValue(se, "normalMatrix", i.normalMatrix), f.setValue(se, "modelMatrix", i.matrixWorld), p
                }

                function M(e, t) {
                    e.opacity.value = t.opacity, t.color && (e.diffuse.value = t.color), t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.specularMap && (e.specularMap.value = t.specularMap), t.envMap && (e.envMap.value = t.envMap, e.flipEnvMap.value = t.envMap && t.envMap.isCubeTexture ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio, e.maxMipLevel.value = Ue.get(t.envMap).__maxMipLevel), t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity);
                    var n;
                    t.map ? n = t.map : t.specularMap ? n = t.specularMap : t.displacementMap ? n = t.displacementMap : t.normalMap ? n = t.normalMap : t.bumpMap ? n = t.bumpMap : t.roughnessMap ? n = t.roughnessMap : t.metalnessMap ? n = t.metalnessMap : t.alphaMap ? n = t.alphaMap : t.emissiveMap && (n = t.emissiveMap), void 0 !== n && (n.isWebGLRenderTarget && (n = n.texture), n.matrixAutoUpdate === !0 && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
                }

                function T(e, t) {
                    e.diffuse.value = t.color, e.opacity.value = t.opacity
                }

                function E(e, t) {
                    e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
                }

                function S(e, t) {
                    e.diffuse.value = t.color, e.opacity.value = t.opacity, e.size.value = t.size * Me, e.scale.value = .5 * we, e.map.value = t.map, null !== t.map && (t.map.matrixAutoUpdate === !0 && t.map.updateMatrix(), e.uvTransform.value.copy(t.map.matrix))
                }

                function P(e, t) {
                    e.diffuse.value = t.color, e.opacity.value = t.opacity, e.rotation.value = t.rotation, e.map.value = t.map, null !== t.map && (t.map.matrixAutoUpdate === !0 && t.map.updateMatrix(), e.uvTransform.value.copy(t.map.matrix))
                }

                function C(e, t) {
                    e.fogColor.value = t.color, t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
                }

                function A(e, t) {
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
                }

                function L(e, t) {
                    e.specular.value = t.specular, e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === yo && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === yo && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }

                function R(e, t) {
                    L(e, t), t.gradientMap && (e.gradientMap.value = t.gradientMap)
                }

                function I(e, t) {
                    e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === yo && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === yo && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
                }

                function O(e, t) {
                    I(e, t), e.reflectivity.value = t.reflectivity, e.clearCoat.value = t.clearCoat, e.clearCoatRoughness.value = t.clearCoatRoughness
                }

                function k(e, t) {
                    t.matcap && (e.matcap.value = t.matcap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === yo && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === yo && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }

                function D(e, t) {
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }

                function z(e, t) {
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance
                }

                function B(e, t) {
                    t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === yo && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === yo && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }

                function N(e, t) {
                    e.ambientLightColor.needsUpdate = t, e.directionalLights.needsUpdate = t, e.pointLights.needsUpdate = t, e.spotLights.needsUpdate = t, e.rectAreaLights.needsUpdate = t, e.hemisphereLights.needsUpdate = t
                }

                function U() {
                    var e = be;
                    return e >= ze.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + e + " texture units while this GPU supports only " + ze.maxTextures), be += 1, e
                }
                console.log("THREE.WebGLRenderer", ao), e = e || {};
                var j = void 0 !== e.canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                    F = void 0 !== e.context ? e.context : null,
                    G = void 0 !== e.alpha && e.alpha,
                    H = void 0 === e.depth || e.depth,
                    V = void 0 === e.stencil || e.stencil,
                    W = void 0 !== e.antialias && e.antialias,
                    q = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
                    te = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
                    re = void 0 !== e.powerPreference ? e.powerPreference : "default",
                    ae = null,
                    oe = null;
                this.domElement = j, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = as, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
                var se, le = this,
                    ce = !1,
                    ue = null,
                    he = null,
                    de = null,
                    pe = -1,
                    fe = {
                        geometry: null,
                        program: null,
                        wireframe: !1
                    },
                    me = null,
                    ve = null,
                    ge = new l,
                    ye = new l,
                    xe = null,
                    be = 0,
                    _e = j.width,
                    we = j.height,
                    Me = 1,
                    Te = new l(0, 0, _e, we),
                    Ee = new l(0, 0, _e, we),
                    Se = !1,
                    Pe = new m,
                    Ce = new J,
                    Ae = !1,
                    Le = !1,
                    Re = new i,
                    Ie = new a;
                try {
                    var Oe = {
                        alpha: G,
                        depth: H,
                        stencil: V,
                        antialias: W,
                        premultipliedAlpha: q,
                        preserveDrawingBuffer: te,
                        powerPreference: re
                    };
                    if (j.addEventListener("webglcontextlost", r, !1), j.addEventListener("webglcontextrestored", o, !1), se = F || j.getContext("webgl", Oe) || j.getContext("experimental-webgl", Oe), null === se) throw null !== j.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                    void 0 === se.getShaderPrecisionFormat && (se.getShaderPrecisionFormat = function () {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (ke) {
                    console.error("THREE.WebGLRenderer: " + ke.message)
                }
                var De, ze, Be, Ne, Ue, je, Fe, He, Ve, We, qe, Xe, Ye, Ze, Je, $e, Qe;
                n();
                var Ke = null;
                "undefined" != typeof navigator && (Ke = "xr" in navigator ? new St(le) : new Et(le)), this.vr = Ke;
                var et = new vt(le, Ve, ze.maxTextureSize);
                this.shadowMap = et, this.getContext = function () {
                    return se
                }, this.getContextAttributes = function () {
                    return se.getContextAttributes()
                }, this.forceContextLoss = function () {
                    var e = De.get("WEBGL_lose_context");
                    e && e.loseContext()
                }, this.forceContextRestore = function () {
                    var e = De.get("WEBGL_lose_context");
                    e && e.restoreContext()
                }, this.getPixelRatio = function () {
                    return Me
                }, this.setPixelRatio = function (e) {
                    void 0 !== e && (Me = e, this.setSize(_e, we, !1))
                }, this.getSize = function () {
                    return {
                        width: _e,
                        height: we
                    }
                }, this.setSize = function (e, t, n) {
                    return Ke.isPresenting() ? void console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (_e = e, we = t, j.width = e * Me, j.height = t * Me, n !== !1 && (j.style.width = e + "px", j.style.height = t + "px"), void this.setViewport(0, 0, e, t))
                }, this.getDrawingBufferSize = function () {
                    return {
                        width: _e * Me,
                        height: we * Me
                    }
                }, this.setDrawingBufferSize = function (e, t, n) {
                    _e = e, we = t, Me = n, j.width = e * n, j.height = t * n, this.setViewport(0, 0, e, t)
                }, this.getCurrentViewport = function () {
                    return ge
                }, this.setViewport = function (e, t, n, i) {
                    Te.set(e, we - t - i, n, i), Be.viewport(ge.copy(Te).multiplyScalar(Me))
                }, this.setScissor = function (e, t, n, i) {
                    Ee.set(e, we - t - i, n, i), Be.scissor(ye.copy(Ee).multiplyScalar(Me))
                }, this.setScissorTest = function (e) {
                    Be.setScissorTest(Se = e)
                }, this.getClearColor = function () {
                    return Ye.getClearColor()
                }, this.setClearColor = function () {
                    Ye.setClearColor.apply(Ye, arguments)
                }, this.getClearAlpha = function () {
                    return Ye.getClearAlpha()
                }, this.setClearAlpha = function () {
                    Ye.setClearAlpha.apply(Ye, arguments)
                }, this.clear = function (e, t, n) {
                    var i = 0;
                    (void 0 === e || e) && (i |= 16384), (void 0 === t || t) && (i |= 256), (void 0 === n || n) && (i |= 1024), se.clear(i)
                }, this.clearColor = function () {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function () {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function () {
                    this.clear(!1, !1, !0)
                }, this.dispose = function () {
                    j.removeEventListener("webglcontextlost", r, !1), j.removeEventListener("webglcontextrestored", o, !1), qe.dispose(), Xe.dispose(), Ue.dispose(), Ve.dispose(), Ke.dispose(), nt.stop()
                }, this.renderBufferImmediate = function (e, t) {
                    Be.initAttributes();
                    var n = Ue.get(e);
                    e.hasPositions && !n.position && (n.position = se.createBuffer()), e.hasNormals && !n.normal && (n.normal = se.createBuffer()), e.hasUvs && !n.uv && (n.uv = se.createBuffer()), e.hasColors && !n.color && (n.color = se.createBuffer());
                    var i = t.getAttributes();
                    e.hasPositions && (se.bindBuffer(34962, n.position), se.bufferData(34962, e.positionArray, 35048), Be.enableAttribute(i.position), se.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)), e.hasNormals && (se.bindBuffer(34962, n.normal), se.bufferData(34962, e.normalArray, 35048), Be.enableAttribute(i.normal), se.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (se.bindBuffer(34962, n.uv), se.bufferData(34962, e.uvArray, 35048), Be.enableAttribute(i.uv), se.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)), e.hasColors && (se.bindBuffer(34962, n.color), se.bufferData(34962, e.colorArray, 35048), Be.enableAttribute(i.color), se.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)), Be.disableUnusedAttributes(), se.drawArrays(4, 0, e.count), e.count = 0
                }, this.renderBufferDirect = function (e, n, i, r, a, o) {
                    var s = a.isMesh && a.normalMatrix.determinant() < 0;
                    Be.setMaterial(r, s);
                    var l = w(e, n, r, a),
                        c = !1;
                    fe.geometry === i.id && fe.program === l.id && fe.wireframe === (r.wireframe === !0) || (fe.geometry = i.id, fe.program = l.id, fe.wireframe = r.wireframe === !0, c = !0), a.morphTargetInfluences && (Ze.update(a, i, r, l), c = !0);
                    var u = i.index,
                        h = i.attributes.position,
                        d = 1;
                    r.wireframe === !0 && (u = He.getWireframeAttribute(i), d = 2);
                    var f, m = Je;
                    null !== u && (f = Fe.get(u), m = $e, m.setIndex(f)), c && (p(r, l, i), null !== u && se.bindBuffer(34963, f.buffer));
                    var v = 1 / 0;
                    null !== u ? v = u.count : void 0 !== h && (v = h.count);
                    var g = i.drawRange.start * d,
                        y = i.drawRange.count * d,
                        x = null !== o ? o.start * d : 0,
                        b = null !== o ? o.count * d : 1 / 0,
                        _ = Math.max(g, x),
                        M = Math.min(v, g + y, x + b) - 1,
                        T = Math.max(0, M - _ + 1);
                    if (0 !== T) {
                        if (a.isMesh)
                            if (r.wireframe === !0) Be.setLineWidth(r.wireframeLinewidth * t()), m.setMode(1);
                            else switch (a.drawMode) {
                                case El:
                                    m.setMode(4);
                                    break;
                                case Sl:
                                    m.setMode(5);
                                    break;
                                case Pl:
                                    m.setMode(6)
                            } else if (a.isLine) {
                                var E = r.linewidth;
                                void 0 === E && (E = 1),
                                    Be.setLineWidth(E * t()), a.isLineSegments ? m.setMode(1) : a.isLineLoop ? m.setMode(2) : m.setMode(3)
                            } else a.isPoints ? m.setMode(0) : a.isSprite && m.setMode(4);
                        i && i.isInstancedBufferGeometry ? i.maxInstancedCount > 0 && m.renderInstances(i, _, T) : m.render(_, T)
                    }
                }, this.compile = function (e, t) {
                    oe = Xe.get(e, t), oe.init(), e.traverse(function (e) {
                        e.isLight && (oe.pushLight(e), e.castShadow && oe.pushShadow(e))
                    }), oe.setupLights(t), e.traverse(function (t) {
                        if (t.material)
                            if (Array.isArray(t.material))
                                for (var n = 0; n < t.material.length; n++) _(t.material[n], e.fog, t);
                            else _(t.material, e.fog, t)
                    })
                };
                var tt = null,
                    nt = new g;
                nt.setAnimationLoop(f), "undefined" != typeof window && nt.setContext(window), this.setAnimationLoop = function (e) {
                    tt = e, Ke.setAnimationLoop(e), nt.start()
                }, this.render = function (e, t, n, i) {
                    if (!t || !t.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!ce) {
                        fe.geometry = null, fe.program = null, fe.wireframe = !1, pe = -1, me = null, e.autoUpdate === !0 && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), Ke.enabled && (t = Ke.getCamera(t)), oe = Xe.get(e, t), oe.init(), e.onBeforeRender(le, e, t, n), Re.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), Pe.setFromMatrix(Re), Le = this.localClippingEnabled, Ae = Ce.init(this.clippingPlanes, Le, t), ae = qe.get(e, t), ae.init(), v(e, t, le.sortObjects), le.sortObjects === !0 && ae.sort(), Ae && Ce.beginShadows();
                        var r = oe.state.shadowsArray;
                        et.render(r, e, t), oe.setupLights(t), Ae && Ce.endShadows(), this.info.autoReset && this.info.reset(), void 0 === n && (n = null), this.setRenderTarget(n), Ye.render(ae, e, t, i);
                        var a = ae.opaque,
                            o = ae.transparent;
                        if (e.overrideMaterial) {
                            var s = e.overrideMaterial;
                            a.length && x(a, e, t, s), o.length && x(o, e, t, s)
                        } else a.length && x(a, e, t), o.length && x(o, e, t);
                        n && je.updateRenderTargetMipmap(n), Be.buffers.depth.setTest(!0), Be.buffers.depth.setMask(!0), Be.buffers.color.setMask(!0), Be.setPolygonOffset(!1), e.onAfterRender(le, e, t), Ke.enabled && Ke.submitFrame(), ae = null, oe = null
                    }
                }, this.allocTextureUnit = U, this.setTexture2D = function () {
                    var e = !1;
                    return function (t, n) {
                        t && t.isWebGLRenderTarget && (e || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), e = !0), t = t.texture), je.setTexture2D(t, n)
                    }
                }(), this.setTexture3D = function () {
                    return function (e, t) {
                        je.setTexture3D(e, t)
                    }
                }(), this.setTexture = function () {
                    var e = !1;
                    return function (t, n) {
                        e || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), e = !0), je.setTexture2D(t, n)
                    }
                }(), this.setTextureCube = function () {
                    var e = !1;
                    return function (t, n) {
                        t && t.isWebGLRenderTargetCube && (e || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), e = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? je.setTextureCube(t, n) : je.setTextureCubeDynamic(t, n)
                    }
                }(), this.setFramebuffer = function (e) {
                    ue = e
                }, this.getRenderTarget = function () {
                    return he
                }, this.setRenderTarget = function (e) {
                    he = e, e && void 0 === Ue.get(e).__webglFramebuffer && je.setupRenderTarget(e);
                    var t = ue,
                        n = !1;
                    if (e) {
                        var i = Ue.get(e).__webglFramebuffer;
                        e.isWebGLRenderTargetCube ? (t = i[e.activeCubeFace], n = !0) : t = i, ge.copy(e.viewport), ye.copy(e.scissor), xe = e.scissorTest
                    } else ge.copy(Te).multiplyScalar(Me), ye.copy(Ee).multiplyScalar(Me), xe = Se;
                    if (de !== t && (se.bindFramebuffer(36160, t), de = t), Be.viewport(ge), Be.scissor(ye), Be.setScissorTest(xe), n) {
                        var r = Ue.get(e.texture);
                        se.framebufferTexture2D(36160, 36064, 34069 + e.activeCubeFace, r.__webglTexture, e.activeMipMapLevel)
                    }
                }, this.readRenderTargetPixels = function (e, t, n, i, r, a) {
                    if (!e || !e.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    var o = Ue.get(e).__webglFramebuffer;
                    if (o) {
                        var s = !1;
                        o !== de && (se.bindFramebuffer(36160, o), s = !0);
                        try {
                            var l = e.texture,
                                c = l.format,
                                u = l.type;
                            if (c !== js && Qe.convert(c) !== se.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            if (!(u === Ss || Qe.convert(u) === se.getParameter(35738) || u === Is && (ze.isWebGL2 || De.get("OES_texture_float") || De.get("WEBGL_color_buffer_float")) || u === Os && (ze.isWebGL2 ? De.get("EXT_color_buffer_float") : De.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            36053 === se.checkFramebufferStatus(36160) ? t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && se.readPixels(t, n, i, r, Qe.convert(c), Qe.convert(u), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                        } finally {
                            s && se.bindFramebuffer(36160, de)
                        }
                    }
                }, this.copyFramebufferToTexture = function (e, t, n) {
                    var i = t.image.width,
                        r = t.image.height,
                        a = Qe.convert(t.format);
                    this.setTexture2D(t, 0), se.copyTexImage2D(3553, n || 0, a, e.x, e.y, i, r, 0)
                }, this.copyTextureToTexture = function (e, t, n, i) {
                    var r = t.image.width,
                        a = t.image.height,
                        o = Qe.convert(n.format),
                        s = Qe.convert(n.type);
                    this.setTexture2D(n, 0), t.isDataTexture ? se.texSubImage2D(3553, i || 0, e.x, e.y, r, a, o, s, t.image.data) : se.texSubImage2D(3553, i || 0, e.x, e.y, o, s, t.image)
                }
            }

            function Ct(e, t) {
                this.name = "", this.color = new v(e), this.density = void 0 !== t ? t : 25e-5
            }

            function At(e, t, n) {
                this.name = "", this.color = new v(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== n ? n : 1e3
            }

            function Lt() {
                w.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
            }

            function Rt(e, t) {
                this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function It(e, t, n, i) {
                this.data = e, this.itemSize = t, this.offset = n, this.normalized = i === !0
            }

            function Ot(e) {
                F.call(this), this.type = "SpriteMaterial", this.color = new v(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(e)
            }

            function kt(e) {
                if (w.call(this), this.type = "Sprite", void 0 === wh) {
                    wh = new z;
                    var t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                        i = new Rt(t, 5);
                    wh.setIndex([0, 1, 2, 0, 2, 3]), wh.addAttribute("position", new It(i, 3, 0, (!1))), wh.addAttribute("uv", new It(i, 2, 3, (!1)))
                }
                this.geometry = wh, this.material = void 0 !== e ? e : new Ot, this.center = new n(.5, .5)
            }

            function Dt() {
                w.call(this), this.type = "LOD", Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    }
                })
            }

            function zt(e, t) {
                if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === t) this.calculateInverses();
                else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
                else {
                    console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
                    for (var n = 0, r = this.bones.length; n < r; n++) this.boneInverses.push(new i)
                }
            }

            function Bt() {
                w.call(this), this.type = "Bone"
            }

            function Nt(e, t) {
                q.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new i, this.bindMatrixInverse = new i;
                var n = this.initBones(),
                    r = new zt(n);
                this.bind(r, this.matrixWorld), this.normalizeSkinWeights()
            }

            function Ut(e) {
                F.call(this), this.type = "LineBasicMaterial", this.color = new v(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(e)
            }

            function jt(e, t, n) {
                1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), w.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new z, this.material = void 0 !== t ? t : new Ut({
                    color: 16777215 * Math.random()
                })
            }

            function Ft(e, t) {
                jt.call(this, e, t), this.type = "LineSegments"
            }

            function Gt(e, t) {
                jt.call(this, e, t), this.type = "LineLoop"
            }

            function Ht(e) {
                F.call(this), this.type = "PointsMaterial", this.color = new v(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.lights = !1, this.setValues(e)
            }

            function Vt(e, t) {
                w.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new z, this.material = void 0 !== t ? t : new Ht({
                    color: 16777215 * Math.random()
                })
            }

            function Wt(e, t, n, i, r, a, o, l, c) {
                s.call(this, e, t, n, i, r, a, o, l, c), this.generateMipmaps = !1
            }

            function qt(e, t, n, i, r, a, o, l, c, u, h, d) {
                s.call(this, null, a, o, l, c, u, i, r, h, d), this.image = {
                    width: t,
                    height: n
                }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
            }

            function Xt(e, t, n, i, r, a, o, l, c) {
                s.call(this, e, t, n, i, r, a, o, l, c), this.needsUpdate = !0
            }

            function Yt(e, t, n, i, r, a, o, l, c, u) {
                if (u = void 0 !== u ? u : Vs, u !== Vs && u !== Ws) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && u === Vs && (n = As), void 0 === n && u === Ws && (n = Bs), s.call(this, null, i, r, a, o, l, u, n, c), this.image = {
                    width: e,
                    height: t
                }, this.magFilter = void 0 !== o ? o : bs, this.minFilter = void 0 !== l ? l : bs, this.flipY = !1, this.generateMipmaps = !1
            }

            function Zt(e) {
                z.call(this), this.type = "WireframeGeometry";
                var t, n, i, r, o, s, l, c, u, h, d = [],
                    p = [0, 0],
                    f = {},
                    m = ["a", "b", "c"];
                if (e && e.isGeometry) {
                    var v = e.faces;
                    for (t = 0, i = v.length; t < i; t++) {
                        var g = v[t];
                        for (n = 0; n < 3; n++) l = g[m[n]], c = g[m[(n + 1) % 3]], p[0] = Math.min(l, c), p[1] = Math.max(l, c), u = p[0] + "," + p[1], void 0 === f[u] && (f[u] = {
                            index1: p[0],
                            index2: p[1]
                        })
                    }
                    for (u in f) s = f[u], h = e.vertices[s.index1], d.push(h.x, h.y, h.z), h = e.vertices[s.index2], d.push(h.x, h.y, h.z)
                } else if (e && e.isBufferGeometry) {
                    var y, x, b, _, w, M, T, E;
                    if (h = new a, null !== e.index) {
                        for (y = e.attributes.position, x = e.index, b = e.groups, 0 === b.length && (b = [{
                                start: 0,
                                count: x.count,
                                materialIndex: 0
                            }]), r = 0, o = b.length; r < o; ++r)
                            for (_ = b[r], w = _.start, M = _.count, t = w, i = w + M; t < i; t += 3)
                                for (n = 0; n < 3; n++) l = x.getX(t + n), c = x.getX(t + (n + 1) % 3), p[0] = Math.min(l, c), p[1] = Math.max(l, c), u = p[0] + "," + p[1], void 0 === f[u] && (f[u] = {
                                    index1: p[0],
                                    index2: p[1]
                                });
                        for (u in f) s = f[u], h.fromBufferAttribute(y, s.index1), d.push(h.x, h.y, h.z), h.fromBufferAttribute(y, s.index2), d.push(h.x, h.y, h.z)
                    } else
                        for (y = e.attributes.position, t = 0, i = y.count / 3; t < i; t++)
                            for (n = 0; n < 3; n++) T = 3 * t + n, h.fromBufferAttribute(y, T), d.push(h.x, h.y, h.z), E = 3 * t + (n + 1) % 3, h.fromBufferAttribute(y, E), d.push(h.x, h.y, h.z)
                }
                this.addAttribute("position", new I(d, 3))
            }

            function Jt(e, t, n) {
                M.call(this), this.type = "ParametricGeometry", this.parameters = {
                    func: e,
                    slices: t,
                    stacks: n
                }, this.fromBufferGeometry(new $t(e, t, n)), this.mergeVertices()
            }

            function $t(e, t, n) {
                z.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                    func: e,
                    slices: t,
                    stacks: n
                };
                var i, r, o = [],
                    s = [],
                    l = [],
                    c = [],
                    u = 1e-5,
                    h = new a,
                    d = new a,
                    p = new a,
                    f = new a,
                    m = new a;
                e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
                var v = t + 1;
                for (i = 0; i <= n; i++) {
                    var g = i / n;
                    for (r = 0; r <= t; r++) {
                        var y = r / t;
                        e(y, g, d), s.push(d.x, d.y, d.z), y - u >= 0 ? (e(y - u, g, p), f.subVectors(d, p)) : (e(y + u, g, p), f.subVectors(p, d)), g - u >= 0 ? (e(y, g - u, p), m.subVectors(d, p)) : (e(y, g + u, p), m.subVectors(p, d)), h.crossVectors(f, m).normalize(), l.push(h.x, h.y, h.z), c.push(y, g)
                    }
                }
                for (i = 0; i < n; i++)
                    for (r = 0; r < t; r++) {
                        var x = i * v + r,
                            b = i * v + r + 1,
                            _ = (i + 1) * v + r + 1,
                            w = (i + 1) * v + r;
                        o.push(x, b, w), o.push(b, _, w)
                    }
                this.setIndex(o), this.addAttribute("position", new I(s, 3)), this.addAttribute("normal", new I(l, 3)), this.addAttribute("uv", new I(c, 2))
            }

            function Qt(e, t, n, i) {
                M.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                    vertices: e,
                    indices: t,
                    radius: n,
                    detail: i
                }, this.fromBufferGeometry(new Kt(e, t, n, i)), this.mergeVertices()
            }

            function Kt(e, t, i, r) {
                function o(e) {
                    for (var n = new a, i = new a, r = new a, o = 0; o < t.length; o += 3) d(t[o + 0], n), d(t[o + 1], i), d(t[o + 2], r), s(n, i, r, e)
                }

                function s(e, t, n, i) {
                    var r, a, o = Math.pow(2, i),
                        s = [];
                    for (r = 0; r <= o; r++) {
                        s[r] = [];
                        var l = e.clone().lerp(n, r / o),
                            c = t.clone().lerp(n, r / o),
                            u = o - r;
                        for (a = 0; a <= u; a++) 0 === a && r === o ? s[r][a] = l : s[r][a] = l.clone().lerp(c, a / u)
                    }
                    for (r = 0; r < o; r++)
                        for (a = 0; a < 2 * (o - r) - 1; a++) {
                            var d = Math.floor(a / 2);
                            a % 2 === 0 ? (h(s[r][d + 1]), h(s[r + 1][d]), h(s[r][d])) : (h(s[r][d + 1]), h(s[r + 1][d + 1]), h(s[r + 1][d]))
                        }
                }

                function l(e) {
                    for (var t = new a, n = 0; n < g.length; n += 3) t.x = g[n + 0], t.y = g[n + 1], t.z = g[n + 2], t.normalize().multiplyScalar(e), g[n + 0] = t.x, g[n + 1] = t.y, g[n + 2] = t.z
                }

                function c() {
                    for (var e = new a, t = 0; t < g.length; t += 3) {
                        e.x = g[t + 0], e.y = g[t + 1], e.z = g[t + 2];
                        var n = m(e) / 2 / Math.PI + .5,
                            i = v(e) / Math.PI + .5;
                        y.push(n, 1 - i)
                    }
                    p(), u()
                }

                function u() {
                    for (var e = 0; e < y.length; e += 6) {
                        var t = y[e + 0],
                            n = y[e + 2],
                            i = y[e + 4],
                            r = Math.max(t, n, i),
                            a = Math.min(t, n, i);
                        r > .9 && a < .1 && (t < .2 && (y[e + 0] += 1), n < .2 && (y[e + 2] += 1), i < .2 && (y[e + 4] += 1))
                    }
                }

                function h(e) {
                    g.push(e.x, e.y, e.z)
                }

                function d(t, n) {
                    var i = 3 * t;
                    n.x = e[i + 0], n.y = e[i + 1], n.z = e[i + 2]
                }

                function p() {
                    for (var e = new a, t = new a, i = new a, r = new a, o = new n, s = new n, l = new n, c = 0, u = 0; c < g.length; c += 9, u += 6) {
                        e.set(g[c + 0], g[c + 1], g[c + 2]), t.set(g[c + 3], g[c + 4], g[c + 5]), i.set(g[c + 6], g[c + 7], g[c + 8]), o.set(y[u + 0], y[u + 1]), s.set(y[u + 2], y[u + 3]), l.set(y[u + 4], y[u + 5]), r.copy(e).add(t).add(i).divideScalar(3);
                        var h = m(r);
                        f(o, u + 0, e, h), f(s, u + 2, t, h), f(l, u + 4, i, h)
                    }
                }

                function f(e, t, n, i) {
                    i < 0 && 1 === e.x && (y[t] = e.x - 1), 0 === n.x && 0 === n.z && (y[t] = i / 2 / Math.PI + .5)
                }

                function m(e) {
                    return Math.atan2(e.z, -e.x)
                }

                function v(e) {
                    return Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z))
                }
                z.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                    vertices: e,
                    indices: t,
                    radius: i,
                    detail: r
                }, i = i || 1, r = r || 0;
                var g = [],
                    y = [];
                o(r), l(i), c(), this.addAttribute("position", new I(g, 3)), this.addAttribute("normal", new I(g.slice(), 3)), this.addAttribute("uv", new I(y, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals()
            }

            function en(e, t) {
                M.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }, this.fromBufferGeometry(new tn(e, t)), this.mergeVertices()
            }

            function tn(e, t) {
                var n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
                    i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
                Kt.call(this, n, i, e, t), this.type = "TetrahedronBufferGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }

            function nn(e, t) {
                M.call(this), this.type = "OctahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }, this.fromBufferGeometry(new rn(e, t)), this.mergeVertices()
            }

            function rn(e, t) {
                var n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
                    i = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
                Kt.call(this, n, i, e, t), this.type = "OctahedronBufferGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }

            function an(e, t) {
                M.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }, this.fromBufferGeometry(new on(e, t)), this.mergeVertices()
            }

            function on(e, t) {
                var n = (1 + Math.sqrt(5)) / 2,
                    i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1],
                    r = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
                Kt.call(this, i, r, e, t), this.type = "IcosahedronBufferGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }

            function sn(e, t) {
                M.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }, this.fromBufferGeometry(new ln(e, t)), this.mergeVertices()
            }

            function ln(e, t) {
                var n = (1 + Math.sqrt(5)) / 2,
                    i = 1 / n,
                    r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i],
                    a = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
                Kt.call(this, r, a, e, t), this.type = "DodecahedronBufferGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }

            function cn(e, t, n, i, r, a) {
                M.call(this), this.type = "TubeGeometry", this.parameters = {
                    path: e,
                    tubularSegments: t,
                    radius: n,
                    radialSegments: i,
                    closed: r
                }, void 0 !== a && console.warn("THREE.TubeGeometry: taper has been removed.");
                var o = new un(e, t, n, i, r);
                this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals, this.fromBufferGeometry(o), this.mergeVertices()
            }

            function un(e, t, i, r, o) {
                function s() {
                    for (d = 0; d < t; d++) l(d);
                    l(o === !1 ? t : 0), u(), c()
                }

                function l(n) {
                    g = e.getPointAt(n / t, g);
                    var a = h.normals[n],
                        o = h.binormals[n];
                    for (p = 0; p <= r; p++) {
                        var s = p / r * Math.PI * 2,
                            l = Math.sin(s),
                            c = -Math.cos(s);
                        m.x = c * a.x + l * o.x, m.y = c * a.y + l * o.y, m.z = c * a.z + l * o.z, m.normalize(), x.push(m.x, m.y, m.z), f.x = g.x + i * m.x, f.y = g.y + i * m.y, f.z = g.z + i * m.z, y.push(f.x, f.y, f.z)
                    }
                }

                function c() {
                    for (p = 1; p <= t; p++)
                        for (d = 1; d <= r; d++) {
                            var e = (r + 1) * (p - 1) + (d - 1),
                                n = (r + 1) * p + (d - 1),
                                i = (r + 1) * p + d,
                                a = (r + 1) * (p - 1) + d;
                            _.push(e, n, a), _.push(n, i, a)
                        }
                }

                function u() {
                    for (d = 0; d <= t; d++)
                        for (p = 0; p <= r; p++) v.x = d / t, v.y = p / r, b.push(v.x, v.y)
                }
                z.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                    path: e,
                    tubularSegments: t,
                    radius: i,
                    radialSegments: r,
                    closed: o
                }, t = t || 64, i = i || 1, r = r || 8, o = o || !1;
                var h = e.computeFrenetFrames(t, o);
                this.tangents = h.tangents, this.normals = h.normals, this.binormals = h.binormals;
                var d, p, f = new a,
                    m = new a,
                    v = new n,
                    g = new a,
                    y = [],
                    x = [],
                    b = [],
                    _ = [];
                s(), this.setIndex(_), this.addAttribute("position", new I(y, 3)), this.addAttribute("normal", new I(x, 3)), this.addAttribute("uv", new I(b, 2))
            }

            function hn(e, t, n, i, r, a, o) {
                M.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    tubularSegments: n,
                    radialSegments: i,
                    p: r,
                    q: a
                }, void 0 !== o && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new dn(e, t, n, i, r, a)), this.mergeVertices()
            }

            function dn(e, t, n, i, r, o) {
                function s(e, t, n, i, r) {
                    var a = Math.cos(e),
                        o = Math.sin(e),
                        s = n / t * e,
                        l = Math.cos(s);
                    r.x = i * (2 + l) * .5 * a, r.y = i * (2 + l) * o * .5, r.z = i * Math.sin(s) * .5
                }
                z.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    tubularSegments: n,
                    radialSegments: i,
                    p: r,
                    q: o
                }, e = e || 1, t = t || .4, n = Math.floor(n) || 64, i = Math.floor(i) || 8, r = r || 2, o = o || 3;
                var l, c, u = [],
                    h = [],
                    d = [],
                    p = [],
                    f = new a,
                    m = new a,
                    v = new a,
                    g = new a,
                    y = new a,
                    x = new a,
                    b = new a;
                for (l = 0; l <= n; ++l) {
                    var _ = l / n * r * Math.PI * 2;
                    for (s(_, r, o, e, v), s(_ + .01, r, o, e, g), x.subVectors(g, v), b.addVectors(g, v), y.crossVectors(x, b), b.crossVectors(y, x), y.normalize(), b.normalize(), c = 0; c <= i; ++c) {
                        var w = c / i * Math.PI * 2,
                            M = -t * Math.cos(w),
                            T = t * Math.sin(w);
                        f.x = v.x + (M * b.x + T * y.x), f.y = v.y + (M * b.y + T * y.y), f.z = v.z + (M * b.z + T * y.z), h.push(f.x, f.y, f.z), m.subVectors(f, v).normalize(), d.push(m.x, m.y, m.z), p.push(l / n), p.push(c / i)
                    }
                }
                for (c = 1; c <= n; c++)
                    for (l = 1; l <= i; l++) {
                        var E = (i + 1) * (c - 1) + (l - 1),
                            S = (i + 1) * c + (l - 1),
                            P = (i + 1) * c + l,
                            C = (i + 1) * (c - 1) + l;
                        u.push(E, S, C), u.push(S, P, C)
                    }
                this.setIndex(u), this.addAttribute("position", new I(h, 3)), this.addAttribute("normal", new I(d, 3)), this.addAttribute("uv", new I(p, 2))
            }

            function pn(e, t, n, i, r) {
                M.call(this), this.type = "TorusGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    radialSegments: n,
                    tubularSegments: i,
                    arc: r
                }, this.fromBufferGeometry(new fn(e, t, n, i, r)), this.mergeVertices()
            }

            function fn(e, t, n, i, r) {
                z.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    radialSegments: n,
                    tubularSegments: i,
                    arc: r
                }, e = e || 1, t = t || .4, n = Math.floor(n) || 8, i = Math.floor(i) || 6, r = r || 2 * Math.PI;
                var o, s, l = [],
                    c = [],
                    u = [],
                    h = [],
                    d = new a,
                    p = new a,
                    f = new a;
                for (o = 0; o <= n; o++)
                    for (s = 0; s <= i; s++) {
                        var m = s / i * r,
                            v = o / n * Math.PI * 2;
                        p.x = (e + t * Math.cos(v)) * Math.cos(m), p.y = (e + t * Math.cos(v)) * Math.sin(m), p.z = t * Math.sin(v), c.push(p.x, p.y, p.z), d.x = e * Math.cos(m), d.y = e * Math.sin(m), f.subVectors(p, d).normalize(), u.push(f.x, f.y, f.z), h.push(s / i), h.push(o / n)
                    }
                for (o = 1; o <= n; o++)
                    for (s = 1; s <= i; s++) {
                        var g = (i + 1) * o + s - 1,
                            y = (i + 1) * (o - 1) + s - 1,
                            x = (i + 1) * (o - 1) + s,
                            b = (i + 1) * o + s;
                        l.push(g, y, b), l.push(y, x, b)
                    }
                this.setIndex(l), this.addAttribute("position", new I(c, 3)), this.addAttribute("normal", new I(u, 3)), this.addAttribute("uv", new I(h, 2))
            }

            function mn(e, t, n, i, r) {
                var a, o;
                if (r === Gn(e, t, n, i) > 0)
                    for (a = t; a < n; a += i) o = Un(a, e[a], e[a + 1], o);
                else
                    for (a = n - i; a >= t; a -= i) o = Un(a, e[a], e[a + 1], o);
                return o && On(o, o.next) && (jn(o), o = o.next), o
            }

            function vn(e, t) {
                if (!e) return e;
                t || (t = e);
                var n, i = e;
                do
                    if (n = !1, i.steiner || !On(i, i.next) && 0 !== In(i.prev, i, i.next)) i = i.next;
                    else {
                        if (jn(i), i = t = i.prev, i === i.next) break;
                        n = !0
                    } while (n || i !== t);
                return t
            }

            function gn(e, t, n, i, r, a, o) {
                if (e) {
                    !o && a && Sn(e, i, r, a);
                    for (var s, l, c = e; e.prev !== e.next;)
                        if (s = e.prev, l = e.next, a ? xn(e, i, r, a) : yn(e)) t.push(s.i / n), t.push(e.i / n), t.push(l.i / n), jn(e), e = l.next, c = l.next;
                        else if (e = l, e === c) {
                        o ? 1 === o ? (e = bn(e, t, n), gn(e, t, n, i, r, a, 2)) : 2 === o && _n(e, t, n, i, r, a) : gn(vn(e), t, n, i, r, a, 1);
                        break
                    }
                }
            }

            function yn(e) {
                var t = e.prev,
                    n = e,
                    i = e.next;
                if (In(t, n, i) >= 0) return !1;
                for (var r = e.next.next; r !== e.prev;) {
                    if (Ln(t.x, t.y, n.x, n.y, i.x, i.y, r.x, r.y) && In(r.prev, r, r.next) >= 0) return !1;
                    r = r.next
                }
                return !0
            }

            function xn(e, t, n, i) {
                var r = e.prev,
                    a = e,
                    o = e.next;
                if (In(r, a, o) >= 0) return !1;
                for (var s = r.x < a.x ? r.x < o.x ? r.x : o.x : a.x < o.x ? a.x : o.x, l = r.y < a.y ? r.y < o.y ? r.y : o.y : a.y < o.y ? a.y : o.y, c = r.x > a.x ? r.x > o.x ? r.x : o.x : a.x > o.x ? a.x : o.x, u = r.y > a.y ? r.y > o.y ? r.y : o.y : a.y > o.y ? a.y : o.y, h = Cn(s, l, t, n, i), d = Cn(c, u, t, n, i), p = e.nextZ; p && p.z <= d;) {
                    if (p !== e.prev && p !== e.next && Ln(r.x, r.y, a.x, a.y, o.x, o.y, p.x, p.y) && In(p.prev, p, p.next) >= 0) return !1;
                    p = p.nextZ
                }
                for (p = e.prevZ; p && p.z >= h;) {
                    if (p !== e.prev && p !== e.next && Ln(r.x, r.y, a.x, a.y, o.x, o.y, p.x, p.y) && In(p.prev, p, p.next) >= 0) return !1;
                    p = p.prevZ
                }
                return !0
            }

            function bn(e, t, n) {
                var i = e;
                do {
                    var r = i.prev,
                        a = i.next.next;
                    !On(r, a) && kn(r, i, i.next, a) && zn(r, a) && zn(a, r) && (t.push(r.i / n), t.push(i.i / n), t.push(a.i / n), jn(i), jn(i.next), i = e = a), i = i.next
                } while (i !== e);
                return i
            }

            function _n(e, t, n, i, r, a) {
                var o = e;
                do {
                    for (var s = o.next.next; s !== o.prev;) {
                        if (o.i !== s.i && Rn(o, s)) {
                            var l = Nn(o, s);
                            return o = vn(o, o.next), l = vn(l, l.next), gn(o, t, n, i, r, a), void gn(l, t, n, i, r, a)
                        }
                        s = s.next
                    }
                    o = o.next
                } while (o !== e)
            }

            function wn(e, t, n, i) {
                var r, a, o, s, l, c = [];
                for (r = 0, a = t.length; r < a; r++) o = t[r] * i, s = r < a - 1 ? t[r + 1] * i : e.length, l = mn(e, o, s, i, !1), l === l.next && (l.steiner = !0), c.push(An(l));
                for (c.sort(Mn), r = 0; r < c.length; r++) Tn(c[r], n), n = vn(n, n.next);
                return n
            }

            function Mn(e, t) {
                return e.x - t.x
            }

            function Tn(e, t) {
                if (t = En(e, t)) {
                    var n = Nn(t, e);
                    vn(n, n.next)
                }
            }

            function En(e, t) {
                var n, i = t,
                    r = e.x,
                    a = e.y,
                    o = -(1 / 0);
                do {
                    if (a <= i.y && a >= i.next.y && i.next.y !== i.y) {
                        var s = i.x + (a - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                        if (s <= r && s > o) {
                            if (o = s, s === r) {
                                if (a === i.y) return i;
                                if (a === i.next.y) return i.next
                            }
                            n = i.x < i.next.x ? i : i.next
                        }
                    }
                    i = i.next
                } while (i !== t);
                if (!n) return null;
                if (r === o) return n.prev;
                var l, c = n,
                    u = n.x,
                    h = n.y,
                    d = 1 / 0;
                for (i = n.next; i !== c;) r >= i.x && i.x >= u && r !== i.x && Ln(a < h ? r : o, a, u, h, a < h ? o : r, a, i.x, i.y) && (l = Math.abs(a - i.y) / (r - i.x), (l < d || l === d && i.x > n.x) && zn(i, e) && (n = i, d = l)), i = i.next;
                return n
            }

            function Sn(e, t, n, i) {
                var r = e;
                do null === r.z && (r.z = Cn(r.x, r.y, t, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next; while (r !== e);
                r.prevZ.nextZ = null, r.prevZ = null, Pn(r)
            }

            function Pn(e) {
                var t, n, i, r, a, o, s, l, c = 1;
                do {
                    for (n = e, e = null, a = null, o = 0; n;) {
                        for (o++, i = n, s = 0, t = 0; t < c && (s++, i = i.nextZ, i); t++);
                        for (l = c; s > 0 || l > 0 && i;) 0 !== s && (0 === l || !i || n.z <= i.z) ? (r = n, n = n.nextZ, s--) : (r = i, i = i.nextZ, l--), a ? a.nextZ = r : e = r, r.prevZ = a, a = r;
                        n = i
                    }
                    a.nextZ = null, c *= 2
                } while (o > 1);
                return e
            }

            function Cn(e, t, n, i, r) {
                return e = 32767 * (e - n) * r, t = 32767 * (t - i) * r, e = 16711935 & (e | e << 8), e = 252645135 & (e | e << 4), e = 858993459 & (e | e << 2), e = 1431655765 & (e | e << 1), t = 16711935 & (t | t << 8), t = 252645135 & (t | t << 4), t = 858993459 & (t | t << 2), t = 1431655765 & (t | t << 1), e | t << 1
            }

            function An(e) {
                var t = e,
                    n = e;
                do t.x < n.x && (n = t), t = t.next; while (t !== e);
                return n
            }

            function Ln(e, t, n, i, r, a, o, s) {
                return (r - o) * (t - s) - (e - o) * (a - s) >= 0 && (e - o) * (i - s) - (n - o) * (t - s) >= 0 && (n - o) * (a - s) - (r - o) * (i - s) >= 0
            }

            function Rn(e, t) {
                return e.next.i !== t.i && e.prev.i !== t.i && !Dn(e, t) && zn(e, t) && zn(t, e) && Bn(e, t)
            }

            function In(e, t, n) {
                return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
            }

            function On(e, t) {
                return e.x === t.x && e.y === t.y
            }

            function kn(e, t, n, i) {
                return !!(On(e, t) && On(n, i) || On(e, i) && On(n, t)) || In(e, t, n) > 0 != In(e, t, i) > 0 && In(n, i, e) > 0 != In(n, i, t) > 0
            }

            function Dn(e, t) {
                var n = e;
                do {
                    if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && kn(n, n.next, e, t)) return !0;
                    n = n.next
                } while (n !== e);
                return !1
            }

            function zn(e, t) {
                return In(e.prev, e, e.next) < 0 ? In(e, t, e.next) >= 0 && In(e, e.prev, t) >= 0 : In(e, t, e.prev) < 0 || In(e, e.next, t) < 0
            }

            function Bn(e, t) {
                var n = e,
                    i = !1,
                    r = (e.x + t.x) / 2,
                    a = (e.y + t.y) / 2;
                do n.y > a != n.next.y > a && n.next.y !== n.y && r < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next; while (n !== e);
                return i
            }

            function Nn(e, t) {
                var n = new Fn(e.i, e.x, e.y),
                    i = new Fn(t.i, t.x, t.y),
                    r = e.next,
                    a = t.prev;
                return e.next = t, t.prev = e, n.next = r, r.prev = n, i.next = n, n.prev = i, a.next = i, i.prev = a, i
            }

            function Un(e, t, n, i) {
                var r = new Fn(e, t, n);
                return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
            }

            function jn(e) {
                e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
            }

            function Fn(e, t, n) {
                this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }

            function Gn(e, t, n, i) {
                for (var r = 0, a = t, o = n - i; a < n; a += i) r += (e[o] - e[a]) * (e[a + 1] + e[o + 1]), o = a;
                return r
            }

            function Hn(e) {
                var t = e.length;
                t > 2 && e[t - 1].equals(e[0]) && e.pop()
            }

            function Vn(e, t) {
                for (var n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
            }

            function Wn(e, t) {
                M.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                    shapes: e,
                    options: t
                }, this.fromBufferGeometry(new qn(e, t)), this.mergeVertices()
            }

            function qn(e, t) {
                function i(e) {
                    function i(e, t, n) {
                        return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e)
                    }

                    function l(e, t, i) {
                        var r, a, o, s = e.x - t.x,
                            l = e.y - t.y,
                            c = i.x - e.x,
                            u = i.y - e.y,
                            h = s * s + l * l,
                            d = s * u - l * c;
                        if (Math.abs(d) > Number.EPSILON) {
                            var p = Math.sqrt(h),
                                f = Math.sqrt(c * c + u * u),
                                m = t.x - l / p,
                                v = t.y + s / p,
                                g = i.x - u / f,
                                y = i.y + c / f,
                                x = ((g - m) * u - (y - v) * c) / (s * u - l * c);
                            r = m + s * x - e.x, a = v + l * x - e.y;
                            var b = r * r + a * a;
                            if (b <= 2) return new n(r, a);
                            o = Math.sqrt(b / 2)
                        } else {
                            var _ = !1;
                            s > Number.EPSILON ? c > Number.EPSILON && (_ = !0) : s < -Number.EPSILON ? c < -Number.EPSILON && (_ = !0) : Math.sign(l) === Math.sign(u) && (_ = !0), _ ? (r = -l, a = s, o = Math.sqrt(h)) : (r = s, a = l, o = Math.sqrt(h / 2))
                        }
                        return new n(r / o, a / o)
                    }

                    function c() {
                        var e = o.length / 3;
                        if (_) {
                            var t = 0,
                                n = Y * t;
                            for ($ = 0; $ < Z; $++) X = j[$], p(X[2] + n, X[1] + n, X[0] + n);
                            for (t = x + 2 * T, n = Y * t, $ = 0; $ < Z; $++) X = j[$], p(X[0] + n, X[1] + n, X[2] + n)
                        } else {
                            for ($ = 0; $ < Z; $++) X = j[$], p(X[2], X[1], X[0]);
                            for ($ = 0; $ < Z; $++) X = j[$], p(X[0] + Y * x, X[1] + Y * x, X[2] + Y * x)
                        }
                        r.addGroup(e, o.length / 3 - e, 0)
                    }

                    function u() {
                        var e = o.length / 3,
                            t = 0;
                        for (h(F, t), t += F.length, k = 0, D = N.length; k < D; k++) O = N[k], h(O, t), t += O.length;
                        r.addGroup(e, o.length / 3 - e, 1)
                    }

                    function h(e, t) {
                        var n, i;
                        for ($ = e.length; --$ >= 0;) {
                            n = $, i = $ - 1, i < 0 && (i = e.length - 1);
                            var r = 0,
                                a = x + 2 * T;
                            for (r = 0; r < a; r++) {
                                var o = Y * r,
                                    s = Y * (r + 1),
                                    l = t + n + o,
                                    c = t + i + o,
                                    u = t + i + s,
                                    h = t + n + s;
                                f(l, c, u, h)
                            }
                        }
                    }

                    function d(e, t, n) {
                        g.push(e), g.push(t), g.push(n)
                    }

                    function p(e, t, n) {
                        m(e), m(t), m(n);
                        var i = o.length / 3,
                            a = S.generateTopUV(r, o, i - 3, i - 2, i - 1);
                        v(a[0]), v(a[1]), v(a[2])
                    }

                    function f(e, t, n, i) {
                        m(e), m(t), m(i), m(t), m(n), m(i);
                        var a = o.length / 3,
                            s = S.generateSideWallUV(r, o, a - 6, a - 3, a - 2, a - 1);
                        v(s[0]), v(s[1]), v(s[3]), v(s[1]), v(s[2]), v(s[3])
                    }

                    function m(e) {
                        o.push(g[3 * e + 0]), o.push(g[3 * e + 1]), o.push(g[3 * e + 2])
                    }

                    function v(e) {
                        s.push(e.x), s.push(e.y)
                    }
                    var g = [],
                        y = void 0 !== t.curveSegments ? t.curveSegments : 12,
                        x = void 0 !== t.steps ? t.steps : 1,
                        b = void 0 !== t.depth ? t.depth : 100,
                        _ = void 0 === t.bevelEnabled || t.bevelEnabled,
                        w = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
                        M = void 0 !== t.bevelSize ? t.bevelSize : w - 2,
                        T = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
                        E = t.extrudePath,
                        S = void 0 !== t.UVGenerator ? t.UVGenerator : Eh;
                    void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), b = t.amount);
                    var P, C, A, L, R, I = !1;
                    E && (P = E.getSpacedPoints(x), I = !0, _ = !1, C = E.computeFrenetFrames(x, !1), A = new a, L = new a, R = new a), _ || (T = 0, w = 0, M = 0);
                    var O, k, D, z = e.extractPoints(y),
                        B = z.shape,
                        N = z.holes,
                        U = !Th.isClockWise(B);
                    if (U)
                        for (B = B.reverse(), k = 0, D = N.length; k < D; k++) O = N[k], Th.isClockWise(O) && (N[k] = O.reverse());
                    var j = Th.triangulateShape(B, N),
                        F = B;
                    for (k = 0, D = N.length; k < D; k++) O = N[k], B = B.concat(O);
                    for (var G, H, V, W, q, X, Y = B.length, Z = j.length, J = [], $ = 0, Q = F.length, K = Q - 1, ee = $ + 1; $ < Q; $++, K++, ee++) K === Q && (K = 0), ee === Q && (ee = 0), J[$] = l(F[$], F[K], F[ee]);
                    var te, ne = [],
                        ie = J.concat();
                    for (k = 0, D = N.length; k < D; k++) {
                        for (O = N[k], te = [], $ = 0, Q = O.length, K = Q - 1, ee = $ + 1; $ < Q; $++, K++, ee++) K === Q && (K = 0), ee === Q && (ee = 0), te[$] = l(O[$], O[K], O[ee]);
                        ne.push(te), ie = ie.concat(te)
                    }
                    for (G = 0; G < T; G++) {
                        for (V = G / T, W = w * Math.cos(V * Math.PI / 2), H = M * Math.sin(V * Math.PI / 2), $ = 0, Q = F.length; $ < Q; $++) q = i(F[$], J[$], H), d(q.x, q.y, -W);
                        for (k = 0, D = N.length; k < D; k++)
                            for (O = N[k], te = ne[k], $ = 0, Q = O.length; $ < Q; $++) q = i(O[$], te[$], H), d(q.x, q.y, -W)
                    }
                    for (H = M, $ = 0; $ < Y; $++) q = _ ? i(B[$], ie[$], H) : B[$], I ? (L.copy(C.normals[0]).multiplyScalar(q.x), A.copy(C.binormals[0]).multiplyScalar(q.y), R.copy(P[0]).add(L).add(A), d(R.x, R.y, R.z)) : d(q.x, q.y, 0);
                    var re;
                    for (re = 1; re <= x; re++)
                        for ($ = 0; $ < Y; $++) q = _ ? i(B[$], ie[$], H) : B[$], I ? (L.copy(C.normals[re]).multiplyScalar(q.x), A.copy(C.binormals[re]).multiplyScalar(q.y), R.copy(P[re]).add(L).add(A), d(R.x, R.y, R.z)) : d(q.x, q.y, b / x * re);
                    for (G = T - 1; G >= 0; G--) {
                        for (V = G / T, W = w * Math.cos(V * Math.PI / 2), H = M * Math.sin(V * Math.PI / 2), $ = 0, Q = F.length; $ < Q; $++) q = i(F[$], J[$], H), d(q.x, q.y, b + W);
                        for (k = 0, D = N.length; k < D; k++)
                            for (O = N[k], te = ne[k], $ = 0, Q = O.length; $ < Q; $++) q = i(O[$], te[$], H), I ? d(q.x, q.y + P[x - 1].y, P[x - 1].x + W) : d(q.x, q.y, b + W)
                    }
                    c(), u()
                }
                z.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
                    shapes: e,
                    options: t
                }, e = Array.isArray(e) ? e : [e];
                for (var r = this, o = [], s = [], l = 0, c = e.length; l < c; l++) {
                    var u = e[l];
                    i(u)
                }
                this.addAttribute("position", new I(o, 3)), this.addAttribute("uv", new I(s, 2)), this.computeVertexNormals()
            }

            function Xn(e, t, n) {
                if (n.shapes = [], Array.isArray(e))
                    for (var i = 0, r = e.length; i < r; i++) {
                        var a = e[i];
                        n.shapes.push(a.uuid)
                    } else n.shapes.push(e.uuid);
                return void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), n
            }

            function Yn(e, t) {
                M.call(this), this.type = "TextGeometry", this.parameters = {
                    text: e,
                    parameters: t
                }, this.fromBufferGeometry(new Zn(e, t)), this.mergeVertices()
            }

            function Zn(e, t) {
                t = t || {};
                var n = t.font;
                if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new M;
                var i = n.generateShapes(e, t.size);
                t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), qn.call(this, i, t), this.type = "TextBufferGeometry"
            }

            function Jn(e, t, n, i, r, a, o) {
                M.call(this), this.type = "SphereGeometry", this.parameters = {
                    radius: e,
                    widthSegments: t,
                    heightSegments: n,
                    phiStart: i,
                    phiLength: r,
                    thetaStart: a,
                    thetaLength: o
                }, this.fromBufferGeometry(new $n(e, t, n, i, r, a, o)), this.mergeVertices()
            }

            function $n(e, t, n, i, r, o, s) {
                z.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                    radius: e,
                    widthSegments: t,
                    heightSegments: n,
                    phiStart: i,
                    phiLength: r,
                    thetaStart: o,
                    thetaLength: s
                }, e = e || 1, t = Math.max(3, Math.floor(t) || 8), n = Math.max(2, Math.floor(n) || 6), i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI, o = void 0 !== o ? o : 0, s = void 0 !== s ? s : Math.PI;
                var l, c, u = o + s,
                    h = 0,
                    d = [],
                    p = new a,
                    f = new a,
                    m = [],
                    v = [],
                    g = [],
                    y = [];
                for (c = 0; c <= n; c++) {
                    var x = [],
                        b = c / n;
                    for (l = 0; l <= t; l++) {
                        var _ = l / t;
                        p.x = -e * Math.cos(i + _ * r) * Math.sin(o + b * s), p.y = e * Math.cos(o + b * s), p.z = e * Math.sin(i + _ * r) * Math.sin(o + b * s), v.push(p.x, p.y, p.z), f.set(p.x, p.y, p.z).normalize(), g.push(f.x, f.y, f.z), y.push(_, 1 - b), x.push(h++)
                    }
                    d.push(x)
                }
                for (c = 0; c < n; c++)
                    for (l = 0; l < t; l++) {
                        var w = d[c][l + 1],
                            M = d[c][l],
                            T = d[c + 1][l],
                            E = d[c + 1][l + 1];
                        (0 !== c || o > 0) && m.push(w, M, E), (c !== n - 1 || u < Math.PI) && m.push(M, T, E)
                    }
                this.setIndex(m), this.addAttribute("position", new I(v, 3)), this.addAttribute("normal", new I(g, 3)), this.addAttribute("uv", new I(y, 2))
            }

            function Qn(e, t, n, i, r, a) {
                M.call(this), this.type = "RingGeometry", this.parameters = {
                    innerRadius: e,
                    outerRadius: t,
                    thetaSegments: n,
                    phiSegments: i,
                    thetaStart: r,
                    thetaLength: a
                }, this.fromBufferGeometry(new Kn(e, t, n, i, r, a)), this.mergeVertices()
            }

            function Kn(e, t, i, r, o, s) {
                z.call(this), this.type = "RingBufferGeometry", this.parameters = {
                    innerRadius: e,
                    outerRadius: t,
                    thetaSegments: i,
                    phiSegments: r,
                    thetaStart: o,
                    thetaLength: s
                }, e = e || .5, t = t || 1, o = void 0 !== o ? o : 0, s = void 0 !== s ? s : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8, r = void 0 !== r ? Math.max(1, r) : 1;
                var l, c, u, h = [],
                    d = [],
                    p = [],
                    f = [],
                    m = e,
                    v = (t - e) / r,
                    g = new a,
                    y = new n;
                for (c = 0; c <= r; c++) {
                    for (u = 0; u <= i; u++) l = o + u / i * s, g.x = m * Math.cos(l), g.y = m * Math.sin(l), d.push(g.x, g.y, g.z), p.push(0, 0, 1), y.x = (g.x / t + 1) / 2, y.y = (g.y / t + 1) / 2, f.push(y.x, y.y);
                    m += v
                }
                for (c = 0; c < r; c++) {
                    var x = c * (i + 1);
                    for (u = 0; u < i; u++) {
                        l = u + x;
                        var b = l,
                            _ = l + i + 1,
                            w = l + i + 2,
                            M = l + 1;
                        h.push(b, _, M), h.push(_, w, M)
                    }
                }
                this.setIndex(h), this.addAttribute("position", new I(d, 3)), this.addAttribute("normal", new I(p, 3)), this.addAttribute("uv", new I(f, 2))
            }

            function ei(e, t, n, i) {
                M.call(this), this.type = "LatheGeometry", this.parameters = {
                    points: e,
                    segments: t,
                    phiStart: n,
                    phiLength: i
                }, this.fromBufferGeometry(new ti(e, t, n, i)), this.mergeVertices()
            }

            function ti(e, t, i, r) {
                z.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                    points: e,
                    segments: t,
                    phiStart: i,
                    phiLength: r
                }, t = Math.floor(t) || 12, i = i || 0, r = r || 2 * Math.PI, r = jl.clamp(r, 0, 2 * Math.PI);
                var o, s, l, c = [],
                    u = [],
                    h = [],
                    d = 1 / t,
                    p = new a,
                    f = new n;
                for (s = 0; s <= t; s++) {
                    var m = i + s * d * r,
                        v = Math.sin(m),
                        g = Math.cos(m);
                    for (l = 0; l <= e.length - 1; l++) p.x = e[l].x * v, p.y = e[l].y, p.z = e[l].x * g, u.push(p.x, p.y, p.z), f.x = s / t, f.y = l / (e.length - 1), h.push(f.x, f.y)
                }
                for (s = 0; s < t; s++)
                    for (l = 0; l < e.length - 1; l++) {
                        o = l + s * e.length;
                        var y = o,
                            x = o + e.length,
                            b = o + e.length + 1,
                            _ = o + 1;
                        c.push(y, x, _), c.push(x, b, _)
                    }
                if (this.setIndex(c), this.addAttribute("position", new I(u, 3)), this.addAttribute("uv", new I(h, 2)), this.computeVertexNormals(), r === 2 * Math.PI) {
                    var w = this.attributes.normal.array,
                        M = new a,
                        T = new a,
                        E = new a;
                    for (o = t * e.length * 3, s = 0, l = 0; s < e.length; s++, l += 3) M.x = w[l + 0], M.y = w[l + 1], M.z = w[l + 2], T.x = w[o + l + 0], T.y = w[o + l + 1], T.z = w[o + l + 2], E.addVectors(M, T).normalize(), w[l + 0] = w[o + l + 0] = E.x, w[l + 1] = w[o + l + 1] = E.y,
                        w[l + 2] = w[o + l + 2] = E.z
                }
            }

            function ni(e, t) {
                M.call(this), this.type = "ShapeGeometry", "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = {
                    shapes: e,
                    curveSegments: t
                }, this.fromBufferGeometry(new ii(e, t)), this.mergeVertices()
            }

            function ii(e, t) {
                function n(e) {
                    var n, s, c, u = r.length / 3,
                        h = e.extractPoints(t),
                        d = h.shape,
                        p = h.holes;
                    if (Th.isClockWise(d) === !1)
                        for (d = d.reverse(), n = 0, s = p.length; n < s; n++) c = p[n], Th.isClockWise(c) === !0 && (p[n] = c.reverse());
                    var f = Th.triangulateShape(d, p);
                    for (n = 0, s = p.length; n < s; n++) c = p[n], d = d.concat(c);
                    for (n = 0, s = d.length; n < s; n++) {
                        var m = d[n];
                        r.push(m.x, m.y, 0), a.push(0, 0, 1), o.push(m.x, m.y)
                    }
                    for (n = 0, s = f.length; n < s; n++) {
                        var v = f[n],
                            g = v[0] + u,
                            y = v[1] + u,
                            x = v[2] + u;
                        i.push(g, y, x), l += 3
                    }
                }
                z.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                    shapes: e,
                    curveSegments: t
                }, t = t || 12;
                var i = [],
                    r = [],
                    a = [],
                    o = [],
                    s = 0,
                    l = 0;
                if (Array.isArray(e) === !1) n(e);
                else
                    for (var c = 0; c < e.length; c++) n(e[c]), this.addGroup(s, l, c), s += l, l = 0;
                this.setIndex(i), this.addAttribute("position", new I(r, 3)), this.addAttribute("normal", new I(a, 3)), this.addAttribute("uv", new I(o, 2))
            }

            function ri(e, t) {
                if (t.shapes = [], Array.isArray(e))
                    for (var n = 0, i = e.length; n < i; n++) {
                        var r = e[n];
                        t.shapes.push(r.uuid)
                    } else t.shapes.push(e.uuid);
                return t
            }

            function ai(e, t) {
                z.call(this), this.type = "EdgesGeometry", this.parameters = {
                    thresholdAngle: t
                }, t = void 0 !== t ? t : 1;
                var n, i, r, a, o = [],
                    s = Math.cos(jl.DEG2RAD * t),
                    l = [0, 0],
                    c = {},
                    u = ["a", "b", "c"];
                e.isBufferGeometry ? (a = new M, a.fromBufferGeometry(e)) : a = e.clone(), a.mergeVertices(), a.computeFaceNormals();
                for (var h = a.vertices, d = a.faces, p = 0, f = d.length; p < f; p++)
                    for (var m = d[p], v = 0; v < 3; v++) n = m[u[v]], i = m[u[(v + 1) % 3]], l[0] = Math.min(n, i), l[1] = Math.max(n, i), r = l[0] + "," + l[1], void 0 === c[r] ? c[r] = {
                        index1: l[0],
                        index2: l[1],
                        face1: p,
                        face2: void 0
                    } : c[r].face2 = p;
                for (r in c) {
                    var g = c[r];
                    if (void 0 === g.face2 || d[g.face1].normal.dot(d[g.face2].normal) <= s) {
                        var y = h[g.index1];
                        o.push(y.x, y.y, y.z), y = h[g.index2], o.push(y.x, y.y, y.z)
                    }
                }
                this.addAttribute("position", new I(o, 3))
            }

            function oi(e, t, n, i, r, a, o, s) {
                M.call(this), this.type = "CylinderGeometry", this.parameters = {
                    radiusTop: e,
                    radiusBottom: t,
                    height: n,
                    radialSegments: i,
                    heightSegments: r,
                    openEnded: a,
                    thetaStart: o,
                    thetaLength: s
                }, this.fromBufferGeometry(new si(e, t, n, i, r, a, o, s)), this.mergeVertices()
            }

            function si(e, t, i, r, o, s, l, c) {
                function u() {
                    var n, s, u = new a,
                        h = new a,
                        _ = 0,
                        w = (t - e) / i;
                    for (s = 0; s <= o; s++) {
                        var M = [],
                            T = s / o,
                            E = T * (t - e) + e;
                        for (n = 0; n <= r; n++) {
                            var S = n / r,
                                P = S * c + l,
                                C = Math.sin(P),
                                A = Math.cos(P);
                            h.x = E * C, h.y = -T * i + x, h.z = E * A, f.push(h.x, h.y, h.z), u.set(C, w, A).normalize(), m.push(u.x, u.y, u.z), v.push(S, 1 - T), M.push(g++)
                        }
                        y.push(M)
                    }
                    for (n = 0; n < r; n++)
                        for (s = 0; s < o; s++) {
                            var L = y[s][n],
                                R = y[s + 1][n],
                                I = y[s + 1][n + 1],
                                O = y[s][n + 1];
                            p.push(L, R, O), p.push(R, I, O), _ += 6
                        }
                    d.addGroup(b, _, 0), b += _
                }

                function h(i) {
                    var o, s, u, h = new n,
                        y = new a,
                        _ = 0,
                        w = i === !0 ? e : t,
                        M = i === !0 ? 1 : -1;
                    for (s = g, o = 1; o <= r; o++) f.push(0, x * M, 0), m.push(0, M, 0), v.push(.5, .5), g++;
                    for (u = g, o = 0; o <= r; o++) {
                        var T = o / r,
                            E = T * c + l,
                            S = Math.cos(E),
                            P = Math.sin(E);
                        y.x = w * P, y.y = x * M, y.z = w * S, f.push(y.x, y.y, y.z), m.push(0, M, 0), h.x = .5 * S + .5, h.y = .5 * P * M + .5, v.push(h.x, h.y), g++
                    }
                    for (o = 0; o < r; o++) {
                        var C = s + o,
                            A = u + o;
                        i === !0 ? p.push(A, A + 1, C) : p.push(A + 1, A, C), _ += 3
                    }
                    d.addGroup(b, _, i === !0 ? 1 : 2), b += _
                }
                z.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                    radiusTop: e,
                    radiusBottom: t,
                    height: i,
                    radialSegments: r,
                    heightSegments: o,
                    openEnded: s,
                    thetaStart: l,
                    thetaLength: c
                };
                var d = this;
                e = void 0 !== e ? e : 1, t = void 0 !== t ? t : 1, i = i || 1, r = Math.floor(r) || 8, o = Math.floor(o) || 1, s = void 0 !== s && s, l = void 0 !== l ? l : 0, c = void 0 !== c ? c : 2 * Math.PI;
                var p = [],
                    f = [],
                    m = [],
                    v = [],
                    g = 0,
                    y = [],
                    x = i / 2,
                    b = 0;
                u(), s === !1 && (e > 0 && h(!0), t > 0 && h(!1)), this.setIndex(p), this.addAttribute("position", new I(f, 3)), this.addAttribute("normal", new I(m, 3)), this.addAttribute("uv", new I(v, 2))
            }

            function li(e, t, n, i, r, a, o) {
                oi.call(this, 0, e, t, n, i, r, a, o), this.type = "ConeGeometry", this.parameters = {
                    radius: e,
                    height: t,
                    radialSegments: n,
                    heightSegments: i,
                    openEnded: r,
                    thetaStart: a,
                    thetaLength: o
                }
            }

            function ci(e, t, n, i, r, a, o) {
                si.call(this, 0, e, t, n, i, r, a, o), this.type = "ConeBufferGeometry", this.parameters = {
                    radius: e,
                    height: t,
                    radialSegments: n,
                    heightSegments: i,
                    openEnded: r,
                    thetaStart: a,
                    thetaLength: o
                }
            }

            function ui(e, t, n, i) {
                M.call(this), this.type = "CircleGeometry", this.parameters = {
                    radius: e,
                    segments: t,
                    thetaStart: n,
                    thetaLength: i
                }, this.fromBufferGeometry(new hi(e, t, n, i)), this.mergeVertices()
            }

            function hi(e, t, i, r) {
                z.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                    radius: e,
                    segments: t,
                    thetaStart: i,
                    thetaLength: r
                }, e = e || 1, t = void 0 !== t ? Math.max(3, t) : 8, i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI;
                var o, s, l = [],
                    c = [],
                    u = [],
                    h = [],
                    d = new a,
                    p = new n;
                for (c.push(0, 0, 0), u.push(0, 0, 1), h.push(.5, .5), s = 0, o = 3; s <= t; s++, o += 3) {
                    var f = i + s / t * r;
                    d.x = e * Math.cos(f), d.y = e * Math.sin(f), c.push(d.x, d.y, d.z), u.push(0, 0, 1), p.x = (c[o] / e + 1) / 2, p.y = (c[o + 1] / e + 1) / 2, h.push(p.x, p.y)
                }
                for (o = 1; o <= t; o++) l.push(o, o + 1, 0);
                this.setIndex(l), this.addAttribute("position", new I(c, 3)), this.addAttribute("normal", new I(u, 3)), this.addAttribute("uv", new I(h, 2))
            }

            function di(e) {
                F.call(this), this.type = "ShadowMaterial", this.color = new v(0), this.transparent = !0, this.setValues(e)
            }

            function pi(e) {
                G.call(this, e), this.type = "RawShaderMaterial"
            }

            function fi(e) {
                F.call(this), this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new v(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new v(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Nl, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function mi(e) {
                fi.call(this), this.defines = {
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(e)
            }

            function vi(e) {
                F.call(this), this.type = "MeshPhongMaterial", this.color = new v(16777215), this.specular = new v(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new v(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Nl, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ts, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function gi(e) {
                vi.call(this), this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(e)
            }

            function yi(e) {
                F.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Nl, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function xi(e) {
                F.call(this), this.type = "MeshLambertMaterial", this.color = new v(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new v(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = ts, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function bi(e) {
                if (F.call(this), this.defines = {
                        MATCAP: ""
                    }, this.type = "MeshMatcapMaterial", this.color = new v(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Nl, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.lights = !1, this.setValues(e), null === this.matcap) {
                    var t = document.createElement("canvas");
                    t.width = 1, t.height = 1;
                    var i = t.getContext("2d");
                    i.fillStyle = "#fff", i.fillRect(0, 0, 1, 1), this.matcap = new THREE.CanvasTexture(t)
                }
            }

            function _i(e) {
                Ut.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
            }

            function wi(e, t, n, i) {
                this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n
            }

            function Mi(e, t, n, i) {
                wi.call(this, e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
            }

            function Ti(e, t, n, i) {
                wi.call(this, e, t, n, i)
            }

            function Ei(e, t, n, i) {
                wi.call(this, e, t, n, i)
            }

            function Si(e, t, n, i) {
                if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                this.name = e, this.times = Ch.convertArray(t, this.TimeBufferType), this.values = Ch.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
            }

            function Pi(e, t, n) {
                Si.call(this, e, t, n)
            }

            function Ci(e, t, n, i) {
                Si.call(this, e, t, n, i)
            }

            function Ai(e, t, n, i) {
                Si.call(this, e, t, n, i)
            }

            function Li(e, t, n, i) {
                wi.call(this, e, t, n, i)
            }

            function Ri(e, t, n, i) {
                Si.call(this, e, t, n, i)
            }

            function Ii(e, t, n, i) {
                Si.call(this, e, t, n, i)
            }

            function Oi(e, t, n, i) {
                Si.call(this, e, t, n, i)
            }

            function ki(e, t, n) {
                this.name = e, this.tracks = n, this.duration = void 0 !== t ? t : -1, this.uuid = jl.generateUUID(), this.duration < 0 && this.resetDuration()
            }

            function Di(e) {
                switch (e.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return Ai;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return Oi;
                    case "color":
                        return Ci;
                    case "quaternion":
                        return Ri;
                    case "bool":
                    case "boolean":
                        return Pi;
                    case "string":
                        return Ii
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
            }

            function zi(e) {
                if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                var t = Di(e.type);
                if (void 0 === e.times) {
                    var n = [],
                        i = [];
                    Ch.flattenJSON(e.keys, n, i, "value"), e.times = n, e.values = i
                }
                return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
            }

            function Bi(e, t, n) {
                var i = this,
                    r = !1,
                    a = 0,
                    o = 0,
                    s = void 0;
                this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function (e) {
                    o++, r === !1 && void 0 !== i.onStart && i.onStart(e, a, o), r = !0
                }, this.itemEnd = function (e) {
                    a++, void 0 !== i.onProgress && i.onProgress(e, a, o), a === o && (r = !1, void 0 !== i.onLoad && i.onLoad())
                }, this.itemError = function (e) {
                    void 0 !== i.onError && i.onError(e)
                }, this.resolveURL = function (e) {
                    return s ? s(e) : e
                }, this.setURLModifier = function (e) {
                    return s = e, this
                }
            }

            function Ni(e) {
                this.manager = void 0 !== e ? e : Lh
            }

            function Ui(e) {
                this.manager = void 0 !== e ? e : Lh
            }

            function ji(e) {
                this.manager = void 0 !== e ? e : Lh, this._parser = null
            }

            function Fi(e) {
                this.manager = void 0 !== e ? e : Lh, this._parser = null
            }

            function Gi(e) {
                this.manager = void 0 !== e ? e : Lh
            }

            function Hi(e) {
                this.manager = void 0 !== e ? e : Lh
            }

            function Vi(e) {
                this.manager = void 0 !== e ? e : Lh
            }

            function Wi() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }

            function qi(e, t, n, i, r, a, o, s) {
                Wi.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = n || 1, this.yRadius = i || 1, this.aStartAngle = r || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = o || !1, this.aRotation = s || 0
            }

            function Xi(e, t, n, i, r, a) {
                qi.call(this, e, t, n, n, i, r, a), this.type = "ArcCurve"
            }

            function Yi() {
                function e(e, a, o, s) {
                    t = e, n = o, i = -3 * e + 3 * a - 2 * o - s, r = 2 * e - 2 * a + o + s
                }
                var t = 0,
                    n = 0,
                    i = 0,
                    r = 0;
                return {
                    initCatmullRom: function (t, n, i, r, a) {
                        e(n, i, a * (i - t), a * (r - n))
                    },
                    initNonuniformCatmullRom: function (t, n, i, r, a, o, s) {
                        var l = (n - t) / a - (i - t) / (a + o) + (i - n) / o,
                            c = (i - n) / o - (r - n) / (o + s) + (r - i) / s;
                        l *= o, c *= o, e(n, i, l, c)
                    },
                    calc: function (e) {
                        var a = e * e,
                            o = a * e;
                        return t + n * e + i * a + r * o
                    }
                }
            }

            function Zi(e, t, n, i) {
                Wi.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = n || "centripetal", this.tension = i || .5
            }

            function Ji(e, t, n, i, r) {
                var a = .5 * (i - t),
                    o = .5 * (r - n),
                    s = e * e,
                    l = e * s;
                return (2 * n - 2 * i + a + o) * l + (-3 * n + 3 * i - 2 * a - o) * s + a * e + n
            }

            function $i(e, t) {
                var n = 1 - e;
                return n * n * t
            }

            function Qi(e, t) {
                return 2 * (1 - e) * e * t
            }

            function Ki(e, t) {
                return e * e * t
            }

            function er(e, t, n, i) {
                return $i(e, t) + Qi(e, n) + Ki(e, i)
            }

            function tr(e, t) {
                var n = 1 - e;
                return n * n * n * t
            }

            function nr(e, t) {
                var n = 1 - e;
                return 3 * n * n * e * t
            }

            function ir(e, t) {
                return 3 * (1 - e) * e * e * t
            }

            function rr(e, t) {
                return e * e * e * t
            }

            function ar(e, t, n, i, r) {
                return tr(e, t) + nr(e, n) + ir(e, i) + rr(e, r)
            }

            function or(e, t, i, r) {
                Wi.call(this), this.type = "CubicBezierCurve", this.v0 = e || new n, this.v1 = t || new n, this.v2 = i || new n, this.v3 = r || new n
            }

            function sr(e, t, n, i) {
                Wi.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new a, this.v1 = t || new a, this.v2 = n || new a, this.v3 = i || new a
            }

            function lr(e, t) {
                Wi.call(this), this.type = "LineCurve", this.v1 = e || new n, this.v2 = t || new n
            }

            function cr(e, t) {
                Wi.call(this), this.type = "LineCurve3", this.v1 = e || new a, this.v2 = t || new a
            }

            function ur(e, t, i) {
                Wi.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new n, this.v1 = t || new n, this.v2 = i || new n
            }

            function hr(e, t, n) {
                Wi.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new a, this.v1 = t || new a, this.v2 = n || new a
            }

            function dr(e) {
                Wi.call(this), this.type = "SplineCurve", this.points = e || []
            }

            function pr() {
                Wi.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }

            function fr(e) {
                pr.call(this), this.type = "Path", this.currentPoint = new n, e && this.setFromPoints(e)
            }

            function mr(e) {
                fr.call(this, e), this.uuid = jl.generateUUID(), this.type = "Shape", this.holes = []
            }

            function vr(e, t) {
                w.call(this), this.type = "Light", this.color = new v(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0
            }

            function gr(e, t, n) {
                vr.call(this, e, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(w.DefaultUp), this.updateMatrix(), this.groundColor = new v(t)
            }

            function yr(e) {
                this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new n(512, 512), this.map = null, this.matrix = new i
            }

            function xr() {
                yr.call(this, new wt(50, 1, .5, 500))
            }

            function br(e, t, n, i, r, a) {
                vr.call(this, e, t), this.type = "SpotLight", this.position.copy(w.DefaultUp), this.updateMatrix(), this.target = new w, Object.defineProperty(this, "power", {
                    get: function () {
                        return this.intensity * Math.PI
                    },
                    set: function (e) {
                        this.intensity = e / Math.PI
                    }
                }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new xr
            }

            function _r(e, t, n, i) {
                vr.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
                    get: function () {
                        return 4 * this.intensity * Math.PI
                    },
                    set: function (e) {
                        this.intensity = e / (4 * Math.PI)
                    }
                }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new yr(new wt(90, 1, .5, 500))
            }

            function wr(e, t, n, i, r, a) {
                _t.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== e ? e : -1, this.right = void 0 !== t ? t : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== i ? i : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix()
            }

            function Mr() {
                yr.call(this, new wr((-5), 5, 5, (-5), .5, 500))
            }

            function Tr(e, t) {
                vr.call(this, e, t), this.type = "DirectionalLight", this.position.copy(w.DefaultUp), this.updateMatrix(), this.target = new w, this.shadow = new Mr
            }

            function Er(e, t) {
                vr.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0
            }

            function Sr(e, t, n, i) {
                vr.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10
            }

            function Pr(e) {
                this.manager = void 0 !== e ? e : Lh, this.textures = {}
            }

            function Cr(e) {
                this.manager = void 0 !== e ? e : Lh
            }

            function Ar() {}

            function Lr(e) {
                "boolean" == typeof e && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), e = void 0), this.manager = void 0 !== e ? e : Lh, this.withCredentials = !1
            }

            function Rr(e) {
                this.manager = void 0 !== e ? e : Lh, this.resourcePath = ""
            }

            function Ir(e) {
                "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== e ? e : Lh, this.options = void 0
            }

            function Or() {
                this.type = "ShapePath", this.color = new v, this.subPaths = [], this.currentPath = null
            }

            function kr(e) {
                this.type = "Font", this.data = e
            }

            function Dr(e, t, n) {
                for (var i = Array.from ? Array.from(e) : String(e).split(""), r = t / n.resolution, a = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r, o = [], s = 0, l = 0, c = 0; c < i.length; c++) {
                    var u = i[c];
                    if ("\n" === u) s = 0, l -= a;
                    else {
                        var h = zr(u, r, s, l, n);
                        s += h.offsetX, o.push(h.path)
                    }
                }
                return o
            }

            function zr(e, t, n, i, r) {
                var a = r.glyphs[e] || r.glyphs["?"];
                if (a) {
                    var o, s, l, c, u, h, d, p, f = new Or;
                    if (a.o)
                        for (var m = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), v = 0, g = m.length; v < g;) {
                            var y = m[v++];
                            switch (y) {
                                case "m":
                                    o = m[v++] * t + n, s = m[v++] * t + i, f.moveTo(o, s);
                                    break;
                                case "l":
                                    o = m[v++] * t + n, s = m[v++] * t + i, f.lineTo(o, s);
                                    break;
                                case "q":
                                    l = m[v++] * t + n, c = m[v++] * t + i, u = m[v++] * t + n, h = m[v++] * t + i, f.quadraticCurveTo(u, h, l, c);
                                    break;
                                case "b":
                                    l = m[v++] * t + n, c = m[v++] * t + i, u = m[v++] * t + n, h = m[v++] * t + i, d = m[v++] * t + n, p = m[v++] * t + i, f.bezierCurveTo(u, h, d, p, l, c)
                            }
                        }
                    return {
                        offsetX: a.ha * t,
                        path: f
                    }
                }
            }

            function Br(e) {
                this.manager = void 0 !== e ? e : Lh
            }

            function Nr(e) {
                this.manager = void 0 !== e ? e : Lh
            }

            function Ur() {
                this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new wt, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new wt, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
            }

            function jr(e, t, n, i) {
                w.call(this), this.type = "CubeCamera";
                var r = 90,
                    o = 1,
                    s = new wt(r, o, e, t);
                s.up.set(0, -1, 0), s.lookAt(new a(1, 0, 0)), this.add(s);
                var l = new wt(r, o, e, t);
                l.up.set(0, -1, 0), l.lookAt(new a((-1), 0, 0)), this.add(l);
                var c = new wt(r, o, e, t);
                c.up.set(0, 0, 1), c.lookAt(new a(0, 1, 0)), this.add(c);
                var h = new wt(r, o, e, t);
                h.up.set(0, 0, -1), h.lookAt(new a(0, (-1), 0)), this.add(h);
                var d = new wt(r, o, e, t);
                d.up.set(0, -1, 0), d.lookAt(new a(0, 0, 1)), this.add(d);
                var p = new wt(r, o, e, t);
                p.up.set(0, -1, 0), p.lookAt(new a(0, 0, (-1))), this.add(p), i = i || {
                    format: Us,
                    magFilter: Ms,
                    minFilter: Ms
                }, this.renderTarget = new u(n, n, i), this.renderTarget.texture.name = "CubeCamera", this.update = function (e, t) {
                    null === this.parent && this.updateMatrixWorld();
                    var n = this.renderTarget,
                        i = n.texture.generateMipmaps;
                    n.texture.generateMipmaps = !1, n.activeCubeFace = 0, e.render(t, s, n), n.activeCubeFace = 1, e.render(t, l, n), n.activeCubeFace = 2, e.render(t, c, n), n.activeCubeFace = 3, e.render(t, h, n), n.activeCubeFace = 4, e.render(t, d, n), n.texture.generateMipmaps = i, n.activeCubeFace = 5, e.render(t, p, n), e.setRenderTarget(null)
                }, this.clear = function (e, t, n, i) {
                    for (var r = this.renderTarget, a = 0; a < 6; a++) r.activeCubeFace = a, e.setRenderTarget(r), e.clear(t, n, i);
                    e.setRenderTarget(null)
                }
            }

            function Fr(e) {
                this.autoStart = void 0 === e || e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }

            function Gr() {
                w.call(this), this.type = "AudioListener", this.context = Hh.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0
            }

            function Hr(e) {
                w.call(this), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
            }

            function Vr(e) {
                Hr.call(this, e), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
            }

            function Wr(e, t) {
                this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
            }

            function qr(e, t, n) {
                this.binding = e, this.valueSize = n;
                var i, r = Float64Array;
                switch (t) {
                    case "quaternion":
                        i = this._slerp;
                        break;
                    case "string":
                    case "bool":
                        r = Array, i = this._select;
                        break;
                    default:
                        i = this._lerp
                }
                this.buffer = new r(4 * n), this._mixBufferRegion = i, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
            }

            function Xr(e, t, n) {
                var i = n || Yr.parseTrackName(t);
                this._targetGroup = e, this._bindings = e.subscribe_(t, i)
            }

            function Yr(e, t, n) {
                this.path = t, this.parsedPath = n || Yr.parseTrackName(t), this.node = Yr.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e
            }

            function Zr() {
                this.uuid = jl.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                var e = {};
                this._indicesByUUID = e;
                for (var t = 0, n = arguments.length; t !== n; ++t) e[arguments[t].uuid] = t;
                this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                var i = this;
                this.stats = {
                    objects: {
                        get total() {
                            return i._objects.length
                        },
                        get inUse() {
                            return this.total - i.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return i._bindings.length
                    }
                }
            }

            function Jr(e, t, n) {
                this._mixer = e, this._clip = t, this._localRoot = n || null;
                for (var i = t.tracks, r = i.length, a = new Array(r), o = {
                        endingStart: wl,
                        endingEnd: wl
                    }, s = 0; s !== r; ++s) {
                    var l = i[s].createInterpolant(null);
                    a[s] = l, l.settings = o
                }
                this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = gl, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }

            function $r(e) {
                this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }

            function Qr(e) {
                "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e
            }

            function Kr() {
                z.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
            }

            function ea(e, t, n) {
                Rt.call(this, e, t), this.meshPerAttribute = n || 1
            }

            function ta(e, t, n, i) {
                "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), T.call(this, e, t, n), this.meshPerAttribute = i || 1
            }

            function na(e, t, n, i) {
                this.ray = new H(e, t), this.near = n || 0, this.far = i || 1 / 0, this.params = {
                    Mesh: {},
                    Line: {},
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }, Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function () {
                            return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                        }
                    }
                })
            }

            function ia(e, t) {
                return e.distance - t.distance
            }

            function ra(e, t, n, i) {
                if (e.visible !== !1 && (e.raycast(t, n), i === !0))
                    for (var r = e.children, a = 0, o = r.length; a < o; a++) ra(r[a], t, n, !0)
            }

            function aa(e, t, n) {
                return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== n ? n : 0, this
            }

            function oa(e, t, n) {
                return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== n ? n : 0, this
            }

            function sa(e, t) {
                this.min = void 0 !== e ? e : new n((+(1 / 0)), (+(1 / 0))), this.max = void 0 !== t ? t : new n((-(1 / 0)), (-(1 / 0)))
            }

            function la(e, t) {
                this.start = void 0 !== e ? e : new a, this.end = void 0 !== t ? t : new a
            }

            function ca(e) {
                w.call(this), this.material = e, this.render = function () {}
            }

            function ua(e, t, n, i) {
                this.object = e, this.size = void 0 !== t ? t : 1;
                var r = void 0 !== n ? n : 16711680,
                    a = void 0 !== i ? i : 1,
                    o = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? o = 3 * s.faces.length : s && s.isBufferGeometry && (o = s.attributes.normal.count);
                var l = new z,
                    c = new I(2 * o * 3, 3);
                l.addAttribute("position", c), Ft.call(this, l, new Ut({
                    color: r,
                    linewidth: a
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function ha(e, t) {
                w.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
                for (var n = new z, i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, a = 1, o = 32; r < o; r++, a++) {
                    var s = r / o * Math.PI * 2,
                        l = a / o * Math.PI * 2;
                    i.push(Math.cos(s), Math.sin(s), 1, Math.cos(l), Math.sin(l), 1)
                }
                n.addAttribute("position", new I(i, 3));
                var c = new Ut({
                    fog: !1
                });
                this.cone = new Ft(n, c), this.add(this.cone), this.update()
            }

            function da(e) {
                var t = [];
                e && e.isBone && t.push(e);
                for (var n = 0; n < e.children.length; n++) t.push.apply(t, da(e.children[n]));
                return t
            }

            function pa(e) {
                for (var t = da(e), n = new z, i = [], r = [], a = new v(0, 0, 1), o = new v(0, 1, 0), s = 0; s < t.length; s++) {
                    var l = t[s];
                    l.parent && l.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(o.r, o.g, o.b))
                }
                n.addAttribute("position", new I(i, 3)), n.addAttribute("color", new I(r, 3));
                var c = new Ut({
                    vertexColors: To,
                    depthTest: !1,
                    depthWrite: !1,
                    transparent: !0
                });
                Ft.call(this, n, c), this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
            }

            function fa(e, t, n) {
                this.light = e, this.light.updateMatrixWorld(), this.color = n;
                var i = new $n(t, 4, 2),
                    r = new W({
                        wireframe: !0,
                        fog: !1
                    });
                q.call(this, i, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
            }

            function ma(e, t) {
                w.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
                var n = new Ut({
                        fog: !1
                    }),
                    i = new z;
                i.addAttribute("position", new T(new Float32Array(15), 3)), this.line = new jt(i, n), this.add(this.line), this.update()
            }

            function va(e, t, n) {
                w.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
                var i = new rn(t);
                i.rotateY(.5 * Math.PI), this.material = new W({
                    wireframe: !0,
                    fog: !1
                }), void 0 === this.color && (this.material.vertexColors = To);
                var r = i.getAttribute("position"),
                    a = new Float32Array(3 * r.count);
                i.addAttribute("color", new T(a, 3)), this.add(new q(i, this.material)), this.update()
            }

            function ga(e, t, n, i) {
                e = e || 10, t = t || 10, n = new v(void 0 !== n ? n : 4473924), i = new v(void 0 !== i ? i : 8947848);
                for (var r = t / 2, a = e / t, o = e / 2, s = [], l = [], c = 0, u = 0, h = -o; c <= t; c++, h += a) {
                    s.push(-o, 0, h, o, 0, h), s.push(h, 0, -o, h, 0, o);
                    var d = c === r ? n : i;
                    d.toArray(l, u), u += 3, d.toArray(l, u), u += 3, d.toArray(l, u), u += 3, d.toArray(l, u), u += 3
                }
                var p = new z;
                p.addAttribute("position", new I(s, 3)), p.addAttribute("color", new I(l, 3));
                var f = new Ut({
                    vertexColors: To
                });
                Ft.call(this, p, f)
            }

            function ya(e, t, n, i, r, a) {
                e = e || 10, t = t || 16, n = n || 8, i = i || 64, r = new v(void 0 !== r ? r : 4473924), a = new v(void 0 !== a ? a : 8947848);
                var o, s, l, c, u, h, d, p = [],
                    f = [];
                for (c = 0; c <= t; c++) l = c / t * (2 * Math.PI), o = Math.sin(l) * e, s = Math.cos(l) * e, p.push(0, 0, 0), p.push(o, 0, s), d = 1 & c ? r : a, f.push(d.r, d.g, d.b), f.push(d.r, d.g, d.b);
                for (c = 0; c <= n; c++)
                    for (d = 1 & c ? r : a, h = e - e / n * c, u = 0; u < i; u++) l = u / i * (2 * Math.PI), o = Math.sin(l) * h, s = Math.cos(l) * h, p.push(o, 0, s), f.push(d.r, d.g, d.b), l = (u + 1) / i * (2 * Math.PI), o = Math.sin(l) * h, s = Math.cos(l) * h, p.push(o, 0, s), f.push(d.r, d.g, d.b);
                var m = new z;
                m.addAttribute("position", new I(p, 3)), m.addAttribute("color", new I(f, 3));
                var g = new Ut({
                    vertexColors: To
                });
                Ft.call(this, m, g)
            }

            function xa(e, t, n, i) {
                this.object = e, this.size = void 0 !== t ? t : 1;
                var r = void 0 !== n ? n : 16776960,
                    a = void 0 !== i ? i : 1,
                    o = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? o = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
                var l = new z,
                    c = new I(2 * o * 3, 3);
                l.addAttribute("position", c), Ft.call(this, l, new Ut({
                    color: r,
                    linewidth: a
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function ba(e, t, n) {
                w.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === t && (t = 1);
                var i = new z;
                i.addAttribute("position", new I([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
                var r = new Ut({
                    fog: !1
                });
                this.lightPlane = new jt(i, r), this.add(this.lightPlane), i = new z, i.addAttribute("position", new I([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new jt(i, r), this.add(this.targetLine), this.update()
            }

            function _a(e) {
                function t(e, t, i) {
                    n(e, i), n(t, i)
                }

                function n(e, t) {
                    a.push(0, 0, 0), o.push(t.r, t.g, t.b), void 0 === s[e] && (s[e] = []), s[e].push(a.length / 3 - 1)
                }
                var i = new z,
                    r = new Ut({
                        color: 16777215,
                        vertexColors: Mo
                    }),
                    a = [],
                    o = [],
                    s = {},
                    l = new v(16755200),
                    c = new v(16711680),
                    u = new v(43775),
                    h = new v(16777215),
                    d = new v(3355443);
                t("n1", "n2", l), t("n2", "n4", l), t("n4", "n3", l), t("n3", "n1", l), t("f1", "f2", l), t("f2", "f4", l), t("f4", "f3", l), t("f3", "f1", l), t("n1", "f1", l), t("n2", "f2", l), t("n3", "f3", l), t("n4", "f4", l), t("p", "n1", c), t("p", "n2", c), t("p", "n3", c), t("p", "n4", c), t("u1", "u2", u), t("u2", "u3", u), t("u3", "u1", u), t("c", "t", h), t("p", "c", d), t("cn1", "cn2", d), t("cn3", "cn4", d), t("cf1", "cf2", d), t("cf3", "cf4", d), i.addAttribute("position", new I(a, 3)), i.addAttribute("color", new I(o, 3)), Ft.call(this, i, r), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
            }

            function wa(e, t) {
                this.object = e, void 0 === t && (t = 16776960);
                var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    i = new Float32Array(24),
                    r = new z;
                r.setIndex(new T(n, 1)), r.addAttribute("position", new T(i, 3)), Ft.call(this, r, new Ut({
                    color: t
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function Ma(e, t) {
                this.type = "Box3Helper", this.box = e;
                var n = void 0 !== t ? t : 16776960,
                    i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],
                    a = new z;
                a.setIndex(new T(i, 1)), a.addAttribute("position", new I(r, 3)), Ft.call(this, a, new Ut({
                    color: n
                })), this.geometry.computeBoundingSphere()
            }

            function Ta(e, t, n) {
                this.type = "PlaneHelper", this.plane = e, this.size = void 0 === t ? 1 : t;
                var i = void 0 !== n ? n : 16776960,
                    r = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0],
                    a = new z;
                a.addAttribute("position", new I(r, 3)), a.computeBoundingSphere(), jt.call(this, a, new Ut({
                    color: i
                }));
                var o = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
                    s = new z;
                s.addAttribute("position", new I(o, 3)), s.computeBoundingSphere(), this.add(new q(s, new W({
                    color: i,
                    opacity: .2,
                    transparent: !0,
                    depthWrite: !1
                })))
            }

            function Ea(e, t, n, i, r, a) {
                w.call(this), void 0 === e && (e = new THREE.Vector3(0, 0, 1)), void 0 === t && (t = new THREE.Vector3(0, 0, 0)), void 0 === n && (n = 1), void 0 === i && (i = 16776960), void 0 === r && (r = .2 * n), void 0 === a && (a = .2 * r), void 0 === Wh && (Wh = new z, Wh.addAttribute("position", new I([0, 0, 0, 0, 1, 0], 3)), qh = new si(0, .5, 1, 5, 1), qh.translate(0, -.5, 0)), this.position.copy(t), this.line = new jt(Wh, new Ut({
                    color: i
                })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new q(qh, new W({
                    color: i
                })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, r, a)
            }

            function Sa(e) {
                e = e || 1;
                var t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
                    n = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],
                    i = new z;
                i.addAttribute("position", new I(t, 3)), i.addAttribute("color", new I(n, 3));
                var r = new Ut({
                    vertexColors: To
                });
                Ft.call(this, i, r)
            }

            function Pa(e, t, n, i, r, a, o) {
                return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new x(e, t, n, r, a, o)
            }

            function Ca(e) {
                return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e
            }

            function Aa(e) {
                return void 0 === e && (e = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, e.materials = e, e.clone = function () {
                    return e.slice()
                }, e
            }

            function La(e, t) {
                return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Vt(e, t)
            }

            function Ra(e) {
                return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new kt(e)
            }

            function Ia(e, t) {
                return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Vt(e, t)
            }

            function Oa(e) {
                return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Ht(e)
            }

            function ka(e) {
                return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Ht(e)
            }

            function Da(e) {
                return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Ht(e)
            }

            function za(e, t, n) {
                return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new a(e, t, n)
            }

            function Ba(e, t) {
                return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new T(e, t).setDynamic(!0)
            }

            function Na(e, t) {
                return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new E(e, t)
            }

            function Ua(e, t) {
                return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new S(e, t)
            }

            function ja(e, t) {
                return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new P(e, t)
            }

            function Fa(e, t) {
                return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new C(e, t)
            }

            function Ga(e, t) {
                return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new A(e, t)
            }

            function Ha(e, t) {
                return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),
                    new L(e, t)
            }

            function Va(e, t) {
                return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new R(e, t)
            }

            function Wa(e, t) {
                return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new I(e, t)
            }

            function qa(e, t) {
                return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new O(e, t)
            }

            function Xa(e) {
                console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Zi.call(this, e), this.type = "catmullrom", this.closed = !0
            }

            function Ya(e) {
                console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Zi.call(this, e), this.type = "catmullrom"
            }

            function Za(e) {
                console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Zi.call(this, e), this.type = "catmullrom"
            }

            function Ja(e) {
                return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Sa(e)
            }

            function $a(e, t) {
                return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new wa(e, t)
            }

            function Qa(e, t) {
                return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Ft(new ai(e.geometry), new Ut({
                    color: void 0 !== t ? t : 16777215
                }))
            }

            function Ka(e, t) {
                return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Ft(new Zt(e.geometry), new Ut({
                    color: void 0 !== t ? t : 16777215
                }))
            }

            function eo(e) {
                return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Ni(e)
            }

            function to(e) {
                return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Fi(e)
            }

            function no() {
                console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function (e, t) {
                    console.warn("THREE.Projector: .projectVector() is now vector.project()."), e.project(t)
                }, this.unprojectVector = function (e, t) {
                    console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), e.unproject(t)
                }, this.pickingRay = function () {
                    console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
                }
            }

            function io() {
                console.error("THREE.CanvasRenderer has been removed")
            }

            function ro() {
                console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
            }
            void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (e) {
                return "number" == typeof e && isFinite(e) && Math.floor(e) === e
            }), void 0 === Math.sign && (Math.sign = function (e) {
                return e < 0 ? -1 : e > 0 ? 1 : +e
            }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
                get: function () {
                    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
                }
            }), void 0 === Object.assign && ! function () {
                Object.assign = function (e) {
                    if (void 0 === e || null === e) throw new TypeError("Cannot convert undefined or null to object");
                    for (var t = Object(e), n = 1; n < arguments.length; n++) {
                        var i = arguments[n];
                        if (void 0 !== i && null !== i)
                            for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (t[r] = i[r])
                    }
                    return t
                }
            }(), Object.assign(t.prototype, {
                addEventListener: function (e, t) {
                    void 0 === this._listeners && (this._listeners = {});
                    var n = this._listeners;
                    void 0 === n[e] && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t)
                },
                hasEventListener: function (e, t) {
                    if (void 0 === this._listeners) return !1;
                    var n = this._listeners;
                    return void 0 !== n[e] && n[e].indexOf(t) !== -1
                },
                removeEventListener: function (e, t) {
                    if (void 0 !== this._listeners) {
                        var n = this._listeners,
                            i = n[e];
                        if (void 0 !== i) {
                            var r = i.indexOf(t);
                            r !== -1 && i.splice(r, 1)
                        }
                    }
                },
                dispatchEvent: function (e) {
                    if (void 0 !== this._listeners) {
                        var t = this._listeners,
                            n = t[e.type];
                        if (void 0 !== n) {
                            e.target = this;
                            for (var i = n.slice(0), r = 0, a = i.length; r < a; r++) i[r].call(this, e)
                        }
                    }
                }
            });
            var ao = "98",
                oo = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2
                },
                so = 0,
                lo = 1,
                co = 2,
                uo = 3,
                ho = 0,
                po = 1,
                fo = 0,
                mo = 1,
                vo = 2,
                go = 0,
                yo = 1,
                xo = 2,
                bo = 1,
                _o = 2,
                wo = 0,
                Mo = 1,
                To = 2,
                Eo = 0,
                So = 1,
                Po = 2,
                Co = 3,
                Ao = 4,
                Lo = 5,
                Ro = 100,
                Io = 101,
                Oo = 102,
                ko = 103,
                Do = 104,
                zo = 200,
                Bo = 201,
                No = 202,
                Uo = 203,
                jo = 204,
                Fo = 205,
                Go = 206,
                Ho = 207,
                Vo = 208,
                Wo = 209,
                qo = 210,
                Xo = 0,
                Yo = 1,
                Zo = 2,
                Jo = 3,
                $o = 4,
                Qo = 5,
                Ko = 6,
                es = 7,
                ts = 0,
                ns = 1,
                is = 2,
                rs = 0,
                as = 1,
                os = 2,
                ss = 3,
                ls = 4,
                cs = 300,
                us = 301,
                hs = 302,
                ds = 303,
                ps = 304,
                fs = 305,
                ms = 306,
                vs = 307,
                gs = 1e3,
                ys = 1001,
                xs = 1002,
                bs = 1003,
                _s = 1004,
                ws = 1005,
                Ms = 1006,
                Ts = 1007,
                Es = 1008,
                Ss = 1009,
                Ps = 1010,
                Cs = 1011,
                As = 1012,
                Ls = 1013,
                Rs = 1014,
                Is = 1015,
                Os = 1016,
                ks = 1017,
                Ds = 1018,
                zs = 1019,
                Bs = 1020,
                Ns = 1021,
                Us = 1022,
                js = 1023,
                Fs = 1024,
                Gs = 1025,
                Hs = js,
                Vs = 1026,
                Ws = 1027,
                qs = 1028,
                Xs = 33776,
                Ys = 33777,
                Zs = 33778,
                Js = 33779,
                $s = 35840,
                Qs = 35841,
                Ks = 35842,
                el = 35843,
                tl = 36196,
                nl = 37808,
                il = 37809,
                rl = 37810,
                al = 37811,
                ol = 37812,
                sl = 37813,
                ll = 37814,
                cl = 37815,
                ul = 37816,
                hl = 37817,
                dl = 37818,
                pl = 37819,
                fl = 37820,
                ml = 37821,
                vl = 2200,
                gl = 2201,
                yl = 2202,
                xl = 2300,
                bl = 2301,
                _l = 2302,
                wl = 2400,
                Ml = 2401,
                Tl = 2402,
                El = 0,
                Sl = 1,
                Pl = 2,
                Cl = 3e3,
                Al = 3001,
                Ll = 3007,
                Rl = 3002,
                Il = 3003,
                Ol = 3004,
                kl = 3005,
                Dl = 3006,
                zl = 3200,
                Bl = 3201,
                Nl = 0,
                Ul = 1,
                jl = {
                    DEG2RAD: Math.PI / 180,
                    RAD2DEG: 180 / Math.PI,
                    generateUUID: function () {
                        for (var e = [], t = 0; t < 256; t++) e[t] = (t < 16 ? "0" : "") + t.toString(16);
                        return function () {
                            var t = 4294967295 * Math.random() | 0,
                                n = 4294967295 * Math.random() | 0,
                                i = 4294967295 * Math.random() | 0,
                                r = 4294967295 * Math.random() | 0,
                                a = e[255 & t] + e[t >> 8 & 255] + e[t >> 16 & 255] + e[t >> 24 & 255] + "-" + e[255 & n] + e[n >> 8 & 255] + "-" + e[n >> 16 & 15 | 64] + e[n >> 24 & 255] + "-" + e[63 & i | 128] + e[i >> 8 & 255] + "-" + e[i >> 16 & 255] + e[i >> 24 & 255] + e[255 & r] + e[r >> 8 & 255] + e[r >> 16 & 255] + e[r >> 24 & 255];
                            return a.toUpperCase()
                        }
                    }(),
                    clamp: function (e, t, n) {
                        return Math.max(t, Math.min(n, e))
                    },
                    euclideanModulo: function (e, t) {
                        return (e % t + t) % t
                    },
                    mapLinear: function (e, t, n, i, r) {
                        return i + (e - t) * (r - i) / (n - t)
                    },
                    lerp: function (e, t, n) {
                        return (1 - n) * e + n * t
                    },
                    smoothstep: function (e, t, n) {
                        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t), e * e * (3 - 2 * e))
                    },
                    smootherstep: function (e, t, n) {
                        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t), e * e * e * (e * (6 * e - 15) + 10))
                    },
                    randInt: function (e, t) {
                        return e + Math.floor(Math.random() * (t - e + 1))
                    },
                    randFloat: function (e, t) {
                        return e + Math.random() * (t - e)
                    },
                    randFloatSpread: function (e) {
                        return e * (.5 - Math.random())
                    },
                    degToRad: function (e) {
                        return e * jl.DEG2RAD
                    },
                    radToDeg: function (e) {
                        return e * jl.RAD2DEG
                    },
                    isPowerOfTwo: function (e) {
                        return 0 === (e & e - 1) && 0 !== e
                    },
                    ceilPowerOfTwo: function (e) {
                        return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
                    },
                    floorPowerOfTwo: function (e) {
                        return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
                    }
                };
            Object.defineProperties(n.prototype, {
                width: {
                    get: function () {
                        return this.x
                    },
                    set: function (e) {
                        this.x = e
                    }
                },
                height: {
                    get: function () {
                        return this.y
                    },
                    set: function (e) {
                        this.y = e
                    }
                }
            }), Object.assign(n.prototype, {
                isVector2: !0,
                set: function (e, t) {
                    return this.x = e, this.y = t, this
                },
                setScalar: function (e) {
                    return this.x = e, this.y = e, this
                },
                setX: function (e) {
                    return this.x = e, this
                },
                setY: function (e) {
                    return this.y = e, this
                },
                setComponent: function (e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                },
                getComponent: function (e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                clone: function () {
                    return new this.constructor(this.x, this.y)
                },
                copy: function (e) {
                    return this.x = e.x, this.y = e.y, this
                },
                add: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
                },
                addScalar: function (e) {
                    return this.x += e, this.y += e, this
                },
                addVectors: function (e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this
                },
                addScaledVector: function (e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this
                },
                sub: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
                },
                subScalar: function (e) {
                    return this.x -= e, this.y -= e, this
                },
                subVectors: function (e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this
                },
                multiply: function (e) {
                    return this.x *= e.x, this.y *= e.y, this
                },
                multiplyScalar: function (e) {
                    return this.x *= e, this.y *= e, this
                },
                divide: function (e) {
                    return this.x /= e.x, this.y /= e.y, this
                },
                divideScalar: function (e) {
                    return this.multiplyScalar(1 / e)
                },
                applyMatrix3: function (e) {
                    var t = this.x,
                        n = this.y,
                        i = e.elements;
                    return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this
                },
                min: function (e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
                },
                max: function (e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
                },
                clamp: function (e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
                },
                clampScalar: function () {
                    var e = new n,
                        t = new n;
                    return function (n, i) {
                        return e.set(n, n), t.set(i, i), this.clamp(e, t)
                    }
                }(),
                clampLength: function (e, t) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                },
                floor: function () {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                },
                ceil: function () {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                },
                round: function () {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                },
                roundToZero: function () {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                },
                negate: function () {
                    return this.x = -this.x, this.y = -this.y, this
                },
                dot: function (e) {
                    return this.x * e.x + this.y * e.y
                },
                cross: function (e) {
                    return this.x * e.y - this.y * e.x
                },
                lengthSq: function () {
                    return this.x * this.x + this.y * this.y
                },
                length: function () {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                manhattanLength: function () {
                    return Math.abs(this.x) + Math.abs(this.y)
                },
                normalize: function () {
                    return this.divideScalar(this.length() || 1)
                },
                angle: function () {
                    var e = Math.atan2(this.y, this.x);
                    return e < 0 && (e += 2 * Math.PI), e
                },
                distanceTo: function (e) {
                    return Math.sqrt(this.distanceToSquared(e))
                },
                distanceToSquared: function (e) {
                    var t = this.x - e.x,
                        n = this.y - e.y;
                    return t * t + n * n
                },
                manhattanDistanceTo: function (e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                },
                setLength: function (e) {
                    return this.normalize().multiplyScalar(e)
                },
                lerp: function (e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
                },
                lerpVectors: function (e, t, n) {
                    return this.subVectors(t, e).multiplyScalar(n).add(e)
                },
                equals: function (e) {
                    return e.x === this.x && e.y === this.y
                },
                fromArray: function (e, t) {
                    return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e
                },
                fromBufferAttribute: function (e, t, n) {
                    return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
                },
                rotateAround: function (e, t) {
                    var n = Math.cos(t),
                        i = Math.sin(t),
                        r = this.x - e.x,
                        a = this.y - e.y;
                    return this.x = r * n - a * i + e.x, this.y = r * i + a * n + e.y, this
                }
            }), Object.assign(i.prototype, {
                isMatrix4: !0,
                set: function (e, t, n, i, r, a, o, s, l, c, u, h, d, p, f, m) {
                    var v = this.elements;
                    return v[0] = e, v[4] = t, v[8] = n, v[12] = i, v[1] = r, v[5] = a, v[9] = o, v[13] = s, v[2] = l, v[6] = c, v[10] = u, v[14] = h, v[3] = d, v[7] = p, v[11] = f, v[15] = m, this
                },
                identity: function () {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                clone: function () {
                    return (new i).fromArray(this.elements)
                },
                copy: function (e) {
                    var t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
                },
                copyPosition: function (e) {
                    var t = this.elements,
                        n = e.elements;
                    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
                },
                extractBasis: function (e, t, n) {
                    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                },
                makeBasis: function (e, t, n) {
                    return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
                },
                extractRotation: function () {
                    var e = new a;
                    return function (t) {
                        var n = this.elements,
                            i = t.elements,
                            r = 1 / e.setFromMatrixColumn(t, 0).length(),
                            a = 1 / e.setFromMatrixColumn(t, 1).length(),
                            o = 1 / e.setFromMatrixColumn(t, 2).length();
                        return n[0] = i[0] * r, n[1] = i[1] * r, n[2] = i[2] * r, n[3] = 0, n[4] = i[4] * a, n[5] = i[5] * a, n[6] = i[6] * a, n[7] = 0, n[8] = i[8] * o, n[9] = i[9] * o, n[10] = i[10] * o, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this
                    }
                }(),
                makeRotationFromEuler: function (e) {
                    e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var t = this.elements,
                        n = e.x,
                        i = e.y,
                        r = e.z,
                        a = Math.cos(n),
                        o = Math.sin(n),
                        s = Math.cos(i),
                        l = Math.sin(i),
                        c = Math.cos(r),
                        u = Math.sin(r);
                    if ("XYZ" === e.order) {
                        var h = a * c,
                            d = a * u,
                            p = o * c,
                            f = o * u;
                        t[0] = s * c, t[4] = -s * u, t[8] = l, t[1] = d + p * l, t[5] = h - f * l, t[9] = -o * s, t[2] = f - h * l, t[6] = p + d * l, t[10] = a * s
                    } else if ("YXZ" === e.order) {
                        var m = s * c,
                            v = s * u,
                            g = l * c,
                            y = l * u;
                        t[0] = m + y * o, t[4] = g * o - v, t[8] = a * l, t[1] = a * u, t[5] = a * c, t[9] = -o, t[2] = v * o - g, t[6] = y + m * o, t[10] = a * s
                    } else if ("ZXY" === e.order) {
                        var m = s * c,
                            v = s * u,
                            g = l * c,
                            y = l * u;
                        t[0] = m - y * o, t[4] = -a * u, t[8] = g + v * o, t[1] = v + g * o, t[5] = a * c, t[9] = y - m * o, t[2] = -a * l, t[6] = o, t[10] = a * s
                    } else if ("ZYX" === e.order) {
                        var h = a * c,
                            d = a * u,
                            p = o * c,
                            f = o * u;
                        t[0] = s * c, t[4] = p * l - d, t[8] = h * l + f, t[1] = s * u, t[5] = f * l + h, t[9] = d * l - p, t[2] = -l, t[6] = o * s, t[10] = a * s
                    } else if ("YZX" === e.order) {
                        var x = a * s,
                            b = a * l,
                            _ = o * s,
                            w = o * l;
                        t[0] = s * c, t[4] = w - x * u, t[8] = _ * u + b, t[1] = u, t[5] = a * c, t[9] = -o * c, t[2] = -l * c, t[6] = b * u + _, t[10] = x - w * u
                    } else if ("XZY" === e.order) {
                        var x = a * s,
                            b = a * l,
                            _ = o * s,
                            w = o * l;
                        t[0] = s * c, t[4] = -u, t[8] = l * c, t[1] = x * u + w, t[5] = a * c, t[9] = b * u - _, t[2] = _ * u - b, t[6] = o * c, t[10] = w * u + x
                    }
                    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                },
                makeRotationFromQuaternion: function () {
                    var e = new a(0, 0, 0),
                        t = new a(1, 1, 1);
                    return function (n) {
                        return this.compose(e, n, t)
                    }
                }(),
                lookAt: function () {
                    var e = new a,
                        t = new a,
                        n = new a;
                    return function (i, r, a) {
                        var o = this.elements;
                        return n.subVectors(i, r), 0 === n.lengthSq() && (n.z = 1), n.normalize(), e.crossVectors(a, n), 0 === e.lengthSq() && (1 === Math.abs(a.z) ? n.x += 1e-4 : n.z += 1e-4, n.normalize(), e.crossVectors(a, n)), e.normalize(), t.crossVectors(n, e), o[0] = e.x, o[4] = t.x, o[8] = n.x, o[1] = e.y, o[5] = t.y, o[9] = n.y, o[2] = e.z, o[6] = t.z, o[10] = n.z, this
                    }
                }(),
                multiply: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
                },
                premultiply: function (e) {
                    return this.multiplyMatrices(e, this)
                },
                multiplyMatrices: function (e, t) {
                    var n = e.elements,
                        i = t.elements,
                        r = this.elements,
                        a = n[0],
                        o = n[4],
                        s = n[8],
                        l = n[12],
                        c = n[1],
                        u = n[5],
                        h = n[9],
                        d = n[13],
                        p = n[2],
                        f = n[6],
                        m = n[10],
                        v = n[14],
                        g = n[3],
                        y = n[7],
                        x = n[11],
                        b = n[15],
                        _ = i[0],
                        w = i[4],
                        M = i[8],
                        T = i[12],
                        E = i[1],
                        S = i[5],
                        P = i[9],
                        C = i[13],
                        A = i[2],
                        L = i[6],
                        R = i[10],
                        I = i[14],
                        O = i[3],
                        k = i[7],
                        D = i[11],
                        z = i[15];
                    return r[0] = a * _ + o * E + s * A + l * O, r[4] = a * w + o * S + s * L + l * k, r[8] = a * M + o * P + s * R + l * D, r[12] = a * T + o * C + s * I + l * z, r[1] = c * _ + u * E + h * A + d * O, r[5] = c * w + u * S + h * L + d * k, r[9] = c * M + u * P + h * R + d * D, r[13] = c * T + u * C + h * I + d * z, r[2] = p * _ + f * E + m * A + v * O, r[6] = p * w + f * S + m * L + v * k, r[10] = p * M + f * P + m * R + v * D, r[14] = p * T + f * C + m * I + v * z, r[3] = g * _ + y * E + x * A + b * O, r[7] = g * w + y * S + x * L + b * k, r[11] = g * M + y * P + x * R + b * D, r[15] = g * T + y * C + x * I + b * z, this
                },
                multiplyScalar: function (e) {
                    var t = this.elements;
                    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
                },
                applyToBufferAttribute: function () {
                    var e = new a;
                    return function (t) {
                        for (var n = 0, i = t.count; n < i; n++) e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.applyMatrix4(this), t.setXYZ(n, e.x, e.y, e.z);
                        return t
                    }
                }(),
                determinant: function () {
                    var e = this.elements,
                        t = e[0],
                        n = e[4],
                        i = e[8],
                        r = e[12],
                        a = e[1],
                        o = e[5],
                        s = e[9],
                        l = e[13],
                        c = e[2],
                        u = e[6],
                        h = e[10],
                        d = e[14],
                        p = e[3],
                        f = e[7],
                        m = e[11],
                        v = e[15];
                    return p * (+r * s * u - i * l * u - r * o * h + n * l * h + i * o * d - n * s * d) + f * (+t * s * d - t * l * h + r * a * h - i * a * d + i * l * c - r * s * c) + m * (+t * l * u - t * o * d - r * a * u + n * a * d + r * o * c - n * l * c) + v * (-i * o * c - t * s * u + t * o * h + i * a * u - n * a * h + n * s * c)
                },
                transpose: function () {
                    var e, t = this.elements;
                    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                },
                setPosition: function (e) {
                    var t = this.elements;
                    return t[12] = e.x, t[13] = e.y, t[14] = e.z, this
                },
                getInverse: function (e, t) {
                    var n = this.elements,
                        i = e.elements,
                        r = i[0],
                        a = i[1],
                        o = i[2],
                        s = i[3],
                        l = i[4],
                        c = i[5],
                        u = i[6],
                        h = i[7],
                        d = i[8],
                        p = i[9],
                        f = i[10],
                        m = i[11],
                        v = i[12],
                        g = i[13],
                        y = i[14],
                        x = i[15],
                        b = p * y * h - g * f * h + g * u * m - c * y * m - p * u * x + c * f * x,
                        _ = v * f * h - d * y * h - v * u * m + l * y * m + d * u * x - l * f * x,
                        w = d * g * h - v * p * h + v * c * m - l * g * m - d * c * x + l * p * x,
                        M = v * p * u - d * g * u - v * c * f + l * g * f + d * c * y - l * p * y,
                        T = r * b + a * _ + o * w + s * M;
                    if (0 === T) {
                        var E = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                        if (t === !0) throw new Error(E);
                        return console.warn(E), this.identity()
                    }
                    var S = 1 / T;
                    return n[0] = b * S, n[1] = (g * f * s - p * y * s - g * o * m + a * y * m + p * o * x - a * f * x) * S, n[2] = (c * y * s - g * u * s + g * o * h - a * y * h - c * o * x + a * u * x) * S, n[3] = (p * u * s - c * f * s - p * o * h + a * f * h + c * o * m - a * u * m) * S, n[4] = _ * S, n[5] = (d * y * s - v * f * s + v * o * m - r * y * m - d * o * x + r * f * x) * S, n[6] = (v * u * s - l * y * s - v * o * h + r * y * h + l * o * x - r * u * x) * S, n[7] = (l * f * s - d * u * s + d * o * h - r * f * h - l * o * m + r * u * m) * S, n[8] = w * S, n[9] = (v * p * s - d * g * s - v * a * m + r * g * m + d * a * x - r * p * x) * S, n[10] = (l * g * s - v * c * s + v * a * h - r * g * h - l * a * x + r * c * x) * S, n[11] = (d * c * s - l * p * s - d * a * h + r * p * h + l * a * m - r * c * m) * S, n[12] = M * S, n[13] = (d * g * o - v * p * o + v * a * f - r * g * f - d * a * y + r * p * y) * S, n[14] = (v * c * o - l * g * o - v * a * u + r * g * u + l * a * y - r * c * y) * S, n[15] = (l * p * o - d * c * o + d * a * u - r * p * u - l * a * f + r * c * f) * S, this
                },
                scale: function (e) {
                    var t = this.elements,
                        n = e.x,
                        i = e.y,
                        r = e.z;
                    return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this
                },
                getMaxScaleOnAxis: function () {
                    var e = this.elements,
                        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                        n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                        i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                    return Math.sqrt(Math.max(t, n, i))
                },
                makeTranslation: function (e, t, n) {
                    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
                },
                makeRotationX: function (e) {
                    var t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
                },
                makeRotationY: function (e) {
                    var t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
                },
                makeRotationZ: function (e) {
                    var t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                makeRotationAxis: function (e, t) {
                    var n = Math.cos(t),
                        i = Math.sin(t),
                        r = 1 - n,
                        a = e.x,
                        o = e.y,
                        s = e.z,
                        l = r * a,
                        c = r * o;
                    return this.set(l * a + n, l * o - i * s, l * s + i * o, 0, l * o + i * s, c * o + n, c * s - i * a, 0, l * s - i * o, c * s + i * a, r * s * s + n, 0, 0, 0, 0, 1), this
                },
                makeScale: function (e, t, n) {
                    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                },
                makeShear: function (e, t, n) {
                    return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this
                },
                compose: function (e, t, n) {
                    var i = this.elements,
                        r = t._x,
                        a = t._y,
                        o = t._z,
                        s = t._w,
                        l = r + r,
                        c = a + a,
                        u = o + o,
                        h = r * l,
                        d = r * c,
                        p = r * u,
                        f = a * c,
                        m = a * u,
                        v = o * u,
                        g = s * l,
                        y = s * c,
                        x = s * u,
                        b = n.x,
                        _ = n.y,
                        w = n.z;
                    return i[0] = (1 - (f + v)) * b, i[1] = (d + x) * b, i[2] = (p - y) * b, i[3] = 0, i[4] = (d - x) * _, i[5] = (1 - (h + v)) * _, i[6] = (m + g) * _, i[7] = 0, i[8] = (p + y) * w, i[9] = (m - g) * w, i[10] = (1 - (h + f)) * w, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
                },
                decompose: function () {
                    var e = new a,
                        t = new i;
                    return function (n, i, r) {
                        var a = this.elements,
                            o = e.set(a[0], a[1], a[2]).length(),
                            s = e.set(a[4], a[5], a[6]).length(),
                            l = e.set(a[8], a[9], a[10]).length(),
                            c = this.determinant();
                        c < 0 && (o = -o), n.x = a[12], n.y = a[13], n.z = a[14], t.copy(this);
                        var u = 1 / o,
                            h = 1 / s,
                            d = 1 / l;
                        return t.elements[0] *= u, t.elements[1] *= u, t.elements[2] *= u, t.elements[4] *= h, t.elements[5] *= h, t.elements[6] *= h, t.elements[8] *= d, t.elements[9] *= d, t.elements[10] *= d, i.setFromRotationMatrix(t), r.x = o, r.y = s, r.z = l, this
                    }
                }(),
                makePerspective: function (e, t, n, i, r, a) {
                    void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    var o = this.elements,
                        s = 2 * r / (t - e),
                        l = 2 * r / (n - i),
                        c = (t + e) / (t - e),
                        u = (n + i) / (n - i),
                        h = -(a + r) / (a - r),
                        d = -2 * a * r / (a - r);
                    return o[0] = s, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = l, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = h, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
                },
                makeOrthographic: function (e, t, n, i, r, a) {
                    var o = this.elements,
                        s = 1 / (t - e),
                        l = 1 / (n - i),
                        c = 1 / (a - r),
                        u = (t + e) * s,
                        h = (n + i) * l,
                        d = (a + r) * c;
                    return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -h, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
                },
                equals: function (e) {
                    for (var t = this.elements, n = e.elements, i = 0; i < 16; i++)
                        if (t[i] !== n[i]) return !1;
                    return !0
                },
                fromArray: function (e, t) {
                    void 0 === t && (t = 0);
                    for (var n = 0; n < 16; n++) this.elements[n] = e[n + t];
                    return this
                },
                toArray: function (e, t) {
                    void 0 === e && (e = []), void 0 === t && (t = 0);
                    var n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
                }
            }), Object.assign(r, {
                slerp: function (e, t, n, i) {
                    return n.copy(e).slerp(t, i)
                },
                slerpFlat: function (e, t, n, i, r, a, o) {
                    var s = n[i + 0],
                        l = n[i + 1],
                        c = n[i + 2],
                        u = n[i + 3],
                        h = r[a + 0],
                        d = r[a + 1],
                        p = r[a + 2],
                        f = r[a + 3];
                    if (u !== f || s !== h || l !== d || c !== p) {
                        var m = 1 - o,
                            v = s * h + l * d + c * p + u * f,
                            g = v >= 0 ? 1 : -1,
                            y = 1 - v * v;
                        if (y > Number.EPSILON) {
                            var x = Math.sqrt(y),
                                b = Math.atan2(x, v * g);
                            m = Math.sin(m * b) / x, o = Math.sin(o * b) / x
                        }
                        var _ = o * g;
                        if (s = s * m + h * _, l = l * m + d * _, c = c * m + p * _, u = u * m + f * _, m === 1 - o) {
                            var w = 1 / Math.sqrt(s * s + l * l + c * c + u * u);
                            s *= w, l *= w, c *= w, u *= w
                        }
                    }
                    e[t] = s, e[t + 1] = l, e[t + 2] = c, e[t + 3] = u
                }
            }), Object.defineProperties(r.prototype, {
                x: {
                    get: function () {
                        return this._x
                    },
                    set: function (e) {
                        this._x = e, this.onChangeCallback()
                    }
                },
                y: {
                    get: function () {
                        return this._y
                    },
                    set: function (e) {
                        this._y = e, this.onChangeCallback()
                    }
                },
                z: {
                    get: function () {
                        return this._z
                    },
                    set: function (e) {
                        this._z = e, this.onChangeCallback()
                    }
                },
                w: {
                    get: function () {
                        return this._w
                    },
                    set: function (e) {
                        this._w = e, this.onChangeCallback()
                    }
                }
            }), Object.assign(r.prototype, {
                isQuaternion: !0,
                set: function (e, t, n, i) {
                    return this._x = e, this._y = t, this._z = n, this._w = i, this.onChangeCallback(), this
                },
                clone: function () {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                },
                copy: function (e) {
                    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this
                },
                setFromEuler: function (e, t) {
                    if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    var n = e._x,
                        i = e._y,
                        r = e._z,
                        a = e.order,
                        o = Math.cos,
                        s = Math.sin,
                        l = o(n / 2),
                        c = o(i / 2),
                        u = o(r / 2),
                        h = s(n / 2),
                        d = s(i / 2),
                        p = s(r / 2);
                    return "XYZ" === a ? (this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p) : "YXZ" === a ? (this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p) : "ZXY" === a ? (this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p) : "ZYX" === a ? (this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p) : "YZX" === a ? (this._x = h * c * u + l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u - h * d * p) : "XZY" === a && (this._x = h * c * u - l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u + h * d * p), t !== !1 && this.onChangeCallback(), this
                },
                setFromAxisAngle: function (e, t) {
                    var n = t / 2,
                        i = Math.sin(n);
                    return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this.onChangeCallback(), this
                },
                setFromRotationMatrix: function (e) {
                    var t, n = e.elements,
                        i = n[0],
                        r = n[4],
                        a = n[8],
                        o = n[1],
                        s = n[5],
                        l = n[9],
                        c = n[2],
                        u = n[6],
                        h = n[10],
                        d = i + s + h;
                    return d > 0 ? (t = .5 / Math.sqrt(d + 1), this._w = .25 / t, this._x = (u - l) * t, this._y = (a - c) * t, this._z = (o - r) * t) : i > s && i > h ? (t = 2 * Math.sqrt(1 + i - s - h), this._w = (u - l) / t, this._x = .25 * t, this._y = (r + o) / t, this._z = (a + c) / t) : s > h ? (t = 2 * Math.sqrt(1 + s - i - h), this._w = (a - c) / t, this._x = (r + o) / t, this._y = .25 * t, this._z = (l + u) / t) : (t = 2 * Math.sqrt(1 + h - i - s), this._w = (o - r) / t, this._x = (a + c) / t, this._y = (l + u) / t, this._z = .25 * t), this.onChangeCallback(), this
                },
                setFromUnitVectors: function () {
                    var e, t = new a,
                        n = 1e-6;
                    return function (i, r) {
                        return void 0 === t && (t = new a), e = i.dot(r) + 1, e < n ? (e = 0, Math.abs(i.x) > Math.abs(i.z) ? t.set(-i.y, i.x, 0) : t.set(0, -i.z, i.y)) : t.crossVectors(i, r), this._x = t.x, this._y = t.y, this._z = t.z, this._w = e, this.normalize()
                    }
                }(),
                angleTo: function (e) {
                    return 2 * Math.acos(Math.abs(jl.clamp(this.dot(e), -1, 1)))
                },
                rotateTowards: function (e, t) {
                    var n = this.angleTo(e);
                    if (0 === n) return this;
                    var i = Math.min(1, t / n);
                    return this.slerp(e, i), this
                },
                inverse: function () {
                    return this.conjugate()
                },
                conjugate: function () {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
                },
                dot: function (e) {
                    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                },
                lengthSq: function () {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                },
                length: function () {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                },
                normalize: function () {
                    var e = this.length();
                    return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this.onChangeCallback(), this
                },
                multiply: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
                },
                premultiply: function (e) {
                    return this.multiplyQuaternions(e, this)
                },
                multiplyQuaternions: function (e, t) {
                    var n = e._x,
                        i = e._y,
                        r = e._z,
                        a = e._w,
                        o = t._x,
                        s = t._y,
                        l = t._z,
                        c = t._w;
                    return this._x = n * c + a * o + i * l - r * s, this._y = i * c + a * s + r * o - n * l, this._z = r * c + a * l + n * s - i * o, this._w = a * c - n * o - i * s - r * l, this.onChangeCallback(), this
                },
                slerp: function (e, t) {
                    if (0 === t) return this;
                    if (1 === t) return this.copy(e);
                    var n = this._x,
                        i = this._y,
                        r = this._z,
                        a = this._w,
                        o = a * e._w + n * e._x + i * e._y + r * e._z;
                    if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = a, this._x = n, this._y = i, this._z = r, this;
                    var s = 1 - o * o;
                    if (s <= Number.EPSILON) {
                        var l = 1 - t;
                        return this._w = l * a + t * this._w, this._x = l * n + t * this._x, this._y = l * i + t * this._y, this._z = l * r + t * this._z, this.normalize()
                    }
                    var c = Math.sqrt(s),
                        u = Math.atan2(c, o),
                        h = Math.sin((1 - t) * u) / c,
                        d = Math.sin(t * u) / c;
                    return this._w = a * h + this._w * d, this._x = n * h + this._x * d, this._y = i * h + this._y * d, this._z = r * h + this._z * d, this.onChangeCallback(), this
                },
                equals: function (e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                },
                fromArray: function (e, t) {
                    return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this.onChangeCallback(), this
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
                },
                onChange: function (e) {
                    return this.onChangeCallback = e, this
                },
                onChangeCallback: function () {}
            }), Object.assign(a.prototype, {
                isVector3: !0,
                set: function (e, t, n) {
                    return this.x = e, this.y = t, this.z = n, this
                },
                setScalar: function (e) {
                    return this.x = e, this.y = e, this.z = e, this
                },
                setX: function (e) {
                    return this.x = e, this
                },
                setY: function (e) {
                    return this.y = e, this
                },
                setZ: function (e) {
                    return this.z = e, this
                },
                setComponent: function (e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                },
                getComponent: function (e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                clone: function () {
                    return new this.constructor(this.x, this.y, this.z)
                },
                copy: function (e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this
                },
                add: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
                },
                addScalar: function (e) {
                    return this.x += e, this.y += e, this.z += e, this
                },
                addVectors: function (e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
                },
                addScaledVector: function (e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
                },
                sub: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
                },
                subScalar: function (e) {
                    return this.x -= e, this.y -= e, this.z -= e, this
                },
                subVectors: function (e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
                },
                multiply: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
                },
                multiplyScalar: function (e) {
                    return this.x *= e, this.y *= e, this.z *= e, this
                },
                multiplyVectors: function (e, t) {
                    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
                },
                applyEuler: function () {
                    var e = new r;
                    return function (t) {
                        return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(e.setFromEuler(t))
                    }
                }(),
                applyAxisAngle: function () {
                    var e = new r;
                    return function (t, n) {
                        return this.applyQuaternion(e.setFromAxisAngle(t, n))
                    }
                }(),
                applyMatrix3: function (e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.elements;
                    return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this
                },
                applyMatrix4: function (e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.elements,
                        a = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
                    return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * a, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * a, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * a, this
                },
                applyQuaternion: function (e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.x,
                        a = e.y,
                        o = e.z,
                        s = e.w,
                        l = s * t + a * i - o * n,
                        c = s * n + o * t - r * i,
                        u = s * i + r * n - a * t,
                        h = -r * t - a * n - o * i;
                    return this.x = l * s + h * -r + c * -o - u * -a, this.y = c * s + h * -a + u * -r - l * -o, this.z = u * s + h * -o + l * -a - c * -r, this
                },
                project: function (e) {
                    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
                },
                unproject: function () {
                    var e = new i;
                    return function (t) {
                        return this.applyMatrix4(e.getInverse(t.projectionMatrix)).applyMatrix4(t.matrixWorld)
                    }
                }(),
                transformDirection: function (e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.elements;
                    return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize()
                },
                divide: function (e) {
                    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
                },
                divideScalar: function (e) {
                    return this.multiplyScalar(1 / e)
                },
                min: function (e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
                },
                max: function (e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
                },
                clamp: function (e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
                },
                clampScalar: function () {
                    var e = new a,
                        t = new a;
                    return function (n, i) {
                        return e.set(n, n, n), t.set(i, i, i), this.clamp(e, t)
                    }
                }(),
                clampLength: function (e, t) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                },
                floor: function () {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                },
                ceil: function () {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                },
                round: function () {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                },
                roundToZero: function () {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                },
                negate: function () {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                },
                dot: function (e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z
                },
                lengthSq: function () {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                },
                length: function () {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                },
                manhattanLength: function () {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                },
                normalize: function () {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function (e) {
                    return this.normalize().multiplyScalar(e)
                },
                lerp: function (e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
                },
                lerpVectors: function (e, t, n) {
                    return this.subVectors(t, e).multiplyScalar(n).add(e)
                },
                cross: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
                },
                crossVectors: function (e, t) {
                    var n = e.x,
                        i = e.y,
                        r = e.z,
                        a = t.x,
                        o = t.y,
                        s = t.z;
                    return this.x = i * s - r * o, this.y = r * a - n * s, this.z = n * o - i * a, this
                },
                projectOnVector: function (e) {
                    var t = e.dot(this) / e.lengthSq();
                    return this.copy(e).multiplyScalar(t)
                },
                projectOnPlane: function () {
                    var e = new a;
                    return function (t) {
                        return e.copy(this).projectOnVector(t), this.sub(e)
                    }
                }(),
                reflect: function () {
                    var e = new a;
                    return function (t) {
                        return this.sub(e.copy(t).multiplyScalar(2 * this.dot(t)))
                    }
                }(),
                angleTo: function (e) {
                    var t = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq());
                    return Math.acos(jl.clamp(t, -1, 1))
                },
                distanceTo: function (e) {
                    return Math.sqrt(this.distanceToSquared(e))
                },
                distanceToSquared: function (e) {
                    var t = this.x - e.x,
                        n = this.y - e.y,
                        i = this.z - e.z;
                    return t * t + n * n + i * i
                },
                manhattanDistanceTo: function (e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                },
                setFromSpherical: function (e) {
                    return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
                },
                setFromSphericalCoords: function (e, t, n) {
                    var i = Math.sin(t) * e;
                    return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this
                },
                setFromCylindrical: function (e) {
                    return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
                },
                setFromCylindricalCoords: function (e, t, n) {
                    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
                },
                setFromMatrixPosition: function (e) {
                    var t = e.elements;
                    return this.x = t[12], this.y = t[13], this.z = t[14], this
                },
                setFromMatrixScale: function (e) {
                    var t = this.setFromMatrixColumn(e, 0).length(),
                        n = this.setFromMatrixColumn(e, 1).length(),
                        i = this.setFromMatrixColumn(e, 2).length();
                    return this.x = t,
                        this.y = n, this.z = i, this
                },
                setFromMatrixColumn: function (e, t) {
                    return this.fromArray(e.elements, 4 * t)
                },
                equals: function (e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z
                },
                fromArray: function (e, t) {
                    return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
                },
                fromBufferAttribute: function (e, t, n) {
                    return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
                }
            }), Object.assign(o.prototype, {
                isMatrix3: !0,
                set: function (e, t, n, i, r, a, o, s, l) {
                    var c = this.elements;
                    return c[0] = e, c[1] = i, c[2] = o, c[3] = t, c[4] = r, c[5] = s, c[6] = n, c[7] = a, c[8] = l, this
                },
                identity: function () {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                },
                clone: function () {
                    return (new this.constructor).fromArray(this.elements)
                },
                copy: function (e) {
                    var t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
                },
                setFromMatrix4: function (e) {
                    var t = e.elements;
                    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
                },
                applyToBufferAttribute: function () {
                    var e = new a;
                    return function (t) {
                        for (var n = 0, i = t.count; n < i; n++) e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.applyMatrix3(this), t.setXYZ(n, e.x, e.y, e.z);
                        return t
                    }
                }(),
                multiply: function (e) {
                    return this.multiplyMatrices(this, e)
                },
                premultiply: function (e) {
                    return this.multiplyMatrices(e, this)
                },
                multiplyMatrices: function (e, t) {
                    var n = e.elements,
                        i = t.elements,
                        r = this.elements,
                        a = n[0],
                        o = n[3],
                        s = n[6],
                        l = n[1],
                        c = n[4],
                        u = n[7],
                        h = n[2],
                        d = n[5],
                        p = n[8],
                        f = i[0],
                        m = i[3],
                        v = i[6],
                        g = i[1],
                        y = i[4],
                        x = i[7],
                        b = i[2],
                        _ = i[5],
                        w = i[8];
                    return r[0] = a * f + o * g + s * b, r[3] = a * m + o * y + s * _, r[6] = a * v + o * x + s * w, r[1] = l * f + c * g + u * b, r[4] = l * m + c * y + u * _, r[7] = l * v + c * x + u * w, r[2] = h * f + d * g + p * b, r[5] = h * m + d * y + p * _, r[8] = h * v + d * x + p * w, this
                },
                multiplyScalar: function (e) {
                    var t = this.elements;
                    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
                },
                determinant: function () {
                    var e = this.elements,
                        t = e[0],
                        n = e[1],
                        i = e[2],
                        r = e[3],
                        a = e[4],
                        o = e[5],
                        s = e[6],
                        l = e[7],
                        c = e[8];
                    return t * a * c - t * o * l - n * r * c + n * o * s + i * r * l - i * a * s
                },
                getInverse: function (e, t) {
                    e && e.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                    var n = e.elements,
                        i = this.elements,
                        r = n[0],
                        a = n[1],
                        o = n[2],
                        s = n[3],
                        l = n[4],
                        c = n[5],
                        u = n[6],
                        h = n[7],
                        d = n[8],
                        p = d * l - c * h,
                        f = c * u - d * s,
                        m = h * s - l * u,
                        v = r * p + a * f + o * m;
                    if (0 === v) {
                        var g = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                        if (t === !0) throw new Error(g);
                        return console.warn(g), this.identity()
                    }
                    var y = 1 / v;
                    return i[0] = p * y, i[1] = (o * h - d * a) * y, i[2] = (c * a - o * l) * y, i[3] = f * y, i[4] = (d * r - o * u) * y, i[5] = (o * s - c * r) * y, i[6] = m * y, i[7] = (a * u - h * r) * y, i[8] = (l * r - a * s) * y, this
                },
                transpose: function () {
                    var e, t = this.elements;
                    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
                },
                getNormalMatrix: function (e) {
                    return this.setFromMatrix4(e).getInverse(this).transpose()
                },
                transposeIntoArray: function (e) {
                    var t = this.elements;
                    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
                },
                setUvTransform: function (e, t, n, i, r, a, o) {
                    var s = Math.cos(r),
                        l = Math.sin(r);
                    this.set(n * s, n * l, -n * (s * a + l * o) + a + e, -i * l, i * s, -i * (-l * a + s * o) + o + t, 0, 0, 1)
                },
                scale: function (e, t) {
                    var n = this.elements;
                    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
                },
                rotate: function (e) {
                    var t = Math.cos(e),
                        n = Math.sin(e),
                        i = this.elements,
                        r = i[0],
                        a = i[3],
                        o = i[6],
                        s = i[1],
                        l = i[4],
                        c = i[7];
                    return i[0] = t * r + n * s, i[3] = t * a + n * l, i[6] = t * o + n * c, i[1] = -n * r + t * s, i[4] = -n * a + t * l, i[7] = -n * o + t * c, this
                },
                translate: function (e, t) {
                    var n = this.elements;
                    return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
                },
                equals: function (e) {
                    for (var t = this.elements, n = e.elements, i = 0; i < 9; i++)
                        if (t[i] !== n[i]) return !1;
                    return !0
                },
                fromArray: function (e, t) {
                    void 0 === t && (t = 0);
                    for (var n = 0; n < 9; n++) this.elements[n] = e[n + t];
                    return this
                },
                toArray: function (e, t) {
                    void 0 === e && (e = []), void 0 === t && (t = 0);
                    var n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
                }
            });
            var Fl = {
                    getDataURL: function (e) {
                        var t;
                        if ("undefined" == typeof HTMLCanvasElement) return e.src;
                        if (e instanceof HTMLCanvasElement) t = e;
                        else {
                            t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), t.width = e.width, t.height = e.height;
                            var n = t.getContext("2d");
                            e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height)
                        }
                        return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
                    }
                },
                Gl = 0;
            s.DEFAULT_IMAGE = void 0, s.DEFAULT_MAPPING = cs, s.prototype = Object.assign(Object.create(t.prototype), {
                constructor: s,
                isTexture: !0,
                updateMatrix: function () {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
                },
                toJSON: function (e) {
                    var t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                    var n = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY
                    };
                    if (void 0 !== this.image) {
                        var i = this.image;
                        if (void 0 === i.uuid && (i.uuid = jl.generateUUID()), !t && void 0 === e.images[i.uuid]) {
                            var r;
                            if (Array.isArray(i)) {
                                r = [];
                                for (var a = 0, o = i.length; a < o; a++) r.push(Fl.getDataURL(i[a]))
                            } else r = Fl.getDataURL(i);
                            e.images[i.uuid] = {
                                uuid: i.uuid,
                                url: r
                            }
                        }
                        n.image = i.uuid
                    }
                    return t || (e.textures[this.uuid] = n), n
                },
                dispose: function () {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                },
                transformUv: function (e) {
                    if (this.mapping !== cs) return e;
                    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                        case gs:
                            e.x = e.x - Math.floor(e.x);
                            break;
                        case ys:
                            e.x = e.x < 0 ? 0 : 1;
                            break;
                        case xs:
                            1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                    }
                    if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                        case gs:
                            e.y = e.y - Math.floor(e.y);
                            break;
                        case ys:
                            e.y = e.y < 0 ? 0 : 1;
                            break;
                        case xs:
                            1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                    }
                    return this.flipY && (e.y = 1 - e.y), e
                }
            }), Object.defineProperty(s.prototype, "needsUpdate", {
                set: function (e) {
                    e === !0 && this.version++
                }
            }), Object.assign(l.prototype, {
                isVector4: !0,
                set: function (e, t, n, i) {
                    return this.x = e, this.y = t, this.z = n, this.w = i, this
                },
                setScalar: function (e) {
                    return this.x = e, this.y = e, this.z = e, this.w = e, this
                },
                setX: function (e) {
                    return this.x = e, this
                },
                setY: function (e) {
                    return this.y = e, this
                },
                setZ: function (e) {
                    return this.z = e, this
                },
                setW: function (e) {
                    return this.w = e, this
                },
                setComponent: function (e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        case 3:
                            this.w = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                },
                getComponent: function (e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                clone: function () {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                },
                copy: function (e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
                },
                add: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
                },
                addScalar: function (e) {
                    return this.x += e, this.y += e, this.z += e, this.w += e, this
                },
                addVectors: function (e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
                },
                addScaledVector: function (e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
                },
                sub: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
                },
                subScalar: function (e) {
                    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
                },
                subVectors: function (e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
                },
                multiplyScalar: function (e) {
                    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
                },
                applyMatrix4: function (e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = this.w,
                        a = e.elements;
                    return this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * r, this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * r, this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * r, this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * r, this
                },
                divideScalar: function (e) {
                    return this.multiplyScalar(1 / e)
                },
                setAxisAngleFromQuaternion: function (e) {
                    this.w = 2 * Math.acos(e.w);
                    var t = Math.sqrt(1 - e.w * e.w);
                    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
                },
                setAxisAngleFromRotationMatrix: function (e) {
                    var t, n, i, r, a = .01,
                        o = .1,
                        s = e.elements,
                        l = s[0],
                        c = s[4],
                        u = s[8],
                        h = s[1],
                        d = s[5],
                        p = s[9],
                        f = s[2],
                        m = s[6],
                        v = s[10];
                    if (Math.abs(c - h) < a && Math.abs(u - f) < a && Math.abs(p - m) < a) {
                        if (Math.abs(c + h) < o && Math.abs(u + f) < o && Math.abs(p + m) < o && Math.abs(l + d + v - 3) < o) return this.set(1, 0, 0, 0), this;
                        t = Math.PI;
                        var g = (l + 1) / 2,
                            y = (d + 1) / 2,
                            x = (v + 1) / 2,
                            b = (c + h) / 4,
                            _ = (u + f) / 4,
                            w = (p + m) / 4;
                        return g > y && g > x ? g < a ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(g), i = b / n, r = _ / n) : y > x ? y < a ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(y), n = b / i, r = w / i) : x < a ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(x), n = _ / r, i = w / r), this.set(n, i, r, t), this
                    }
                    var M = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c));
                    return Math.abs(M) < .001 && (M = 1), this.x = (m - p) / M, this.y = (u - f) / M, this.z = (h - c) / M, this.w = Math.acos((l + d + v - 1) / 2), this
                },
                min: function (e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
                },
                max: function (e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
                },
                clamp: function (e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
                },
                clampScalar: function () {
                    var e, t;
                    return function (n, i) {
                        return void 0 === e && (e = new l, t = new l), e.set(n, n, n, n), t.set(i, i, i, i), this.clamp(e, t)
                    }
                }(),
                clampLength: function (e, t) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                },
                floor: function () {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                },
                ceil: function () {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                },
                round: function () {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                },
                roundToZero: function () {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                },
                negate: function () {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                },
                dot: function (e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                },
                lengthSq: function () {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                },
                length: function () {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                },
                manhattanLength: function () {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                },
                normalize: function () {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function (e) {
                    return this.normalize().multiplyScalar(e)
                },
                lerp: function (e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
                },
                lerpVectors: function (e, t, n) {
                    return this.subVectors(t, e).multiplyScalar(n).add(e)
                },
                equals: function (e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                },
                fromArray: function (e, t) {
                    return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
                },
                fromBufferAttribute: function (e, t, n) {
                    return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
                }
            }), c.prototype = Object.assign(Object.create(t.prototype), {
                constructor: c,
                isWebGLRenderTarget: !0,
                setSize: function (e, t) {
                    this.width === e && this.height === t || (this.width = e, this.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
                },
                dispose: function () {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), u.prototype = Object.create(c.prototype), u.prototype.constructor = u, u.prototype.isWebGLRenderTargetCube = !0, h.prototype = Object.create(s.prototype), h.prototype.constructor = h, h.prototype.isDataTexture = !0, Object.assign(d.prototype, {
                isBox3: !0,
                set: function (e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                },
                setFromArray: function (e) {
                    for (var t = +(1 / 0), n = +(1 / 0), i = +(1 / 0), r = -(1 / 0), a = -(1 / 0), o = -(1 / 0), s = 0, l = e.length; s < l; s += 3) {
                        var c = e[s],
                            u = e[s + 1],
                            h = e[s + 2];
                        c < t && (t = c), u < n && (n = u), h < i && (i = h), c > r && (r = c), u > a && (a = u), h > o && (o = h)
                    }
                    return this.min.set(t, n, i), this.max.set(r, a, o), this
                },
                setFromBufferAttribute: function (e) {
                    for (var t = +(1 / 0), n = +(1 / 0), i = +(1 / 0), r = -(1 / 0), a = -(1 / 0), o = -(1 / 0), s = 0, l = e.count; s < l; s++) {
                        var c = e.getX(s),
                            u = e.getY(s),
                            h = e.getZ(s);
                        c < t && (t = c), u < n && (n = u), h < i && (i = h), c > r && (r = c), u > a && (a = u), h > o && (o = h)
                    }
                    return this.min.set(t, n, i), this.max.set(r, a, o), this
                },
                setFromPoints: function (e) {
                    this.makeEmpty();
                    for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                },
                setFromCenterAndSize: function () {
                    var e = new a;
                    return function (t, n) {
                        var i = e.copy(n).multiplyScalar(.5);
                        return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
                    }
                }(),
                setFromObject: function (e) {
                    return this.makeEmpty(), this.expandByObject(e)
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                },
                makeEmpty: function () {
                    return this.min.x = this.min.y = this.min.z = +(1 / 0), this.max.x = this.max.y = this.max.z = -(1 / 0), this
                },
                isEmpty: function () {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                },
                getCenter: function (e) {
                    return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new a), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function (e) {
                    return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"), e = new a), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                },
                expandByPoint: function (e) {
                    return this.min.min(e), this.max.max(e), this
                },
                expandByVector: function (e) {
                    return this.min.sub(e), this.max.add(e), this
                },
                expandByScalar: function (e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                },
                expandByObject: function () {
                    function e(e) {
                        var a = e.geometry;
                        if (void 0 !== a)
                            if (a.isGeometry) {
                                var o = a.vertices;
                                for (n = 0, i = o.length; n < i; n++) r.copy(o[n]), r.applyMatrix4(e.matrixWorld), t.expandByPoint(r)
                            } else if (a.isBufferGeometry) {
                            var s = a.attributes.position;
                            if (void 0 !== s)
                                for (n = 0, i = s.count; n < i; n++) r.fromBufferAttribute(s, n).applyMatrix4(e.matrixWorld), t.expandByPoint(r)
                        }
                    }
                    var t, n, i, r = new a;
                    return function (n) {
                        return t = this, n.updateMatrixWorld(!0), n.traverse(e), this
                    }
                }(),
                containsPoint: function (e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
                },
                containsBox: function (e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                },
                getParameter: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new a), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                },
                intersectsBox: function (e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
                },
                intersectsSphere: function () {
                    var e = new a;
                    return function (t) {
                        return this.clampPoint(t.center, e), e.distanceToSquared(t.center) <= t.radius * t.radius
                    }
                }(),
                intersectsPlane: function (e) {
                    var t, n;
                    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
                },
                intersectsTriangle: function () {
                    function e(e) {
                        var r, a;
                        for (r = 0, a = e.length - 3; r <= a; r += 3) {
                            l.fromArray(e, r);
                            var o = u.x * Math.abs(l.x) + u.y * Math.abs(l.y) + u.z * Math.abs(l.z),
                                s = t.dot(l),
                                c = n.dot(l),
                                h = i.dot(l);
                            if (Math.max(-Math.max(s, c, h), Math.min(s, c, h)) > o) return !1
                        }
                        return !0
                    }
                    var t = new a,
                        n = new a,
                        i = new a,
                        r = new a,
                        o = new a,
                        s = new a,
                        l = new a,
                        c = new a,
                        u = new a,
                        h = new a;
                    return function (a) {
                        if (this.isEmpty()) return !1;
                        this.getCenter(c), u.subVectors(this.max, c), t.subVectors(a.a, c), n.subVectors(a.b, c), i.subVectors(a.c, c), r.subVectors(n, t), o.subVectors(i, n), s.subVectors(t, i);
                        var l = [0, -r.z, r.y, 0, -o.z, o.y, 0, -s.z, s.y, r.z, 0, -r.x, o.z, 0, -o.x, s.z, 0, -s.x, -r.y, r.x, 0, -o.y, o.x, 0, -s.y, s.x, 0];
                        return !!e(l) && (l = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!e(l) && (h.crossVectors(r, o), l = [h.x, h.y, h.z], e(l)))
                    }
                }(),
                clampPoint: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new a), t.copy(e).clamp(this.min, this.max)
                },
                distanceToPoint: function () {
                    var e = new a;
                    return function (t) {
                        var n = e.copy(t).clamp(this.min, this.max);
                        return n.sub(t).length()
                    }
                }(),
                getBoundingSphere: function () {
                    var e = new a;
                    return function (t) {
                        return void 0 === t && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), t = new p), this.getCenter(t.center), t.radius = .5 * this.getSize(e).length(), t
                    }
                }(),
                intersect: function (e) {
                    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
                },
                union: function (e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                },
                applyMatrix4: function () {
                    var e = [new a, new a, new a, new a, new a, new a, new a, new a];
                    return function (t) {
                        return this.isEmpty() ? this : (e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(e), this)
                    }
                }(),
                translate: function (e) {
                    return this.min.add(e), this.max.add(e), this
                },
                equals: function (e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }), Object.assign(p.prototype, {
                set: function (e, t) {
                    return this.center.copy(e), this.radius = t, this
                },
                setFromPoints: function () {
                    var e = new d;
                    return function (t, n) {
                        var i = this.center;
                        void 0 !== n ? i.copy(n) : e.setFromPoints(t).getCenter(i);
                        for (var r = 0, a = 0, o = t.length; a < o; a++) r = Math.max(r, i.distanceToSquared(t[a]));
                        return this.radius = Math.sqrt(r), this
                    }
                }(),
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.center.copy(e.center), this.radius = e.radius, this
                },
                empty: function () {
                    return this.radius <= 0
                },
                containsPoint: function (e) {
                    return e.distanceToSquared(this.center) <= this.radius * this.radius
                },
                distanceToPoint: function (e) {
                    return e.distanceTo(this.center) - this.radius
                },
                intersectsSphere: function (e) {
                    var t = this.radius + e.radius;
                    return e.center.distanceToSquared(this.center) <= t * t
                },
                intersectsBox: function (e) {
                    return e.intersectsSphere(this)
                },
                intersectsPlane: function (e) {
                    return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                },
                clampPoint: function (e, t) {
                    var n = this.center.distanceToSquared(e);
                    return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new a), t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
                },
                getBoundingBox: function (e) {
                    return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new d), e.set(this.center, this.center), e.expandByScalar(this.radius), e
                },
                applyMatrix4: function (e) {
                    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
                },
                translate: function (e) {
                    return this.center.add(e), this
                },
                equals: function (e) {
                    return e.center.equals(this.center) && e.radius === this.radius
                }
            }), Object.assign(f.prototype, {
                set: function (e, t) {
                    return this.normal.copy(e), this.constant = t, this
                },
                setComponents: function (e, t, n, i) {
                    return this.normal.set(e, t, n), this.constant = i, this
                },
                setFromNormalAndCoplanarPoint: function (e, t) {
                    return this.normal.copy(e), this.constant = -t.dot(this.normal), this
                },
                setFromCoplanarPoints: function () {
                    var e = new a,
                        t = new a;
                    return function (n, i, r) {
                        var a = e.subVectors(r, i).cross(t.subVectors(n, i)).normalize();
                        return this.setFromNormalAndCoplanarPoint(a, n), this
                    }
                }(),
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.normal.copy(e.normal), this.constant = e.constant, this
                },
                normalize: function () {
                    var e = 1 / this.normal.length();
                    return this.normal.multiplyScalar(e), this.constant *= e, this
                },
                negate: function () {
                    return this.constant *= -1, this.normal.negate(), this
                },
                distanceToPoint: function (e) {
                    return this.normal.dot(e) + this.constant
                },
                distanceToSphere: function (e) {
                    return this.distanceToPoint(e.center) - e.radius
                },
                projectPoint: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new a), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
                },
                intersectLine: function () {
                    var e = new a;
                    return function (t, n) {
                        void 0 === n && (console.warn("THREE.Plane: .intersectLine() target is now required"), n = new a);
                        var i = t.delta(e),
                            r = this.normal.dot(i);
                        if (0 !== r) {
                            var o = -(t.start.dot(this.normal) + this.constant) / r;
                            if (!(o < 0 || o > 1)) return n.copy(i).multiplyScalar(o).add(t.start)
                        } else if (0 === this.distanceToPoint(t.start)) return n.copy(t.start)
                    }
                }(),
                intersectsLine: function (e) {
                    var t = this.distanceToPoint(e.start),
                        n = this.distanceToPoint(e.end);
                    return t < 0 && n > 0 || n < 0 && t > 0
                },
                intersectsBox: function (e) {
                    return e.intersectsPlane(this)
                },
                intersectsSphere: function (e) {
                    return e.intersectsPlane(this)
                },
                coplanarPoint: function (e) {
                    return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new a), e.copy(this.normal).multiplyScalar(-this.constant)
                },
                applyMatrix4: function () {
                    var e = new a,
                        t = new o;
                    return function (n, i) {
                        var r = i || t.getNormalMatrix(n),
                            a = this.coplanarPoint(e).applyMatrix4(n),
                            o = this.normal.applyMatrix3(r).normalize();
                        return this.constant = -a.dot(o), this
                    }
                }(),
                translate: function (e) {
                    return this.constant -= e.dot(this.normal), this
                },
                equals: function (e) {
                    return e.normal.equals(this.normal) && e.constant === this.constant
                }
            }), Object.assign(m.prototype, {
                set: function (e, t, n, i, r, a) {
                    var o = this.planes;
                    return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(a), this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    for (var t = this.planes, n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                    return this
                },
                setFromMatrix: function (e) {
                    var t = this.planes,
                        n = e.elements,
                        i = n[0],
                        r = n[1],
                        a = n[2],
                        o = n[3],
                        s = n[4],
                        l = n[5],
                        c = n[6],
                        u = n[7],
                        h = n[8],
                        d = n[9],
                        p = n[10],
                        f = n[11],
                        m = n[12],
                        v = n[13],
                        g = n[14],
                        y = n[15];
                    return t[0].setComponents(o - i, u - s, f - h, y - m).normalize(), t[1].setComponents(o + i, u + s, f + h, y + m).normalize(), t[2].setComponents(o + r, u + l, f + d, y + v).normalize(), t[3].setComponents(o - r, u - l, f - d, y - v).normalize(), t[4].setComponents(o - a, u - c, f - p, y - g).normalize(), t[5].setComponents(o + a, u + c, f + p, y + g).normalize(), this
                },
                intersectsObject: function () {
                    var e = new p;
                    return function (t) {
                        var n = t.geometry;
                        return null === n.boundingSphere && n.computeBoundingSphere(), e.copy(n.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
                    }
                }(),
                intersectsSprite: function () {
                    var e = new p;
                    return function (t) {
                        return e.center.set(0, 0, 0), e.radius = .7071067811865476, e.applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
                    }
                }(),
                intersectsSphere: function (e) {
                    for (var t = this.planes, n = e.center, i = -e.radius, r = 0; r < 6; r++) {
                        var a = t[r].distanceToPoint(n);
                        if (a < i) return !1
                    }
                    return !0
                },
                intersectsBox: function () {
                    var e = new a;
                    return function (t) {
                        for (var n = this.planes, i = 0; i < 6; i++) {
                            var r = n[i];
                            if (e.x = r.normal.x > 0 ? t.max.x : t.min.x, e.y = r.normal.y > 0 ? t.max.y : t.min.y, e.z = r.normal.z > 0 ? t.max.z : t.min.z, r.distanceToPoint(e) < 0) return !1
                        }
                        return !0
                    }
                }(),
                containsPoint: function (e) {
                    for (var t = this.planes, n = 0; n < 6; n++)
                        if (t[n].distanceToPoint(e) < 0) return !1;
                    return !0
                }
            });
            var Hl = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
                Vl = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
                Wl = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
                ql = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
                Xl = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                Yl = "\nvec3 transformed = vec3( position );\n",
                Zl = "\nvec3 objectNormal = vec3( normal );\n",
                Jl = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
                $l = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
                Ql = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n",
                Kl = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
                ec = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif\n",
                tc = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
                nc = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                ic = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
                rc = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                ac = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
                oc = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
                sc = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
                lc = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
                cc = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
                uc = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
                hc = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
                dc = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
                pc = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
                fc = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}\n",
                mc = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
                vc = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
                gc = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
                yc = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
                xc = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif\n",
                bc = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif\n",
                _c = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
                wc = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
                Mc = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
                Tc = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
                Ec = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                Sc = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
                Pc = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n",
                Cc = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
                Ac = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
                Lc = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
                Rc = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
                Ic = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
                Oc = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n",
                kc = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n",
                Dc = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
                zc = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                Bc = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif\n",
                Nc = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n",
                Uc = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
                jc = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
                Fc = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
                Gc = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
                Hc = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
                Vc = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
                Wc = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                qc = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
                Xc = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                Yc = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
                Zc = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n",
                Jc = "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
                $c = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif\n",
                Qc = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
                Kc = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
                eu = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
                tu = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
                nu = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
                iu = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
                ru = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                au = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
                ou = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
                su = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
                lu = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
                cu = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                uu = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
                hu = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
                du = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
                pu = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                fu = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                mu = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
                vu = "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
                gu = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
                yu = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
                xu = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                bu = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                _u = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
                wu = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
                Mu = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
                Tu = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n}\n",
                Eu = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position, 1.0 );\n\tgl_Position.z = 1.0;\n}\n",
                Su = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
                Pu = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
                Cu = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
                Au = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
                Lu = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
                Ru = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
                Iu = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
                Ou = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
                ku = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                Du = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
                zu = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                Bu = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
                Nu = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                Uu = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                ju = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\tvec4 matcapColor = texture2D( matcap, uv );\n\tmatcapColor = matcapTexelToLinear( matcapColor );\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                Fu = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}\n",
                Gu = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                Hu = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                Vu = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
                Wu = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                qu = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
                Xu = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
                Yu = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                Zu = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}\n",
                Ju = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
                $u = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
                Qu = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
                Ku = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
                eh = {
                    alphamap_fragment: Hl,
                    alphamap_pars_fragment: Vl,
                    alphatest_fragment: Wl,
                    aomap_fragment: ql,
                    aomap_pars_fragment: Xl,
                    begin_vertex: Yl,
                    beginnormal_vertex: Zl,
                    bsdfs: Jl,
                    bumpmap_pars_fragment: $l,
                    clipping_planes_fragment: Ql,
                    clipping_planes_pars_fragment: Kl,
                    clipping_planes_pars_vertex: ec,
                    clipping_planes_vertex: tc,
                    color_fragment: nc,
                    color_pars_fragment: ic,
                    color_pars_vertex: rc,
                    color_vertex: ac,
                    common: oc,
                    cube_uv_reflection_fragment: sc,
                    defaultnormal_vertex: lc,
                    displacementmap_pars_vertex: cc,
                    displacementmap_vertex: uc,
                    emissivemap_fragment: hc,
                    emissivemap_pars_fragment: dc,
                    encodings_fragment: pc,
                    encodings_pars_fragment: fc,
                    envmap_fragment: mc,
                    envmap_pars_fragment: vc,
                    envmap_pars_vertex: gc,
                    envmap_physical_pars_fragment: Cc,
                    envmap_vertex: yc,
                    fog_vertex: xc,
                    fog_pars_vertex: bc,
                    fog_fragment: _c,
                    fog_pars_fragment: wc,
                    gradientmap_pars_fragment: Mc,
                    lightmap_fragment: Tc,
                    lightmap_pars_fragment: Ec,
                    lights_lambert_vertex: Sc,
                    lights_pars_begin: Pc,
                    lights_phong_fragment: Ac,
                    lights_phong_pars_fragment: Lc,
                    lights_physical_fragment: Rc,
                    lights_physical_pars_fragment: Ic,
                    lights_fragment_begin: Oc,
                    lights_fragment_maps: kc,
                    lights_fragment_end: Dc,
                    logdepthbuf_fragment: zc,
                    logdepthbuf_pars_fragment: Bc,
                    logdepthbuf_pars_vertex: Nc,
                    logdepthbuf_vertex: Uc,
                    map_fragment: jc,
                    map_pars_fragment: Fc,
                    map_particle_fragment: Gc,
                    map_particle_pars_fragment: Hc,
                    metalnessmap_fragment: Vc,
                    metalnessmap_pars_fragment: Wc,
                    morphnormal_vertex: qc,
                    morphtarget_pars_vertex: Xc,
                    morphtarget_vertex: Yc,
                    normal_fragment_begin: Zc,
                    normal_fragment_maps: Jc,
                    normalmap_pars_fragment: $c,
                    packing: Qc,
                    premultiplied_alpha_fragment: Kc,
                    project_vertex: eu,
                    dithering_fragment: tu,
                    dithering_pars_fragment: nu,
                    roughnessmap_fragment: iu,
                    roughnessmap_pars_fragment: ru,
                    shadowmap_pars_fragment: au,
                    shadowmap_pars_vertex: ou,
                    shadowmap_vertex: su,
                    shadowmask_pars_fragment: lu,
                    skinbase_vertex: cu,
                    skinning_pars_vertex: uu,
                    skinning_vertex: hu,
                    skinnormal_vertex: du,
                    specularmap_fragment: pu,
                    specularmap_pars_fragment: fu,
                    tonemapping_fragment: mu,
                    tonemapping_pars_fragment: vu,
                    uv_pars_fragment: gu,
                    uv_pars_vertex: yu,
                    uv_vertex: xu,
                    uv2_pars_fragment: bu,
                    uv2_pars_vertex: _u,
                    uv2_vertex: wu,
                    worldpos_vertex: Mu,
                    background_frag: Tu,
                    background_vert: Eu,
                    cube_frag: Su,
                    cube_vert: Pu,
                    depth_frag: Cu,
                    depth_vert: Au,
                    distanceRGBA_frag: Lu,
                    distanceRGBA_vert: Ru,
                    equirect_frag: Iu,
                    equirect_vert: Ou,
                    linedashed_frag: ku,
                    linedashed_vert: Du,
                    meshbasic_frag: zu,
                    meshbasic_vert: Bu,
                    meshlambert_frag: Nu,
                    meshlambert_vert: Uu,
                    meshmatcap_frag: ju,
                    meshmatcap_vert: Fu,
                    meshphong_frag: Gu,
                    meshphong_vert: Hu,
                    meshphysical_frag: Vu,
                    meshphysical_vert: Wu,
                    normal_frag: qu,
                    normal_vert: Xu,
                    points_frag: Yu,
                    points_vert: Zu,
                    shadow_frag: Ju,
                    shadow_vert: $u,
                    sprite_frag: Qu,
                    sprite_vert: Ku
                },
                th = {
                    merge: function (e) {
                        for (var t = {}, n = 0; n < e.length; n++) {
                            var i = this.clone(e[n]);
                            for (var r in i) t[r] = i[r]
                        }
                        return t
                    },
                    clone: function (e) {
                        var t = {};
                        for (var n in e) {
                            t[n] = {};
                            for (var i in e[n]) {
                                var r = e[n][i];
                                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r
                            }
                        }
                        return t
                    }
                },
                nh = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                };
            Object.assign(v.prototype, {
                isColor: !0,
                r: 1,
                g: 1,
                b: 1,
                set: function (e) {
                    return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
                },
                setScalar: function (e) {
                    return this.r = e, this.g = e, this.b = e, this
                },
                setHex: function (e) {
                    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
                },
                setRGB: function (e, t, n) {
                    return this.r = e, this.g = t, this.b = n, this
                },
                setHSL: function () {
                    function e(e, t, n) {
                        return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
                    }
                    return function (t, n, i) {
                        if (t = jl.euclideanModulo(t, 1), n = jl.clamp(n, 0, 1), i = jl.clamp(i, 0, 1), 0 === n) this.r = this.g = this.b = i;
                        else {
                            var r = i <= .5 ? i * (1 + n) : i + n - i * n,
                                a = 2 * i - r;
                            this.r = e(a, r, t + 1 / 3), this.g = e(a, r, t), this.b = e(a, r, t - 1 / 3)
                        }
                        return this
                    }
                }(),
                setStyle: function (e) {
                    function t(t) {
                        void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                    }
                    var n;
                    if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
                        var i, r = n[1],
                            a = n[2];
                        switch (r) {
                            case "rgb":
                            case "rgba":
                                if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, t(i[5]), this;
                                if (i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, t(i[5]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) {
                                    var o = parseFloat(i[1]) / 360,
                                        s = parseInt(i[2], 10) / 100,
                                        l = parseInt(i[3], 10) / 100;
                                    return t(i[5]), this.setHSL(o, s, l)
                                }
                        }
                    } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
                        var c = n[1],
                            u = c.length;
                        if (3 === u) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this;
                        if (6 === u) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this
                    }
                    if (e && e.length > 0) {
                        var c = nh[e];
                        void 0 !== c ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + e)
                    }
                    return this
                },
                clone: function () {
                    return new this.constructor(this.r, this.g, this.b)
                },
                copy: function (e) {
                    return this.r = e.r, this.g = e.g, this.b = e.b, this
                },
                copyGammaToLinear: function (e, t) {
                    return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
                },
                copyLinearToGamma: function (e, t) {
                    void 0 === t && (t = 2);
                    var n = t > 0 ? 1 / t : 1;
                    return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this
                },
                convertGammaToLinear: function (e) {
                    return this.copyGammaToLinear(this, e), this
                },
                convertLinearToGamma: function (e) {
                    return this.copyLinearToGamma(this, e), this
                },
                copySRGBToLinear: function () {
                    function e(e) {
                        return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
                    }
                    return function (t) {
                        return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this
                    }
                }(),
                copyLinearToSRGB: function () {
                    function e(e) {
                        return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
                    }
                    return function (t) {
                        return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this
                    }
                }(),
                convertSRGBToLinear: function () {
                    return this.copySRGBToLinear(this), this
                },
                convertLinearToSRGB: function () {
                    return this.copyLinearToSRGB(this), this
                },
                getHex: function () {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                },
                getHexString: function () {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                },
                getHSL: function (e) {
                    void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"), e = {
                        h: 0,
                        s: 0,
                        l: 0
                    });
                    var t, n, i = this.r,
                        r = this.g,
                        a = this.b,
                        o = Math.max(i, r, a),
                        s = Math.min(i, r, a),
                        l = (s + o) / 2;
                    if (s === o) t = 0, n = 0;
                    else {
                        var c = o - s;
                        switch (n = l <= .5 ? c / (o + s) : c / (2 - o - s), o) {
                            case i:
                                t = (r - a) / c + (r < a ? 6 : 0);
                                break;
                            case r:
                                t = (a - i) / c + 2;
                                break;
                            case a:
                                t = (i - r) / c + 4
                        }
                        t /= 6
                    }
                    return e.h = t, e.s = n, e.l = l, e
                },
                getStyle: function () {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                },
                offsetHSL: function () {
                    var e = {};
                    return function (t, n, i) {
                        return this.getHSL(e), e.h += t, e.s += n, e.l += i, this.setHSL(e.h, e.s, e.l), this
                    }
                }(),
                add: function (e) {
                    return this.r += e.r, this.g += e.g, this.b += e.b, this
                },
                addColors: function (e, t) {
                    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
                },
                addScalar: function (e) {
                    return this.r += e, this.g += e, this.b += e, this
                },
                sub: function (e) {
                    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
                },
                multiply: function (e) {
                    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
                },
                multiplyScalar: function (e) {
                    return this.r *= e, this.g *= e, this.b *= e, this
                },
                lerp: function (e, t) {
                    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
                },
                lerpHSL: function () {
                    var e = {
                            h: 0,
                            s: 0,
                            l: 0
                        },
                        t = {
                            h: 0,
                            s: 0,
                            l: 0
                        };
                    return function (n, i) {
                        this.getHSL(e), n.getHSL(t);
                        var r = jl.lerp(e.h, t.h, i),
                            a = jl.lerp(e.s, t.s, i),
                            o = jl.lerp(e.l, t.l, i);
                        return this.setHSL(r, a, o), this
                    }
                }(),
                equals: function (e) {
                    return e.r === this.r && e.g === this.g && e.b === this.b
                },
                fromArray: function (e, t) {
                    return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
                },
                toJSON: function () {
                    return this.getHex()
                }
            });
            var ih = {
                    common: {
                        diffuse: {
                            value: new v(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new o
                        },
                        alphaMap: {
                            value: null
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        refractionRatio: {
                            value: .98
                        },
                        maxMipLevel: {
                            value: 0
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new n(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new v(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        }
                    },
                    points: {
                        diffuse: {
                            value: new v(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new o
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new v(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new n(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new o
                        }
                    }
                },
                rh = {
                    basic: {
                        uniforms: th.merge([ih.common, ih.specularmap, ih.envmap, ih.aomap, ih.lightmap, ih.fog]),
                        vertexShader: eh.meshbasic_vert,
                        fragmentShader: eh.meshbasic_frag
                    },
                    lambert: {
                        uniforms: th.merge([ih.common, ih.specularmap, ih.envmap, ih.aomap, ih.lightmap, ih.emissivemap, ih.fog, ih.lights, {
                            emissive: {
                                value: new v(0)
                            }
                        }]),
                        vertexShader: eh.meshlambert_vert,
                        fragmentShader: eh.meshlambert_frag
                    },
                    phong: {
                        uniforms: th.merge([ih.common, ih.specularmap, ih.envmap, ih.aomap, ih.lightmap, ih.emissivemap, ih.bumpmap, ih.normalmap, ih.displacementmap, ih.gradientmap, ih.fog, ih.lights, {
                            emissive: {
                                value: new v(0)
                            },
                            specular: {
                                value: new v(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: eh.meshphong_vert,
                        fragmentShader: eh.meshphong_frag
                    },
                    standard: {
                        uniforms: th.merge([ih.common, ih.envmap, ih.aomap, ih.lightmap, ih.emissivemap, ih.bumpmap, ih.normalmap, ih.displacementmap, ih.roughnessmap, ih.metalnessmap, ih.fog, ih.lights, {
                            emissive: {
                                value: new v(0)
                            },
                            roughness: {
                                value: .5
                            },
                            metalness: {
                                value: .5
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: eh.meshphysical_vert,
                        fragmentShader: eh.meshphysical_frag
                    },
                    matcap: {
                        uniforms: th.merge([ih.common, ih.bumpmap, ih.normalmap, ih.displacementmap, ih.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: eh.meshmatcap_vert,
                        fragmentShader: eh.meshmatcap_frag
                    },
                    points: {
                        uniforms: th.merge([ih.points, ih.fog]),
                        vertexShader: eh.points_vert,
                        fragmentShader: eh.points_frag
                    },
                    dashed: {
                        uniforms: th.merge([ih.common, ih.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: eh.linedashed_vert,
                        fragmentShader: eh.linedashed_frag
                    },
                    depth: {
                        uniforms: th.merge([ih.common, ih.displacementmap]),
                        vertexShader: eh.depth_vert,
                        fragmentShader: eh.depth_frag
                    },
                    normal: {
                        uniforms: th.merge([ih.common, ih.bumpmap, ih.normalmap, ih.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: eh.normal_vert,
                        fragmentShader: eh.normal_frag
                    },
                    sprite: {
                        uniforms: th.merge([ih.sprite, ih.fog]),
                        vertexShader: eh.sprite_vert,
                        fragmentShader: eh.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new o
                            },
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: eh.background_vert,
                        fragmentShader: eh.background_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: eh.cube_vert,
                        fragmentShader: eh.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: eh.equirect_vert,
                        fragmentShader: eh.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: th.merge([ih.common, ih.displacementmap, {
                            referencePosition: {
                                value: new a
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: eh.distanceRGBA_vert,
                        fragmentShader: eh.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: th.merge([ih.lights, ih.fog, {
                            color: {
                                value: new v(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: eh.shadow_vert,
                        fragmentShader: eh.shadow_frag
                    }
                };
            rh.physical = {
                uniforms: th.merge([rh.standard.uniforms, {
                    clearCoat: {
                        value: 0
                    },
                    clearCoatRoughness: {
                        value: 0
                    }
                }]),
                vertexShader: eh.meshphysical_vert,
                fragmentShader: eh.meshphysical_frag
            }, Object.assign(x.prototype, {
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
                    for (var t = 0, n = e.vertexNormals.length; t < n; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
                    for (var t = 0, n = e.vertexColors.length; t < n; t++) this.vertexColors[t] = e.vertexColors[t].clone();
                    return this
                }
            }), b.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], b.DefaultOrder = "XYZ", Object.defineProperties(b.prototype, {
                x: {
                    get: function () {
                        return this._x
                    },
                    set: function (e) {
                        this._x = e, this.onChangeCallback()
                    }
                },
                y: {
                    get: function () {
                        return this._y
                    },
                    set: function (e) {
                        this._y = e, this.onChangeCallback()
                    }
                },
                z: {
                    get: function () {
                        return this._z
                    },
                    set: function (e) {
                        this._z = e, this.onChangeCallback()
                    }
                },
                order: {
                    get: function () {
                        return this._order
                    },
                    set: function (e) {
                        this._order = e, this.onChangeCallback()
                    }
                }
            }), Object.assign(b.prototype, {
                isEuler: !0,
                set: function (e, t, n, i) {
                    return this._x = e, this._y = t, this._z = n, this._order = i || this._order, this.onChangeCallback(), this
                },
                clone: function () {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                },
                copy: function (e) {
                    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this
                },
                setFromRotationMatrix: function (e, t, n) {
                    var i = jl.clamp,
                        r = e.elements,
                        a = r[0],
                        o = r[4],
                        s = r[8],
                        l = r[1],
                        c = r[5],
                        u = r[9],
                        h = r[2],
                        d = r[6],
                        p = r[10];
                    return t = t || this._order, "XYZ" === t ? (this._y = Math.asin(i(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(d, c), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-i(u, -1, 1)), Math.abs(u) < .99999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, a), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(i(d, -1, 1)), Math.abs(d) < .99999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, a))) : "ZYX" === t ? (this._y = Math.asin(-i(h, -1, 1)), Math.abs(h) < .99999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(l, a)) : (this._x = 0, this._z = Math.atan2(-o, c))) : "YZX" === t ? (this._z = Math.asin(i(l, -1, 1)), Math.abs(l) < .99999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-h, a)) : (this._x = 0, this._y = Math.atan2(s, p))) : "XZY" === t ? (this._z = Math.asin(-i(o, -1, 1)), Math.abs(o) < .99999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-u, p), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, n !== !1 && this.onChangeCallback(), this
                },
                setFromQuaternion: function () {
                    var e = new i;
                    return function (t, n, i) {
                        return e.makeRotationFromQuaternion(t), this.setFromRotationMatrix(e, n, i)
                    }
                }(),
                setFromVector3: function (e, t) {
                    return this.set(e.x, e.y, e.z, t || this._order)
                },
                reorder: function () {
                    var e = new r;
                    return function (t) {
                        return e.setFromEuler(this), this.setFromQuaternion(e, t)
                    }
                }(),
                equals: function (e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                },
                fromArray: function (e) {
                    return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this.onChangeCallback(), this
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
                },
                toVector3: function (e) {
                    return e ? e.set(this._x, this._y, this._z) : new a(this._x, this._y, this._z)
                },
                onChange: function (e) {
                    return this.onChangeCallback = e, this
                },
                onChangeCallback: function () {}
            }), Object.assign(_.prototype, {
                set: function (e) {
                    this.mask = 1 << e | 0
                },
                enable: function (e) {
                    this.mask |= 1 << e | 0
                },
                toggle: function (e) {
                    this.mask ^= 1 << e | 0
                },
                disable: function (e) {
                    this.mask &= ~(1 << e | 0)
                },
                test: function (e) {
                    return 0 !== (this.mask & e.mask)
                }
            });
            var ah = 0;
            w.DefaultUp = new a(0, 1, 0), w.DefaultMatrixAutoUpdate = !0, w.prototype = Object.assign(Object.create(t.prototype), {
                constructor: w,
                isObject3D: !0,
                onBeforeRender: function () {},
                onAfterRender: function () {},
                applyMatrix: function (e) {
                    this.matrix.multiplyMatrices(e, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                applyQuaternion: function (e) {
                    return this.quaternion.premultiply(e), this
                },
                setRotationFromAxisAngle: function (e, t) {
                    this.quaternion.setFromAxisAngle(e, t)
                },
                setRotationFromEuler: function (e) {
                    this.quaternion.setFromEuler(e, !0)
                },
                setRotationFromMatrix: function (e) {
                    this.quaternion.setFromRotationMatrix(e)
                },
                setRotationFromQuaternion: function (e) {
                    this.quaternion.copy(e)
                },
                rotateOnAxis: function () {
                    var e = new r;
                    return function (t, n) {
                        return e.setFromAxisAngle(t, n), this.quaternion.multiply(e), this
                    }
                }(),
                rotateOnWorldAxis: function () {
                    var e = new r;
                    return function (t, n) {
                        return e.setFromAxisAngle(t, n), this.quaternion.premultiply(e), this
                    }
                }(),
                rotateX: function () {
                    var e = new a(1, 0, 0);
                    return function (t) {
                        return this.rotateOnAxis(e, t)
                    }
                }(),
                rotateY: function () {
                    var e = new a(0, 1, 0);
                    return function (t) {
                        return this.rotateOnAxis(e, t)
                    }
                }(),
                rotateZ: function () {
                    var e = new a(0, 0, 1);
                    return function (t) {
                        return this.rotateOnAxis(e, t)
                    }
                }(),
                translateOnAxis: function () {
                    var e = new a;
                    return function (t, n) {
                        return e.copy(t).applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(n)), this
                    }
                }(),
                translateX: function () {
                    var e = new a(1, 0, 0);
                    return function (t) {
                        return this.translateOnAxis(e, t)
                    }
                }(),
                translateY: function () {
                    var e = new a(0, 1, 0);
                    return function (t) {
                        return this.translateOnAxis(e, t)
                    }
                }(),
                translateZ: function () {
                    var e = new a(0, 0, 1);
                    return function (t) {
                        return this.translateOnAxis(e, t)
                    }
                }(),
                localToWorld: function (e) {
                    return e.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: function () {
                    var e = new i;
                    return function (t) {
                        return t.applyMatrix4(e.getInverse(this.matrixWorld))
                    }
                }(),
                lookAt: function () {
                    var e = new r,
                        t = new i,
                        n = new a,
                        o = new a;
                    return function (i, r, a) {
                        i.isVector3 ? n.copy(i) : n.set(i, r, a);
                        var s = this.parent;
                        this.updateWorldMatrix(!0, !1), o.setFromMatrixPosition(this.matrixWorld), this.isCamera ? t.lookAt(o, n, this.up) : t.lookAt(n, o, this.up), this.quaternion.setFromRotationMatrix(t), s && (t.extractRotation(s.matrixWorld), e.setFromRotationMatrix(t), this.quaternion.premultiply(e.inverse()))
                    }
                }(),
                add: function (e) {
                    if (arguments.length > 1) {
                        for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                        return this
                    }
                    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({
                        type: "added"
                    }), this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
                },
                remove: function (e) {
                    if (arguments.length > 1) {
                        for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                        return this
                    }
                    var n = this.children.indexOf(e);
                    return n !== -1 && (e.parent = null, e.dispatchEvent({
                        type: "removed"
                    }), this.children.splice(n, 1)), this
                },
                getObjectById: function (e) {
                    return this.getObjectByProperty("id", e)
                },
                getObjectByName: function (e) {
                    return this.getObjectByProperty("name", e)
                },
                getObjectByProperty: function (e, t) {
                    if (this[e] === t) return this;
                    for (var n = 0, i = this.children.length; n < i; n++) {
                        var r = this.children[n],
                            a = r.getObjectByProperty(e, t);
                        if (void 0 !== a) return a
                    }
                },
                getWorldPosition: function (e) {
                    return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new a), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: function () {
                    var e = new a,
                        t = new a;
                    return function (n) {
                        return void 0 === n && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), n = new r), this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, n, t), n
                    }
                }(),
                getWorldScale: function () {
                    var e = new a,
                        t = new r;
                    return function (n) {
                        return void 0 === n && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), n = new a), this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, t, n), n
                    }
                }(),
                getWorldDirection: function (e) {
                    void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e = new a), this.updateMatrixWorld(!0);
                    var t = this.matrixWorld.elements;
                    return e.set(t[8], t[9], t[10]).normalize()
                },
                raycast: function () {},
                traverse: function (e) {
                    e(this);
                    for (var t = this.children, n = 0, i = t.length; n < i; n++) t[n].traverse(e)
                },
                traverseVisible: function (e) {
                    if (this.visible !== !1) {
                        e(this);
                        for (var t = this.children, n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e)
                    }
                },
                traverseAncestors: function (e) {
                    var t = this.parent;
                    null !== t && (e(t), t.traverseAncestors(e))
                },
                updateMatrix: function () {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function (e) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
                    for (var t = this.children, n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e)
                },
                updateWorldMatrix: function (e, t) {
                    var n = this.parent;
                    if (e === !0 && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0)
                        for (var i = this.children, r = 0, a = i.length; r < a; r++) i[r].updateWorldMatrix(!1, !0)
                },
                toJSON: function (e) {
                    function t(t, n) {
                        return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
                    }

                    function n(e) {
                        var t = [];
                        for (var n in e) {
                            var i = e[n];
                            delete i.metadata, t.push(i)
                        }
                        return t
                    }
                    var i = void 0 === e || "string" == typeof e,
                        r = {};
                    i && (e = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {}
                    }, r.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    var a = {};
                    if (a.uuid = this.uuid, a.type = this.type, "" !== this.name && (a.name = this.name), this.castShadow === !0 && (a.castShadow = !0), this.receiveShadow === !0 && (a.receiveShadow = !0), this.visible === !1 && (a.visible = !1), this.frustumCulled === !1 && (a.frustumCulled = !1), 0 !== this.renderOrder && (a.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (a.userData = this.userData), a.layers = this.layers.mask, a.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (a.matrixAutoUpdate = !1), this.isMesh || this.isLine || this.isPoints) {
                        a.geometry = t(e.geometries, this.geometry);
                        var o = this.geometry.parameters;
                        if (void 0 !== o && void 0 !== o.shapes) {
                            var s = o.shapes;
                            if (Array.isArray(s))
                                for (var l = 0, c = s.length; l < c; l++) {
                                    var u = s[l];
                                    t(e.shapes, u)
                                } else t(e.shapes, s)
                        }
                    }
                    if (void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            for (var h = [], l = 0, c = this.material.length; l < c; l++) h.push(t(e.materials, this.material[l]));
                            a.material = h
                        } else a.material = t(e.materials, this.material);
                    if (this.children.length > 0) {
                        a.children = [];
                        for (var l = 0; l < this.children.length; l++) a.children.push(this.children[l].toJSON(e).object)
                    }
                    if (i) {
                        var d = n(e.geometries),
                            p = n(e.materials),
                            f = n(e.textures),
                            m = n(e.images),
                            s = n(e.shapes);
                        d.length > 0 && (r.geometries = d), p.length > 0 && (r.materials = p), f.length > 0 && (r.textures = f), m.length > 0 && (r.images = m), s.length > 0 && (r.shapes = s)
                    }
                    return r.object = a, r
                },
                clone: function (e) {
                    return (new this.constructor).copy(this, e)
                },
                copy: function (e, t) {
                    if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
                        for (var n = 0; n < e.children.length; n++) {
                            var i = e.children[n];
                            this.add(i.clone())
                        }
                    return this
                }
            });
            var oh = 0;
            M.prototype = Object.assign(Object.create(t.prototype), {
                constructor: M,
                isGeometry: !0,
                applyMatrix: function (e) {
                    for (var t = (new o).getNormalMatrix(e), n = 0, i = this.vertices.length; n < i; n++) {
                        var r = this.vertices[n];
                        r.applyMatrix4(e)
                    }
                    for (var n = 0, i = this.faces.length; n < i; n++) {
                        var a = this.faces[n];
                        a.normal.applyMatrix3(t).normalize();
                        for (var s = 0, l = a.vertexNormals.length; s < l; s++) a.vertexNormals[s].applyMatrix3(t).normalize()
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
                },
                rotateX: function () {
                    var e = new i;
                    return function (t) {
                        return e.makeRotationX(t), this.applyMatrix(e), this
                    }
                }(),
                rotateY: function () {
                    var e = new i;
                    return function (t) {
                        return e.makeRotationY(t), this.applyMatrix(e), this
                    }
                }(),
                rotateZ: function () {
                    var e = new i;
                    return function (t) {
                        return e.makeRotationZ(t), this.applyMatrix(e), this
                    }
                }(),
                translate: function () {
                    var e = new i;
                    return function (t, n, i) {
                        return e.makeTranslation(t, n, i), this.applyMatrix(e), this
                    }
                }(),
                scale: function () {
                    var e = new i;
                    return function (t, n, i) {
                        return e.makeScale(t, n, i), this.applyMatrix(e), this
                    }
                }(),
                lookAt: function () {
                    var e = new w;
                    return function (t) {
                        e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix)
                    }
                }(),
                fromBufferGeometry: function (e) {
                    function t(e, t, r, o) {
                        var s = void 0 === c ? [] : [i.colors[e].clone(), i.colors[t].clone(), i.colors[r].clone()],
                            d = void 0 === l ? [] : [(new a).fromArray(l, 3 * e), (new a).fromArray(l, 3 * t), (new a).fromArray(l, 3 * r)],
                            p = new x(e, t, r, d, s, o);
                        i.faces.push(p), void 0 !== u && i.faceVertexUvs[0].push([(new n).fromArray(u, 2 * e), (new n).fromArray(u, 2 * t), (new n).fromArray(u, 2 * r)]), void 0 !== h && i.faceVertexUvs[1].push([(new n).fromArray(h, 2 * e), (new n).fromArray(h, 2 * t), (new n).fromArray(h, 2 * r)])
                    }
                    var i = this,
                        r = null !== e.index ? e.index.array : void 0,
                        o = e.attributes,
                        s = o.position.array,
                        l = void 0 !== o.normal ? o.normal.array : void 0,
                        c = void 0 !== o.color ? o.color.array : void 0,
                        u = void 0 !== o.uv ? o.uv.array : void 0,
                        h = void 0 !== o.uv2 ? o.uv2.array : void 0;
                    void 0 !== h && (this.faceVertexUvs[1] = []);
                    for (var d = 0, p = 0; d < s.length; d += 3, p += 2) i.vertices.push((new a).fromArray(s, d)), void 0 !== c && i.colors.push((new v).fromArray(c, d));
                    var f = e.groups;
                    if (f.length > 0)
                        for (var d = 0; d < f.length; d++)
                            for (var m = f[d], g = m.start, y = m.count, p = g, b = g + y; p < b; p += 3) void 0 !== r ? t(r[p], r[p + 1], r[p + 2], m.materialIndex) : t(p, p + 1, p + 2, m.materialIndex);
                    else if (void 0 !== r)
                        for (var d = 0; d < r.length; d += 3) t(r[d], r[d + 1], r[d + 2]);
                    else
                        for (var d = 0; d < s.length / 3; d += 3) t(d, d + 1, d + 2);
                    return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
                },
                center: function () {
                    var e = new a;
                    return function () {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(e).negate(), this.translate(e.x, e.y, e.z), this
                    }
                }(),
                normalize: function () {
                    this.computeBoundingSphere();
                    var e = this.boundingSphere.center,
                        t = this.boundingSphere.radius,
                        n = 0 === t ? 1 : 1 / t,
                        r = new i;
                    return r.set(n, 0, 0, -n * e.x, 0, n, 0, -n * e.y, 0, 0, n, -n * e.z, 0, 0, 0, 1), this.applyMatrix(r), this
                },
                computeFaceNormals: function () {
                    for (var e = new a, t = new a, n = 0, i = this.faces.length; n < i; n++) {
                        var r = this.faces[n],
                            o = this.vertices[r.a],
                            s = this.vertices[r.b],
                            l = this.vertices[r.c];
                        e.subVectors(l, s), t.subVectors(o, s), e.cross(t), e.normalize(), r.normal.copy(e)
                    }
                },
                computeVertexNormals: function (e) {
                    void 0 === e && (e = !0);
                    var t, n, i, r, o, s;
                    for (s = new Array(this.vertices.length), t = 0, n = this.vertices.length; t < n; t++) s[t] = new a;
                    if (e) {
                        var l, c, u, h = new a,
                            d = new a;
                        for (i = 0, r = this.faces.length; i < r; i++) o = this.faces[i], l = this.vertices[o.a], c = this.vertices[o.b], u = this.vertices[o.c], h.subVectors(u, c), d.subVectors(l, c), h.cross(d), s[o.a].add(h), s[o.b].add(h), s[o.c].add(h)
                    } else
                        for (this.computeFaceNormals(), i = 0, r = this.faces.length; i < r; i++) o = this.faces[i], s[o.a].add(o.normal), s[o.b].add(o.normal), s[o.c].add(o.normal);
                    for (t = 0, n = this.vertices.length; t < n; t++) s[t].normalize();
                    for (i = 0, r = this.faces.length; i < r; i++) {
                        o = this.faces[i];
                        var p = o.vertexNormals;
                        3 === p.length ? (p[0].copy(s[o.a]), p[1].copy(s[o.b]), p[2].copy(s[o.c])) : (p[0] = s[o.a].clone(), p[1] = s[o.b].clone(), p[2] = s[o.c].clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeFlatVertexNormals: function () {
                    var e, t, n;
                    for (this.computeFaceNormals(), e = 0, t = this.faces.length; e < t; e++) {
                        n = this.faces[e];
                        var i = n.vertexNormals;
                        3 === i.length ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal)) : (i[0] = n.normal.clone(), i[1] = n.normal.clone(), i[2] = n.normal.clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function () {
                    var e, t, n, i, r;
                    for (n = 0, i = this.faces.length; n < i; n++)
                        for (r = this.faces[n], r.__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), e = 0, t = r.vertexNormals.length; e < t; e++) r.__originalVertexNormals[e] ? r.__originalVertexNormals[e].copy(r.vertexNormals[e]) : r.__originalVertexNormals[e] = r.vertexNormals[e].clone();
                    var o = new M;
                    for (o.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) {
                        if (!this.morphNormals[e]) {
                            this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
                            var s, l, c = this.morphNormals[e].faceNormals,
                                u = this.morphNormals[e].vertexNormals;
                            for (n = 0, i = this.faces.length; n < i; n++) s = new a, l = {
                                a: new a,
                                b: new a,
                                c: new a
                            }, c.push(s), u.push(l);
                        }
                        var h = this.morphNormals[e];
                        o.vertices = this.morphTargets[e].vertices, o.computeFaceNormals(), o.computeVertexNormals();
                        var s, l;
                        for (n = 0, i = this.faces.length; n < i; n++) r = this.faces[n], s = h.faceNormals[n], l = h.vertexNormals[n], s.copy(r.normal), l.a.copy(r.vertexNormals[0]), l.b.copy(r.vertexNormals[1]), l.c.copy(r.vertexNormals[2])
                    }
                    for (n = 0, i = this.faces.length; n < i; n++) r = this.faces[n], r.normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
                },
                computeBoundingBox: function () {
                    null === this.boundingBox && (this.boundingBox = new d), this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function () {
                    null === this.boundingSphere && (this.boundingSphere = new p), this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function (e, t, n) {
                    if (!e || !e.isGeometry) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e);
                    var i, r = this.vertices.length,
                        a = this.vertices,
                        s = e.vertices,
                        l = this.faces,
                        c = e.faces,
                        u = this.faceVertexUvs[0],
                        h = e.faceVertexUvs[0],
                        d = this.colors,
                        p = e.colors;
                    void 0 === n && (n = 0), void 0 !== t && (i = (new o).getNormalMatrix(t));
                    for (var f = 0, m = s.length; f < m; f++) {
                        var v = s[f],
                            g = v.clone();
                        void 0 !== t && g.applyMatrix4(t), a.push(g)
                    }
                    for (var f = 0, m = p.length; f < m; f++) d.push(p[f].clone());
                    for (f = 0, m = c.length; f < m; f++) {
                        var y, b, _, w = c[f],
                            M = w.vertexNormals,
                            T = w.vertexColors;
                        y = new x(w.a + r, w.b + r, w.c + r), y.normal.copy(w.normal), void 0 !== i && y.normal.applyMatrix3(i).normalize();
                        for (var E = 0, S = M.length; E < S; E++) b = M[E].clone(), void 0 !== i && b.applyMatrix3(i).normalize(), y.vertexNormals.push(b);
                        y.color.copy(w.color);
                        for (var E = 0, S = T.length; E < S; E++) _ = T[E], y.vertexColors.push(_.clone());
                        y.materialIndex = w.materialIndex + n, l.push(y)
                    }
                    for (f = 0, m = h.length; f < m; f++) {
                        var P = h[f],
                            C = [];
                        if (void 0 !== P) {
                            for (var E = 0, S = P.length; E < S; E++) C.push(P[E].clone());
                            u.push(C)
                        }
                    }
                },
                mergeMesh: function (e) {
                    return e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), void this.merge(e.geometry, e.matrix)) : void console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e)
                },
                mergeVertices: function () {
                    var e, t, n, i, r, a, o, s, l = {},
                        c = [],
                        u = [],
                        h = 4,
                        d = Math.pow(10, h);
                    for (n = 0, i = this.vertices.length; n < i; n++) e = this.vertices[n], t = Math.round(e.x * d) + "_" + Math.round(e.y * d) + "_" + Math.round(e.z * d), void 0 === l[t] ? (l[t] = n, c.push(this.vertices[n]), u[n] = c.length - 1) : u[n] = u[l[t]];
                    var p = [];
                    for (n = 0, i = this.faces.length; n < i; n++) {
                        r = this.faces[n], r.a = u[r.a], r.b = u[r.b], r.c = u[r.c], a = [r.a, r.b, r.c];
                        for (var f = 0; f < 3; f++)
                            if (a[f] === a[(f + 1) % 3]) {
                                p.push(n);
                                break
                            }
                    }
                    for (n = p.length - 1; n >= 0; n--) {
                        var m = p[n];
                        for (this.faces.splice(m, 1), o = 0, s = this.faceVertexUvs.length; o < s; o++) this.faceVertexUvs[o].splice(m, 1)
                    }
                    var v = this.vertices.length - c.length;
                    return this.vertices = c, v
                },
                setFromPoints: function (e) {
                    this.vertices = [];
                    for (var t = 0, n = e.length; t < n; t++) {
                        var i = e[t];
                        this.vertices.push(new a(i.x, i.y, i.z || 0))
                    }
                    return this
                },
                sortFacesByMaterialIndex: function () {
                    function e(e, t) {
                        return e.materialIndex - t.materialIndex
                    }
                    for (var t = this.faces, n = t.length, i = 0; i < n; i++) t[i]._id = i;
                    t.sort(e);
                    var r, a, o = this.faceVertexUvs[0],
                        s = this.faceVertexUvs[1];
                    o && o.length === n && (r = []), s && s.length === n && (a = []);
                    for (var i = 0; i < n; i++) {
                        var l = t[i]._id;
                        r && r.push(o[l]), a && a.push(s[l])
                    }
                    r && (this.faceVertexUvs[0] = r), a && (this.faceVertexUvs[1] = a)
                },
                toJSON: function () {
                    function e(e, t, n) {
                        return n ? e | 1 << t : e & ~(1 << t)
                    }

                    function t(e) {
                        var t = e.x.toString() + e.y.toString() + e.z.toString();
                        return void 0 !== d[t] ? d[t] : (d[t] = h.length / 3, h.push(e.x, e.y, e.z), d[t])
                    }

                    function n(e) {
                        var t = e.r.toString() + e.g.toString() + e.b.toString();
                        return void 0 !== f[t] ? f[t] : (f[t] = p.length, p.push(e.getHex()), f[t])
                    }

                    function i(e) {
                        var t = e.x.toString() + e.y.toString();
                        return void 0 !== v[t] ? v[t] : (v[t] = m.length / 2, m.push(e.x, e.y), v[t])
                    }
                    var r = {
                        metadata: {
                            version: 4.5,
                            type: "Geometry",
                            generator: "Geometry.toJSON"
                        }
                    };
                    if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), void 0 !== this.parameters) {
                        var a = this.parameters;
                        for (var o in a) void 0 !== a[o] && (r[o] = a[o]);
                        return r
                    }
                    for (var s = [], l = 0; l < this.vertices.length; l++) {
                        var c = this.vertices[l];
                        s.push(c.x, c.y, c.z)
                    }
                    for (var u = [], h = [], d = {}, p = [], f = {}, m = [], v = {}, l = 0; l < this.faces.length; l++) {
                        var g = this.faces[l],
                            y = !0,
                            x = !1,
                            b = void 0 !== this.faceVertexUvs[0][l],
                            _ = g.normal.length() > 0,
                            w = g.vertexNormals.length > 0,
                            M = 1 !== g.color.r || 1 !== g.color.g || 1 !== g.color.b,
                            T = g.vertexColors.length > 0,
                            E = 0;
                        if (E = e(E, 0, 0), E = e(E, 1, y), E = e(E, 2, x), E = e(E, 3, b), E = e(E, 4, _), E = e(E, 5, w), E = e(E, 6, M), E = e(E, 7, T), u.push(E), u.push(g.a, g.b, g.c), u.push(g.materialIndex), b) {
                            var S = this.faceVertexUvs[0][l];
                            u.push(i(S[0]), i(S[1]), i(S[2]))
                        }
                        if (_ && u.push(t(g.normal)), w) {
                            var P = g.vertexNormals;
                            u.push(t(P[0]), t(P[1]), t(P[2]))
                        }
                        if (M && u.push(n(g.color)), T) {
                            var C = g.vertexColors;
                            u.push(n(C[0]), n(C[1]), n(C[2]))
                        }
                    }
                    return r.data = {}, r.data.vertices = s, r.data.normals = h, p.length > 0 && (r.data.colors = p), m.length > 0 && (r.data.uvs = [m]), r.data.faces = u, r
                },
                clone: function () {
                    return (new M).copy(this)
                },
                copy: function (e) {
                    var t, n, i, r, a, o;
                    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
                    var s = e.vertices;
                    for (t = 0, n = s.length; t < n; t++) this.vertices.push(s[t].clone());
                    var l = e.colors;
                    for (t = 0, n = l.length; t < n; t++) this.colors.push(l[t].clone());
                    var c = e.faces;
                    for (t = 0, n = c.length; t < n; t++) this.faces.push(c[t].clone());
                    for (t = 0, n = e.faceVertexUvs.length; t < n; t++) {
                        var u = e.faceVertexUvs[t];
                        for (void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []), i = 0, r = u.length; i < r; i++) {
                            var h = u[i],
                                d = [];
                            for (a = 0, o = h.length; a < o; a++) {
                                var p = h[a];
                                d.push(p.clone())
                            }
                            this.faceVertexUvs[t].push(d)
                        }
                    }
                    var f = e.morphTargets;
                    for (t = 0, n = f.length; t < n; t++) {
                        var m = {};
                        if (m.name = f[t].name, void 0 !== f[t].vertices)
                            for (m.vertices = [], i = 0, r = f[t].vertices.length; i < r; i++) m.vertices.push(f[t].vertices[i].clone());
                        if (void 0 !== f[t].normals)
                            for (m.normals = [], i = 0, r = f[t].normals.length; i < r; i++) m.normals.push(f[t].normals[i].clone());
                        this.morphTargets.push(m)
                    }
                    var v = e.morphNormals;
                    for (t = 0, n = v.length; t < n; t++) {
                        var g = {};
                        if (void 0 !== v[t].vertexNormals)
                            for (g.vertexNormals = [], i = 0, r = v[t].vertexNormals.length; i < r; i++) {
                                var y = v[t].vertexNormals[i],
                                    x = {};
                                x.a = y.a.clone(), x.b = y.b.clone(), x.c = y.c.clone(), g.vertexNormals.push(x)
                            }
                        if (void 0 !== v[t].faceNormals)
                            for (g.faceNormals = [], i = 0, r = v[t].faceNormals.length; i < r; i++) g.faceNormals.push(v[t].faceNormals[i].clone());
                        this.morphNormals.push(g)
                    }
                    var b = e.skinWeights;
                    for (t = 0, n = b.length; t < n; t++) this.skinWeights.push(b[t].clone());
                    var _ = e.skinIndices;
                    for (t = 0, n = _.length; t < n; t++) this.skinIndices.push(_[t].clone());
                    var w = e.lineDistances;
                    for (t = 0, n = w.length; t < n; t++) this.lineDistances.push(w[t]);
                    var M = e.boundingBox;
                    null !== M && (this.boundingBox = M.clone());
                    var T = e.boundingSphere;
                    return null !== T && (this.boundingSphere = T.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
                },
                dispose: function () {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Object.defineProperty(T.prototype, "needsUpdate", {
                set: function (e) {
                    e === !0 && this.version++
                }
            }), Object.assign(T.prototype, {
                isBufferAttribute: !0,
                onUploadCallback: function () {},
                setArray: function (e) {
                    if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    return this.count = void 0 !== e ? e.length / this.itemSize : 0, this.array = e, this
                },
                setDynamic: function (e) {
                    return this.dynamic = e, this
                },
                copy: function (e) {
                    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.dynamic = e.dynamic, this
                },
                copyAt: function (e, t, n) {
                    e *= this.itemSize, n *= t.itemSize;
                    for (var i = 0, r = this.itemSize; i < r; i++) this.array[e + i] = t.array[n + i];
                    return this
                },
                copyArray: function (e) {
                    return this.array.set(e), this
                },
                copyColorsArray: function (e) {
                    for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
                        var a = e[i];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), a = new v), t[n++] = a.r, t[n++] = a.g, t[n++] = a.b
                    }
                    return this
                },
                copyVector2sArray: function (e) {
                    for (var t = this.array, i = 0, r = 0, a = e.length; r < a; r++) {
                        var o = e[r];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), o = new n), t[i++] = o.x, t[i++] = o.y
                    }
                    return this
                },
                copyVector3sArray: function (e) {
                    for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
                        var o = e[i];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), o = new a), t[n++] = o.x, t[n++] = o.y, t[n++] = o.z
                    }
                    return this
                },
                copyVector4sArray: function (e) {
                    for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
                        var a = e[i];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), a = new l), t[n++] = a.x, t[n++] = a.y, t[n++] = a.z, t[n++] = a.w
                    }
                    return this
                },
                set: function (e, t) {
                    return void 0 === t && (t = 0), this.array.set(e, t), this
                },
                getX: function (e) {
                    return this.array[e * this.itemSize]
                },
                setX: function (e, t) {
                    return this.array[e * this.itemSize] = t, this
                },
                getY: function (e) {
                    return this.array[e * this.itemSize + 1]
                },
                setY: function (e, t) {
                    return this.array[e * this.itemSize + 1] = t, this
                },
                getZ: function (e) {
                    return this.array[e * this.itemSize + 2]
                },
                setZ: function (e, t) {
                    return this.array[e * this.itemSize + 2] = t, this
                },
                getW: function (e) {
                    return this.array[e * this.itemSize + 3]
                },
                setW: function (e, t) {
                    return this.array[e * this.itemSize + 3] = t, this
                },
                setXY: function (e, t, n) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
                },
                setXYZ: function (e, t, n, i) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this
                },
                setXYZW: function (e, t, n, i, r) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this
                },
                onUpload: function (e) {
                    return this.onUploadCallback = e, this
                },
                clone: function () {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
            }), E.prototype = Object.create(T.prototype), E.prototype.constructor = E, S.prototype = Object.create(T.prototype), S.prototype.constructor = S, P.prototype = Object.create(T.prototype), P.prototype.constructor = P, C.prototype = Object.create(T.prototype), C.prototype.constructor = C, A.prototype = Object.create(T.prototype), A.prototype.constructor = A, L.prototype = Object.create(T.prototype), L.prototype.constructor = L, R.prototype = Object.create(T.prototype), R.prototype.constructor = R, I.prototype = Object.create(T.prototype), I.prototype.constructor = I, O.prototype = Object.create(T.prototype), O.prototype.constructor = O, Object.assign(k.prototype, {
                computeGroups: function (e) {
                    for (var t, n = [], i = void 0, r = e.faces, a = 0; a < r.length; a++) {
                        var o = r[a];
                        o.materialIndex !== i && (i = o.materialIndex, void 0 !== t && (t.count = 3 * a - t.start, n.push(t)), t = {
                            start: 3 * a,
                            materialIndex: i
                        })
                    }
                    void 0 !== t && (t.count = 3 * a - t.start, n.push(t)), this.groups = n
                },
                fromGeometry: function (e) {
                    var t, i = e.faces,
                        r = e.vertices,
                        a = e.faceVertexUvs,
                        o = a[0] && a[0].length > 0,
                        s = a[1] && a[1].length > 0,
                        l = e.morphTargets,
                        c = l.length;
                    if (c > 0) {
                        t = [];
                        for (var u = 0; u < c; u++) t[u] = {
                            name: l[u].name,
                            data: []
                        };
                        this.morphTargets.position = t
                    }
                    var h, d = e.morphNormals,
                        p = d.length;
                    if (p > 0) {
                        h = [];
                        for (var u = 0; u < p; u++) h[u] = {
                            name: d[u].name,
                            data: []
                        };
                        this.morphTargets.normal = h
                    }
                    var f = e.skinIndices,
                        m = e.skinWeights,
                        v = f.length === r.length,
                        g = m.length === r.length;
                    r.length > 0 && 0 === i.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
                    for (var u = 0; u < i.length; u++) {
                        var y = i[u];
                        this.vertices.push(r[y.a], r[y.b], r[y.c]);
                        var x = y.vertexNormals;
                        if (3 === x.length) this.normals.push(x[0], x[1], x[2]);
                        else {
                            var b = y.normal;
                            this.normals.push(b, b, b)
                        }
                        var _ = y.vertexColors;
                        if (3 === _.length) this.colors.push(_[0], _[1], _[2]);
                        else {
                            var w = y.color;
                            this.colors.push(w, w, w)
                        }
                        if (o === !0) {
                            var M = a[0][u];
                            void 0 !== M ? this.uvs.push(M[0], M[1], M[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", u), this.uvs.push(new n, new n, new n))
                        }
                        if (s === !0) {
                            var M = a[1][u];
                            void 0 !== M ? this.uvs2.push(M[0], M[1], M[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", u), this.uvs2.push(new n, new n, new n))
                        }
                        for (var T = 0; T < c; T++) {
                            var E = l[T].vertices;
                            t[T].data.push(E[y.a], E[y.b], E[y.c])
                        }
                        for (var T = 0; T < p; T++) {
                            var S = d[T].vertexNormals[u];
                            h[T].data.push(S.a, S.b, S.c)
                        }
                        v && this.skinIndices.push(f[y.a], f[y.b], f[y.c]), g && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
                    }
                    return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
                }
            });
            var sh = 1;
            z.prototype = Object.assign(Object.create(t.prototype), {
                constructor: z,
                isBufferGeometry: !0,
                getIndex: function () {
                    return this.index
                },
                setIndex: function (e) {
                    Array.isArray(e) ? this.index = new(D(e) > 65535 ? R : A)(e, 1) : this.index = e
                },
                addAttribute: function (e, t) {
                    return t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : (this.attributes[e] = t, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(e, new T(arguments[1], arguments[2])))
                },
                getAttribute: function (e) {
                    return this.attributes[e]
                },
                removeAttribute: function (e) {
                    return delete this.attributes[e], this
                },
                addGroup: function (e, t, n) {
                    this.groups.push({
                        start: e,
                        count: t,
                        materialIndex: void 0 !== n ? n : 0
                    })
                },
                clearGroups: function () {
                    this.groups = []
                },
                setDrawRange: function (e, t) {
                    this.drawRange.start = e, this.drawRange.count = t
                },
                applyMatrix: function (e) {
                    var t = this.attributes.position;
                    void 0 !== t && (e.applyToBufferAttribute(t), t.needsUpdate = !0);
                    var n = this.attributes.normal;
                    if (void 0 !== n) {
                        var i = (new o).getNormalMatrix(e);
                        i.applyToBufferAttribute(n), n.needsUpdate = !0
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                },
                rotateX: function () {
                    var e = new i;
                    return function (t) {
                        return e.makeRotationX(t), this.applyMatrix(e), this
                    }
                }(),
                rotateY: function () {
                    var e = new i;
                    return function (t) {
                        return e.makeRotationY(t), this.applyMatrix(e), this
                    }
                }(),
                rotateZ: function () {
                    var e = new i;
                    return function (t) {
                        return e.makeRotationZ(t), this.applyMatrix(e), this
                    }
                }(),
                translate: function () {
                    var e = new i;
                    return function (t, n, i) {
                        return e.makeTranslation(t, n, i), this.applyMatrix(e), this
                    }
                }(),
                scale: function () {
                    var e = new i;
                    return function (t, n, i) {
                        return e.makeScale(t, n, i), this.applyMatrix(e), this
                    }
                }(),
                lookAt: function () {
                    var e = new w;
                    return function (t) {
                        e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix)
                    }
                }(),
                center: function () {
                    var e = new a;
                    return function () {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(e).negate(), this.translate(e.x, e.y, e.z), this
                    }
                }(),
                setFromObject: function (e) {
                    var t = e.geometry;
                    if (e.isPoints || e.isLine) {
                        var n = new I(3 * t.vertices.length, 3),
                            i = new I(3 * t.colors.length, 3);
                        if (this.addAttribute("position", n.copyVector3sArray(t.vertices)), this.addAttribute("color", i.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) {
                            var r = new I(t.lineDistances.length, 1);
                            this.addAttribute("lineDistance", r.copyArray(t.lineDistances))
                        }
                        null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
                    } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
                    return this
                },
                setFromPoints: function (e) {
                    for (var t = [], n = 0, i = e.length; n < i; n++) {
                        var r = e[n];
                        t.push(r.x, r.y, r.z || 0)
                    }
                    return this.addAttribute("position", new I(t, 3)), this
                },
                updateFromObject: function (e) {
                    var t = e.geometry;
                    if (e.isMesh) {
                        var n = t.__directGeometry;
                        if (t.elementsNeedUpdate === !0 && (n = void 0, t.elementsNeedUpdate = !1), void 0 === n) return this.fromGeometry(t);
                        n.verticesNeedUpdate = t.verticesNeedUpdate, n.normalsNeedUpdate = t.normalsNeedUpdate, n.colorsNeedUpdate = t.colorsNeedUpdate, n.uvsNeedUpdate = t.uvsNeedUpdate, n.groupsNeedUpdate = t.groupsNeedUpdate, t.verticesNeedUpdate = !1, t.normalsNeedUpdate = !1, t.colorsNeedUpdate = !1, t.uvsNeedUpdate = !1, t.groupsNeedUpdate = !1, t = n
                    }
                    var i;
                    return t.verticesNeedUpdate === !0 && (i = this.attributes.position, void 0 !== i && (i.copyVector3sArray(t.vertices), i.needsUpdate = !0), t.verticesNeedUpdate = !1), t.normalsNeedUpdate === !0 && (i = this.attributes.normal, void 0 !== i && (i.copyVector3sArray(t.normals), i.needsUpdate = !0), t.normalsNeedUpdate = !1), t.colorsNeedUpdate === !0 && (i = this.attributes.color, void 0 !== i && (i.copyColorsArray(t.colors), i.needsUpdate = !0), t.colorsNeedUpdate = !1), t.uvsNeedUpdate && (i = this.attributes.uv, void 0 !== i && (i.copyVector2sArray(t.uvs), i.needsUpdate = !0), t.uvsNeedUpdate = !1), t.lineDistancesNeedUpdate && (i = this.attributes.lineDistance, void 0 !== i && (i.copyArray(t.lineDistances), i.needsUpdate = !0), t.lineDistancesNeedUpdate = !1), t.groupsNeedUpdate && (t.computeGroups(e.geometry), this.groups = t.groups, t.groupsNeedUpdate = !1), this
                },
                fromGeometry: function (e) {
                    return e.__directGeometry = (new k).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry)
                },
                fromDirectGeometry: function (e) {
                    var t = new Float32Array(3 * e.vertices.length);
                    if (this.addAttribute("position", new T(t, 3).copyVector3sArray(e.vertices)), e.normals.length > 0) {
                        var n = new Float32Array(3 * e.normals.length);
                        this.addAttribute("normal", new T(n, 3).copyVector3sArray(e.normals))
                    }
                    if (e.colors.length > 0) {
                        var i = new Float32Array(3 * e.colors.length);
                        this.addAttribute("color", new T(i, 3).copyColorsArray(e.colors))
                    }
                    if (e.uvs.length > 0) {
                        var r = new Float32Array(2 * e.uvs.length);
                        this.addAttribute("uv", new T(r, 2).copyVector2sArray(e.uvs))
                    }
                    if (e.uvs2.length > 0) {
                        var a = new Float32Array(2 * e.uvs2.length);
                        this.addAttribute("uv2", new T(a, 2).copyVector2sArray(e.uvs2))
                    }
                    this.groups = e.groups;
                    for (var o in e.morphTargets) {
                        for (var s = [], l = e.morphTargets[o], c = 0, u = l.length; c < u; c++) {
                            var h = l[c],
                                d = new I(3 * h.data.length, 3);
                            d.name = h.name, s.push(d.copyVector3sArray(h.data))
                        }
                        this.morphAttributes[o] = s
                    }
                    if (e.skinIndices.length > 0) {
                        var p = new I(4 * e.skinIndices.length, 4);
                        this.addAttribute("skinIndex", p.copyVector4sArray(e.skinIndices))
                    }
                    if (e.skinWeights.length > 0) {
                        var f = new I(4 * e.skinWeights.length, 4);
                        this.addAttribute("skinWeight", f.copyVector4sArray(e.skinWeights))
                    }
                    return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
                },
                computeBoundingBox: function () {
                    null === this.boundingBox && (this.boundingBox = new d);
                    var e = this.attributes.position;
                    void 0 !== e ? this.boundingBox.setFromBufferAttribute(e) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                },
                computeBoundingSphere: function () {
                    var e = new d,
                        t = new a;
                    return function () {
                        null === this.boundingSphere && (this.boundingSphere = new p);
                        var n = this.attributes.position;
                        if (n) {
                            var i = this.boundingSphere.center;
                            e.setFromBufferAttribute(n), e.getCenter(i);
                            for (var r = 0, a = 0, o = n.count; a < o; a++) t.x = n.getX(a), t.y = n.getY(a), t.z = n.getZ(a), r = Math.max(r, i.distanceToSquared(t));
                            this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                }(),
                computeFaceNormals: function () {},
                computeVertexNormals: function () {
                    var e = this.index,
                        t = this.attributes;
                    if (t.position) {
                        var n = t.position.array;
                        if (void 0 === t.normal) this.addAttribute("normal", new T(new Float32Array(n.length), 3));
                        else
                            for (var i = t.normal.array, r = 0, o = i.length; r < o; r++) i[r] = 0;
                        var s, l, c, u = t.normal.array,
                            h = new a,
                            d = new a,
                            p = new a,
                            f = new a,
                            m = new a;
                        if (e)
                            for (var v = e.array, r = 0, o = e.count; r < o; r += 3) s = 3 * v[r + 0], l = 3 * v[r + 1], c = 3 * v[r + 2], h.fromArray(n, s), d.fromArray(n, l), p.fromArray(n, c), f.subVectors(p, d), m.subVectors(h, d), f.cross(m), u[s] += f.x, u[s + 1] += f.y, u[s + 2] += f.z, u[l] += f.x, u[l + 1] += f.y, u[l + 2] += f.z, u[c] += f.x, u[c + 1] += f.y, u[c + 2] += f.z;
                        else
                            for (var r = 0, o = n.length; r < o; r += 9) h.fromArray(n, r), d.fromArray(n, r + 3), p.fromArray(n, r + 6), f.subVectors(p, d), m.subVectors(h, d), f.cross(m), u[r] = f.x, u[r + 1] = f.y, u[r + 2] = f.z, u[r + 3] = f.x, u[r + 4] = f.y, u[r + 5] = f.z, u[r + 6] = f.x, u[r + 7] = f.y, u[r + 8] = f.z;
                        this.normalizeNormals(), t.normal.needsUpdate = !0
                    }
                },
                merge: function (e, t) {
                    if (!e || !e.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
                    void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                    var n = this.attributes;
                    for (var i in n)
                        if (void 0 !== e.attributes[i])
                            for (var r = n[i], a = r.array, o = e.attributes[i], s = o.array, l = o.itemSize, c = 0, u = l * t; c < s.length; c++, u++) a[u] = s[c];
                    return this
                },
                normalizeNormals: function () {
                    var e = new a;
                    return function () {
                        for (var t = this.attributes.normal, n = 0, i = t.count; n < i; n++) e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.normalize(), t.setXYZ(n, e.x, e.y, e.z)
                    }
                }(),
                toNonIndexed: function () {
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                    var e = new z,
                        t = this.index.array,
                        n = this.attributes;
                    for (var i in n) {
                        for (var r = n[i], a = r.array, o = r.itemSize, s = new a.constructor(t.length * o), l = 0, c = 0, u = 0, h = t.length; u < h; u++) {
                            l = t[u] * o;
                            for (var d = 0; d < o; d++) s[c++] = a[l++]
                        }
                        e.addAttribute(i, new T(s, o))
                    }
                    for (var p = this.groups, u = 0, h = p.length; u < h; u++) {
                        var f = p[u];
                        e.addGroup(f.start, f.count, f.materialIndex)
                    }
                    return e
                },
                toJSON: function () {
                    var e = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
                        var t = this.parameters;
                        for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
                        return e
                    }
                    e.data = {
                        attributes: {}
                    };
                    var i = this.index;
                    if (null !== i) {
                        var r = Array.prototype.slice.call(i.array);
                        e.data.index = {
                            type: i.array.constructor.name,
                            array: r
                        }
                    }
                    var a = this.attributes;
                    for (var n in a) {
                        var o = a[n],
                            r = Array.prototype.slice.call(o.array);
                        e.data.attributes[n] = {
                            itemSize: o.itemSize,
                            type: o.array.constructor.name,
                            array: r,
                            normalized: o.normalized
                        }
                    }
                    var s = this.groups;
                    s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
                    var l = this.boundingSphere;
                    return null !== l && (e.data.boundingSphere = {
                        center: l.center.toArray(),
                        radius: l.radius
                    }), e
                },
                clone: function () {
                    return (new z).copy(this)
                },
                copy: function (e) {
                    var t, n, i;
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
                    var r = e.index;
                    null !== r && this.setIndex(r.clone());
                    var a = e.attributes;
                    for (t in a) {
                        var o = a[t];
                        this.addAttribute(t, o.clone())
                    }
                    var s = e.morphAttributes;
                    for (t in s) {
                        var l = [],
                            c = s[t];
                        for (n = 0, i = c.length; n < i; n++) l.push(c[n].clone());
                        this.morphAttributes[t] = l
                    }
                    var u = e.groups;
                    for (n = 0, i = u.length; n < i; n++) {
                        var h = u[n];
                        this.addGroup(h.start, h.count, h.materialIndex)
                    }
                    var d = e.boundingBox;
                    null !== d && (this.boundingBox = d.clone());
                    var p = e.boundingSphere;
                    return null !== p && (this.boundingSphere = p.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
                },
                dispose: function () {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), B.prototype = Object.create(M.prototype), B.prototype.constructor = B, N.prototype = Object.create(z.prototype), N.prototype.constructor = N, U.prototype = Object.create(M.prototype), U.prototype.constructor = U, j.prototype = Object.create(z.prototype), j.prototype.constructor = j;
            var lh = 0;
            F.prototype = Object.assign(Object.create(t.prototype), {
                constructor: F,
                isMaterial: !0,
                onBeforeCompile: function () {},
                setValues: function (e) {
                    if (void 0 !== e)
                        for (var t in e) {
                            var n = e[t];
                            if (void 0 !== n)
                                if ("shading" !== t) {
                                    var i = this[t];
                                    void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                                } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === bo;
                            else console.warn("THREE.Material: '" + t + "' parameter is undefined.")
                        }
                },
                toJSON: function (e) {
                    function t(e) {
                        var t = [];
                        for (var n in e) {
                            var i = e[n];
                            delete i.metadata, t.push(i)
                        }
                        return t
                    }
                    var n = void 0 === e || "string" == typeof e;
                    n && (e = {
                        textures: {},
                        images: {}
                    });
                    var i = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };
                    if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearCoat && (i.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (i.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, i.reflectivity = this.reflectivity, void 0 !== this.combine && (i.combine = this.combine), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (i.size = this.size), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== So && (i.blending = this.blending), this.flatShading === !0 && (i.flatShading = this.flatShading), this.side !== go && (i.side = this.side), this.vertexColors !== wo && (i.vertexColors = this.vertexColors), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, 0 !== this.rotation && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), this.morphTargets === !0 && (i.morphTargets = !0), this.skinning === !0 && (i.skinning = !0), this.visible === !1 && (i.visible = !1), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), n) {
                        var r = t(e.textures),
                            a = t(e.images);
                        r.length > 0 && (i.textures = r), a.length > 0 && (i.images = a)
                    }
                    return i
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    this.name = e.name, this.fog = e.fog, this.lights = e.lights, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.userData = JSON.parse(JSON.stringify(e.userData)), this.clipShadows = e.clipShadows, this.clipIntersection = e.clipIntersection;
                    var t = e.clippingPlanes,
                        n = null;
                    if (null !== t) {
                        var i = t.length;
                        n = new Array(i);
                        for (var r = 0; r !== i; ++r) n[r] = t[r].clone()
                    }
                    return this.clippingPlanes = n, this.shadowSide = e.shadowSide, this
                },
                dispose: function () {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), G.prototype = Object.create(F.prototype), G.prototype.constructor = G, G.prototype.isShaderMaterial = !0, G.prototype.copy = function (e) {
                return F.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = th.clone(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this
            }, G.prototype.toJSON = function (e) {
                var t = F.prototype.toJSON.call(this, e);
                t.uniforms = {};
                for (var n in this.uniforms) {
                    var i = this.uniforms[n],
                        r = i.value;
                    r.isTexture ? t.uniforms[n] = {
                        type: "t",
                        value: r.toJSON(e).uuid
                    } : r.isColor ? t.uniforms[n] = {
                        type: "c",
                        value: r.getHex()
                    } : r.isVector2 ? t.uniforms[n] = {
                        type: "v2",
                        value: r.toArray()
                    } : r.isVector3 ? t.uniforms[n] = {
                        type: "v3",
                        value: r.toArray()
                    } : r.isVector4 ? t.uniforms[n] = {
                        type: "v4",
                        value: r.toArray()
                    } : r.isMatrix4 ? t.uniforms[n] = {
                        type: "m4",
                        value: r.toArray()
                    } : t.uniforms[n] = {
                        value: r
                    }
                }
                return Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t
            }, Object.assign(H.prototype, {
                set: function (e, t) {
                    return this.origin.copy(e), this.direction.copy(t), this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.origin.copy(e.origin), this.direction.copy(e.direction), this
                },
                at: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"), t = new a), t.copy(this.direction).multiplyScalar(e).add(this.origin)
                },
                lookAt: function (e) {
                    return this.direction.copy(e).sub(this.origin).normalize(), this
                },
                recast: function () {
                    var e = new a;
                    return function (t) {
                        return this.origin.copy(this.at(t, e)), this
                    }
                }(),
                closestPointToPoint: function (e, t) {
                    void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new a), t.subVectors(e, this.origin);
                    var n = t.dot(this.direction);
                    return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
                },
                distanceToPoint: function (e) {
                    return Math.sqrt(this.distanceSqToPoint(e))
                },
                distanceSqToPoint: function () {
                    var e = new a;
                    return function (t) {
                        var n = e.subVectors(t, this.origin).dot(this.direction);
                        return n < 0 ? this.origin.distanceToSquared(t) : (e.copy(this.direction).multiplyScalar(n).add(this.origin), e.distanceToSquared(t))
                    }
                }(),
                distanceSqToSegment: function () {
                    var e = new a,
                        t = new a,
                        n = new a;
                    return function (i, r, a, o) {
                        e.copy(i).add(r).multiplyScalar(.5), t.copy(r).sub(i).normalize(), n.copy(this.origin).sub(e);
                        var s, l, c, u, h = .5 * i.distanceTo(r),
                            d = -this.direction.dot(t),
                            p = n.dot(this.direction),
                            f = -n.dot(t),
                            m = n.lengthSq(),
                            v = Math.abs(1 - d * d);
                        if (v > 0)
                            if (s = d * f - p, l = d * p - f, u = h * v, s >= 0)
                                if (l >= -u)
                                    if (l <= u) {
                                        var g = 1 / v;
                                        s *= g, l *= g, c = s * (s + d * l + 2 * p) + l * (d * s + l + 2 * f) + m
                                    } else l = h, s = Math.max(0, -(d * l + p)), c = -s * s + l * (l + 2 * f) + m;
                        else l = -h, s = Math.max(0, -(d * l + p)), c = -s * s + l * (l + 2 * f) + m;
                        else l <= -u ? (s = Math.max(0, -(-d * h + p)), l = s > 0 ? -h : Math.min(Math.max(-h, -f), h), c = -s * s + l * (l + 2 * f) + m) : l <= u ? (s = 0, l = Math.min(Math.max(-h, -f), h), c = l * (l + 2 * f) + m) : (s = Math.max(0, -(d * h + p)), l = s > 0 ? h : Math.min(Math.max(-h, -f), h), c = -s * s + l * (l + 2 * f) + m);
                        else l = d > 0 ? -h : h,
                            s = Math.max(0, -(d * l + p)), c = -s * s + l * (l + 2 * f) + m;
                        return a && a.copy(this.direction).multiplyScalar(s).add(this.origin), o && o.copy(t).multiplyScalar(l).add(e), c
                    }
                }(),
                intersectSphere: function () {
                    var e = new a;
                    return function (t, n) {
                        e.subVectors(t.center, this.origin);
                        var i = e.dot(this.direction),
                            r = e.dot(e) - i * i,
                            a = t.radius * t.radius;
                        if (r > a) return null;
                        var o = Math.sqrt(a - r),
                            s = i - o,
                            l = i + o;
                        return s < 0 && l < 0 ? null : s < 0 ? this.at(l, n) : this.at(s, n)
                    }
                }(),
                intersectsSphere: function (e) {
                    return this.distanceSqToPoint(e.center) <= e.radius * e.radius
                },
                distanceToPlane: function (e) {
                    var t = e.normal.dot(this.direction);
                    if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                    var n = -(this.origin.dot(e.normal) + e.constant) / t;
                    return n >= 0 ? n : null
                },
                intersectPlane: function (e, t) {
                    var n = this.distanceToPlane(e);
                    return null === n ? null : this.at(n, t)
                },
                intersectsPlane: function (e) {
                    var t = e.distanceToPoint(this.origin);
                    if (0 === t) return !0;
                    var n = e.normal.dot(this.direction);
                    return n * t < 0
                },
                intersectBox: function (e, t) {
                    var n, i, r, a, o, s, l = 1 / this.direction.x,
                        c = 1 / this.direction.y,
                        u = 1 / this.direction.z,
                        h = this.origin;
                    return l >= 0 ? (n = (e.min.x - h.x) * l, i = (e.max.x - h.x) * l) : (n = (e.max.x - h.x) * l, i = (e.min.x - h.x) * l), c >= 0 ? (r = (e.min.y - h.y) * c, a = (e.max.y - h.y) * c) : (r = (e.max.y - h.y) * c, a = (e.min.y - h.y) * c), n > a || r > i ? null : ((r > n || n !== n) && (n = r), (a < i || i !== i) && (i = a), u >= 0 ? (o = (e.min.z - h.z) * u, s = (e.max.z - h.z) * u) : (o = (e.max.z - h.z) * u, s = (e.min.z - h.z) * u), n > s || o > i ? null : ((o > n || n !== n) && (n = o), (s < i || i !== i) && (i = s), i < 0 ? null : this.at(n >= 0 ? n : i, t)))
                },
                intersectsBox: function () {
                    var e = new a;
                    return function (t) {
                        return null !== this.intersectBox(t, e)
                    }
                }(),
                intersectTriangle: function () {
                    var e = new a,
                        t = new a,
                        n = new a,
                        i = new a;
                    return function (r, a, o, s, l) {
                        t.subVectors(a, r), n.subVectors(o, r), i.crossVectors(t, n);
                        var c, u = this.direction.dot(i);
                        if (u > 0) {
                            if (s) return null;
                            c = 1
                        } else {
                            if (!(u < 0)) return null;
                            c = -1, u = -u
                        }
                        e.subVectors(this.origin, r);
                        var h = c * this.direction.dot(n.crossVectors(e, n));
                        if (h < 0) return null;
                        var d = c * this.direction.dot(t.cross(e));
                        if (d < 0) return null;
                        if (h + d > u) return null;
                        var p = -c * e.dot(i);
                        return p < 0 ? null : this.at(p / u, l)
                    }
                }(),
                applyMatrix4: function (e) {
                    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
                },
                equals: function (e) {
                    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                }
            }), Object.assign(V, {
                getNormal: function () {
                    var e = new a;
                    return function (t, n, i, r) {
                        void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), r = new a), r.subVectors(i, n), e.subVectors(t, n), r.cross(e);
                        var o = r.lengthSq();
                        return o > 0 ? r.multiplyScalar(1 / Math.sqrt(o)) : r.set(0, 0, 0)
                    }
                }(),
                getBarycoord: function () {
                    var e = new a,
                        t = new a,
                        n = new a;
                    return function (i, r, o, s, l) {
                        e.subVectors(s, r), t.subVectors(o, r), n.subVectors(i, r);
                        var c = e.dot(e),
                            u = e.dot(t),
                            h = e.dot(n),
                            d = t.dot(t),
                            p = t.dot(n),
                            f = c * d - u * u;
                        if (void 0 === l && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), l = new a), 0 === f) return l.set(-2, -1, -1);
                        var m = 1 / f,
                            v = (d * h - u * p) * m,
                            g = (c * p - u * h) * m;
                        return l.set(1 - v - g, g, v)
                    }
                }(),
                containsPoint: function () {
                    var e = new a;
                    return function (t, n, i, r) {
                        return V.getBarycoord(t, n, i, r, e), e.x >= 0 && e.y >= 0 && e.x + e.y <= 1
                    }
                }(),
                getUV: function () {
                    var e = new a;
                    return function (t, n, i, r, a, o, s, l) {
                        return this.getBarycoord(t, n, i, r, e), l.set(0, 0), l.addScaledVector(a, e.x), l.addScaledVector(o, e.y), l.addScaledVector(s, e.z), l
                    }
                }()
            }), Object.assign(V.prototype, {
                set: function (e, t, n) {
                    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
                },
                setFromPointsAndIndices: function (e, t, n, i) {
                    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
                },
                getArea: function () {
                    var e = new a,
                        t = new a;
                    return function () {
                        return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), .5 * e.cross(t).length()
                    }
                }(),
                getMidpoint: function (e) {
                    return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new a), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                },
                getNormal: function (e) {
                    return V.getNormal(this.a, this.b, this.c, e)
                },
                getPlane: function (e) {
                    return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new a), e.setFromCoplanarPoints(this.a, this.b, this.c)
                },
                getBarycoord: function (e, t) {
                    return V.getBarycoord(e, this.a, this.b, this.c, t)
                },
                containsPoint: function (e) {
                    return V.containsPoint(e, this.a, this.b, this.c)
                },
                getUV: function (e, t, n, i, r) {
                    return V.getUV(e, this.a, this.b, this.c, t, n, i, r)
                },
                intersectsBox: function (e) {
                    return e.intersectsTriangle(this)
                },
                closestPointToPoint: function () {
                    var e = new a,
                        t = new a,
                        n = new a,
                        i = new a,
                        r = new a,
                        o = new a;
                    return function (s, l) {
                        void 0 === l && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), l = new a);
                        var c, u, h = this.a,
                            d = this.b,
                            p = this.c;
                        e.subVectors(d, h), t.subVectors(p, h), i.subVectors(s, h);
                        var f = e.dot(i),
                            m = t.dot(i);
                        if (f <= 0 && m <= 0) return l.copy(h);
                        r.subVectors(s, d);
                        var v = e.dot(r),
                            g = t.dot(r);
                        if (v >= 0 && g <= v) return l.copy(d);
                        var y = f * g - v * m;
                        if (y <= 0 && f >= 0 && v <= 0) return c = f / (f - v), l.copy(h).addScaledVector(e, c);
                        o.subVectors(s, p);
                        var x = e.dot(o),
                            b = t.dot(o);
                        if (b >= 0 && x <= b) return l.copy(p);
                        var _ = x * m - f * b;
                        if (_ <= 0 && m >= 0 && b <= 0) return u = m / (m - b), l.copy(h).addScaledVector(t, u);
                        var w = v * b - x * g;
                        if (w <= 0 && g - v >= 0 && x - b >= 0) return n.subVectors(p, d), u = (g - v) / (g - v + (x - b)), l.copy(d).addScaledVector(n, u);
                        var M = 1 / (w + _ + y);
                        return c = _ * M, u = y * M, l.copy(h).addScaledVector(e, c).addScaledVector(t, u)
                    }
                }(),
                equals: function (e) {
                    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                }
            }), W.prototype = Object.create(F.prototype), W.prototype.constructor = W, W.prototype.isMeshBasicMaterial = !0, W.prototype.copy = function (e) {
                return F.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this
            }, q.prototype = Object.assign(Object.create(w.prototype), {
                constructor: q,
                isMesh: !0,
                setDrawMode: function (e) {
                    this.drawMode = e
                },
                copy: function (e) {
                    return w.prototype.copy.call(this, e), this.drawMode = e.drawMode, void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this
                },
                updateMorphTargets: function () {
                    var e, t, n, i = this.geometry;
                    if (i.isBufferGeometry) {
                        var r = i.morphAttributes,
                            a = Object.keys(r);
                        if (a.length > 0) {
                            var o = r[a[0]];
                            if (void 0 !== o)
                                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = o.length; e < t; e++) n = o[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                        }
                    } else {
                        var s = i.morphTargets;
                        if (void 0 !== s && s.length > 0)
                            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = s.length; e < t; e++) n = s[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                    }
                },
                raycast: function () {
                    function e(e, t, n, i, r, a, o, s) {
                        var l;
                        if (l = t.side === yo ? i.intersectTriangle(o, a, r, !0, s) : i.intersectTriangle(r, a, o, t.side !== xo, s), null === l) return null;
                        b.copy(s), b.applyMatrix4(e.matrixWorld);
                        var c = n.ray.origin.distanceTo(b);
                        return c < n.near || c > n.far ? null : {
                            distance: c,
                            point: b.clone(),
                            object: e
                        }
                    }

                    function t(t, i, r, a, o, s, h, d, p) {
                        l.fromBufferAttribute(o, h), c.fromBufferAttribute(o, d), u.fromBufferAttribute(o, p);
                        var f = e(t, i, r, a, l, c, u, y);
                        if (f) {
                            s && (m.fromBufferAttribute(s, h), v.fromBufferAttribute(s, d), g.fromBufferAttribute(s, p), f.uv = V.getUV(y, l, c, u, m, v, g, new n));
                            var b = new x(h, d, p);
                            V.getNormal(l, c, u, b.normal), f.face = b
                        }
                        return f
                    }
                    var r = new i,
                        o = new H,
                        s = new p,
                        l = new a,
                        c = new a,
                        u = new a,
                        h = new a,
                        d = new a,
                        f = new a,
                        m = new n,
                        v = new n,
                        g = new n,
                        y = new a,
                        b = new a;
                    return function (i, a) {
                        var p = this.geometry,
                            x = this.material,
                            b = this.matrixWorld;
                        if (void 0 !== x && (null === p.boundingSphere && p.computeBoundingSphere(), s.copy(p.boundingSphere), s.applyMatrix4(b), i.ray.intersectsSphere(s) !== !1 && (r.getInverse(b), o.copy(i.ray).applyMatrix4(r), null === p.boundingBox || o.intersectsBox(p.boundingBox) !== !1))) {
                            var _;
                            if (p.isBufferGeometry) {
                                var w, M, T, E, S, P, C, A, L, R, I, O = p.index,
                                    k = p.attributes.position,
                                    D = p.attributes.uv,
                                    z = p.groups,
                                    B = p.drawRange;
                                if (null !== O)
                                    if (Array.isArray(x))
                                        for (E = 0, P = z.length; E < P; E++)
                                            for (A = z[E], L = x[A.materialIndex], R = Math.max(A.start, B.start), I = Math.min(A.start + A.count, B.start + B.count), S = R, C = I; S < C; S += 3) w = O.getX(S), M = O.getX(S + 1), T = O.getX(S + 2), _ = t(this, L, i, o, k, D, w, M, T), _ && (_.faceIndex = Math.floor(S / 3), a.push(_));
                                    else
                                        for (R = Math.max(0, B.start), I = Math.min(O.count, B.start + B.count), E = R, P = I; E < P; E += 3) w = O.getX(E), M = O.getX(E + 1), T = O.getX(E + 2), _ = t(this, x, i, o, k, D, w, M, T), _ && (_.faceIndex = Math.floor(E / 3), a.push(_));
                                else if (void 0 !== k)
                                    if (Array.isArray(x))
                                        for (E = 0, P = z.length; E < P; E++)
                                            for (A = z[E], L = x[A.materialIndex], R = Math.max(A.start, B.start), I = Math.min(A.start + A.count, B.start + B.count), S = R, C = I; S < C; S += 3) w = S, M = S + 1, T = S + 2, _ = t(this, L, i, o, k, D, w, M, T), _ && (_.faceIndex = Math.floor(S / 3), a.push(_));
                                    else
                                        for (R = Math.max(0, B.start), I = Math.min(k.count, B.start + B.count), E = R, P = I; E < P; E += 3) w = E, M = E + 1, T = E + 2, _ = t(this, x, i, o, k, D, w, M, T), _ && (_.faceIndex = Math.floor(E / 3), a.push(_))
                            } else if (p.isGeometry) {
                                var N, U, j, F, G = Array.isArray(x),
                                    H = p.vertices,
                                    W = p.faces,
                                    q = p.faceVertexUvs[0];
                                q.length > 0 && (F = q);
                                for (var X = 0, Y = W.length; X < Y; X++) {
                                    var Z = W[X],
                                        J = G ? x[Z.materialIndex] : x;
                                    if (void 0 !== J) {
                                        if (N = H[Z.a], U = H[Z.b], j = H[Z.c], J.morphTargets === !0) {
                                            var $ = p.morphTargets,
                                                Q = this.morphTargetInfluences;
                                            l.set(0, 0, 0), c.set(0, 0, 0), u.set(0, 0, 0);
                                            for (var K = 0, ee = $.length; K < ee; K++) {
                                                var te = Q[K];
                                                if (0 !== te) {
                                                    var ne = $[K].vertices;
                                                    l.addScaledVector(h.subVectors(ne[Z.a], N), te), c.addScaledVector(d.subVectors(ne[Z.b], U), te), u.addScaledVector(f.subVectors(ne[Z.c], j), te)
                                                }
                                            }
                                            l.add(N), c.add(U), u.add(j), N = l, U = c, j = u
                                        }
                                        if (_ = e(this, J, i, o, N, U, j, y)) {
                                            if (F && F[X]) {
                                                var ie = F[X];
                                                m.copy(ie[0]), v.copy(ie[1]), g.copy(ie[2]), _.uv = V.getUV(y, N, U, j, m, v, g, new n)
                                            }
                                            _.face = Z, _.faceIndex = X, a.push(_)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }(),
                clone: function () {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), re.prototype = Object.create(s.prototype), re.prototype.constructor = re, re.prototype.isCubeTexture = !0, Object.defineProperty(re.prototype, "images", {
                get: function () {
                    return this.image
                },
                set: function (e) {
                    this.image = e
                }
            }), ae.prototype = Object.create(s.prototype), ae.prototype.constructor = ae, ae.prototype.isDataTexture3D = !0;
            var ch = new s,
                uh = new ae,
                hh = new re,
                dh = [],
                ph = [],
                fh = new Float32Array(16),
                mh = new Float32Array(9),
                vh = new Float32Array(4);
            Ne.prototype.updateCache = function (e) {
                var t = this.cache;
                e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), ce(t, e)
            }, Ue.prototype.setValue = function (e, t, n) {
                for (var i = this.seq, r = 0, a = i.length; r !== a; ++r) {
                    var o = i[r];
                    o.setValue(e, t[o.id], n)
                }
            };
            var gh = /([\w\d_]+)(\])?(\[|\.)?/g;
            Ge.prototype.setValue = function (e, t, n) {
                var i = this.map[t];
                void 0 !== i && i.setValue(e, n, this.renderer)
            }, Ge.prototype.setOptional = function (e, t, n) {
                var i = t[n];
                void 0 !== i && this.setValue(e, n, i)
            }, Ge.upload = function (e, t, n, i) {
                for (var r = 0, a = t.length; r !== a; ++r) {
                    var o = t[r],
                        s = n[o.id];
                    s.needsUpdate !== !1 && o.setValue(e, s.value, i)
                }
            }, Ge.seqWithValue = function (e, t) {
                for (var n = [], i = 0, r = e.length; i !== r; ++i) {
                    var a = e[i];
                    a.id in t && n.push(a)
                }
                return n
            };
            var yh = 0,
                xh = 0;
            ft.prototype = Object.create(F.prototype), ft.prototype.constructor = ft, ft.prototype.isMeshDepthMaterial = !0, ft.prototype.copy = function (e) {
                return F.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
            }, mt.prototype = Object.create(F.prototype), mt.prototype.constructor = mt, mt.prototype.isMeshDistanceMaterial = !0, mt.prototype.copy = function (e) {
                return F.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
            }, bt.prototype = Object.assign(Object.create(w.prototype), {
                constructor: bt,
                isGroup: !0
            }), _t.prototype = Object.assign(Object.create(w.prototype), {
                constructor: _t,
                isCamera: !0,
                copy: function (e, t) {
                    return w.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
                },
                getWorldDirection: function (e) {
                    void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e = new a), this.updateMatrixWorld(!0);
                    var t = this.matrixWorld.elements;
                    return e.set(-t[8], -t[9], -t[10]).normalize()
                },
                updateMatrixWorld: function (e) {
                    w.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                }
            }), wt.prototype = Object.assign(Object.create(_t.prototype), {
                constructor: wt,
                isPerspectiveCamera: !0,
                copy: function (e, t) {
                    return _t.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
                },
                setFocalLength: function (e) {
                    var t = .5 * this.getFilmHeight() / e;
                    this.fov = 2 * jl.RAD2DEG * Math.atan(t), this.updateProjectionMatrix()
                },
                getFocalLength: function () {
                    var e = Math.tan(.5 * jl.DEG2RAD * this.fov);
                    return .5 * this.getFilmHeight() / e
                },
                getEffectiveFOV: function () {
                    return 2 * jl.RAD2DEG * Math.atan(Math.tan(.5 * jl.DEG2RAD * this.fov) / this.zoom)
                },
                getFilmWidth: function () {
                    return this.filmGauge * Math.min(this.aspect, 1)
                },
                getFilmHeight: function () {
                    return this.filmGauge / Math.max(this.aspect, 1)
                },
                setViewOffset: function (e, t, n, i, r, a) {
                    this.aspect = e / t, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
                },
                clearViewOffset: function () {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function () {
                    var e = this.near,
                        t = e * Math.tan(.5 * jl.DEG2RAD * this.fov) / this.zoom,
                        n = 2 * t,
                        i = this.aspect * n,
                        r = -.5 * i,
                        a = this.view;
                    if (null !== this.view && this.view.enabled) {
                        var o = a.fullWidth,
                            s = a.fullHeight;
                        r += a.offsetX * i / o, t -= a.offsetY * n / s, i *= a.width / o, n *= a.height / s
                    }
                    var l = this.filmOffset;
                    0 !== l && (r += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function (e) {
                    var t = w.prototype.toJSON.call(this, e);
                    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
                }
            }), Mt.prototype = Object.assign(Object.create(wt.prototype), {
                constructor: Mt,
                isArrayCamera: !0
            });
            var bh = new a,
                _h = new a;
            Ct.prototype.isFogExp2 = !0, Ct.prototype.clone = function () {
                return new Ct(this.color, this.density)
            }, Ct.prototype.toJSON = function () {
                return {
                    type: "FogExp2",
                    color: this.color.getHex(),
                    density: this.density
                }
            }, At.prototype.isFog = !0, At.prototype.clone = function () {
                return new At(this.color, this.near, this.far)
            }, At.prototype.toJSON = function () {
                return {
                    type: "Fog",
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }, Lt.prototype = Object.assign(Object.create(w.prototype), {
                constructor: Lt,
                copy: function (e, t) {
                    return w.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
                },
                toJSON: function (e) {
                    var t = w.prototype.toJSON.call(this, e);
                    return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t
                }
            }), Object.defineProperty(Rt.prototype, "needsUpdate", {
                set: function (e) {
                    e === !0 && this.version++
                }
            }), Object.assign(Rt.prototype, {
                isInterleavedBuffer: !0,
                onUploadCallback: function () {},
                setArray: function (e) {
                    if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    return this.count = void 0 !== e ? e.length / this.stride : 0, this.array = e, this
                },
                setDynamic: function (e) {
                    return this.dynamic = e, this
                },
                copy: function (e) {
                    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.dynamic = e.dynamic, this
                },
                copyAt: function (e, t, n) {
                    e *= this.stride, n *= t.stride;
                    for (var i = 0, r = this.stride; i < r; i++) this.array[e + i] = t.array[n + i];
                    return this
                },
                set: function (e, t) {
                    return void 0 === t && (t = 0), this.array.set(e, t), this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                onUpload: function (e) {
                    return this.onUploadCallback = e, this
                }
            }), Object.defineProperties(It.prototype, {
                count: {
                    get: function () {
                        return this.data.count
                    }
                },
                array: {
                    get: function () {
                        return this.data.array
                    }
                }
            }), Object.assign(It.prototype, {
                isInterleavedBufferAttribute: !0,
                setX: function (e, t) {
                    return this.data.array[e * this.data.stride + this.offset] = t, this
                },
                setY: function (e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 1] = t, this
                },
                setZ: function (e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 2] = t, this
                },
                setW: function (e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 3] = t, this
                },
                getX: function (e) {
                    return this.data.array[e * this.data.stride + this.offset]
                },
                getY: function (e) {
                    return this.data.array[e * this.data.stride + this.offset + 1]
                },
                getZ: function (e) {
                    return this.data.array[e * this.data.stride + this.offset + 2]
                },
                getW: function (e) {
                    return this.data.array[e * this.data.stride + this.offset + 3]
                },
                setXY: function (e, t, n) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
                },
                setXYZ: function (e, t, n, i) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this
                },
                setXYZW: function (e, t, n, i, r) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this
                }
            }), Ot.prototype = Object.create(F.prototype), Ot.prototype.constructor = Ot, Ot.prototype.isSpriteMaterial = !0, Ot.prototype.copy = function (e) {
                return F.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
            };
            var wh;
            kt.prototype = Object.assign(Object.create(w.prototype), {
                constructor: kt,
                isSprite: !0,
                raycast: function () {
                    function e(e, t, n, i, r, a) {
                        s.subVectors(e, n).addScalar(.5).multiply(i), void 0 !== r ? (l.x = a * s.x - r * s.y, l.y = r * s.x + a * s.y) : l.copy(s), e.copy(t), e.x += l.x, e.y += l.y, e.applyMatrix4(c)
                    }
                    var t = new a,
                        r = new a,
                        o = new a,
                        s = new n,
                        l = new n,
                        c = new i,
                        u = new a,
                        h = new a,
                        d = new a,
                        p = new n,
                        f = new n,
                        m = new n;
                    return function (i, a) {
                        r.setFromMatrixScale(this.matrixWorld), c.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), o.setFromMatrixPosition(this.modelViewMatrix);
                        var s, l, v = this.material.rotation;
                        0 !== v && (l = Math.cos(v), s = Math.sin(v));
                        var g = this.center;
                        e(u.set(-.5, -.5, 0), o, g, r, s, l), e(h.set(.5, -.5, 0), o, g, r, s, l), e(d.set(.5, .5, 0), o, g, r, s, l), p.set(0, 0), f.set(1, 0), m.set(1, 1);
                        var y = i.ray.intersectTriangle(u, h, d, !1, t);
                        if (null !== y || (e(h.set(-.5, .5, 0), o, g, r, s, l), f.set(0, 1), y = i.ray.intersectTriangle(u, d, h, !1, t), null !== y)) {
                            var x = i.ray.origin.distanceTo(t);
                            x < i.near || x > i.far || a.push({
                                distance: x,
                                point: t.clone(),
                                uv: V.getUV(t, u, h, d, p, f, m, new n),
                                face: null,
                                object: this
                            })
                        }
                    }
                }(),
                clone: function () {
                    return new this.constructor(this.material).copy(this)
                },
                copy: function (e) {
                    return w.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this
                }
            }), Dt.prototype = Object.assign(Object.create(w.prototype), {
                constructor: Dt,
                copy: function (e) {
                    w.prototype.copy.call(this, e, !1);
                    for (var t = e.levels, n = 0, i = t.length; n < i; n++) {
                        var r = t[n];
                        this.addLevel(r.object.clone(), r.distance)
                    }
                    return this
                },
                addLevel: function (e, t) {
                    void 0 === t && (t = 0), t = Math.abs(t);
                    for (var n = this.levels, i = 0; i < n.length && !(t < n[i].distance); i++);
                    n.splice(i, 0, {
                        distance: t,
                        object: e
                    }), this.add(e)
                },
                getObjectForDistance: function (e) {
                    for (var t = this.levels, n = 1, i = t.length; n < i && !(e < t[n].distance); n++);
                    return t[n - 1].object
                },
                raycast: function () {
                    var e = new a;
                    return function (t, n) {
                        e.setFromMatrixPosition(this.matrixWorld);
                        var i = t.ray.origin.distanceTo(e);
                        this.getObjectForDistance(i).raycast(t, n)
                    }
                }(),
                update: function () {
                    var e = new a,
                        t = new a;
                    return function (n) {
                        var i = this.levels;
                        if (i.length > 1) {
                            e.setFromMatrixPosition(n.matrixWorld), t.setFromMatrixPosition(this.matrixWorld);
                            var r = e.distanceTo(t);
                            i[0].object.visible = !0;
                            for (var a = 1, o = i.length; a < o && r >= i[a].distance; a++) i[a - 1].object.visible = !1, i[a].object.visible = !0;
                            for (; a < o; a++) i[a].object.visible = !1
                        }
                    }
                }(),
                toJSON: function (e) {
                    var t = w.prototype.toJSON.call(this, e);
                    t.object.levels = [];
                    for (var n = this.levels, i = 0, r = n.length; i < r; i++) {
                        var a = n[i];
                        t.object.levels.push({
                            object: a.object.uuid,
                            distance: a.distance
                        })
                    }
                    return t
                }
            }), Object.assign(zt.prototype, {
                calculateInverses: function () {
                    this.boneInverses = [];
                    for (var e = 0, t = this.bones.length; e < t; e++) {
                        var n = new i;
                        this.bones[e] && n.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(n)
                    }
                },
                pose: function () {
                    var e, t, n;
                    for (t = 0, n = this.bones.length; t < n; t++) e = this.bones[t], e && e.matrixWorld.getInverse(this.boneInverses[t]);
                    for (t = 0, n = this.bones.length; t < n; t++) e = this.bones[t], e && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
                },
                update: function () {
                    var e = new i,
                        t = new i;
                    return function () {
                        for (var n = this.bones, i = this.boneInverses, r = this.boneMatrices, a = this.boneTexture, o = 0, s = n.length; o < s; o++) {
                            var l = n[o] ? n[o].matrixWorld : t;
                            e.multiplyMatrices(l, i[o]), e.toArray(r, 16 * o)
                        }
                        void 0 !== a && (a.needsUpdate = !0)
                    }
                }(),
                clone: function () {
                    return new zt(this.bones, this.boneInverses)
                },
                getBoneByName: function (e) {
                    for (var t = 0, n = this.bones.length; t < n; t++) {
                        var i = this.bones[t];
                        if (i.name === e) return i
                    }
                }
            }), Bt.prototype = Object.assign(Object.create(w.prototype), {
                constructor: Bt,
                isBone: !0
            }), Nt.prototype = Object.assign(Object.create(q.prototype), {
                constructor: Nt,
                isSkinnedMesh: !0,
                initBones: function () {
                    var e, t, n, i, r = [];
                    if (this.geometry && void 0 !== this.geometry.bones) {
                        for (n = 0, i = this.geometry.bones.length; n < i; n++) t = this.geometry.bones[n], e = new Bt, r.push(e), e.name = t.name, e.position.fromArray(t.pos), e.quaternion.fromArray(t.rotq), void 0 !== t.scl && e.scale.fromArray(t.scl);
                        for (n = 0, i = this.geometry.bones.length; n < i; n++) t = this.geometry.bones[n], t.parent !== -1 && null !== t.parent && void 0 !== r[t.parent] ? r[t.parent].add(r[n]) : this.add(r[n])
                    }
                    return this.updateMatrixWorld(!0), r
                },
                bind: function (e, t) {
                    this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
                },
                pose: function () {
                    this.skeleton.pose()
                },
                normalizeSkinWeights: function () {
                    var e, t;
                    if (this.geometry && this.geometry.isGeometry)
                        for (t = 0; t < this.geometry.skinWeights.length; t++) {
                            var n = this.geometry.skinWeights[t];
                            e = 1 / n.manhattanLength(), e !== 1 / 0 ? n.multiplyScalar(e) : n.set(1, 0, 0, 0)
                        } else if (this.geometry && this.geometry.isBufferGeometry) {
                            var i = new l,
                                r = this.geometry.attributes.skinWeight;
                            for (t = 0; t < r.count; t++) i.x = r.getX(t), i.y = r.getY(t), i.z = r.getZ(t), i.w = r.getW(t), e = 1 / i.manhattanLength(), e !== 1 / 0 ? i.multiplyScalar(e) : i.set(1, 0, 0, 0), r.setXYZW(t, i.x, i.y, i.z, i.w)
                        }
                },
                updateMatrixWorld: function (e) {
                    q.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                },
                clone: function () {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), Ut.prototype = Object.create(F.prototype), Ut.prototype.constructor = Ut, Ut.prototype.isLineBasicMaterial = !0, Ut.prototype.copy = function (e) {
                return F.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
            }, jt.prototype = Object.assign(Object.create(w.prototype), {
                constructor: jt,
                isLine: !0,
                computeLineDistances: function () {
                    var e = new a,
                        t = new a;
                    return function () {
                        var n = this.geometry;
                        if (n.isBufferGeometry)
                            if (null === n.index) {
                                for (var i = n.attributes.position, r = [0], a = 1, o = i.count; a < o; a++) e.fromBufferAttribute(i, a - 1), t.fromBufferAttribute(i, a), r[a] = r[a - 1], r[a] += e.distanceTo(t);
                                n.addAttribute("lineDistance", new I(r, 1))
                            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else if (n.isGeometry) {
                            var s = n.vertices,
                                r = n.lineDistances;
                            r[0] = 0;
                            for (var a = 1, o = s.length; a < o; a++) r[a] = r[a - 1], r[a] += s[a - 1].distanceTo(s[a])
                        }
                        return this
                    }
                }(),
                raycast: function () {
                    var e = new i,
                        t = new H,
                        n = new p;
                    return function (i, r) {
                        var o = i.linePrecision,
                            s = this.geometry,
                            l = this.matrixWorld;
                        if (null === s.boundingSphere && s.computeBoundingSphere(), n.copy(s.boundingSphere), n.applyMatrix4(l), n.radius += o, i.ray.intersectsSphere(n) !== !1) {
                            e.getInverse(l), t.copy(i.ray).applyMatrix4(e);
                            var c = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                u = c * c,
                                h = new a,
                                d = new a,
                                p = new a,
                                f = new a,
                                m = this && this.isLineSegments ? 2 : 1;
                            if (s.isBufferGeometry) {
                                var v = s.index,
                                    g = s.attributes,
                                    y = g.position.array;
                                if (null !== v)
                                    for (var x = v.array, b = 0, _ = x.length - 1; b < _; b += m) {
                                        var w = x[b],
                                            M = x[b + 1];
                                        h.fromArray(y, 3 * w), d.fromArray(y, 3 * M);
                                        var T = t.distanceSqToSegment(h, d, f, p);
                                        if (!(T > u)) {
                                            f.applyMatrix4(this.matrixWorld);
                                            var E = i.ray.origin.distanceTo(f);
                                            E < i.near || E > i.far || r.push({
                                                distance: E,
                                                point: p.clone().applyMatrix4(this.matrixWorld),
                                                index: b,
                                                face: null,
                                                faceIndex: null,
                                                object: this
                                            })
                                        }
                                    } else
                                        for (var b = 0, _ = y.length / 3 - 1; b < _; b += m) {
                                            h.fromArray(y, 3 * b), d.fromArray(y, 3 * b + 3);
                                            var T = t.distanceSqToSegment(h, d, f, p);
                                            if (!(T > u)) {
                                                f.applyMatrix4(this.matrixWorld);
                                                var E = i.ray.origin.distanceTo(f);
                                                E < i.near || E > i.far || r.push({
                                                    distance: E,
                                                    point: p.clone().applyMatrix4(this.matrixWorld),
                                                    index: b,
                                                    face: null,
                                                    faceIndex: null,
                                                    object: this
                                                })
                                            }
                                        }
                            } else if (s.isGeometry)
                                for (var S = s.vertices, P = S.length, b = 0; b < P - 1; b += m) {
                                    var T = t.distanceSqToSegment(S[b], S[b + 1], f, p);
                                    if (!(T > u)) {
                                        f.applyMatrix4(this.matrixWorld);
                                        var E = i.ray.origin.distanceTo(f);
                                        E < i.near || E > i.far || r.push({
                                            distance: E,
                                            point: p.clone().applyMatrix4(this.matrixWorld),
                                            index: b,
                                            face: null,
                                            faceIndex: null,
                                            object: this
                                        })
                                    }
                                }
                        }
                    }
                }(),
                copy: function (e) {
                    return w.prototype.copy.call(this, e), this.geometry.copy(e.geometry), this.material.copy(e.material), this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                }
            }), Ft.prototype = Object.assign(Object.create(jt.prototype), {
                constructor: Ft,
                isLineSegments: !0,
                computeLineDistances: function () {
                    var e = new a,
                        t = new a;
                    return function () {
                        var n = this.geometry;
                        if (n.isBufferGeometry)
                            if (null === n.index) {
                                for (var i = n.attributes.position, r = [], a = 0, o = i.count; a < o; a += 2) e.fromBufferAttribute(i, a), t.fromBufferAttribute(i, a + 1), r[a] = 0 === a ? 0 : r[a - 1], r[a + 1] = r[a] + e.distanceTo(t);
                                n.addAttribute("lineDistance", new I(r, 1))
                            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else if (n.isGeometry)
                            for (var s = n.vertices, r = n.lineDistances, a = 0, o = s.length; a < o; a += 2) e.copy(s[a]), t.copy(s[a + 1]), r[a] = 0 === a ? 0 : r[a - 1], r[a + 1] = r[a] + e.distanceTo(t);
                        return this
                    }
                }()
            }), Gt.prototype = Object.assign(Object.create(jt.prototype), {
                constructor: Gt,
                isLineLoop: !0
            }), Ht.prototype = Object.create(F.prototype), Ht.prototype.constructor = Ht, Ht.prototype.isPointsMaterial = !0, Ht.prototype.copy = function (e) {
                return F.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this
            }, Vt.prototype = Object.assign(Object.create(w.prototype), {
                constructor: Vt,
                isPoints: !0,
                raycast: function () {
                    var e = new i,
                        t = new H,
                        n = new p;
                    return function (i, r) {
                        function o(e, n) {
                            var a = t.distanceSqToPoint(e);
                            if (a < d) {
                                t.closestPointToPoint(e, f), f.applyMatrix4(c);
                                var o = i.ray.origin.distanceTo(f);
                                if (o < i.near || o > i.far) return;
                                r.push({
                                    distance: o,
                                    distanceToRay: Math.sqrt(a),
                                    point: f.clone(),
                                    index: n,
                                    face: null,
                                    object: s
                                })
                            }
                        }
                        var s = this,
                            l = this.geometry,
                            c = this.matrixWorld,
                            u = i.params.Points.threshold;
                        if (null === l.boundingSphere && l.computeBoundingSphere(), n.copy(l.boundingSphere), n.applyMatrix4(c), n.radius += u, i.ray.intersectsSphere(n) !== !1) {
                            e.getInverse(c), t.copy(i.ray).applyMatrix4(e);
                            var h = u / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                d = h * h,
                                p = new a,
                                f = new a;
                            if (l.isBufferGeometry) {
                                var m = l.index,
                                    v = l.attributes,
                                    g = v.position.array;
                                if (null !== m)
                                    for (var y = m.array, x = 0, b = y.length; x < b; x++) {
                                        var _ = y[x];
                                        p.fromArray(g, 3 * _), o(p, _)
                                    } else
                                        for (var x = 0, w = g.length / 3; x < w; x++) p.fromArray(g, 3 * x), o(p, x)
                            } else
                                for (var M = l.vertices, x = 0, w = M.length; x < w; x++) o(M[x], x)
                        }
                    }
                }(),
                clone: function () {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), Wt.prototype = Object.assign(Object.create(s.prototype), {
                constructor: Wt,
                isVideoTexture: !0,
                update: function () {
                    var e = this.image;
                    e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }), qt.prototype = Object.create(s.prototype), qt.prototype.constructor = qt, qt.prototype.isCompressedTexture = !0, Xt.prototype = Object.create(s.prototype), Xt.prototype.constructor = Xt, Xt.prototype.isCanvasTexture = !0, Yt.prototype = Object.create(s.prototype), Yt.prototype.constructor = Yt, Yt.prototype.isDepthTexture = !0, Zt.prototype = Object.create(z.prototype), Zt.prototype.constructor = Zt, Jt.prototype = Object.create(M.prototype), Jt.prototype.constructor = Jt, $t.prototype = Object.create(z.prototype), $t.prototype.constructor = $t, Qt.prototype = Object.create(M.prototype), Qt.prototype.constructor = Qt, Kt.prototype = Object.create(z.prototype), Kt.prototype.constructor = Kt, en.prototype = Object.create(M.prototype), en.prototype.constructor = en, tn.prototype = Object.create(Kt.prototype), tn.prototype.constructor = tn, nn.prototype = Object.create(M.prototype), nn.prototype.constructor = nn, rn.prototype = Object.create(Kt.prototype), rn.prototype.constructor = rn, an.prototype = Object.create(M.prototype), an.prototype.constructor = an, on.prototype = Object.create(Kt.prototype), on.prototype.constructor = on, sn.prototype = Object.create(M.prototype), sn.prototype.constructor = sn, ln.prototype = Object.create(Kt.prototype), ln.prototype.constructor = ln, cn.prototype = Object.create(M.prototype), cn.prototype.constructor = cn, un.prototype = Object.create(z.prototype), un.prototype.constructor = un, hn.prototype = Object.create(M.prototype), hn.prototype.constructor = hn, dn.prototype = Object.create(z.prototype), dn.prototype.constructor = dn, pn.prototype = Object.create(M.prototype), pn.prototype.constructor = pn, fn.prototype = Object.create(z.prototype), fn.prototype.constructor = fn;
            var Mh = {
                    triangulate: function (e, t, n) {
                        n = n || 2;
                        var i = t && t.length,
                            r = i ? t[0] * n : e.length,
                            a = mn(e, 0, r, n, !0),
                            o = [];
                        if (!a) return o;
                        var s, l, c, u, h, d, p;
                        if (i && (a = wn(e, t, a, n)), e.length > 80 * n) {
                            s = c = e[0], l = u = e[1];
                            for (var f = n; f < r; f += n) h = e[f], d = e[f + 1], h < s && (s = h), d < l && (l = d), h > c && (c = h), d > u && (u = d);
                            p = Math.max(c - s, u - l), p = 0 !== p ? 1 / p : 0
                        }
                        return gn(a, o, n, s, l, p), o
                    }
                },
                Th = {
                    area: function (e) {
                        for (var t = e.length, n = 0, i = t - 1, r = 0; r < t; i = r++) n += e[i].x * e[r].y - e[r].x * e[i].y;
                        return .5 * n
                    },
                    isClockWise: function (e) {
                        return Th.area(e) < 0
                    },
                    triangulateShape: function (e, t) {
                        var n = [],
                            i = [],
                            r = [];
                        Hn(e), Vn(n, e);
                        var a = e.length;
                        t.forEach(Hn);
                        for (var o = 0; o < t.length; o++) i.push(a), a += t[o].length, Vn(n, t[o]);
                        for (var s = Mh.triangulate(n, i), o = 0; o < s.length; o += 3) r.push(s.slice(o, o + 3));
                        return r
                    }
                };
            Wn.prototype = Object.create(M.prototype), Wn.prototype.constructor = Wn, Wn.prototype.toJSON = function () {
                var e = M.prototype.toJSON.call(this),
                    t = this.parameters.shapes,
                    n = this.parameters.options;
                return Xn(t, n, e)
            }, qn.prototype = Object.create(z.prototype), qn.prototype.constructor = qn, qn.prototype.toJSON = function () {
                var e = z.prototype.toJSON.call(this),
                    t = this.parameters.shapes,
                    n = this.parameters.options;
                return Xn(t, n, e)
            };
            var Eh = {
                generateTopUV: function (e, t, i, r, a) {
                    var o = t[3 * i],
                        s = t[3 * i + 1],
                        l = t[3 * r],
                        c = t[3 * r + 1],
                        u = t[3 * a],
                        h = t[3 * a + 1];
                    return [new n(o, s), new n(l, c), new n(u, h)]
                },
                generateSideWallUV: function (e, t, i, r, a, o) {
                    var s = t[3 * i],
                        l = t[3 * i + 1],
                        c = t[3 * i + 2],
                        u = t[3 * r],
                        h = t[3 * r + 1],
                        d = t[3 * r + 2],
                        p = t[3 * a],
                        f = t[3 * a + 1],
                        m = t[3 * a + 2],
                        v = t[3 * o],
                        g = t[3 * o + 1],
                        y = t[3 * o + 2];
                    return Math.abs(l - h) < .01 ? [new n(s, 1 - c), new n(u, 1 - d), new n(p, 1 - m), new n(v, 1 - y)] : [new n(l, 1 - c), new n(h, 1 - d), new n(f, 1 - m), new n(g, 1 - y)]
                }
            };
            Yn.prototype = Object.create(M.prototype), Yn.prototype.constructor = Yn, Zn.prototype = Object.create(qn.prototype), Zn.prototype.constructor = Zn, Jn.prototype = Object.create(M.prototype), Jn.prototype.constructor = Jn, $n.prototype = Object.create(z.prototype), $n.prototype.constructor = $n, Qn.prototype = Object.create(M.prototype), Qn.prototype.constructor = Qn, Kn.prototype = Object.create(z.prototype), Kn.prototype.constructor = Kn, ei.prototype = Object.create(M.prototype), ei.prototype.constructor = ei, ti.prototype = Object.create(z.prototype), ti.prototype.constructor = ti, ni.prototype = Object.create(M.prototype), ni.prototype.constructor = ni, ni.prototype.toJSON = function () {
                var e = M.prototype.toJSON.call(this),
                    t = this.parameters.shapes;
                return ri(t, e)
            }, ii.prototype = Object.create(z.prototype), ii.prototype.constructor = ii, ii.prototype.toJSON = function () {
                var e = z.prototype.toJSON.call(this),
                    t = this.parameters.shapes;
                return ri(t, e)
            }, ai.prototype = Object.create(z.prototype), ai.prototype.constructor = ai, oi.prototype = Object.create(M.prototype), oi.prototype.constructor = oi, si.prototype = Object.create(z.prototype), si.prototype.constructor = si, li.prototype = Object.create(oi.prototype), li.prototype.constructor = li, ci.prototype = Object.create(si.prototype), ci.prototype.constructor = ci, ui.prototype = Object.create(M.prototype), ui.prototype.constructor = ui, hi.prototype = Object.create(z.prototype), hi.prototype.constructor = hi;
            var Sh = Object.freeze({
                WireframeGeometry: Zt,
                ParametricGeometry: Jt,
                ParametricBufferGeometry: $t,
                TetrahedronGeometry: en,
                TetrahedronBufferGeometry: tn,
                OctahedronGeometry: nn,
                OctahedronBufferGeometry: rn,
                IcosahedronGeometry: an,
                IcosahedronBufferGeometry: on,
                DodecahedronGeometry: sn,
                DodecahedronBufferGeometry: ln,
                PolyhedronGeometry: Qt,
                PolyhedronBufferGeometry: Kt,
                TubeGeometry: cn,
                TubeBufferGeometry: un,
                TorusKnotGeometry: hn,
                TorusKnotBufferGeometry: dn,
                TorusGeometry: pn,
                TorusBufferGeometry: fn,
                TextGeometry: Yn,
                TextBufferGeometry: Zn,
                SphereGeometry: Jn,
                SphereBufferGeometry: $n,
                RingGeometry: Qn,
                RingBufferGeometry: Kn,
                PlaneGeometry: U,
                PlaneBufferGeometry: j,
                LatheGeometry: ei,
                LatheBufferGeometry: ti,
                ShapeGeometry: ni,
                ShapeBufferGeometry: ii,
                ExtrudeGeometry: Wn,
                ExtrudeBufferGeometry: qn,
                EdgesGeometry: ai,
                ConeGeometry: li,
                ConeBufferGeometry: ci,
                CylinderGeometry: oi,
                CylinderBufferGeometry: si,
                CircleGeometry: ui,
                CircleBufferGeometry: hi,
                BoxGeometry: B,
                BoxBufferGeometry: N
            });
            di.prototype = Object.create(F.prototype), di.prototype.constructor = di, di.prototype.isShadowMaterial = !0, di.prototype.copy = function (e) {
                return F.prototype.copy.call(this, e), this.color.copy(e.color), this
            }, pi.prototype = Object.create(G.prototype), pi.prototype.constructor = pi, pi.prototype.isRawShaderMaterial = !0, fi.prototype = Object.create(F.prototype), fi.prototype.constructor = fi, fi.prototype.isMeshStandardMaterial = !0, fi.prototype.copy = function (e) {
                return F.prototype.copy.call(this, e), this.defines = {
                    STANDARD: ""
                }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, mi.prototype = Object.create(fi.prototype), mi.prototype.constructor = mi, mi.prototype.isMeshPhysicalMaterial = !0, mi.prototype.copy = function (e) {
                return fi.prototype.copy.call(this, e), this.defines = {
                    PHYSICAL: ""
                }, this.reflectivity = e.reflectivity, this.clearCoat = e.clearCoat, this.clearCoatRoughness = e.clearCoatRoughness, this
            }, vi.prototype = Object.create(F.prototype), vi.prototype.constructor = vi, vi.prototype.isMeshPhongMaterial = !0, vi.prototype.copy = function (e) {
                return F.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, gi.prototype = Object.create(vi.prototype), gi.prototype.constructor = gi, gi.prototype.isMeshToonMaterial = !0, gi.prototype.copy = function (e) {
                return vi.prototype.copy.call(this, e), this.gradientMap = e.gradientMap, this
            }, yi.prototype = Object.create(F.prototype), yi.prototype.constructor = yi, yi.prototype.isMeshNormalMaterial = !0, yi.prototype.copy = function (e) {
                return F.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, xi.prototype = Object.create(F.prototype), xi.prototype.constructor = xi, xi.prototype.isMeshLambertMaterial = !0, xi.prototype.copy = function (e) {
                return F.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, bi.prototype = Object.create(F.prototype), bi.prototype.constructor = bi, bi.prototype.isMeshMatcapMaterial = !0, bi.prototype.copy = function (e) {
                return F.prototype.copy.call(this, e), this.defines = {
                    MATCAP: ""
                }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, _i.prototype = Object.create(Ut.prototype), _i.prototype.constructor = _i, _i.prototype.isLineDashedMaterial = !0, _i.prototype.copy = function (e) {
                return Ut.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
            };
            var Ph = Object.freeze({
                    ShadowMaterial: di,
                    SpriteMaterial: Ot,
                    RawShaderMaterial: pi,
                    ShaderMaterial: G,
                    PointsMaterial: Ht,
                    MeshPhysicalMaterial: mi,
                    MeshStandardMaterial: fi,
                    MeshPhongMaterial: vi,
                    MeshToonMaterial: gi,
                    MeshNormalMaterial: yi,
                    MeshLambertMaterial: xi,
                    MeshDepthMaterial: ft,
                    MeshDistanceMaterial: mt,
                    MeshBasicMaterial: W,
                    MeshMatcapMaterial: bi,
                    LineDashedMaterial: _i,
                    LineBasicMaterial: Ut,
                    Material: F
                }),
                Ch = {
                    arraySlice: function (e, t, n) {
                        return Ch.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
                    },
                    convertArray: function (e, t, n) {
                        return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
                    },
                    isTypedArray: function (e) {
                        return ArrayBuffer.isView(e) && !(e instanceof DataView)
                    },
                    getKeyframeOrder: function (e) {
                        function t(t, n) {
                            return e[t] - e[n]
                        }
                        for (var n = e.length, i = new Array(n), r = 0; r !== n; ++r) i[r] = r;
                        return i.sort(t), i
                    },
                    sortedArray: function (e, t, n) {
                        for (var i = e.length, r = new e.constructor(i), a = 0, o = 0; o !== i; ++a)
                            for (var s = n[a] * t, l = 0; l !== t; ++l) r[o++] = e[s + l];
                        return r
                    },
                    flattenJSON: function (e, t, n, i) {
                        for (var r = 1, a = e[0]; void 0 !== a && void 0 === a[i];) a = e[r++];
                        if (void 0 !== a) {
                            var o = a[i];
                            if (void 0 !== o)
                                if (Array.isArray(o)) {
                                    do o = a[i], void 0 !== o && (t.push(a.time), n.push.apply(n, o)), a = e[r++]; while (void 0 !== a)
                                } else if (void 0 !== o.toArray) {
                                do o = a[i], void 0 !== o && (t.push(a.time), o.toArray(n, n.length)), a = e[r++]; while (void 0 !== a)
                            } else
                                do o = a[i], void 0 !== o && (t.push(a.time), n.push(o)), a = e[r++]; while (void 0 !== a)
                        }
                    }
                };
            Object.assign(wi.prototype, {
                evaluate: function (e) {
                    var t = this.parameterPositions,
                        n = this._cachedIndex,
                        i = t[n],
                        r = t[n - 1];
                    e: {
                        t: {
                            var a;n: {
                                i: if (!(e < i)) {
                                    for (var o = n + 2;;) {
                                        if (void 0 === i) {
                                            if (e < r) break i;
                                            return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, r)
                                        }
                                        if (n === o) break;
                                        if (r = i, i = t[++n], e < i) break t
                                    }
                                    a = t.length;
                                    break n
                                } {
                                    if (e >= r) break e;
                                    var s = t[1];
                                    e < s && (n = 2, r = s);
                                    for (var o = n - 2;;) {
                                        if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, i);
                                        if (n === o) break;
                                        if (i = r, r = t[--n - 1], e >= r) break t
                                    }
                                    a = n, n = 0
                                }
                            }
                            for (; n < a;) {
                                var l = n + a >>> 1;
                                e < t[l] ? a = l : n = l + 1
                            }
                            if (i = t[n], r = t[n - 1], void 0 === r) return this._cachedIndex = 0,
                            this.beforeStart_(0, e, i);
                            if (void 0 === i) return n = t.length,
                            this._cachedIndex = n,
                            this.afterEnd_(n - 1, r, e)
                        }
                        this._cachedIndex = n,
                        this.intervalChanged_(n, r, i)
                    }
                    return this.interpolate_(n, r, e, i)
                },
                settings: null,
                DefaultSettings_: {},
                getSettings_: function () {
                    return this.settings || this.DefaultSettings_
                },
                copySampleValue_: function (e) {
                    for (var t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i, a = 0; a !== i; ++a) t[a] = n[r + a];
                    return t
                },
                interpolate_: function () {
                    throw new Error("call to abstract method")
                },
                intervalChanged_: function () {}
            }), Object.assign(wi.prototype, {
                beforeStart_: wi.prototype.copySampleValue_,
                afterEnd_: wi.prototype.copySampleValue_
            }), Mi.prototype = Object.assign(Object.create(wi.prototype), {
                constructor: Mi,
                DefaultSettings_: {
                    endingStart: wl,
                    endingEnd: wl
                },
                intervalChanged_: function (e, t, n) {
                    var i = this.parameterPositions,
                        r = e - 2,
                        a = e + 1,
                        o = i[r],
                        s = i[a];
                    if (void 0 === o) switch (this.getSettings_().endingStart) {
                        case Ml:
                            r = e, o = 2 * t - n;
                            break;
                        case Tl:
                            r = i.length - 2, o = t + i[r] - i[r + 1];
                            break;
                        default:
                            r = e, o = n
                    }
                    if (void 0 === s) switch (this.getSettings_().endingEnd) {
                        case Ml:
                            a = e, s = 2 * n - t;
                            break;
                        case Tl:
                            a = 1, s = n + i[1] - i[0];
                            break;
                        default:
                            a = e - 1, s = t
                    }
                    var l = .5 * (n - t),
                        c = this.valueSize;
                    this._weightPrev = l / (t - o), this._weightNext = l / (s - n), this._offsetPrev = r * c, this._offsetNext = a * c
                },
                interpolate_: function (e, t, n, i) {
                    for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, c = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, d = this._weightNext, p = (n - t) / (i - t), f = p * p, m = f * p, v = -h * m + 2 * h * f - h * p, g = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p, x = d * m - d * f, b = 0; b !== o; ++b) r[b] = v * a[c + b] + g * a[l + b] + y * a[s + b] + x * a[u + b];
                    return r
                }
            }), Ti.prototype = Object.assign(Object.create(wi.prototype), {
                constructor: Ti,
                interpolate_: function (e, t, n, i) {
                    for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, c = (n - t) / (i - t), u = 1 - c, h = 0; h !== o; ++h) r[h] = a[l + h] * u + a[s + h] * c;
                    return r
                }
            }), Ei.prototype = Object.assign(Object.create(wi.prototype), {
                constructor: Ei,
                interpolate_: function (e) {
                    return this.copySampleValue_(e - 1)
                }
            }), Object.assign(Si, {
                toJSON: function (e) {
                    var t, n = e.constructor;
                    if (void 0 !== n.toJSON) t = n.toJSON(e);
                    else {
                        t = {
                            name: e.name,
                            times: Ch.convertArray(e.times, Array),
                            values: Ch.convertArray(e.values, Array)
                        };
                        var i = e.getInterpolation();
                        i !== e.DefaultInterpolation && (t.interpolation = i)
                    }
                    return t.type = e.ValueTypeName, t
                }
            }), Object.assign(Si.prototype, {
                constructor: Si,
                TimeBufferType: Float32Array,
                ValueBufferType: Float32Array,
                DefaultInterpolation: bl,
                InterpolantFactoryMethodDiscrete: function (e) {
                    return new Ei(this.times, this.values, this.getValueSize(), e)
                },
                InterpolantFactoryMethodLinear: function (e) {
                    return new Ti(this.times, this.values, this.getValueSize(), e)
                },
                InterpolantFactoryMethodSmooth: function (e) {
                    return new Mi(this.times, this.values, this.getValueSize(), e)
                },
                setInterpolation: function (e) {
                    var t;
                    switch (e) {
                        case xl:
                            t = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case bl:
                            t = this.InterpolantFactoryMethodLinear;
                            break;
                        case _l:
                            t = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === t) {
                        var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (e === this.DefaultInterpolation) throw new Error(n);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        return console.warn("THREE.KeyframeTrack:", n), this
                    }
                    return this.createInterpolant = t, this
                },
                getInterpolation: function () {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return xl;
                        case this.InterpolantFactoryMethodLinear:
                            return bl;
                        case this.InterpolantFactoryMethodSmooth:
                            return _l
                    }
                },
                getValueSize: function () {
                    return this.values.length / this.times.length
                },
                shift: function (e) {
                    if (0 !== e)
                        for (var t = this.times, n = 0, i = t.length; n !== i; ++n) t[n] += e;
                    return this
                },
                scale: function (e) {
                    if (1 !== e)
                        for (var t = this.times, n = 0, i = t.length; n !== i; ++n) t[n] *= e;
                    return this
                },
                trim: function (e, t) {
                    for (var n = this.times, i = n.length, r = 0, a = i - 1; r !== i && n[r] < e;) ++r;
                    for (; a !== -1 && n[a] > t;) --a;
                    if (++a, 0 !== r || a !== i) {
                        r >= a && (a = Math.max(a, 1), r = a - 1);
                        var o = this.getValueSize();
                        this.times = Ch.arraySlice(n, r, a), this.values = Ch.arraySlice(this.values, r * o, a * o)
                    }
                    return this
                },
                validate: function () {
                    var e = !0,
                        t = this.getValueSize();
                    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                    var n = this.times,
                        i = this.values,
                        r = n.length;
                    0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                    for (var a = null, o = 0; o !== r; o++) {
                        var s = n[o];
                        if ("number" == typeof s && isNaN(s)) {
                            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, s), e = !1;
                            break
                        }
                        if (null !== a && a > s) {
                            console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s, a), e = !1;
                            break
                        }
                        a = s
                    }
                    if (void 0 !== i && Ch.isTypedArray(i))
                        for (var o = 0, l = i.length; o !== l; ++o) {
                            var c = i[o];
                            if (isNaN(c)) {
                                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, c), e = !1;
                                break
                            }
                        }
                    return e
                },
                optimize: function () {
                    for (var e = this.times, t = this.values, n = this.getValueSize(), i = this.getInterpolation() === _l, r = 1, a = e.length - 1, o = 1; o < a; ++o) {
                        var s = !1,
                            l = e[o],
                            c = e[o + 1];
                        if (l !== c && (1 !== o || l !== l[0]))
                            if (i) s = !0;
                            else
                                for (var u = o * n, h = u - n, d = u + n, p = 0; p !== n; ++p) {
                                    var f = t[u + p];
                                    if (f !== t[h + p] || f !== t[d + p]) {
                                        s = !0;
                                        break
                                    }
                                }
                        if (s) {
                            if (o !== r) {
                                e[r] = e[o];
                                for (var m = o * n, v = r * n, p = 0; p !== n; ++p) t[v + p] = t[m + p]
                            }++r
                        }
                    }
                    if (a > 0) {
                        e[r] = e[a];
                        for (var m = a * n, v = r * n, p = 0; p !== n; ++p) t[v + p] = t[m + p];
                        ++r
                    }
                    return r !== e.length && (this.times = Ch.arraySlice(e, 0, r), this.values = Ch.arraySlice(t, 0, r * n)), this
                }
            }), Pi.prototype = Object.assign(Object.create(Si.prototype), {
                constructor: Pi,
                ValueTypeName: "bool",
                ValueBufferType: Array,
                DefaultInterpolation: xl,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), Ci.prototype = Object.assign(Object.create(Si.prototype), {
                constructor: Ci,
                ValueTypeName: "color"
            }), Ai.prototype = Object.assign(Object.create(Si.prototype), {
                constructor: Ai,
                ValueTypeName: "number"
            }), Li.prototype = Object.assign(Object.create(wi.prototype), {
                constructor: Li,
                interpolate_: function (e, t, n, i) {
                    for (var a = this.resultBuffer, o = this.sampleValues, s = this.valueSize, l = e * s, c = (n - t) / (i - t), u = l + s; l !== u; l += 4) r.slerpFlat(a, 0, o, l - s, o, l, c);
                    return a
                }
            }), Ri.prototype = Object.assign(Object.create(Si.prototype), {
                constructor: Ri,
                ValueTypeName: "quaternion",
                DefaultInterpolation: bl,
                InterpolantFactoryMethodLinear: function (e) {
                    return new Li(this.times, this.values, this.getValueSize(), e)
                },
                InterpolantFactoryMethodSmooth: void 0
            }), Ii.prototype = Object.assign(Object.create(Si.prototype), {
                constructor: Ii,
                ValueTypeName: "string",
                ValueBufferType: Array,
                DefaultInterpolation: xl,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), Oi.prototype = Object.assign(Object.create(Si.prototype), {
                constructor: Oi,
                ValueTypeName: "vector"
            }), Object.assign(ki, {
                parse: function (e) {
                    for (var t = [], n = e.tracks, i = 1 / (e.fps || 1), r = 0, a = n.length; r !== a; ++r) t.push(zi(n[r]).scale(i));
                    return new ki(e.name, e.duration, t)
                },
                toJSON: function (e) {
                    for (var t = [], n = e.tracks, i = {
                            name: e.name,
                            duration: e.duration,
                            tracks: t,
                            uuid: e.uuid
                        }, r = 0, a = n.length; r !== a; ++r) t.push(Si.toJSON(n[r]));
                    return i
                },
                CreateFromMorphTargetSequence: function (e, t, n, i) {
                    for (var r = t.length, a = [], o = 0; o < r; o++) {
                        var s = [],
                            l = [];
                        s.push((o + r - 1) % r, o, (o + 1) % r), l.push(0, 1, 0);
                        var c = Ch.getKeyframeOrder(s);
                        s = Ch.sortedArray(s, 1, c), l = Ch.sortedArray(l, 1, c), i || 0 !== s[0] || (s.push(r), l.push(l[0])), a.push(new Ai(".morphTargetInfluences[" + t[o].name + "]", s, l).scale(1 / n))
                    }
                    return new ki(e, (-1), a)
                },
                findByName: function (e, t) {
                    var n = e;
                    if (!Array.isArray(e)) {
                        var i = e;
                        n = i.geometry && i.geometry.animations || i.animations
                    }
                    for (var r = 0; r < n.length; r++)
                        if (n[r].name === t) return n[r];
                    return null
                },
                CreateClipsFromMorphTargetSequences: function (e, t, n) {
                    for (var i = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = e.length; a < o; a++) {
                        var s = e[a],
                            l = s.name.match(r);
                        if (l && l.length > 1) {
                            var c = l[1],
                                u = i[c];
                            u || (i[c] = u = []), u.push(s)
                        }
                    }
                    var h = [];
                    for (var c in i) h.push(ki.CreateFromMorphTargetSequence(c, i[c], t, n));
                    return h
                },
                parseAnimation: function (e, t) {
                    if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                    for (var n = function (e, t, n, i, r) {
                            if (0 !== n.length) {
                                var a = [],
                                    o = [];
                                Ch.flattenJSON(n, a, o, i), 0 !== a.length && r.push(new e(t, a, o))
                            }
                        }, i = [], r = e.name || "default", a = e.length || -1, o = e.fps || 30, s = e.hierarchy || [], l = 0; l < s.length; l++) {
                        var c = s[l].keys;
                        if (c && 0 !== c.length)
                            if (c[0].morphTargets) {
                                for (var u = {}, h = 0; h < c.length; h++)
                                    if (c[h].morphTargets)
                                        for (var d = 0; d < c[h].morphTargets.length; d++) u[c[h].morphTargets[d]] = -1;
                                for (var p in u) {
                                    for (var f = [], m = [], d = 0; d !== c[h].morphTargets.length; ++d) {
                                        var v = c[h];
                                        f.push(v.time), m.push(v.morphTarget === p ? 1 : 0)
                                    }
                                    i.push(new Ai(".morphTargetInfluence[" + p + "]", f, m))
                                }
                                a = u.length * (o || 1)
                            } else {
                                var g = ".bones[" + t[l].name + "]";
                                n(Oi, g + ".position", c, "pos", i), n(Ri, g + ".quaternion", c, "rot", i), n(Oi, g + ".scale", c, "scl", i)
                            }
                    }
                    if (0 === i.length) return null;
                    var y = new ki(r, a, i);
                    return y
                }
            }), Object.assign(ki.prototype, {
                resetDuration: function () {
                    for (var e = this.tracks, t = 0, n = 0, i = e.length; n !== i; ++n) {
                        var r = this.tracks[n];
                        t = Math.max(t, r.times[r.times.length - 1])
                    }
                    return this.duration = t, this
                },
                trim: function () {
                    for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                    return this
                },
                validate: function () {
                    for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                    return e
                },
                optimize: function () {
                    for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                    return this
                }
            });
            var Ah = {
                    enabled: !1,
                    files: {},
                    add: function (e, t) {
                        this.enabled !== !1 && (this.files[e] = t)
                    },
                    get: function (e) {
                        if (this.enabled !== !1) return this.files[e]
                    },
                    remove: function (e) {
                        delete this.files[e]
                    },
                    clear: function () {
                        this.files = {}
                    }
                },
                Lh = new Bi,
                Rh = {};
            Object.assign(Ni.prototype, {
                load: function (e, t, n, i) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    var r = this,
                        a = Ah.get(e);
                    if (void 0 !== a) return r.manager.itemStart(e), setTimeout(function () {
                        t && t(a), r.manager.itemEnd(e)
                    }, 0), a;
                    if (void 0 !== Rh[e]) return void Rh[e].push({
                        onLoad: t,
                        onProgress: n,
                        onError: i
                    });
                    var o = /^data:(.*?)(;base64)?,(.*)$/,
                        s = e.match(o);
                    if (s) {
                        var l = s[1],
                            c = !!s[2],
                            u = s[3];
                        u = decodeURIComponent(u), c && (u = atob(u));
                        try {
                            var h, d = (this.responseType || "").toLowerCase();
                            switch (d) {
                                case "arraybuffer":
                                case "blob":
                                    for (var p = new Uint8Array(u.length), f = 0; f < u.length; f++) p[f] = u.charCodeAt(f);
                                    h = "blob" === d ? new Blob([p.buffer], {
                                        type: l
                                    }) : p.buffer;
                                    break;
                                case "document":
                                    var m = new DOMParser;
                                    h = m.parseFromString(u, l);
                                    break;
                                case "json":
                                    h = JSON.parse(u);
                                    break;
                                default:
                                    h = u
                            }
                            setTimeout(function () {
                                t && t(h), r.manager.itemEnd(e)
                            }, 0)
                        } catch (v) {
                            setTimeout(function () {
                                i && i(v), r.manager.itemError(e), r.manager.itemEnd(e)
                            }, 0)
                        }
                    } else {
                        Rh[e] = [], Rh[e].push({
                            onLoad: t,
                            onProgress: n,
                            onError: i
                        });
                        var g = new XMLHttpRequest;
                        g.open("GET", e, !0), g.addEventListener("load", function (t) {
                            var n = this.response;
                            Ah.add(e, n);
                            var i = Rh[e];
                            if (delete Rh[e], 200 === this.status || 0 === this.status) {
                                0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                for (var a = 0, o = i.length; a < o; a++) {
                                    var s = i[a];
                                    s.onLoad && s.onLoad(n)
                                }
                                r.manager.itemEnd(e)
                            } else {
                                for (var a = 0, o = i.length; a < o; a++) {
                                    var s = i[a];
                                    s.onError && s.onError(t)
                                }
                                r.manager.itemError(e), r.manager.itemEnd(e)
                            }
                        }, !1), g.addEventListener("progress", function (t) {
                            for (var n = Rh[e], i = 0, r = n.length; i < r; i++) {
                                var a = n[i];
                                a.onProgress && a.onProgress(t)
                            }
                        }, !1), g.addEventListener("error", function (t) {
                            var n = Rh[e];
                            delete Rh[e];
                            for (var i = 0, a = n.length; i < a; i++) {
                                var o = n[i];
                                o.onError && o.onError(t)
                            }
                            r.manager.itemError(e), r.manager.itemEnd(e)
                        }, !1), g.addEventListener("abort", function (t) {
                            var n = Rh[e];
                            delete Rh[e];
                            for (var i = 0, a = n.length; i < a; i++) {
                                var o = n[i];
                                o.onError && o.onError(t)
                            }
                            r.manager.itemError(e), r.manager.itemEnd(e)
                        }, !1), void 0 !== this.responseType && (g.responseType = this.responseType), void 0 !== this.withCredentials && (g.withCredentials = this.withCredentials), g.overrideMimeType && g.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                        for (var y in this.requestHeader) g.setRequestHeader(y, this.requestHeader[y]);
                        g.send(null)
                    }
                    return r.manager.itemStart(e), g
                },
                setPath: function (e) {
                    return this.path = e, this
                },
                setResponseType: function (e) {
                    return this.responseType = e, this
                },
                setWithCredentials: function (e) {
                    return this.withCredentials = e, this
                },
                setMimeType: function (e) {
                    return this.mimeType = e, this
                },
                setRequestHeader: function (e) {
                    return this.requestHeader = e, this
                }
            }), Object.assign(Ui.prototype, {
                load: function (e, t, n, i) {
                    var r = this,
                        a = new Ni(r.manager);
                    a.setPath(r.path), a.load(e, function (e) {
                        t(r.parse(JSON.parse(e)))
                    }, n, i)
                },
                parse: function (e, t) {
                    for (var n = [], i = 0; i < e.length; i++) {
                        var r = ki.parse(e[i]);
                        n.push(r)
                    }
                    t(n)
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }), Object.assign(ji.prototype, {
                load: function (e, t, n, i) {
                    function r(r) {
                        l.load(e[r], function (e) {
                            var n = a._parser(e, !0);
                            o[r] = {
                                width: n.width,
                                height: n.height,
                                format: n.format,
                                mipmaps: n.mipmaps
                            }, c += 1, 6 === c && (1 === n.mipmapCount && (s.minFilter = Ms), s.format = n.format, s.needsUpdate = !0, t && t(s))
                        }, n, i)
                    }
                    var a = this,
                        o = [],
                        s = new qt;
                    s.image = o;
                    var l = new Ni(this.manager);
                    if (l.setPath(this.path), l.setResponseType("arraybuffer"), Array.isArray(e))
                        for (var c = 0, u = 0, h = e.length; u < h; ++u) r(u);
                    else l.load(e, function (e) {
                        var n = a._parser(e, !0);
                        if (n.isCubemap)
                            for (var i = n.mipmaps.length / n.mipmapCount, r = 0; r < i; r++) {
                                o[r] = {
                                    mipmaps: []
                                };
                                for (var l = 0; l < n.mipmapCount; l++) o[r].mipmaps.push(n.mipmaps[r * n.mipmapCount + l]), o[r].format = n.format, o[r].width = n.width, o[r].height = n.height
                            } else s.image.width = n.width, s.image.height = n.height, s.mipmaps = n.mipmaps;
                        1 === n.mipmapCount && (s.minFilter = Ms), s.format = n.format, s.needsUpdate = !0, t && t(s)
                    }, n, i);
                    return s
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }), Object.assign(Fi.prototype, {
                load: function (e, t, n, i) {
                    var r = this,
                        a = new h,
                        o = new Ni(this.manager);
                    return o.setResponseType("arraybuffer"), o.setPath(this.path), o.load(e, function (e) {
                        var n = r._parser(e);
                        n && (void 0 !== n.image ? a.image = n.image : void 0 !== n.data && (a.image.width = n.width, a.image.height = n.height, a.image.data = n.data), a.wrapS = void 0 !== n.wrapS ? n.wrapS : ys, a.wrapT = void 0 !== n.wrapT ? n.wrapT : ys, a.magFilter = void 0 !== n.magFilter ? n.magFilter : Ms, a.minFilter = void 0 !== n.minFilter ? n.minFilter : Es, a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (a.format = n.format), void 0 !== n.type && (a.type = n.type), void 0 !== n.mipmaps && (a.mipmaps = n.mipmaps), 1 === n.mipmapCount && (a.minFilter = Ms), a.needsUpdate = !0, t && t(a, n))
                    }, n, i), a
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }), Object.assign(Gi.prototype, {
                crossOrigin: "anonymous",
                load: function (e, t, n, i) {
                    function r() {
                        l.removeEventListener("load", r, !1), l.removeEventListener("error", a, !1), Ah.add(e, this), t && t(this), o.manager.itemEnd(e)
                    }

                    function a(t) {
                        l.removeEventListener("load", r, !1), l.removeEventListener("error", a, !1), i && i(t), o.manager.itemError(e), o.manager.itemEnd(e)
                    }
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    var o = this,
                        s = Ah.get(e);
                    if (void 0 !== s) return o.manager.itemStart(e), setTimeout(function () {
                        t && t(s), o.manager.itemEnd(e)
                    }, 0), s;
                    var l = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                    return l.addEventListener("load", r, !1), l.addEventListener("error", a, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (l.crossOrigin = this.crossOrigin), o.manager.itemStart(e), l.src = e, l
                },
                setCrossOrigin: function (e) {
                    return this.crossOrigin = e, this
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }), Object.assign(Hi.prototype, {
                crossOrigin: "anonymous",
                load: function (e, t, n, i) {
                    function r(n) {
                        o.load(e[n], function (e) {
                            a.images[n] = e, s++, 6 === s && (a.needsUpdate = !0, t && t(a))
                        }, void 0, i)
                    }
                    var a = new re,
                        o = new Gi(this.manager);
                    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                    for (var s = 0, l = 0; l < e.length; ++l) r(l);
                    return a
                },
                setCrossOrigin: function (e) {
                    return this.crossOrigin = e, this
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }), Object.assign(Vi.prototype, {
                crossOrigin: "anonymous",
                load: function (e, t, n, i) {
                    var r = new s,
                        a = new Gi(this.manager);
                    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function (n) {
                        r.image = n;
                        var i = e.search(/\.jpe?g$/i) > 0 || 0 === e.search(/^data\:image\/jpeg/);
                        r.format = i ? Us : js, r.needsUpdate = !0, void 0 !== t && t(r)
                    }, n, i), r
                },
                setCrossOrigin: function (e) {
                    return this.crossOrigin = e, this
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }), Object.assign(Wi.prototype, {
                getPoint: function () {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                },
                getPointAt: function (e, t) {
                    var n = this.getUtoTmapping(e);
                    return this.getPoint(n, t)
                },
                getPoints: function (e) {
                    void 0 === e && (e = 5);
                    for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                    return t
                },
                getSpacedPoints: function (e) {
                    void 0 === e && (e = 5);
                    for (var t = [], n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
                    return t
                },
                getLength: function () {
                    var e = this.getLengths();
                    return e[e.length - 1]
                },
                getLengths: function (e) {
                    if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    var t, n, i = [],
                        r = this.getPoint(0),
                        a = 0;
                    for (i.push(0), n = 1; n <= e; n++) t = this.getPoint(n / e), a += t.distanceTo(r), i.push(a), r = t;
                    return this.cacheArcLengths = i, i
                },
                updateArcLengths: function () {
                    this.needsUpdate = !0, this.getLengths()
                },
                getUtoTmapping: function (e, t) {
                    var n, i = this.getLengths(),
                        r = 0,
                        a = i.length;
                    n = t ? t : e * i[a - 1];
                    for (var o, s = 0, l = a - 1; s <= l;)
                        if (r = Math.floor(s + (l - s) / 2), o = i[r] - n, o < 0) s = r + 1;
                        else {
                            if (!(o > 0)) {
                                l = r;
                                break
                            }
                            l = r - 1
                        } if (r = l, i[r] === n) return r / (a - 1);
                    var c = i[r],
                        u = i[r + 1],
                        h = u - c,
                        d = (n - c) / h,
                        p = (r + d) / (a - 1);
                    return p
                },
                getTangent: function (e) {
                    var t = 1e-4,
                        n = e - t,
                        i = e + t;
                    n < 0 && (n = 0), i > 1 && (i = 1);
                    var r = this.getPoint(n),
                        a = this.getPoint(i),
                        o = a.clone().sub(r);
                    return o.normalize()
                },
                getTangentAt: function (e) {
                    var t = this.getUtoTmapping(e);
                    return this.getTangent(t)
                },
                computeFrenetFrames: function (e, t) {
                    var n, r, o, s = new a,
                        l = [],
                        c = [],
                        u = [],
                        h = new a,
                        d = new i;
                    for (n = 0; n <= e; n++) r = n / e, l[n] = this.getTangentAt(r), l[n].normalize();
                    c[0] = new a, u[0] = new a;
                    var p = Number.MAX_VALUE,
                        f = Math.abs(l[0].x),
                        m = Math.abs(l[0].y),
                        v = Math.abs(l[0].z);
                    for (f <= p && (p = f, s.set(1, 0, 0)), m <= p && (p = m, s.set(0, 1, 0)), v <= p && s.set(0, 0, 1), h.crossVectors(l[0], s).normalize(), c[0].crossVectors(l[0], h), u[0].crossVectors(l[0], c[0]), n = 1; n <= e; n++) c[n] = c[n - 1].clone(), u[n] = u[n - 1].clone(), h.crossVectors(l[n - 1], l[n]), h.length() > Number.EPSILON && (h.normalize(), o = Math.acos(jl.clamp(l[n - 1].dot(l[n]), -1, 1)), c[n].applyMatrix4(d.makeRotationAxis(h, o))), u[n].crossVectors(l[n], c[n]);
                    if (t === !0)
                        for (o = Math.acos(jl.clamp(c[0].dot(c[e]), -1, 1)), o /= e, l[0].dot(h.crossVectors(c[0], c[e])) > 0 && (o = -o), n = 1; n <= e; n++) c[n].applyMatrix4(d.makeRotationAxis(l[n], o * n)), u[n].crossVectors(l[n], c[n]);
                    return {
                        tangents: l,
                        normals: c,
                        binormals: u
                    }
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                },
                toJSON: function () {
                    var e = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
                },
                fromJSON: function (e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                }
            }), qi.prototype = Object.create(Wi.prototype), qi.prototype.constructor = qi, qi.prototype.isEllipseCurve = !0, qi.prototype.getPoint = function (e, t) {
                for (var i = t || new n, r = 2 * Math.PI, a = this.aEndAngle - this.aStartAngle, o = Math.abs(a) < Number.EPSILON; a < 0;) a += r;
                for (; a > r;) a -= r;
                a < Number.EPSILON && (a = o ? 0 : r), this.aClockwise !== !0 || o || (a === r ? a = -r : a -= r);
                var s = this.aStartAngle + e * a,
                    l = this.aX + this.xRadius * Math.cos(s),
                    c = this.aY + this.yRadius * Math.sin(s);
                if (0 !== this.aRotation) {
                    var u = Math.cos(this.aRotation),
                        h = Math.sin(this.aRotation),
                        d = l - this.aX,
                        p = c - this.aY;
                    l = d * u - p * h + this.aX, c = d * h + p * u + this.aY
                }
                return i.set(l, c)
            }, qi.prototype.copy = function (e) {
                return Wi.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
            }, qi.prototype.toJSON = function () {
                var e = Wi.prototype.toJSON.call(this);
                return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
            }, qi.prototype.fromJSON = function (e) {
                return Wi.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
            }, Xi.prototype = Object.create(qi.prototype), Xi.prototype.constructor = Xi, Xi.prototype.isArcCurve = !0;
            var Ih = new a,
                Oh = new Yi,
                kh = new Yi,
                Dh = new Yi;
            Zi.prototype = Object.create(Wi.prototype), Zi.prototype.constructor = Zi, Zi.prototype.isCatmullRomCurve3 = !0, Zi.prototype.getPoint = function (e, t) {
                var n = t || new a,
                    i = this.points,
                    r = i.length,
                    o = (r - (this.closed ? 0 : 1)) * e,
                    s = Math.floor(o),
                    l = o - s;
                this.closed ? s += s > 0 ? 0 : (Math.floor(Math.abs(s) / r) + 1) * r : 0 === l && s === r - 1 && (s = r - 2, l = 1);
                var c, u, h, d;
                if (this.closed || s > 0 ? c = i[(s - 1) % r] : (Ih.subVectors(i[0], i[1]).add(i[0]), c = Ih), u = i[s % r], h = i[(s + 1) % r], this.closed || s + 2 < r ? d = i[(s + 2) % r] : (Ih.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), d = Ih), "centripetal" === this.curveType || "chordal" === this.curveType) {
                    var p = "chordal" === this.curveType ? .5 : .25,
                        f = Math.pow(c.distanceToSquared(u), p),
                        m = Math.pow(u.distanceToSquared(h), p),
                        v = Math.pow(h.distanceToSquared(d), p);
                    m < 1e-4 && (m = 1), f < 1e-4 && (f = m), v < 1e-4 && (v = m), Oh.initNonuniformCatmullRom(c.x, u.x, h.x, d.x, f, m, v), kh.initNonuniformCatmullRom(c.y, u.y, h.y, d.y, f, m, v), Dh.initNonuniformCatmullRom(c.z, u.z, h.z, d.z, f, m, v)
                } else "catmullrom" === this.curveType && (Oh.initCatmullRom(c.x, u.x, h.x, d.x, this.tension), kh.initCatmullRom(c.y, u.y, h.y, d.y, this.tension), Dh.initCatmullRom(c.z, u.z, h.z, d.z, this.tension));
                return n.set(Oh.calc(l), kh.calc(l), Dh.calc(l)), n
            }, Zi.prototype.copy = function (e) {
                Wi.prototype.copy.call(this, e), this.points = [];
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var i = e.points[t];
                    this.points.push(i.clone())
                }
                return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
            }, Zi.prototype.toJSON = function () {
                var e = Wi.prototype.toJSON.call(this);
                e.points = [];
                for (var t = 0, n = this.points.length; t < n; t++) {
                    var i = this.points[t];
                    e.points.push(i.toArray())
                }
                return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
            }, Zi.prototype.fromJSON = function (e) {
                Wi.prototype.fromJSON.call(this, e), this.points = [];
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var i = e.points[t];
                    this.points.push((new a).fromArray(i))
                }
                return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
            }, or.prototype = Object.create(Wi.prototype), or.prototype.constructor = or, or.prototype.isCubicBezierCurve = !0, or.prototype.getPoint = function (e, t) {
                var i = t || new n,
                    r = this.v0,
                    a = this.v1,
                    o = this.v2,
                    s = this.v3;
                return i.set(ar(e, r.x, a.x, o.x, s.x), ar(e, r.y, a.y, o.y, s.y)), i
            }, or.prototype.copy = function (e) {
                return Wi.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
            }, or.prototype.toJSON = function () {
                var e = Wi.prototype.toJSON.call(this);
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
            }, or.prototype.fromJSON = function (e) {
                return Wi.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
            }, sr.prototype = Object.create(Wi.prototype), sr.prototype.constructor = sr, sr.prototype.isCubicBezierCurve3 = !0, sr.prototype.getPoint = function (e, t) {
                var n = t || new a,
                    i = this.v0,
                    r = this.v1,
                    o = this.v2,
                    s = this.v3;
                return n.set(ar(e, i.x, r.x, o.x, s.x), ar(e, i.y, r.y, o.y, s.y), ar(e, i.z, r.z, o.z, s.z)), n
            }, sr.prototype.copy = function (e) {
                return Wi.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
            }, sr.prototype.toJSON = function () {
                var e = Wi.prototype.toJSON.call(this);
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
            }, sr.prototype.fromJSON = function (e) {
                return Wi.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
            }, lr.prototype = Object.create(Wi.prototype), lr.prototype.constructor = lr, lr.prototype.isLineCurve = !0, lr.prototype.getPoint = function (e, t) {
                var i = t || new n;
                return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i
            }, lr.prototype.getPointAt = function (e, t) {
                return this.getPoint(e, t)
            }, lr.prototype.getTangent = function () {
                var e = this.v2.clone().sub(this.v1);
                return e.normalize()
            }, lr.prototype.copy = function (e) {
                return Wi.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }, lr.prototype.toJSON = function () {
                var e = Wi.prototype.toJSON.call(this);
                return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }, lr.prototype.fromJSON = function (e) {
                return Wi.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }, cr.prototype = Object.create(Wi.prototype), cr.prototype.constructor = cr, cr.prototype.isLineCurve3 = !0, cr.prototype.getPoint = function (e, t) {
                var n = t || new a;
                return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
            }, cr.prototype.getPointAt = function (e, t) {
                return this.getPoint(e, t)
            }, cr.prototype.copy = function (e) {
                return Wi.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }, cr.prototype.toJSON = function () {
                var e = Wi.prototype.toJSON.call(this);
                return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }, cr.prototype.fromJSON = function (e) {
                return Wi.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }, ur.prototype = Object.create(Wi.prototype), ur.prototype.constructor = ur, ur.prototype.isQuadraticBezierCurve = !0, ur.prototype.getPoint = function (e, t) {
                var i = t || new n,
                    r = this.v0,
                    a = this.v1,
                    o = this.v2;
                return i.set(er(e, r.x, a.x, o.x), er(e, r.y, a.y, o.y)), i
            }, ur.prototype.copy = function (e) {
                return Wi.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }, ur.prototype.toJSON = function () {
                var e = Wi.prototype.toJSON.call(this);
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }, ur.prototype.fromJSON = function (e) {
                return Wi.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }, hr.prototype = Object.create(Wi.prototype), hr.prototype.constructor = hr, hr.prototype.isQuadraticBezierCurve3 = !0, hr.prototype.getPoint = function (e, t) {
                var n = t || new a,
                    i = this.v0,
                    r = this.v1,
                    o = this.v2;
                return n.set(er(e, i.x, r.x, o.x), er(e, i.y, r.y, o.y), er(e, i.z, r.z, o.z)), n
            }, hr.prototype.copy = function (e) {
                return Wi.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }, hr.prototype.toJSON = function () {
                var e = Wi.prototype.toJSON.call(this);
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }, hr.prototype.fromJSON = function (e) {
                return Wi.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }, dr.prototype = Object.create(Wi.prototype), dr.prototype.constructor = dr, dr.prototype.isSplineCurve = !0, dr.prototype.getPoint = function (e, t) {
                var i = t || new n,
                    r = this.points,
                    a = (r.length - 1) * e,
                    o = Math.floor(a),
                    s = a - o,
                    l = r[0 === o ? o : o - 1],
                    c = r[o],
                    u = r[o > r.length - 2 ? r.length - 1 : o + 1],
                    h = r[o > r.length - 3 ? r.length - 1 : o + 2];
                return i.set(Ji(s, l.x, c.x, u.x, h.x), Ji(s, l.y, c.y, u.y, h.y)), i
            }, dr.prototype.copy = function (e) {
                Wi.prototype.copy.call(this, e), this.points = [];
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var i = e.points[t];
                    this.points.push(i.clone())
                }
                return this
            }, dr.prototype.toJSON = function () {
                var e = Wi.prototype.toJSON.call(this);
                e.points = [];
                for (var t = 0, n = this.points.length; t < n; t++) {
                    var i = this.points[t];
                    e.points.push(i.toArray())
                }
                return e
            }, dr.prototype.fromJSON = function (e) {
                Wi.prototype.fromJSON.call(this, e), this.points = [];
                for (var t = 0, i = e.points.length; t < i; t++) {
                    var r = e.points[t];
                    this.points.push((new n).fromArray(r))
                }
                return this
            };
            var zh = Object.freeze({
                ArcCurve: Xi,
                CatmullRomCurve3: Zi,
                CubicBezierCurve: or,
                CubicBezierCurve3: sr,
                EllipseCurve: qi,
                LineCurve: lr,
                LineCurve3: cr,
                QuadraticBezierCurve: ur,
                QuadraticBezierCurve3: hr,
                SplineCurve: dr
            });
            pr.prototype = Object.assign(Object.create(Wi.prototype), {
                constructor: pr,
                add: function (e) {
                    this.curves.push(e)
                },
                closePath: function () {
                    var e = this.curves[0].getPoint(0),
                        t = this.curves[this.curves.length - 1].getPoint(1);
                    e.equals(t) || this.curves.push(new lr(t, e))
                },
                getPoint: function (e) {
                    for (var t = e * this.getLength(), n = this.getCurveLengths(), i = 0; i < n.length;) {
                        if (n[i] >= t) {
                            var r = n[i] - t,
                                a = this.curves[i],
                                o = a.getLength(),
                                s = 0 === o ? 0 : 1 - r / o;
                            return a.getPointAt(s)
                        }
                        i++
                    }
                    return null
                },
                getLength: function () {
                    var e = this.getCurveLengths();
                    return e[e.length - 1]
                },
                updateArcLengths: function () {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                },
                getCurveLengths: function () {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    for (var e = [], t = 0, n = 0, i = this.curves.length; n < i; n++) t += this.curves[n].getLength(), e.push(t);
                    return this.cacheLengths = e, e
                },
                getSpacedPoints: function (e) {
                    void 0 === e && (e = 40);
                    for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                    return this.autoClose && t.push(t[0]), t
                },
                getPoints: function (e) {
                    e = e || 12;
                    for (var t, n = [], i = 0, r = this.curves; i < r.length; i++)
                        for (var a = r[i], o = a && a.isEllipseCurve ? 2 * e : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? e * a.points.length : e, s = a.getPoints(o), l = 0; l < s.length; l++) {
                            var c = s[l];
                            t && t.equals(c) || (n.push(c), t = c)
                        }
                    return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
                },
                copy: function (e) {
                    Wi.prototype.copy.call(this, e), this.curves = [];
                    for (var t = 0, n = e.curves.length; t < n; t++) {
                        var i = e.curves[t];
                        this.curves.push(i.clone())
                    }
                    return this.autoClose = e.autoClose, this
                },
                toJSON: function () {
                    var e = Wi.prototype.toJSON.call(this);
                    e.autoClose = this.autoClose, e.curves = [];
                    for (var t = 0, n = this.curves.length; t < n; t++) {
                        var i = this.curves[t];
                        e.curves.push(i.toJSON())
                    }
                    return e
                },
                fromJSON: function (e) {
                    Wi.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
                    for (var t = 0, n = e.curves.length; t < n; t++) {
                        var i = e.curves[t];
                        this.curves.push((new zh[i.type]).fromJSON(i))
                    }
                    return this
                }
            }), fr.prototype = Object.assign(Object.create(pr.prototype), {
                constructor: fr,
                setFromPoints: function (e) {
                    this.moveTo(e[0].x, e[0].y);
                    for (var t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y)
                },
                moveTo: function (e, t) {
                    this.currentPoint.set(e, t)
                },
                lineTo: function (e, t) {
                    var i = new lr(this.currentPoint.clone(), new n(e, t));
                    this.curves.push(i), this.currentPoint.set(e, t)
                },
                quadraticCurveTo: function (e, t, i, r) {
                    var a = new ur(this.currentPoint.clone(), new n(e, t), new n(i, r));
                    this.curves.push(a), this.currentPoint.set(i, r)
                },
                bezierCurveTo: function (e, t, i, r, a, o) {
                    var s = new or(this.currentPoint.clone(), new n(e, t), new n(i, r), new n(a, o));
                    this.curves.push(s), this.currentPoint.set(a, o)
                },
                splineThru: function (e) {
                    var t = [this.currentPoint.clone()].concat(e),
                        n = new dr(t);
                    this.curves.push(n), this.currentPoint.copy(e[e.length - 1])
                },
                arc: function (e, t, n, i, r, a) {
                    var o = this.currentPoint.x,
                        s = this.currentPoint.y;
                    this.absarc(e + o, t + s, n, i, r, a)
                },
                absarc: function (e, t, n, i, r, a) {
                    this.absellipse(e, t, n, n, i, r, a)
                },
                ellipse: function (e, t, n, i, r, a, o, s) {
                    var l = this.currentPoint.x,
                        c = this.currentPoint.y;
                    this.absellipse(e + l, t + c, n, i, r, a, o, s)
                },
                absellipse: function (e, t, n, i, r, a, o, s) {
                    var l = new qi(e, t, n, i, r, a, o, s);
                    if (this.curves.length > 0) {
                        var c = l.getPoint(0);
                        c.equals(this.currentPoint) || this.lineTo(c.x, c.y)
                    }
                    this.curves.push(l);
                    var u = l.getPoint(1);
                    this.currentPoint.copy(u)
                },
                copy: function (e) {
                    return pr.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this
                },
                toJSON: function () {
                    var e = pr.prototype.toJSON.call(this);
                    return e.currentPoint = this.currentPoint.toArray(), e
                },
                fromJSON: function (e) {
                    return pr.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this
                }
            }), mr.prototype = Object.assign(Object.create(fr.prototype), {
                constructor: mr,
                getPointsHoles: function (e) {
                    for (var t = [], n = 0, i = this.holes.length; n < i; n++) t[n] = this.holes[n].getPoints(e);
                    return t
                },
                extractPoints: function (e) {
                    return {
                        shape: this.getPoints(e),
                        holes: this.getPointsHoles(e)
                    }
                },
                copy: function (e) {
                    fr.prototype.copy.call(this, e), this.holes = [];
                    for (var t = 0, n = e.holes.length; t < n; t++) {
                        var i = e.holes[t];
                        this.holes.push(i.clone())
                    }
                    return this
                },
                toJSON: function () {
                    var e = fr.prototype.toJSON.call(this);
                    e.uuid = this.uuid, e.holes = [];
                    for (var t = 0, n = this.holes.length; t < n; t++) {
                        var i = this.holes[t];
                        e.holes.push(i.toJSON())
                    }
                    return e
                },
                fromJSON: function (e) {
                    fr.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
                    for (var t = 0, n = e.holes.length; t < n; t++) {
                        var i = e.holes[t];
                        this.holes.push((new fr).fromJSON(i))
                    }
                    return this
                }
            }), vr.prototype = Object.assign(Object.create(w.prototype), {
                constructor: vr,
                isLight: !0,
                copy: function (e) {
                    return w.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this
                },
                toJSON: function (e) {
                    var t = w.prototype.toJSON.call(this, e);
                    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
                }
            }), gr.prototype = Object.assign(Object.create(vr.prototype), {
                constructor: gr,
                isHemisphereLight: !0,
                copy: function (e) {
                    return vr.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
                }
            }), Object.assign(yr.prototype, {
                copy: function (e) {
                    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                toJSON: function () {
                    var e = {};
                    return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
                }
            }), xr.prototype = Object.assign(Object.create(yr.prototype), {
                constructor: xr,
                isSpotLightShadow: !0,
                update: function (e) {
                    var t = this.camera,
                        n = 2 * jl.RAD2DEG * e.angle,
                        i = this.mapSize.width / this.mapSize.height,
                        r = e.distance || t.far;
                    n === t.fov && i === t.aspect && r === t.far || (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix())
                }
            }), br.prototype = Object.assign(Object.create(vr.prototype), {
                constructor: br,
                isSpotLight: !0,
                copy: function (e) {
                    return vr.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }), _r.prototype = Object.assign(Object.create(vr.prototype), {
                constructor: _r,
                isPointLight: !0,
                copy: function (e) {
                    return vr.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
                }
            }), wr.prototype = Object.assign(Object.create(_t.prototype), {
                constructor: wr,
                isOrthographicCamera: !0,
                copy: function (e, t) {
                    return _t.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
                },
                setViewOffset: function (e, t, n, i, r, a) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
                },
                clearViewOffset: function () {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function () {
                    var e = (this.right - this.left) / (2 * this.zoom),
                        t = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        i = (this.top + this.bottom) / 2,
                        r = n - e,
                        a = n + e,
                        o = i + t,
                        s = i - t;
                    if (null !== this.view && this.view.enabled) {
                        var l = this.zoom / (this.view.width / this.view.fullWidth),
                            c = this.zoom / (this.view.height / this.view.fullHeight),
                            u = (this.right - this.left) / this.view.width,
                            h = (this.top - this.bottom) / this.view.height;
                        r += u * (this.view.offsetX / l), a = r + u * (this.view.width / l), o -= h * (this.view.offsetY / c), s = o - h * (this.view.height / c)
                    }
                    this.projectionMatrix.makeOrthographic(r, a, o, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function (e) {
                    var t = w.prototype.toJSON.call(this, e);
                    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
                }
            }), Mr.prototype = Object.assign(Object.create(yr.prototype), {
                constructor: Mr
            }), Tr.prototype = Object.assign(Object.create(vr.prototype), {
                constructor: Tr,
                isDirectionalLight: !0,
                copy: function (e) {
                    return vr.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }), Er.prototype = Object.assign(Object.create(vr.prototype), {
                constructor: Er,
                isAmbientLight: !0
            }), Sr.prototype = Object.assign(Object.create(vr.prototype), {
                constructor: Sr,
                isRectAreaLight: !0,
                copy: function (e) {
                    return vr.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this
                },
                toJSON: function (e) {
                    var t = vr.prototype.toJSON.call(this, e);
                    return t.object.width = this.width, t.object.height = this.height, t
                }
            }), Object.assign(Pr.prototype, {
                load: function (e, t, n, i) {
                    var r = this,
                        a = new Ni(r.manager);
                    a.setPath(r.path), a.load(e, function (e) {
                        t(r.parse(JSON.parse(e)))
                    }, n, i)
                },
                parse: function (e) {
                    function t(e) {
                        return void 0 === r[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), r[e]
                    }
                    var r = this.textures,
                        o = new Ph[e.type];
                    if (void 0 !== e.uuid && (o.uuid = e.uuid), void 0 !== e.name && (o.name = e.name), void 0 !== e.color && o.color.setHex(e.color), void 0 !== e.roughness && (o.roughness = e.roughness), void 0 !== e.metalness && (o.metalness = e.metalness), void 0 !== e.emissive && o.emissive.setHex(e.emissive), void 0 !== e.specular && o.specular.setHex(e.specular), void 0 !== e.shininess && (o.shininess = e.shininess), void 0 !== e.clearCoat && (o.clearCoat = e.clearCoat), void 0 !== e.clearCoatRoughness && (o.clearCoatRoughness = e.clearCoatRoughness), void 0 !== e.vertexColors && (o.vertexColors = e.vertexColors), void 0 !== e.fog && (o.fog = e.fog), void 0 !== e.flatShading && (o.flatShading = e.flatShading), void 0 !== e.blending && (o.blending = e.blending), void 0 !== e.combine && (o.combine = e.combine), void 0 !== e.side && (o.side = e.side), void 0 !== e.opacity && (o.opacity = e.opacity), void 0 !== e.transparent && (o.transparent = e.transparent), void 0 !== e.alphaTest && (o.alphaTest = e.alphaTest), void 0 !== e.depthTest && (o.depthTest = e.depthTest), void 0 !== e.depthWrite && (o.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (o.colorWrite = e.colorWrite), void 0 !== e.wireframe && (o.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (o.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (o.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (o.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (o.rotation = e.rotation), 1 !== e.linewidth && (o.linewidth = e.linewidth), void 0 !== e.dashSize && (o.dashSize = e.dashSize), void 0 !== e.gapSize && (o.gapSize = e.gapSize), void 0 !== e.scale && (o.scale = e.scale), void 0 !== e.polygonOffset && (o.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (o.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (o.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (o.skinning = e.skinning), void 0 !== e.morphTargets && (o.morphTargets = e.morphTargets), void 0 !== e.dithering && (o.dithering = e.dithering), void 0 !== e.visible && (o.visible = e.visible), void 0 !== e.userData && (o.userData = e.userData), void 0 !== e.uniforms)
                        for (var s in e.uniforms) {
                            var c = e.uniforms[s];
                            switch (o.uniforms[s] = {}, c.type) {
                                case "t":
                                    o.uniforms[s].value = t(c.value);
                                    break;
                                case "c":
                                    o.uniforms[s].value = (new v).setHex(c.value);
                                    break;
                                case "v2":
                                    o.uniforms[s].value = (new n).fromArray(c.value);
                                    break;
                                case "v3":
                                    o.uniforms[s].value = (new a).fromArray(c.value);
                                    break;
                                case "v4":
                                    o.uniforms[s].value = (new l).fromArray(c.value);
                                    break;
                                case "m4":
                                    o.uniforms[s].value = (new i).fromArray(c.value);
                                    break;
                                default:
                                    o.uniforms[s].value = c.value
                            }
                        }
                    if (void 0 !== e.defines && (o.defines = e.defines), void 0 !== e.vertexShader && (o.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (o.fragmentShader = e.fragmentShader), void 0 !== e.shading && (o.flatShading = 1 === e.shading), void 0 !== e.size && (o.size = e.size), void 0 !== e.sizeAttenuation && (o.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (o.map = t(e.map)), void 0 !== e.alphaMap && (o.alphaMap = t(e.alphaMap), o.transparent = !0), void 0 !== e.bumpMap && (o.bumpMap = t(e.bumpMap)), void 0 !== e.bumpScale && (o.bumpScale = e.bumpScale), void 0 !== e.normalMap && (o.normalMap = t(e.normalMap)), void 0 !== e.normalMapType && (o.normalMapType = e.normalMapType), void 0 !== e.normalScale) {
                        var u = e.normalScale;
                        Array.isArray(u) === !1 && (u = [u, u]), o.normalScale = (new n).fromArray(u)
                    }
                    return void 0 !== e.displacementMap && (o.displacementMap = t(e.displacementMap)), void 0 !== e.displacementScale && (o.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (o.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (o.roughnessMap = t(e.roughnessMap)), void 0 !== e.metalnessMap && (o.metalnessMap = t(e.metalnessMap)), void 0 !== e.emissiveMap && (o.emissiveMap = t(e.emissiveMap)), void 0 !== e.emissiveIntensity && (o.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (o.specularMap = t(e.specularMap)), void 0 !== e.envMap && (o.envMap = t(e.envMap)), void 0 !== e.envMapIntensity && (o.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (o.reflectivity = e.reflectivity), void 0 !== e.lightMap && (o.lightMap = t(e.lightMap)), void 0 !== e.lightMapIntensity && (o.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (o.aoMap = t(e.aoMap)), void 0 !== e.aoMapIntensity && (o.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (o.gradientMap = t(e.gradientMap)), o
                },
                setPath: function (e) {
                    return this.path = e, this
                },
                setTextures: function (e) {
                    return this.textures = e, this
                }
            });
            var Bh = {
                decodeText: function (e) {
                    if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
                    for (var t = "", n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
                    return decodeURIComponent(escape(t))
                },
                extractUrlBase: function (e) {
                    var t = e.lastIndexOf("/");
                    return t === -1 ? "./" : e.substr(0, t + 1)
                }
            };
            Object.assign(Cr.prototype, {
                load: function (e, t, n, i) {
                    var r = this,
                        a = new Ni(r.manager);
                    a.setPath(r.path), a.load(e, function (e) {
                        t(r.parse(JSON.parse(e)))
                    }, n, i)
                },
                parse: function (e) {
                    var t = new z,
                        n = e.data.index;
                    if (void 0 !== n) {
                        var i = new Nh[n.type](n.array);
                        t.setIndex(new T(i, 1))
                    }
                    var r = e.data.attributes;
                    for (var o in r) {
                        var s = r[o],
                            i = new Nh[s.type](s.array);
                        t.addAttribute(o, new T(i, s.itemSize, s.normalized))
                    }
                    var l = e.data.groups || e.data.drawcalls || e.data.offsets;
                    if (void 0 !== l)
                        for (var c = 0, u = l.length; c !== u; ++c) {
                            var h = l[c];
                            t.addGroup(h.start, h.count, h.materialIndex)
                        }
                    var d = e.data.boundingSphere;
                    if (void 0 !== d) {
                        var f = new a;
                        void 0 !== d.center && f.fromArray(d.center), t.boundingSphere = new p(f, d.radius)
                    }
                    return t
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            });
            var Nh = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };
            Ar.Handlers = {
                handlers: [],
                add: function (e, t) {
                    this.handlers.push(e, t)
                },
                get: function (e) {
                    for (var t = this.handlers, n = 0, i = t.length; n < i; n += 2) {
                        var r = t[n],
                            a = t[n + 1];
                        if (r.test(e)) return a
                    }
                    return null
                }
            }, Object.assign(Ar.prototype, {
                crossOrigin: "anonymous",
                onLoadStart: function () {},
                onLoadProgress: function () {},
                onLoadComplete: function () {},
                initMaterials: function (e, t, n) {
                    for (var i = [], r = 0; r < e.length; ++r) i[r] = this.createMaterial(e[r], t, n);
                    return i
                },
                createMaterial: function () {
                    var e = {
                            NoBlending: Eo,
                            NormalBlending: So,
                            AdditiveBlending: Po,
                            SubtractiveBlending: Co,
                            MultiplyBlending: Ao,
                            CustomBlending: Lo
                        },
                        t = new v,
                        n = new Vi,
                        i = new Pr;
                    return function (r, a, o) {
                        function s(e, t, i, r, s) {
                            var c, u = a + e,
                                h = Ar.Handlers.get(u);
                            null !== h ? c = h.load(u) : (n.setCrossOrigin(o), c = n.load(u)), void 0 !== t && (c.repeat.fromArray(t), 1 !== t[0] && (c.wrapS = gs), 1 !== t[1] && (c.wrapT = gs)), void 0 !== i && c.offset.fromArray(i), void 0 !== r && ("repeat" === r[0] && (c.wrapS = gs), "mirror" === r[0] && (c.wrapS = xs), "repeat" === r[1] && (c.wrapT = gs), "mirror" === r[1] && (c.wrapT = xs)), void 0 !== s && (c.anisotropy = s);
                            var d = jl.generateUUID();
                            return l[d] = c, d
                        }
                        var l = {},
                            c = {
                                uuid: jl.generateUUID(),
                                type: "MeshLambertMaterial"
                            };
                        for (var u in r) {
                            var h = r[u];
                            switch (u) {
                                case "DbgColor":
                                case "DbgIndex":
                                case "opticalDensity":
                                case "illumination":
                                    break;
                                case "DbgName":
                                    c.name = h;
                                    break;
                                case "blending":
                                    c.blending = e[h];
                                    break;
                                case "colorAmbient":
                                case "mapAmbient":
                                    console.warn("THREE.Loader.createMaterial:", u, "is no longer supported.");
                                    break;
                                case "colorDiffuse":
                                    c.color = t.fromArray(h).getHex();
                                    break;
                                case "colorSpecular":
                                    c.specular = t.fromArray(h).getHex();
                                    break;
                                case "colorEmissive":
                                    c.emissive = t.fromArray(h).getHex();
                                    break;
                                case "specularCoef":
                                    c.shininess = h;
                                    break;
                                case "shading":
                                    "basic" === h.toLowerCase() && (c.type = "MeshBasicMaterial"), "phong" === h.toLowerCase() && (c.type = "MeshPhongMaterial"), "standard" === h.toLowerCase() && (c.type = "MeshStandardMaterial");
                                    break;
                                case "mapDiffuse":
                                    c.map = s(h, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy);
                                    break;
                                case "mapDiffuseRepeat":
                                case "mapDiffuseOffset":
                                case "mapDiffuseWrap":
                                case "mapDiffuseAnisotropy":
                                    break;
                                case "mapEmissive":
                                    c.emissiveMap = s(h, r.mapEmissiveRepeat, r.mapEmissiveOffset, r.mapEmissiveWrap, r.mapEmissiveAnisotropy);
                                    break;
                                case "mapEmissiveRepeat":
                                case "mapEmissiveOffset":
                                case "mapEmissiveWrap":
                                case "mapEmissiveAnisotropy":
                                    break;
                                case "mapLight":
                                    c.lightMap = s(h, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy);
                                    break;
                                case "mapLightRepeat":
                                case "mapLightOffset":
                                case "mapLightWrap":
                                case "mapLightAnisotropy":
                                    break;
                                case "mapAO":
                                    c.aoMap = s(h, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy);
                                    break;
                                case "mapAORepeat":
                                case "mapAOOffset":
                                case "mapAOWrap":
                                case "mapAOAnisotropy":
                                    break;
                                case "mapBump":
                                    c.bumpMap = s(h, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy);
                                    break;
                                case "mapBumpScale":
                                    c.bumpScale = h;
                                    break;
                                case "mapBumpRepeat":
                                case "mapBumpOffset":
                                case "mapBumpWrap":
                                case "mapBumpAnisotropy":
                                    break;
                                case "mapNormal":
                                    c.normalMap = s(h, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy);
                                    break;
                                case "mapNormalFactor":
                                    c.normalScale = h;
                                    break;
                                case "mapNormalRepeat":
                                case "mapNormalOffset":
                                case "mapNormalWrap":
                                case "mapNormalAnisotropy":
                                    break;
                                case "mapSpecular":
                                    c.specularMap = s(h, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy);
                                    break;
                                case "mapSpecularRepeat":
                                case "mapSpecularOffset":
                                case "mapSpecularWrap":
                                case "mapSpecularAnisotropy":
                                    break;
                                case "mapMetalness":
                                    c.metalnessMap = s(h, r.mapMetalnessRepeat, r.mapMetalnessOffset, r.mapMetalnessWrap, r.mapMetalnessAnisotropy);
                                    break;
                                case "mapMetalnessRepeat":
                                case "mapMetalnessOffset":
                                case "mapMetalnessWrap":
                                case "mapMetalnessAnisotropy":
                                    break;
                                case "mapRoughness":
                                    c.roughnessMap = s(h, r.mapRoughnessRepeat, r.mapRoughnessOffset, r.mapRoughnessWrap, r.mapRoughnessAnisotropy);
                                    break;
                                case "mapRoughnessRepeat":
                                case "mapRoughnessOffset":
                                case "mapRoughnessWrap":
                                case "mapRoughnessAnisotropy":
                                    break;
                                case "mapAlpha":
                                    c.alphaMap = s(h, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy);
                                    break;
                                case "mapAlphaRepeat":
                                case "mapAlphaOffset":
                                case "mapAlphaWrap":
                                case "mapAlphaAnisotropy":
                                    break;
                                case "flipSided":
                                    c.side = yo;
                                    break;
                                case "doubleSided":
                                    c.side = xo;
                                    break;
                                case "transparency":
                                    console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), c.opacity = h;
                                    break;
                                case "depthTest":
                                case "depthWrite":
                                case "colorWrite":
                                case "opacity":
                                case "reflectivity":
                                case "transparent":
                                case "visible":
                                case "wireframe":
                                    c[u] = h;
                                    break;
                                case "vertexColors":
                                    h === !0 && (c.vertexColors = To), "face" === h && (c.vertexColors = Mo);
                                    break;
                                default:
                                    console.error("THREE.Loader.createMaterial: Unsupported", u, h)
                            }
                        }
                        return "MeshBasicMaterial" === c.type && delete c.emissive, "MeshPhongMaterial" !== c.type && delete c.specular, c.opacity < 1 && (c.transparent = !0), i.setTextures(l), i.parse(c)
                    }
                }()
            }), Object.assign(Lr.prototype, {
                crossOrigin: "anonymous",
                load: function (e, t, n, i) {
                    var r = this,
                        a = void 0 === this.path ? Bh.extractUrlBase(e) : this.path,
                        o = new Ni(this.manager);
                    o.setPath(this.path), o.setWithCredentials(this.withCredentials), o.load(e, function (n) {
                        var i = JSON.parse(n),
                            o = i.metadata;
                        if (void 0 !== o) {
                            var s = o.type;
                            if (void 0 !== s && "object" === s.toLowerCase()) return void console.error("THREE.JSONLoader: " + e + " should be loaded with THREE.ObjectLoader instead.")
                        }
                        var l = r.parse(i, a);
                        t(l.geometry, l.materials)
                    }, n, i)
                },
                setPath: function (e) {
                    return this.path = e, this
                },
                setResourcePath: function (e) {
                    return this.resourcePath = e, this
                },
                setCrossOrigin: function (e) {
                    return this.crossOrigin = e, this
                },
                parse: function () {
                    function e(e, t) {
                        function i(e, t) {
                            return e & 1 << t
                        }
                        var r, o, s, l, c, u, h, d, p, f, m, g, y, b, _, w, M, T, E, S, P, C, A, L, R, I, O, k = e.faces,
                            D = e.vertices,
                            z = e.normals,
                            B = e.colors,
                            N = e.scale,
                            U = 0;
                        if (void 0 !== e.uvs) {
                            for (r = 0; r < e.uvs.length; r++) e.uvs[r].length && U++;
                            for (r = 0; r < U; r++) t.faceVertexUvs[r] = []
                        }
                        for (l = 0, c = D.length; l < c;) T = new a, T.x = D[l++] * N, T.y = D[l++] * N, T.z = D[l++] * N, t.vertices.push(T);
                        for (l = 0, c = k.length; l < c;)
                            if (f = k[l++], m = i(f, 0), g = i(f, 1), y = i(f, 3), b = i(f, 4), _ = i(f, 5), w = i(f, 6), M = i(f, 7), m) {
                                if (S = new x, S.a = k[l], S.b = k[l + 1], S.c = k[l + 3], P = new x, P.a = k[l + 1], P.b = k[l + 2], P.c = k[l + 3], l += 4, g && (p = k[l++], S.materialIndex = p, P.materialIndex = p), s = t.faces.length, y)
                                    for (r = 0; r < U; r++)
                                        for (L = e.uvs[r], t.faceVertexUvs[r][s] = [], t.faceVertexUvs[r][s + 1] = [], o = 0; o < 4; o++) d = k[l++], I = L[2 * d], O = L[2 * d + 1], R = new n(I, O), 2 !== o && t.faceVertexUvs[r][s].push(R), 0 !== o && t.faceVertexUvs[r][s + 1].push(R);
                                if (b && (h = 3 * k[l++], S.normal.set(z[h++], z[h++], z[h]), P.normal.copy(S.normal)), _)
                                    for (r = 0; r < 4; r++) h = 3 * k[l++], A = new a(z[h++], z[h++], z[h]), 2 !== r && S.vertexNormals.push(A), 0 !== r && P.vertexNormals.push(A);
                                if (w && (u = k[l++], C = B[u], S.color.setHex(C), P.color.setHex(C)), M)
                                    for (r = 0; r < 4; r++) u = k[l++], C = B[u], 2 !== r && S.vertexColors.push(new v(C)), 0 !== r && P.vertexColors.push(new v(C));
                                t.faces.push(S), t.faces.push(P)
                            } else {
                                if (E = new x, E.a = k[l++], E.b = k[l++], E.c = k[l++], g && (p = k[l++], E.materialIndex = p), s = t.faces.length, y)
                                    for (r = 0; r < U; r++)
                                        for (L = e.uvs[r], t.faceVertexUvs[r][s] = [], o = 0; o < 3; o++) d = k[l++], I = L[2 * d], O = L[2 * d + 1], R = new n(I, O), t.faceVertexUvs[r][s].push(R);
                                if (b && (h = 3 * k[l++], E.normal.set(z[h++], z[h++], z[h])), _)
                                    for (r = 0; r < 3; r++) h = 3 * k[l++], A = new a(z[h++], z[h++], z[h]), E.vertexNormals.push(A);
                                if (w && (u = k[l++], E.color.setHex(B[u])), M)
                                    for (r = 0; r < 3; r++) u = k[l++], E.vertexColors.push(new v(B[u]));
                                t.faces.push(E)
                            }
                    }

                    function t(e, t) {
                        var n = void 0 !== e.influencesPerVertex ? e.influencesPerVertex : 2;
                        if (e.skinWeights)
                            for (var i = 0, r = e.skinWeights.length; i < r; i += n) {
                                var a = e.skinWeights[i],
                                    o = n > 1 ? e.skinWeights[i + 1] : 0,
                                    s = n > 2 ? e.skinWeights[i + 2] : 0,
                                    c = n > 3 ? e.skinWeights[i + 3] : 0;
                                t.skinWeights.push(new l(a, o, s, c))
                            }
                        if (e.skinIndices)
                            for (var i = 0, r = e.skinIndices.length; i < r; i += n) {
                                var u = e.skinIndices[i],
                                    h = n > 1 ? e.skinIndices[i + 1] : 0,
                                    d = n > 2 ? e.skinIndices[i + 2] : 0,
                                    p = n > 3 ? e.skinIndices[i + 3] : 0;
                                t.skinIndices.push(new l(u, h, d, p))
                            }
                        t.bones = e.bones, t.bones && t.bones.length > 0 && (t.skinWeights.length !== t.skinIndices.length || t.skinIndices.length !== t.vertices.length) && console.warn("When skinning, number of vertices (" + t.vertices.length + "), skinIndices (" + t.skinIndices.length + "), and skinWeights (" + t.skinWeights.length + ") should match.")
                    }

                    function i(e, t) {
                        var n = e.scale;
                        if (void 0 !== e.morphTargets)
                            for (var i = 0, r = e.morphTargets.length; i < r; i++) {
                                t.morphTargets[i] = {}, t.morphTargets[i].name = e.morphTargets[i].name, t.morphTargets[i].vertices = [];
                                for (var o = t.morphTargets[i].vertices, s = e.morphTargets[i].vertices, l = 0, c = s.length; l < c; l += 3) {
                                    var u = new a;
                                    u.x = s[l] * n, u.y = s[l + 1] * n, u.z = s[l + 2] * n, o.push(u)
                                }
                            }
                        if (void 0 !== e.morphColors && e.morphColors.length > 0) {
                            console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                            for (var h = t.faces, d = e.morphColors[0].colors, i = 0, r = h.length; i < r; i++) h[i].color.fromArray(d, 3 * i)
                        }
                    }

                    function r(e, t) {
                        var n = [],
                            i = [];
                        void 0 !== e.animation && i.push(e.animation), void 0 !== e.animations && (e.animations.length ? i = i.concat(e.animations) : i.push(e.animations));
                        for (var r = 0; r < i.length; r++) {
                            var a = ki.parseAnimation(i[r], t.bones);
                            a && n.push(a)
                        }
                        if (t.morphTargets) {
                            var o = ki.CreateClipsFromMorphTargetSequences(t.morphTargets, 10);
                            n = n.concat(o)
                        }
                        n.length > 0 && (t.animations = n)
                    }
                    return function (n, a) {
                        void 0 !== n.data && (n = n.data), void 0 !== n.scale ? n.scale = 1 / n.scale : n.scale = 1;
                        var o = new M;
                        if (e(n, o), t(n, o), i(n, o), r(n, o), o.computeFaceNormals(), o.computeBoundingSphere(), void 0 === n.materials || 0 === n.materials.length) return {
                            geometry: o
                        };
                        var s = Ar.prototype.initMaterials(n.materials, this.resourcePath || a, this.crossOrigin);
                        return {
                            geometry: o,
                            materials: s
                        }
                    }
                }()
            }), Object.assign(Rr.prototype, {
                crossOrigin: "anonymous",
                load: function (e, t, n, i) {
                    var r = this,
                        a = void 0 === this.path ? Bh.extractUrlBase(e) : this.path;
                    this.resourcePath = this.resourcePath || a;
                    var o = new Ni(r.manager);
                    o.setPath(this.path), o.load(e, function (n) {
                        var a = null;
                        try {
                            a = JSON.parse(n)
                        } catch (o) {
                            return void 0 !== i && i(o), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", o.message)
                        }
                        var s = a.metadata;
                        return void 0 === s || void 0 === s.type || "geometry" === s.type.toLowerCase() ? void console.error("THREE.ObjectLoader: Can't load " + e + ". Use THREE.JSONLoader instead.") : void r.parse(a, t)
                    }, n, i)
                },
                setPath: function (e) {
                    return this.path = e, this
                },
                setResourcePath: function (e) {
                    return this.resourcePath = e, this
                },
                setCrossOrigin: function (e) {
                    return this.crossOrigin = e, this
                },
                parse: function (e, t) {
                    var n = this.parseShape(e.shapes),
                        i = this.parseGeometries(e.geometries, n),
                        r = this.parseImages(e.images, function () {
                            void 0 !== t && t(s)
                        }),
                        a = this.parseTextures(e.textures, r),
                        o = this.parseMaterials(e.materials, a),
                        s = this.parseObject(e.object, i, o);
                    return e.animations && (s.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 !== t && t(s), s
                },
                parseShape: function (e) {
                    var t = {};
                    if (void 0 !== e)
                        for (var n = 0, i = e.length; n < i; n++) {
                            var r = (new mr).fromJSON(e[n]);
                            t[r.uuid] = r
                        }
                    return t
                },
                parseGeometries: function (e, t) {
                    var n = {};
                    if (void 0 !== e)
                        for (var i = new Lr, r = new Cr, a = 0, o = e.length; a < o; a++) {
                            var s, l = e[a];
                            switch (l.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    s = new Sh[l.type](l.width, l.height, l.widthSegments, l.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    s = new Sh[l.type](l.width, l.height, l.depth, l.widthSegments, l.heightSegments, l.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    s = new Sh[l.type](l.radius, l.segments, l.thetaStart, l.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    s = new Sh[l.type](l.radiusTop, l.radiusBottom, l.height, l.radialSegments, l.heightSegments, l.openEnded, l.thetaStart, l.thetaLength);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    s = new Sh[l.type](l.radius, l.height, l.radialSegments, l.heightSegments, l.openEnded, l.thetaStart, l.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    s = new Sh[l.type](l.radius, l.widthSegments, l.heightSegments, l.phiStart, l.phiLength, l.thetaStart, l.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                case "DodecahedronBufferGeometry":
                                case "IcosahedronGeometry":
                                case "IcosahedronBufferGeometry":
                                case "OctahedronGeometry":
                                case "OctahedronBufferGeometry":
                                case "TetrahedronGeometry":
                                case "TetrahedronBufferGeometry":
                                    s = new Sh[l.type](l.radius, l.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    s = new Sh[l.type](l.innerRadius, l.outerRadius, l.thetaSegments, l.phiSegments, l.thetaStart, l.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    s = new Sh[l.type](l.radius, l.tube, l.radialSegments, l.tubularSegments, l.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    s = new Sh[l.type](l.radius, l.tube, l.tubularSegments, l.radialSegments, l.p, l.q);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    s = new Sh[l.type](l.points, l.segments, l.phiStart, l.phiLength);
                                    break;
                                case "PolyhedronGeometry":
                                case "PolyhedronBufferGeometry":
                                    s = new Sh[l.type](l.vertices, l.indices, l.radius, l.details);
                                    break;
                                case "ShapeGeometry":
                                case "ShapeBufferGeometry":
                                    for (var c = [], u = 0, h = l.shapes.length; u < h; u++) {
                                        var d = t[l.shapes[u]];
                                        c.push(d)
                                    }
                                    s = new Sh[l.type](c, l.curveSegments);
                                    break;
                                case "ExtrudeGeometry":
                                case "ExtrudeBufferGeometry":
                                    for (var c = [], u = 0, h = l.shapes.length; u < h; u++) {
                                        var d = t[l.shapes[u]];
                                        c.push(d)
                                    }
                                    var p = l.options.extrudePath;
                                    void 0 !== p && (l.options.extrudePath = (new zh[p.type]).fromJSON(p)), s = new Sh[l.type](c, l.options);
                                    break;
                                case "BufferGeometry":
                                    s = r.parse(l);
                                    break;
                                case "Geometry":
                                    s = i.parse(l, this.resourcePath).geometry;
                                    break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + l.type + '"');
                                    continue
                            }
                            s.uuid = l.uuid, void 0 !== l.name && (s.name = l.name), s.isBufferGeometry === !0 && void 0 !== l.userData && (s.userData = l.userData), n[l.uuid] = s
                        }
                    return n
                },
                parseMaterials: function (e, t) {
                    var n = {},
                        i = {};
                    if (void 0 !== e) {
                        var r = new Pr;
                        r.setTextures(t);
                        for (var a = 0, o = e.length; a < o; a++) {
                            var s = e[a];
                            if ("MultiMaterial" === s.type) {
                                for (var l = [], c = 0; c < s.materials.length; c++) {
                                    var u = s.materials[c];
                                    void 0 === n[u.uuid] && (n[u.uuid] = r.parse(u)), l.push(n[u.uuid])
                                }
                                i[s.uuid] = l
                            } else i[s.uuid] = r.parse(s), n[s.uuid] = i[s.uuid]
                        }
                    }
                    return i
                },
                parseAnimations: function (e) {
                    for (var t = [], n = 0; n < e.length; n++) {
                        var i = e[n],
                            r = ki.parse(i);
                        void 0 !== i.uuid && (r.uuid = i.uuid), t.push(r)
                    }
                    return t
                },
                parseImages: function (e, t) {
                    function n(e) {
                        return i.manager.itemStart(e), o.load(e, function () {
                            i.manager.itemEnd(e)
                        }, void 0, function () {
                            i.manager.itemError(e), i.manager.itemEnd(e)
                        })
                    }
                    var i = this,
                        r = {};
                    if (void 0 !== e && e.length > 0) {
                        var a = new Bi(t),
                            o = new Gi(a);
                        o.setCrossOrigin(this.crossOrigin);
                        for (var s = 0, l = e.length; s < l; s++) {
                            var c = e[s],
                                u = c.url;
                            if (Array.isArray(u)) {
                                r[c.uuid] = [];
                                for (var h = 0, d = u.length; h < d; h++) {
                                    var p = u[h],
                                        f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : i.resourcePath + p;
                                    r[c.uuid].push(n(f))
                                }
                            } else {
                                var f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : i.resourcePath + c.url;
                                r[c.uuid] = n(f)
                            }
                        }
                    }
                    return r
                },
                parseTextures: function (e, t) {
                    function n(e, t) {
                        return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
                    }
                    var i = {};
                    if (void 0 !== e)
                        for (var r = 0, a = e.length; r < a; r++) {
                            var o = e[r];
                            void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), void 0 === t[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image);
                            var l;
                            l = Array.isArray(t[o.image]) ? new re(t[o.image]) : new s(t[o.image]), l.needsUpdate = !0, l.uuid = o.uuid, void 0 !== o.name && (l.name = o.name), void 0 !== o.mapping && (l.mapping = n(o.mapping, Uh)), void 0 !== o.offset && l.offset.fromArray(o.offset), void 0 !== o.repeat && l.repeat.fromArray(o.repeat), void 0 !== o.center && l.center.fromArray(o.center), void 0 !== o.rotation && (l.rotation = o.rotation), void 0 !== o.wrap && (l.wrapS = n(o.wrap[0], jh), l.wrapT = n(o.wrap[1], jh)), void 0 !== o.format && (l.format = o.format), void 0 !== o.minFilter && (l.minFilter = n(o.minFilter, Fh)), void 0 !== o.magFilter && (l.magFilter = n(o.magFilter, Fh)), void 0 !== o.anisotropy && (l.anisotropy = o.anisotropy), void 0 !== o.flipY && (l.flipY = o.flipY), i[o.uuid] = l
                        }
                    return i
                },
                parseObject: function (e, t, n) {
                    function i(e) {
                        return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e]
                    }

                    function r(e) {
                        if (void 0 !== e) {
                            if (Array.isArray(e)) {
                                for (var t = [], i = 0, r = e.length; i < r; i++) {
                                    var a = e[i];
                                    void 0 === n[a] && console.warn("THREE.ObjectLoader: Undefined material", a), t.push(n[a])
                                }
                                return t
                            }
                            return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e), n[e]
                        }
                    }
                    var a;
                    switch (e.type) {
                        case "Scene":
                            a = new Lt, void 0 !== e.background && Number.isInteger(e.background) && (a.background = new v(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? a.fog = new At(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (a.fog = new Ct(e.fog.color, e.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            a = new wt(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (a.focus = e.focus), void 0 !== e.zoom && (a.zoom = e.zoom), void 0 !== e.filmGauge && (a.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (a.filmOffset = e.filmOffset), void 0 !== e.view && (a.view = Object.assign({}, e.view));
                            break;
                        case "OrthographicCamera":
                            a = new wr(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (a.zoom = e.zoom), void 0 !== e.view && (a.view = Object.assign({}, e.view));
                            break;
                        case "AmbientLight":
                            a = new Er(e.color, e.intensity);
                            break;
                        case "DirectionalLight":
                            a = new Tr(e.color, e.intensity);
                            break;
                        case "PointLight":
                            a = new _r(e.color, e.intensity, e.distance, e.decay);
                            break;
                        case "RectAreaLight":
                            a = new Sr(e.color, e.intensity, e.width, e.height);
                            break;
                        case "SpotLight":
                            a = new br(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                            break;
                        case "HemisphereLight":
                            a = new gr(e.color, e.groundColor, e.intensity);
                            break;
                        case "SkinnedMesh":
                            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                        case "Mesh":
                            var o = i(e.geometry),
                                s = r(e.material);
                            a = o.bones && o.bones.length > 0 ? new Nt(o, s) : new q(o, s);
                            break;
                        case "LOD":
                            a = new Dt;
                            break;
                        case "Line":
                            a = new jt(i(e.geometry), r(e.material), e.mode);
                            break;
                        case "LineLoop":
                            a = new Gt(i(e.geometry), r(e.material));
                            break;
                        case "LineSegments":
                            a = new Ft(i(e.geometry), r(e.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            a = new Vt(i(e.geometry), r(e.material));
                            break;
                        case "Sprite":
                            a = new kt(r(e.material));
                            break;
                        case "Group":
                            a = new bt;
                            break;
                        default:
                            a = new w
                    }
                    if (a.uuid = e.uuid, void 0 !== e.name && (a.name = e.name), void 0 !== e.matrix ? (a.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (a.matrixAutoUpdate = e.matrixAutoUpdate), a.matrixAutoUpdate && a.matrix.decompose(a.position, a.quaternion, a.scale)) : (void 0 !== e.position && a.position.fromArray(e.position), void 0 !== e.rotation && a.rotation.fromArray(e.rotation), void 0 !== e.quaternion && a.quaternion.fromArray(e.quaternion), void 0 !== e.scale && a.scale.fromArray(e.scale)), void 0 !== e.castShadow && (a.castShadow = e.castShadow), void 0 !== e.receiveShadow && (a.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (a.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (a.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && a.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (a.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (a.visible = e.visible), void 0 !== e.frustumCulled && (a.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (a.renderOrder = e.renderOrder), void 0 !== e.userData && (a.userData = e.userData), void 0 !== e.layers && (a.layers.mask = e.layers), void 0 !== e.children)
                        for (var l = e.children, c = 0; c < l.length; c++) a.add(this.parseObject(l[c], t, n));
                    if ("LOD" === e.type)
                        for (var u = e.levels, h = 0; h < u.length; h++) {
                            var d = u[h],
                                p = a.getObjectByProperty("uuid", d.object);
                            void 0 !== p && a.addLevel(p, d.distance)
                        }
                    return a
                }
            });
            var Uh = {
                    UVMapping: cs,
                    CubeReflectionMapping: us,
                    CubeRefractionMapping: hs,
                    EquirectangularReflectionMapping: ds,
                    EquirectangularRefractionMapping: ps,
                    SphericalReflectionMapping: fs,
                    CubeUVReflectionMapping: ms,
                    CubeUVRefractionMapping: vs
                },
                jh = {
                    RepeatWrapping: gs,
                    ClampToEdgeWrapping: ys,
                    MirroredRepeatWrapping: xs
                },
                Fh = {
                    NearestFilter: bs,
                    NearestMipMapNearestFilter: _s,
                    NearestMipMapLinearFilter: ws,
                    LinearFilter: Ms,
                    LinearMipMapNearestFilter: Ts,
                    LinearMipMapLinearFilter: Es
                };
            Ir.prototype = {
                constructor: Ir,
                setOptions: function (e) {
                    return this.options = e, this
                },
                load: function (e, t, n, i) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    var r = this,
                        a = Ah.get(e);
                    return void 0 !== a ? (r.manager.itemStart(e), setTimeout(function () {
                        t && t(a), r.manager.itemEnd(e)
                    }, 0), a) : void fetch(e).then(function (e) {
                        return e.blob()
                    }).then(function (e) {
                        return createImageBitmap(e, r.options)
                    }).then(function (n) {
                        Ah.add(e, n), t && t(n), r.manager.itemEnd(e)
                    })["catch"](function (t) {
                        i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
                    })
                },
                setCrossOrigin: function () {
                    return this
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }, Object.assign(Or.prototype, {
                moveTo: function (e, t) {
                    this.currentPath = new fr, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t)
                },
                lineTo: function (e, t) {
                    this.currentPath.lineTo(e, t)
                },
                quadraticCurveTo: function (e, t, n, i) {
                    this.currentPath.quadraticCurveTo(e, t, n, i)
                },
                bezierCurveTo: function (e, t, n, i, r, a) {
                    this.currentPath.bezierCurveTo(e, t, n, i, r, a)
                },
                splineThru: function (e) {
                    this.currentPath.splineThru(e)
                },
                toShapes: function (e, t) {
                    function n(e) {
                        for (var t = [], n = 0, i = e.length; n < i; n++) {
                            var r = e[n],
                                a = new mr;
                            a.curves = r.curves, t.push(a)
                        }
                        return t
                    }

                    function i(e, t) {
                        for (var n = t.length, i = !1, r = n - 1, a = 0; a < n; r = a++) {
                            var o = t[r],
                                s = t[a],
                                l = s.x - o.x,
                                c = s.y - o.y;
                            if (Math.abs(c) > Number.EPSILON) {
                                if (c < 0 && (o = t[a], l = -l, s = t[r], c = -c), e.y < o.y || e.y > s.y) continue;
                                if (e.y === o.y) {
                                    if (e.x === o.x) return !0
                                } else {
                                    var u = c * (e.x - o.x) - l * (e.y - o.y);
                                    if (0 === u) return !0;
                                    if (u < 0) continue;
                                    i = !i
                                }
                            } else {
                                if (e.y !== o.y) continue;
                                if (s.x <= e.x && e.x <= o.x || o.x <= e.x && e.x <= s.x) return !0
                            }
                        }
                        return i
                    }
                    var r = Th.isClockWise,
                        a = this.subPaths;
                    if (0 === a.length) return [];
                    if (t === !0) return n(a);
                    var o, s, l, c = [];
                    if (1 === a.length) return s = a[0], l = new mr, l.curves = s.curves, c.push(l), c;
                    var u = !r(a[0].getPoints());
                    u = e ? !u : u;
                    var h, d = [],
                        p = [],
                        f = [],
                        m = 0;
                    p[m] = void 0, f[m] = [];
                    for (var v = 0, g = a.length; v < g; v++) s = a[v], h = s.getPoints(), o = r(h), o = e ? !o : o, o ? (!u && p[m] && m++, p[m] = {
                        s: new mr,
                        p: h
                    }, p[m].s.curves = s.curves, u && m++, f[m] = []) : f[m].push({
                        h: s,
                        p: h[0]
                    });
                    if (!p[0]) return n(a);
                    if (p.length > 1) {
                        for (var y = !1, x = [], b = 0, _ = p.length; b < _; b++) d[b] = [];
                        for (var b = 0, _ = p.length; b < _; b++)
                            for (var w = f[b], M = 0; M < w.length; M++) {
                                for (var T = w[M], E = !0, S = 0; S < p.length; S++) i(T.p, p[S].p) && (b !== S && x.push({
                                    froms: b,
                                    tos: S,
                                    hole: M
                                }), E ? (E = !1, d[S].push(T)) : y = !0);
                                E && d[b].push(T)
                            }
                        x.length > 0 && (y || (f = d))
                    }
                    for (var P, v = 0, C = p.length; v < C; v++) {
                        l = p[v].s, c.push(l), P = f[v];
                        for (var A = 0, L = P.length; A < L; A++) l.holes.push(P[A].h)
                    }
                    return c
                }
            }), Object.assign(kr.prototype, {
                isFont: !0,
                generateShapes: function (e, t) {
                    void 0 === t && (t = 100);
                    for (var n = [], i = Dr(e, t, this.data), r = 0, a = i.length; r < a; r++) Array.prototype.push.apply(n, i[r].toShapes());
                    return n
                }
            }), Object.assign(Br.prototype, {
                load: function (e, t, n, i) {
                    var r = this,
                        a = new Ni(this.manager);
                    a.setPath(this.path), a.load(e, function (e) {
                        var n;
                        try {
                            n = JSON.parse(e)
                        } catch (i) {
                            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(e.substring(65, e.length - 2))
                        }
                        var a = r.parse(n);
                        t && t(a)
                    }, n, i)
                },
                parse: function (e) {
                    return new kr(e)
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            });
            var Gh, Hh = {
                getContext: function () {
                    return void 0 === Gh && (Gh = new(window.AudioContext || window.webkitAudioContext)), Gh
                },
                setContext: function (e) {
                    Gh = e
                }
            };
            Object.assign(Nr.prototype, {
                load: function (e, t, n, i) {
                    var r = new Ni(this.manager);
                    r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(e, function (e) {
                        var n = e.slice(0),
                            i = Hh.getContext();
                        i.decodeAudioData(n, function (e) {
                            t(e)
                        })
                    }, n, i)
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }), Object.assign(Ur.prototype, {
                update: function () {
                    var e, t, n, r, a, o, s, l, c = new i,
                        u = new i;
                    return function (i) {
                        var h = e !== this || t !== i.focus || n !== i.fov || r !== i.aspect * this.aspect || a !== i.near || o !== i.far || s !== i.zoom || l !== this.eyeSep;
                        if (h) {
                            e = this, t = i.focus, n = i.fov, r = i.aspect * this.aspect, a = i.near, o = i.far, s = i.zoom;
                            var d = i.projectionMatrix.clone();
                            l = this.eyeSep / 2;
                            var p, f, m = l * a / t,
                                v = a * Math.tan(jl.DEG2RAD * n * .5) / s;
                            u.elements[12] = -l, c.elements[12] = l, p = -v * r + m, f = v * r + m, d.elements[0] = 2 * a / (f - p), d.elements[8] = (f + p) / (f - p), this.cameraL.projectionMatrix.copy(d), p = -v * r - m, f = v * r - m, d.elements[0] = 2 * a / (f - p), d.elements[8] = (f + p) / (f - p), this.cameraR.projectionMatrix.copy(d)
                        }
                        this.cameraL.matrixWorld.copy(i.matrixWorld).multiply(u), this.cameraR.matrixWorld.copy(i.matrixWorld).multiply(c)
                    }
                }()
            }), jr.prototype = Object.create(w.prototype), jr.prototype.constructor = jr, Object.assign(Fr.prototype, {
                start: function () {
                    this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                },
                stop: function () {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                },
                getElapsedTime: function () {
                    return this.getDelta(), this.elapsedTime
                },
                getDelta: function () {
                    var e = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        var t = ("undefined" == typeof performance ? Date : performance).now();
                        e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
                    }
                    return e
                }
            }), Gr.prototype = Object.assign(Object.create(w.prototype), {
                constructor: Gr,
                getInput: function () {
                    return this.gain
                },
                removeFilter: function () {
                    return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                },
                getFilter: function () {
                    return this.filter
                },
                setFilter: function (e) {
                    return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                },
                getMasterVolume: function () {
                    return this.gain.gain.value
                },
                setMasterVolume: function (e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                },
                updateMatrixWorld: function () {
                    var e = new a,
                        t = new r,
                        n = new a,
                        i = new a,
                        o = new Fr;
                    return function (r) {
                        w.prototype.updateMatrixWorld.call(this, r);
                        var a = this.context.listener,
                            s = this.up;
                        if (this.timeDelta = o.getDelta(), this.matrixWorld.decompose(e, t, n), i.set(0, 0, -1).applyQuaternion(t), a.positionX) {
                            var l = this.context.currentTime + this.timeDelta;
                            a.positionX.linearRampToValueAtTime(e.x, l), a.positionY.linearRampToValueAtTime(e.y, l), a.positionZ.linearRampToValueAtTime(e.z, l), a.forwardX.linearRampToValueAtTime(i.x, l), a.forwardY.linearRampToValueAtTime(i.y, l), a.forwardZ.linearRampToValueAtTime(i.z, l), a.upX.linearRampToValueAtTime(s.x, l), a.upY.linearRampToValueAtTime(s.y, l), a.upZ.linearRampToValueAtTime(s.z, l)
                        } else a.setPosition(e.x, e.y, e.z), a.setOrientation(i.x, i.y, i.z, s.x, s.y, s.z)
                    }
                }()
            }), Hr.prototype = Object.assign(Object.create(w.prototype), {
                constructor: Hr,
                getOutput: function () {
                    return this.gain
                },
                setNodeSource: function (e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
                },
                setMediaElementSource: function (e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
                },
                setBuffer: function (e) {
                    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
                },
                play: function () {
                    if (this.isPlaying === !0) return void console.warn("THREE.Audio: Audio is already playing.");
                    if (this.hasPlaybackControl === !1) return void console.warn("THREE.Audio: this Audio has no playback control.");
                    var e = this.context.createBufferSource();
                    return e.buffer = this.buffer, e.loop = this.loop, e.onended = this.onEnded.bind(this), e.playbackRate.setValueAtTime(this.playbackRate, this.startTime), this.startTime = this.context.currentTime, e.start(this.startTime, this.offset), this.isPlaying = !0, this.source = e, this.connect()
                },
                pause: function () {
                    return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.isPlaying === !0 && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this)
                },
                stop: function () {
                    return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this)
                },
                connect: function () {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this
                },
                disconnect: function () {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this
                },
                getFilters: function () {
                    return this.filters
                },
                setFilters: function (e) {
                    return e || (e = []), this.isPlaying === !0 ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this
                },
                getFilter: function () {
                    return this.getFilters()[0]
                },
                setFilter: function (e) {
                    return this.setFilters(e ? [e] : [])
                },
                setPlaybackRate: function (e) {
                    return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this)
                },
                getPlaybackRate: function () {
                    return this.playbackRate
                },
                onEnded: function () {
                    this.isPlaying = !1
                },
                getLoop: function () {
                    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                },
                setLoop: function (e) {
                    return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this)
                },
                getVolume: function () {
                    return this.gain.gain.value
                },
                setVolume: function (e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                }
            }), Vr.prototype = Object.assign(Object.create(Hr.prototype), {
                constructor: Vr,
                getOutput: function () {
                    return this.panner
                },
                getRefDistance: function () {
                    return this.panner.refDistance
                },
                setRefDistance: function (e) {
                    return this.panner.refDistance = e, this
                },
                getRolloffFactor: function () {
                    return this.panner.rolloffFactor
                },
                setRolloffFactor: function (e) {
                    return this.panner.rolloffFactor = e, this
                },
                getDistanceModel: function () {
                    return this.panner.distanceModel
                },
                setDistanceModel: function (e) {
                    return this.panner.distanceModel = e, this
                },
                getMaxDistance: function () {
                    return this.panner.maxDistance
                },
                setMaxDistance: function (e) {
                    return this.panner.maxDistance = e, this
                },
                setDirectionalCone: function (e, t, n) {
                    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this
                },
                updateMatrixWorld: function () {
                    var e = new a,
                        t = new r,
                        n = new a,
                        i = new a;
                    return function (r) {
                        w.prototype.updateMatrixWorld.call(this, r);
                        var a = this.panner;
                        if (this.matrixWorld.decompose(e, t, n), i.set(0, 0, 1).applyQuaternion(t), a.positionX) {
                            var o = this.context.currentTime + this.listener.timeDelta;
                            a.positionX.linearRampToValueAtTime(e.x, o), a.positionY.linearRampToValueAtTime(e.y, o), a.positionZ.linearRampToValueAtTime(e.z, o), a.orientationX.linearRampToValueAtTime(i.x, o), a.orientationY.linearRampToValueAtTime(i.y, o), a.orientationZ.linearRampToValueAtTime(i.z, o)
                        } else a.setPosition(e.x, e.y, e.z), a.setOrientation(i.x, i.y, i.z)
                    }
                }()
            }), Object.assign(Wr.prototype, {
                getFrequencyData: function () {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                },
                getAverageFrequency: function () {
                    for (var e = 0, t = this.getFrequencyData(), n = 0; n < t.length; n++) e += t[n];
                    return e / t.length
                }
            }), Object.assign(qr.prototype, {
                accumulate: function (e, t) {
                    var n = this.buffer,
                        i = this.valueSize,
                        r = e * i + i,
                        a = this.cumulativeWeight;
                    if (0 === a) {
                        for (var o = 0; o !== i; ++o) n[r + o] = n[o];
                        a = t
                    } else {
                        a += t;
                        var s = t / a;
                        this._mixBufferRegion(n, r, 0, s, i)
                    }
                    this.cumulativeWeight = a
                },
                apply: function (e) {
                    var t = this.valueSize,
                        n = this.buffer,
                        i = e * t + t,
                        r = this.cumulativeWeight,
                        a = this.binding;
                    if (this.cumulativeWeight = 0, r < 1) {
                        var o = 3 * t;
                        this._mixBufferRegion(n, i, o, 1 - r, t)
                    }
                    for (var s = t, l = t + t; s !== l; ++s)
                        if (n[s] !== n[s + t]) {
                            a.setValue(n, i);
                            break
                        }
                },
                saveOriginalState: function () {
                    var e = this.binding,
                        t = this.buffer,
                        n = this.valueSize,
                        i = 3 * n;
                    e.getValue(t, i);
                    for (var r = n, a = i; r !== a; ++r) t[r] = t[i + r % n];
                    this.cumulativeWeight = 0
                },
                restoreOriginalState: function () {
                    var e = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, e)
                },
                _select: function (e, t, n, i, r) {
                    if (i >= .5)
                        for (var a = 0; a !== r; ++a) e[t + a] = e[n + a]
                },
                _slerp: function (e, t, n, i) {
                    r.slerpFlat(e, t, e, t, e, n, i)
                },
                _lerp: function (e, t, n, i, r) {
                    for (var a = 1 - i, o = 0; o !== r; ++o) {
                        var s = t + o;
                        e[s] = e[s] * a + e[n + o] * i
                    }
                }
            });
            var Vh = "\\[\\]\\.:\\/";
            Object.assign(Xr.prototype, {
                getValue: function (e, t) {
                    this.bind();
                    var n = this._targetGroup.nCachedObjects_,
                        i = this._bindings[n];
                    void 0 !== i && i.getValue(e, t)
                },
                setValue: function (e, t) {
                    for (var n = this._bindings, i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(e, t)
                },
                bind: function () {
                    for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
                },
                unbind: function () {
                    for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
                }
            }), Object.assign(Yr, {
                Composite: Xr,
                create: function (e, t, n) {
                    return e && e.isAnimationObjectGroup ? new Yr.Composite(e, t, n) : new Yr(e, t, n)
                },
                sanitizeNodeName: function () {
                    var e = new RegExp("[" + Vh + "]", "g");
                    return function (t) {
                        return t.replace(/\s/g, "_").replace(e, "")
                    }
                }(),
                parseTrackName: function () {
                    var e = "[^" + Vh + "]",
                        t = "[^" + Vh.replace("\\.", "") + "]",
                        n = /((?:WC+[\/:])*)/.source.replace("WC", e),
                        i = /(WCOD+)?/.source.replace("WCOD", t),
                        r = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", e),
                        a = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", e),
                        o = new RegExp("^" + n + i + r + a + "$"),
                        s = ["material", "materials", "bones"];
                    return function (e) {
                        var t = o.exec(e);
                        if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                        var n = {
                                nodeName: t[2],
                                objectName: t[3],
                                objectIndex: t[4],
                                propertyName: t[5],
                                propertyIndex: t[6]
                            },
                            i = n.nodeName && n.nodeName.lastIndexOf(".");
                        if (void 0 !== i && i !== -1) {
                            var r = n.nodeName.substring(i + 1);
                            s.indexOf(r) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = r)
                        }
                        if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                        return n
                    }
                }(),
                findNode: function (e, t) {
                    if (!t || "" === t || "root" === t || "." === t || t === -1 || t === e.name || t === e.uuid) return e;
                    if (e.skeleton) {
                        var n = e.skeleton.getBoneByName(t);
                        if (void 0 !== n) return n
                    }
                    if (e.children) {
                        var i = function (e) {
                                for (var n = 0; n < e.length; n++) {
                                    var r = e[n];
                                    if (r.name === t || r.uuid === t) return r;
                                    var a = i(r.children);
                                    if (a) return a
                                }
                                return null
                            },
                            r = i(e.children);
                        if (r) return r
                    }
                    return null
                }
            }), Object.assign(Yr.prototype, {
                _getValue_unavailable: function () {},
                _setValue_unavailable: function () {},
                BindingType: {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                Versioning: {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                GetterByBindingType: [function (e, t) {
                    e[t] = this.node[this.propertyName]
                }, function (e, t) {
                    for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) e[t++] = n[i]
                }, function (e, t) {
                    e[t] = this.resolvedProperty[this.propertyIndex]
                }, function (e, t) {
                    this.resolvedProperty.toArray(e, t)
                }],
                SetterByBindingTypeAndVersioning: [
                    [function (e, t) {
                        this.targetObject[this.propertyName] = e[t]
                    }, function (e, t) {
                        this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
                    }, function (e, t) {
                        this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function (e, t) {
                        for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = e[t++]
                    }, function (e, t) {
                        for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                        this.targetObject.needsUpdate = !0
                    }, function (e, t) {
                        for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function (e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t]
                    }, function (e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
                    }, function (e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function (e, t) {
                        this.resolvedProperty.fromArray(e, t)
                    }, function (e, t) {
                        this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
                    }, function (e, t) {
                        this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
                    }]
                ],
                getValue: function (e, t) {
                    this.bind(), this.getValue(e, t)
                },
                setValue: function (e, t) {
                    this.bind(), this.setValue(e, t)
                },
                bind: function () {
                    var e = this.node,
                        t = this.parsedPath,
                        n = t.objectName,
                        i = t.propertyName,
                        r = t.propertyIndex;
                    if (e || (e = Yr.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                    if (n) {
                        var a = t.objectIndex;
                        switch (n) {
                            case "materials":
                                if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                e = e.material.materials;
                                break;
                            case "bones":
                                if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                e = e.skeleton.bones;
                                for (var o = 0; o < e.length; o++)
                                    if (e[o].name === a) {
                                        a = o;
                                        break
                                    } break;
                            default:
                                if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                e = e[n]
                        }
                        if (void 0 !== a) {
                            if (void 0 === e[a]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                            e = e[a]
                        }
                    }
                    var s = e[i];
                    if (void 0 === s) {
                        var l = t.nodeName;
                        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + i + " but it wasn't found.", e)
                    }
                    var c = this.Versioning.None;
                    this.targetObject = e, void 0 !== e.needsUpdate ? c = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate);
                    var u = this.BindingType.Direct;
                    if (void 0 !== r) {
                        if ("morphTargetInfluences" === i) {
                            if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (e.geometry.isBufferGeometry) {
                                if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                for (var o = 0; o < this.node.geometry.morphAttributes.position.length; o++)
                                    if (e.geometry.morphAttributes.position[o].name === r) {
                                        r = o;
                                        break
                                    }
                            } else {
                                if (!e.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                for (var o = 0; o < this.node.geometry.morphTargets.length; o++)
                                    if (e.geometry.morphTargets[o].name === r) {
                                        r = o;
                                        break
                                    }
                            }
                        }
                        u = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                    } else void 0 !== s.fromArray && void 0 !== s.toArray ? (u = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (u = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                    this.getValue = this.GetterByBindingType[u], this.setValue = this.SetterByBindingTypeAndVersioning[u][c]
                },
                unbind: function () {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }), Object.assign(Yr.prototype, {
                _getValue_unbound: Yr.prototype.getValue,
                _setValue_unbound: Yr.prototype.setValue
            }), Object.assign(Zr.prototype, {
                isAnimationObjectGroup: !0,
                add: function () {
                    for (var e = this._objects, t = e.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._paths, a = this._parsedPaths, o = this._bindings, s = o.length, l = void 0, c = 0, u = arguments.length; c !== u; ++c) {
                        var h = arguments[c],
                            d = h.uuid,
                            p = i[d];
                        if (void 0 === p) {
                            p = t++, i[d] = p, e.push(h);
                            for (var f = 0, m = s; f !== m; ++f) o[f].push(new Yr(h, r[f], a[f]))
                        } else if (p < n) {
                            l = e[p];
                            var v = --n,
                                g = e[v];
                            i[g.uuid] = p, e[p] = g, i[d] = v, e[v] = h;
                            for (var f = 0, m = s; f !== m; ++f) {
                                var y = o[f],
                                    x = y[v],
                                    b = y[p];
                                y[p] = x, void 0 === b && (b = new Yr(h, r[f], a[f])), y[v] = b
                            }
                        } else e[p] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                    }
                    this.nCachedObjects_ = n
                },
                remove: function () {
                    for (var e = this._objects, t = this.nCachedObjects_, n = this._indicesByUUID, i = this._bindings, r = i.length, a = 0, o = arguments.length; a !== o; ++a) {
                        var s = arguments[a],
                            l = s.uuid,
                            c = n[l];
                        if (void 0 !== c && c >= t) {
                            var u = t++,
                                h = e[u];
                            n[h.uuid] = c, e[c] = h, n[l] = u, e[u] = s;
                            for (var d = 0, p = r; d !== p; ++d) {
                                var f = i[d],
                                    m = f[u],
                                    v = f[c];
                                f[c] = m, f[u] = v
                            }
                        }
                    }
                    this.nCachedObjects_ = t
                },
                uncache: function () {
                    for (var e = this._objects, t = e.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._bindings, a = r.length, o = 0, s = arguments.length; o !== s; ++o) {
                        var l = arguments[o],
                            c = l.uuid,
                            u = i[c];
                        if (void 0 !== u)
                            if (delete i[c], u < n) {
                                var h = --n,
                                    d = e[h],
                                    p = --t,
                                    f = e[p];
                                i[d.uuid] = u, e[u] = d, i[f.uuid] = h, e[h] = f, e.pop();
                                for (var m = 0, v = a; m !== v; ++m) {
                                    var g = r[m],
                                        y = g[h],
                                        x = g[p];
                                    g[u] = y, g[h] = x, g.pop()
                                }
                            } else {
                                var p = --t,
                                    f = e[p];
                                i[f.uuid] = u, e[u] = f, e.pop();
                                for (var m = 0, v = a; m !== v; ++m) {
                                    var g = r[m];
                                    g[u] = g[p], g.pop()
                                }
                            }
                    }
                    this.nCachedObjects_ = n
                },
                subscribe_: function (e, t) {
                    var n = this._bindingsIndicesByPath,
                        i = n[e],
                        r = this._bindings;
                    if (void 0 !== i) return r[i];
                    var a = this._paths,
                        o = this._parsedPaths,
                        s = this._objects,
                        l = s.length,
                        c = this.nCachedObjects_,
                        u = new Array(l);
                    i = r.length, n[e] = i, a.push(e), o.push(t), r.push(u);
                    for (var h = c, d = s.length; h !== d; ++h) {
                        var p = s[h];
                        u[h] = new Yr(p, e, t)
                    }
                    return u
                },
                unsubscribe_: function (e) {
                    var t = this._bindingsIndicesByPath,
                        n = t[e];
                    if (void 0 !== n) {
                        var i = this._paths,
                            r = this._parsedPaths,
                            a = this._bindings,
                            o = a.length - 1,
                            s = a[o],
                            l = e[o];
                        t[l] = n, a[n] = s, a.pop(), r[n] = r[o], r.pop(), i[n] = i[o], i.pop()
                    }
                }
            }), Object.assign(Jr.prototype, {
                play: function () {
                    return this._mixer._activateAction(this), this
                },
                stop: function () {
                    return this._mixer._deactivateAction(this), this.reset()
                },
                reset: function () {
                    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                },
                isRunning: function () {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                },
                isScheduled: function () {
                    return this._mixer._isActiveAction(this)
                },
                startAt: function (e) {
                    return this._startTime = e, this
                },
                setLoop: function (e, t) {
                    return this.loop = e, this.repetitions = t, this
                },
                setEffectiveWeight: function (e) {
                    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
                },
                getEffectiveWeight: function () {
                    return this._effectiveWeight
                },
                fadeIn: function (e) {
                    return this._scheduleFading(e, 0, 1)
                },
                fadeOut: function (e) {
                    return this._scheduleFading(e, 1, 0)
                },
                crossFadeFrom: function (e, t, n) {
                    if (e.fadeOut(t), this.fadeIn(t), n) {
                        var i = this._clip.duration,
                            r = e._clip.duration,
                            a = r / i,
                            o = i / r;
                        e.warp(1, a, t), this.warp(o, 1, t)
                    }
                    return this
                },
                crossFadeTo: function (e, t, n) {
                    return e.crossFadeFrom(this, t, n)
                },
                stopFading: function () {
                    var e = this._weightInterpolant;
                    return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                },
                setEffectiveTimeScale: function (e) {
                    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
                },
                getEffectiveTimeScale: function () {
                    return this._effectiveTimeScale
                },
                setDuration: function (e) {
                    return this.timeScale = this._clip.duration / e, this.stopWarping()
                },
                syncWith: function (e) {
                    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
                },
                halt: function (e) {
                    return this.warp(this._effectiveTimeScale, 0, e)
                },
                warp: function (e, t, n) {
                    var i = this._mixer,
                        r = i.time,
                        a = this._timeScaleInterpolant,
                        o = this.timeScale;
                    null === a && (a = i._lendControlInterpolant(), this._timeScaleInterpolant = a);
                    var s = a.parameterPositions,
                        l = a.sampleValues;
                    return s[0] = r, s[1] = r + n, l[0] = e / o, l[1] = t / o, this
                },
                stopWarping: function () {
                    var e = this._timeScaleInterpolant;
                    return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                },
                getMixer: function () {
                    return this._mixer
                },
                getClip: function () {
                    return this._clip
                },
                getRoot: function () {
                    return this._localRoot || this._mixer._root
                },
                _update: function (e, t, n, i) {
                    if (!this.enabled) return void this._updateWeight(e);
                    var r = this._startTime;
                    if (null !== r) {
                        var a = (e - r) * n;
                        if (a < 0 || 0 === n) return;
                        this._startTime = null, t = n * a
                    }
                    t *= this._updateTimeScale(e);
                    var o = this._updateTime(t),
                        s = this._updateWeight(e);
                    if (s > 0)
                        for (var l = this._interpolants, c = this._propertyBindings, u = 0, h = l.length; u !== h; ++u) l[u].evaluate(o), c[u].accumulate(i, s)
                },
                _updateWeight: function (e) {
                    var t = 0;
                    if (this.enabled) {
                        t = this.weight;
                        var n = this._weightInterpolant;
                        if (null !== n) {
                            var i = n.evaluate(e)[0];
                            t *= i, e > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = t, t
                },
                _updateTimeScale: function (e) {
                    var t = 0;
                    if (!this.paused) {
                        t = this.timeScale;
                        var n = this._timeScaleInterpolant;
                        if (null !== n) {
                            var i = n.evaluate(e)[0];
                            t *= i, e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
                        }
                    }
                    return this._effectiveTimeScale = t, t
                },
                _updateTime: function (e) {
                    var t = this.time + e,
                        n = this._clip.duration,
                        i = this.loop,
                        r = this._loopCount,
                        a = i === yl;
                    if (0 === e) return r === -1 ? t : a && 1 === (1 & r) ? n - t : t;
                    if (i === vl) {
                        r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                        e: {
                            if (t >= n) t = n;
                            else {
                                if (!(t < 0)) break e;
                                t = 0
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e < 0 ? -1 : 1
                            })
                        }
                    } else {
                        if (r === -1 && (e >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), t >= n || t < 0) {
                            var o = Math.floor(t / n);
                            t -= n * o, r += Math.abs(o);
                            var s = this.repetitions - r;
                            if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, t = e > 0 ? n : 0, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e > 0 ? 1 : -1
                            });
                            else {
                                if (1 === s) {
                                    var l = e < 0;
                                    this._setEndings(l, !l, a)
                                } else this._setEndings(!1, !1, a);
                                this._loopCount = r, this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: o
                                })
                            }
                        }
                        if (a && 1 === (1 & r)) return this.time = t, n - t
                    }
                    return this.time = t, t
                },
                _setEndings: function (e, t, n) {
                    var i = this._interpolantSettings;
                    n ? (i.endingStart = Ml, i.endingEnd = Ml) : (e ? i.endingStart = this.zeroSlopeAtStart ? Ml : wl : i.endingStart = Tl, t ? i.endingEnd = this.zeroSlopeAtEnd ? Ml : wl : i.endingEnd = Tl)
                },
                _scheduleFading: function (e, t, n) {
                    var i = this._mixer,
                        r = i.time,
                        a = this._weightInterpolant;
                    null === a && (a = i._lendControlInterpolant(), this._weightInterpolant = a);
                    var o = a.parameterPositions,
                        s = a.sampleValues;
                    return o[0] = r, s[0] = t, o[1] = r + e, s[1] = n, this
                }
            }), $r.prototype = Object.assign(Object.create(t.prototype), {
                constructor: $r,
                _bindAction: function (e, t) {
                    var n = e._localRoot || this._root,
                        i = e._clip.tracks,
                        r = i.length,
                        a = e._propertyBindings,
                        o = e._interpolants,
                        s = n.uuid,
                        l = this._bindingsByRootAndName,
                        c = l[s];
                    void 0 === c && (c = {}, l[s] = c);
                    for (var u = 0; u !== r; ++u) {
                        var h = i[u],
                            d = h.name,
                            p = c[d];
                        if (void 0 !== p) a[u] = p;
                        else {
                            if (p = a[u], void 0 !== p) {
                                null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, d));
                                continue
                            }
                            var f = t && t._propertyBindings[u].binding.parsedPath;
                            p = new qr(Yr.create(n, d, f), h.ValueTypeName, h.getValueSize()), ++p.referenceCount, this._addInactiveBinding(p, s, d), a[u] = p
                        }
                        o[u].resultBuffer = p.buffer
                    }
                },
                _activateAction: function (e) {
                    if (!this._isActiveAction(e)) {
                        if (null === e._cacheIndex) {
                            var t = (e._localRoot || this._root).uuid,
                                n = e._clip.uuid,
                                i = this._actionsByClip[n];
                            this._bindAction(e, i && i.knownActions[0]), this._addInactiveAction(e, n, t)
                        }
                        for (var r = e._propertyBindings, a = 0, o = r.length; a !== o; ++a) {
                            var s = r[a];
                            0 === s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                        }
                        this._lendAction(e)
                    }
                },
                _deactivateAction: function (e) {
                    if (this._isActiveAction(e)) {
                        for (var t = e._propertyBindings, n = 0, i = t.length; n !== i; ++n) {
                            var r = t[n];
                            0 === --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                        }
                        this._takeBackAction(e)
                    }
                },
                _initMemoryManager: function () {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    var e = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return e._actions.length
                            },
                            get inUse() {
                                return e._nActiveActions
                            }
                        },
                        bindings: {
                            get total() {
                                return e._bindings.length
                            },
                            get inUse() {
                                return e._nActiveBindings
                            }
                        },
                        controlInterpolants: {
                            get total() {
                                return e._controlInterpolants.length
                            },
                            get inUse() {
                                return e._nActiveControlInterpolants
                            }
                        }
                    }
                },
                _isActiveAction: function (e) {
                    var t = e._cacheIndex;
                    return null !== t && t < this._nActiveActions
                },
                _addInactiveAction: function (e, t, n) {
                    var i = this._actions,
                        r = this._actionsByClip,
                        a = r[t];
                    if (void 0 === a) a = {
                        knownActions: [e],
                        actionByRoot: {}
                    }, e._byClipCacheIndex = 0, r[t] = a;
                    else {
                        var o = a.knownActions;
                        e._byClipCacheIndex = o.length, o.push(e)
                    }
                    e._cacheIndex = i.length, i.push(e), a.actionByRoot[n] = e
                },
                _removeInactiveAction: function (e) {
                    var t = this._actions,
                        n = t[t.length - 1],
                        i = e._cacheIndex;
                    n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null;
                    var r = e._clip.uuid,
                        a = this._actionsByClip,
                        o = a[r],
                        s = o.knownActions,
                        l = s[s.length - 1],
                        c = e._byClipCacheIndex;
                    l._byClipCacheIndex = c, s[c] = l, s.pop(), e._byClipCacheIndex = null;
                    var u = o.actionByRoot,
                        h = (e._localRoot || this._root).uuid;
                    delete u[h], 0 === s.length && delete a[r], this._removeInactiveBindingsForAction(e)
                },
                _removeInactiveBindingsForAction: function (e) {
                    for (var t = e._propertyBindings, n = 0, i = t.length; n !== i; ++n) {
                        var r = t[n];
                        0 === --r.referenceCount && this._removeInactiveBinding(r)
                    }
                },
                _lendAction: function (e) {
                    var t = this._actions,
                        n = e._cacheIndex,
                        i = this._nActiveActions++,
                        r = t[i];
                    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
                },
                _takeBackAction: function (e) {
                    var t = this._actions,
                        n = e._cacheIndex,
                        i = --this._nActiveActions,
                        r = t[i];
                    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
                },
                _addInactiveBinding: function (e, t, n) {
                    var i = this._bindingsByRootAndName,
                        r = i[t],
                        a = this._bindings;
                    void 0 === r && (r = {}, i[t] = r), r[n] = e, e._cacheIndex = a.length, a.push(e)
                },
                _removeInactiveBinding: function (e) {
                    var t = this._bindings,
                        n = e.binding,
                        i = n.rootNode.uuid,
                        r = n.path,
                        a = this._bindingsByRootAndName,
                        o = a[i],
                        s = t[t.length - 1],
                        l = e._cacheIndex;
                    s._cacheIndex = l, t[l] = s, t.pop(), delete o[r];
                    e: {
                        for (var c in o) break e;delete a[i]
                    }
                },
                _lendBinding: function (e) {
                    var t = this._bindings,
                        n = e._cacheIndex,
                        i = this._nActiveBindings++,
                        r = t[i];
                    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
                },
                _takeBackBinding: function (e) {
                    var t = this._bindings,
                        n = e._cacheIndex,
                        i = --this._nActiveBindings,
                        r = t[i];
                    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
                },
                _lendControlInterpolant: function () {
                    var e = this._controlInterpolants,
                        t = this._nActiveControlInterpolants++,
                        n = e[t];
                    return void 0 === n && (n = new Ti(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = t, e[t] = n), n
                },
                _takeBackControlInterpolant: function (e) {
                    var t = this._controlInterpolants,
                        n = e.__cacheIndex,
                        i = --this._nActiveControlInterpolants,
                        r = t[i];
                    e.__cacheIndex = i, t[i] = e, r.__cacheIndex = n, t[n] = r
                },
                _controlInterpolantsResultBuffer: new Float32Array(1),
                clipAction: function (e, t) {
                    var n = t || this._root,
                        i = n.uuid,
                        r = "string" == typeof e ? ki.findByName(n, e) : e,
                        a = null !== r ? r.uuid : e,
                        o = this._actionsByClip[a],
                        s = null;
                    if (void 0 !== o) {
                        var l = o.actionByRoot[i];
                        if (void 0 !== l) return l;
                        s = o.knownActions[0], null === r && (r = s._clip)
                    }
                    if (null === r) return null;
                    var c = new Jr(this, r, t);
                    return this._bindAction(c, s), this._addInactiveAction(c, a, i), c
                },
                existingAction: function (e, t) {
                    var n = t || this._root,
                        i = n.uuid,
                        r = "string" == typeof e ? ki.findByName(n, e) : e,
                        a = r ? r.uuid : e,
                        o = this._actionsByClip[a];
                    return void 0 !== o ? o.actionByRoot[i] || null : null
                },
                stopAllAction: function () {
                    var e = this._actions,
                        t = this._nActiveActions,
                        n = this._bindings,
                        i = this._nActiveBindings;
                    this._nActiveActions = 0, this._nActiveBindings = 0;
                    for (var r = 0; r !== t; ++r) e[r].reset();
                    for (var r = 0; r !== i; ++r) n[r].useCount = 0;
                    return this
                },
                update: function (e) {
                    e *= this.timeScale;
                    for (var t = this._actions, n = this._nActiveActions, i = this.time += e, r = Math.sign(e), a = this._accuIndex ^= 1, o = 0; o !== n; ++o) {
                        var s = t[o];
                        s._update(i, e, r, a)
                    }
                    for (var l = this._bindings, c = this._nActiveBindings, o = 0; o !== c; ++o) l[o].apply(a);
                    return this
                },
                getRoot: function () {
                    return this._root
                },
                uncacheClip: function (e) {
                    var t = this._actions,
                        n = e.uuid,
                        i = this._actionsByClip,
                        r = i[n];
                    if (void 0 !== r) {
                        for (var a = r.knownActions, o = 0, s = a.length; o !== s; ++o) {
                            var l = a[o];
                            this._deactivateAction(l);
                            var c = l._cacheIndex,
                                u = t[t.length - 1];
                            l._cacheIndex = null, l._byClipCacheIndex = null, u._cacheIndex = c, t[c] = u, t.pop(), this._removeInactiveBindingsForAction(l)
                        }
                        delete i[n]
                    }
                },
                uncacheRoot: function (e) {
                    var t = e.uuid,
                        n = this._actionsByClip;
                    for (var i in n) {
                        var r = n[i].actionByRoot,
                            a = r[t];
                        void 0 !== a && (this._deactivateAction(a), this._removeInactiveAction(a))
                    }
                    var o = this._bindingsByRootAndName,
                        s = o[t];
                    if (void 0 !== s)
                        for (var l in s) {
                            var c = s[l];
                            c.restoreOriginalState(), this._removeInactiveBinding(c)
                        }
                },
                uncacheAction: function (e, t) {
                    var n = this.existingAction(e, t);
                    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                }
            }), Qr.prototype.clone = function () {
                return new Qr(void 0 === this.value.clone ? this.value : this.value.clone())
            }, Kr.prototype = Object.assign(Object.create(z.prototype), {
                constructor: Kr,
                isInstancedBufferGeometry: !0,
                copy: function (e) {
                    return z.prototype.copy.call(this, e), this.maxInstancedCount = e.maxInstancedCount, this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                }
            }), ea.prototype = Object.assign(Object.create(Rt.prototype), {
                constructor: ea,
                isInstancedInterleavedBuffer: !0,
                copy: function (e) {
                    return Rt.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
                }
            }), ta.prototype = Object.assign(Object.create(T.prototype), {
                constructor: ta,
                isInstancedBufferAttribute: !0,
                copy: function (e) {
                    return T.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
                }
            }), Object.assign(na.prototype, {
                linePrecision: 1,
                set: function (e, t) {
                    this.ray.set(e, t)
                },
                setFromCamera: function (e, t) {
                    t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize()) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
                },
                intersectObject: function (e, t, n) {
                    var i = n || [];
                    return ra(e, this, i, t), i.sort(ia), i
                },
                intersectObjects: function (e, t, n) {
                    var i = n || [];
                    if (Array.isArray(e) === !1) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
                    for (var r = 0, a = e.length; r < a; r++) ra(e[r], this, i, t);
                    return i.sort(ia), i
                }
            }), Object.assign(aa.prototype, {
                set: function (e, t, n) {
                    return this.radius = e, this.phi = t, this.theta = n, this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
                },
                makeSafe: function () {
                    var e = 1e-6;
                    return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this
                },
                setFromVector3: function (e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                },
                setFromCartesianCoords: function (e, t, n) {
                    return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(jl.clamp(t / this.radius, -1, 1))), this
                }
            }), Object.assign(oa.prototype, {
                set: function (e, t, n) {
                    return this.radius = e, this.theta = t, this.y = n, this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
                },
                setFromVector3: function (e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                },
                setFromCartesianCoords: function (e, t, n) {
                    return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this
                }
            }), Object.assign(sa.prototype, {
                set: function (e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                },
                setFromPoints: function (e) {
                    this.makeEmpty();
                    for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                },
                setFromCenterAndSize: function () {
                    var e = new n;
                    return function (t, n) {
                        var i = e.copy(n).multiplyScalar(.5);
                        return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
                    }
                }(),
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                },
                makeEmpty: function () {
                    return this.min.x = this.min.y = +(1 / 0), this.max.x = this.max.y = -(1 / 0), this
                },
                isEmpty: function () {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                },
                getCenter: function (e) {
                    return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new n), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function (e) {
                    return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"), e = new n), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
                },
                expandByPoint: function (e) {
                    return this.min.min(e), this.max.max(e), this
                },
                expandByVector: function (e) {
                    return this.min.sub(e), this.max.add(e), this
                },
                expandByScalar: function (e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                },
                containsPoint: function (e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
                },
                containsBox: function (e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
                },
                getParameter: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new n), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
                },
                intersectsBox: function (e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
                },
                clampPoint: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new n), t.copy(e).clamp(this.min, this.max)
                },
                distanceToPoint: function () {
                    var e = new n;
                    return function (t) {
                        var n = e.copy(t).clamp(this.min, this.max);
                        return n.sub(t).length()
                    }
                }(),
                intersect: function (e) {
                    return this.min.max(e.min), this.max.min(e.max), this
                },
                union: function (e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                },
                translate: function (e) {
                    return this.min.add(e), this.max.add(e), this
                },
                equals: function (e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }), Object.assign(la.prototype, {
                set: function (e, t) {
                    return this.start.copy(e), this.end.copy(t), this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.start.copy(e.start), this.end.copy(e.end), this
                },
                getCenter: function (e) {
                    return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new a), e.addVectors(this.start, this.end).multiplyScalar(.5)
                },
                delta: function (e) {
                    return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"), e = new a), e.subVectors(this.end, this.start)
                },
                distanceSq: function () {
                    return this.start.distanceToSquared(this.end)
                },
                distance: function () {
                    return this.start.distanceTo(this.end)
                },
                at: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"), t = new a), this.delta(t).multiplyScalar(e).add(this.start)
                },
                closestPointToPointParameter: function () {
                    var e = new a,
                        t = new a;
                    return function (n, i) {
                        e.subVectors(n, this.start), t.subVectors(this.end, this.start);
                        var r = t.dot(t),
                            a = t.dot(e),
                            o = a / r;
                        return i && (o = jl.clamp(o, 0, 1)), o
                    }
                }(),
                closestPointToPoint: function (e, t, n) {
                    var i = this.closestPointToPointParameter(e, t);
                    return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new a), this.delta(n).multiplyScalar(i).add(this.start)
                },
                applyMatrix4: function (e) {
                    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
                },
                equals: function (e) {
                    return e.start.equals(this.start) && e.end.equals(this.end)
                }
            }), ca.prototype = Object.create(w.prototype), ca.prototype.constructor = ca, ca.prototype.isImmediateRenderObject = !0, ua.prototype = Object.create(Ft.prototype), ua.prototype.constructor = ua, ua.prototype.update = function () {
                var e = new a,
                    t = new a,
                    n = new o;
                return function () {
                    var i = ["a", "b", "c"];
                    this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
                    var r = this.object.matrixWorld,
                        a = this.geometry.attributes.position,
                        o = this.object.geometry;
                    if (o && o.isGeometry)
                        for (var s = o.vertices, l = o.faces, c = 0, u = 0, h = l.length; u < h; u++)
                            for (var d = l[u], p = 0, f = d.vertexNormals.length; p < f; p++) {
                                var m = s[d[i[p]]],
                                    v = d.vertexNormals[p];
                                e.copy(m).applyMatrix4(r), t.copy(v).applyMatrix3(n).normalize().multiplyScalar(this.size).add(e), a.setXYZ(c, e.x, e.y, e.z), c += 1, a.setXYZ(c, t.x, t.y, t.z), c += 1
                            } else if (o && o.isBufferGeometry)
                                for (var g = o.attributes.position, y = o.attributes.normal, c = 0, p = 0, f = g.count; p < f; p++) e.set(g.getX(p), g.getY(p), g.getZ(p)).applyMatrix4(r), t.set(y.getX(p), y.getY(p), y.getZ(p)), t.applyMatrix3(n).normalize().multiplyScalar(this.size).add(e), a.setXYZ(c, e.x, e.y, e.z), c += 1, a.setXYZ(c, t.x, t.y, t.z), c += 1;
                    a.needsUpdate = !0
                }
            }(), ha.prototype = Object.create(w.prototype), ha.prototype.constructor = ha, ha.prototype.dispose = function () {
                this.cone.geometry.dispose(), this.cone.material.dispose()
            }, ha.prototype.update = function () {
                var e = new a,
                    t = new a;
                return function () {
                    this.light.updateMatrixWorld();
                    var n = this.light.distance ? this.light.distance : 1e3,
                        i = n * Math.tan(this.light.angle);
                    this.cone.scale.set(i, i, n), e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t.sub(e)), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                }
            }(), pa.prototype = Object.create(Ft.prototype), pa.prototype.constructor = pa, pa.prototype.updateMatrixWorld = function () {
                var e = new a,
                    t = new i,
                    n = new i;
                return function (i) {
                    var r = this.bones,
                        a = this.geometry,
                        o = a.getAttribute("position");
                    n.getInverse(this.root.matrixWorld);
                    for (var s = 0, l = 0; s < r.length; s++) {
                        var c = r[s];
                        c.parent && c.parent.isBone && (t.multiplyMatrices(n, c.matrixWorld), e.setFromMatrixPosition(t), o.setXYZ(l, e.x, e.y, e.z), t.multiplyMatrices(n, c.parent.matrixWorld), e.setFromMatrixPosition(t), o.setXYZ(l + 1, e.x, e.y, e.z), l += 2)
                    }
                    a.getAttribute("position").needsUpdate = !0, w.prototype.updateMatrixWorld.call(this, i)
                }
            }(), fa.prototype = Object.create(q.prototype), fa.prototype.constructor = fa, fa.prototype.dispose = function () {
                this.geometry.dispose(), this.material.dispose()
            }, fa.prototype.update = function () {
                void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
            }, ma.prototype = Object.create(w.prototype), ma.prototype.constructor = ma, ma.prototype.dispose = function () {
                this.children[0].geometry.dispose(), this.children[0].material.dispose()
            }, ma.prototype.update = function () {
                var e = .5 * this.light.width,
                    t = .5 * this.light.height,
                    n = this.line.geometry.attributes.position,
                    i = n.array;
                i[0] = e, i[1] = -t, i[2] = 0, i[3] = e, i[4] = t, i[5] = 0, i[6] = -e, i[7] = t, i[8] = 0, i[9] = -e, i[10] = -t, i[11] = 0, i[12] = e, i[13] = -t, i[14] = 0, n.needsUpdate = !0, void 0 !== this.color ? this.line.material.color.set(this.color) : this.line.material.color.copy(this.light.color)
            }, va.prototype = Object.create(w.prototype), va.prototype.constructor = va, va.prototype.dispose = function () {
                this.children[0].geometry.dispose(), this.children[0].material.dispose()
            }, va.prototype.update = function () {
                var e = new a,
                    t = new v,
                    n = new v;
                return function () {
                    var i = this.children[0];
                    if (void 0 !== this.color) this.material.color.set(this.color);
                    else {
                        var r = i.geometry.getAttribute("color");
                        t.copy(this.light.color), n.copy(this.light.groundColor);
                        for (var a = 0, o = r.count; a < o; a++) {
                            var s = a < o / 2 ? t : n;
                            r.setXYZ(a, s.r, s.g, s.b)
                        }
                        r.needsUpdate = !0
                    }
                    i.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate())
                }
            }(), ga.prototype = Object.create(Ft.prototype), ga.prototype.constructor = ga, ya.prototype = Object.create(Ft.prototype), ya.prototype.constructor = ya, xa.prototype = Object.create(Ft.prototype), xa.prototype.constructor = xa, xa.prototype.update = function () {
                var e = new a,
                    t = new a,
                    n = new o;
                return function () {
                    this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
                    for (var i = this.object.matrixWorld, r = this.geometry.attributes.position, a = this.object.geometry, o = a.vertices, s = a.faces, l = 0, c = 0, u = s.length; c < u; c++) {
                        var h = s[c],
                            d = h.normal;
                        e.copy(o[h.a]).add(o[h.b]).add(o[h.c]).divideScalar(3).applyMatrix4(i), t.copy(d).applyMatrix3(n).normalize().multiplyScalar(this.size).add(e), r.setXYZ(l, e.x, e.y, e.z), l += 1, r.setXYZ(l, t.x, t.y, t.z), l += 1
                    }
                    r.needsUpdate = !0
                }
            }(), ba.prototype = Object.create(w.prototype), ba.prototype.constructor = ba, ba.prototype.dispose = function () {
                this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
            }, ba.prototype.update = function () {
                var e = new a,
                    t = new a,
                    n = new a;
                return function () {
                    e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), n.subVectors(t, e), this.lightPlane.lookAt(n), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(n), this.targetLine.scale.z = n.length()
                }
            }(), _a.prototype = Object.create(Ft.prototype), _a.prototype.constructor = _a, _a.prototype.update = function () {
                function e(e, a, o, s) {
                    i.set(a, o, s).unproject(r);
                    var l = n[e];
                    if (void 0 !== l)
                        for (var c = t.getAttribute("position"), u = 0, h = l.length; u < h; u++) c.setXYZ(l[u], i.x, i.y, i.z)
                }
                var t, n, i = new a,
                    r = new _t;
                return function () {
                    t = this.geometry, n = this.pointMap;
                    var i = 1,
                        a = 1;
                    r.projectionMatrix.copy(this.camera.projectionMatrix), e("c", 0, 0, -1), e("t", 0, 0, 1), e("n1", -i, -a, -1), e("n2", i, -a, -1), e("n3", -i, a, -1), e("n4", i, a, -1), e("f1", -i, -a, 1), e("f2", i, -a, 1), e("f3", -i, a, 1), e("f4", i, a, 1), e("u1", .7 * i, 1.1 * a, -1), e("u2", .7 * -i, 1.1 * a, -1), e("u3", 0, 2 * a, -1), e("cf1", -i, 0, 1), e("cf2", i, 0, 1), e("cf3", 0, -a, 1), e("cf4", 0, a, 1), e("cn1", -i, 0, -1), e("cn2", i, 0, -1), e("cn3", 0, -a, -1), e("cn4", 0, a, -1), t.getAttribute("position").needsUpdate = !0
                }
            }(), wa.prototype = Object.create(Ft.prototype), wa.prototype.constructor = wa, wa.prototype.update = function () {
                var e = new d;
                return function (t) {
                    if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && e.setFromObject(this.object), !e.isEmpty()) {
                        var n = e.min,
                            i = e.max,
                            r = this.geometry.attributes.position,
                            a = r.array;
                        a[0] = i.x, a[1] = i.y, a[2] = i.z, a[3] = n.x, a[4] = i.y, a[5] = i.z, a[6] = n.x, a[7] = n.y, a[8] = i.z, a[9] = i.x, a[10] = n.y, a[11] = i.z, a[12] = i.x, a[13] = i.y, a[14] = n.z, a[15] = n.x, a[16] = i.y, a[17] = n.z, a[18] = n.x, a[19] = n.y, a[20] = n.z, a[21] = i.x, a[22] = n.y, a[23] = n.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
                    }
                }
            }(), wa.prototype.setFromObject = function (e) {
                return this.object = e, this.update(), this
            }, wa.prototype.copy = function (e) {
                return Ft.prototype.copy.call(this, e), this.object = e.object, this
            }, wa.prototype.clone = function () {
                return (new this.constructor).copy(this)
            }, Ma.prototype = Object.create(Ft.prototype), Ma.prototype.constructor = Ma, Ma.prototype.updateMatrixWorld = function (e) {
                var t = this.box;
                t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), w.prototype.updateMatrixWorld.call(this, e))
            }, Ta.prototype = Object.create(jt.prototype), Ta.prototype.constructor = Ta, Ta.prototype.updateMatrixWorld = function (e) {
                var t = -this.plane.constant;
                Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? yo : go, this.lookAt(this.plane.normal), w.prototype.updateMatrixWorld.call(this, e)
            };
            var Wh, qh;
            Ea.prototype = Object.create(w.prototype), Ea.prototype.constructor = Ea, Ea.prototype.setDirection = function () {
                var e, t = new a;
                return function (n) {
                    n.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : n.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (t.set(n.z, 0, -n.x).normalize(), e = Math.acos(n.y), this.quaternion.setFromAxisAngle(t, e))
                }
            }(), Ea.prototype.setLength = function (e, t, n) {
                void 0 === t && (t = .2 * e), void 0 === n && (n = .2 * t), this.line.scale.set(1, Math.max(0, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
            }, Ea.prototype.setColor = function (e) {
                this.line.material.color.copy(e), this.cone.material.color.copy(e)
            }, Ea.prototype.copy = function (e) {
                return w.prototype.copy.call(this, e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
            }, Ea.prototype.clone = function () {
                return (new this.constructor).copy(this)
            }, Sa.prototype = Object.create(Ft.prototype), Sa.prototype.constructor = Sa;
            var Xh = 0,
                Yh = 1;
            Wi.create = function (e, t) {
                return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Wi.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
            }, Object.assign(pr.prototype, {
                createPointsGeometry: function (e) {
                    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var t = this.getPoints(e);
                    return this.createGeometry(t)
                },
                createSpacedPointsGeometry: function (e) {
                    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var t = this.getSpacedPoints(e);
                    return this.createGeometry(t)
                },
                createGeometry: function (e) {
                    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    for (var t = new M, n = 0, i = e.length; n < i; n++) {
                        var r = e[n];
                        t.vertices.push(new a(r.x, r.y, r.z || 0))
                    }
                    return t
                }
            }), Object.assign(fr.prototype, {
                fromPoints: function (e) {
                    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e)
                }
            }), Xa.prototype = Object.create(Zi.prototype), Ya.prototype = Object.create(Zi.prototype), Za.prototype = Object.create(Zi.prototype), Object.assign(Za.prototype, {
                initFromArray: function () {
                    console.error("THREE.Spline: .initFromArray() has been removed.")
                },
                getControlPointsArray: function () {
                    console.error("THREE.Spline: .getControlPointsArray() has been removed.")
                },
                reparametrizeByArcLength: function () {
                    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
                }
            }), ga.prototype.setColors = function () {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            }, pa.prototype.update = function () {
                console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
            }, Object.assign(Ar.prototype, {
                extractUrlBase: function (e) {
                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Bh.extractUrlBase(e)
                }
            }), Object.assign(Lr.prototype, {
                setTexturePath: function (e) {
                    return console.warn("THREE.JSONLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e)
                }
            }), Object.assign(Rr.prototype, {
                setTexturePath: function (e) {
                    return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e)
                }
            }), Object.assign(sa.prototype, {
                center: function (e) {
                    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e)
                },
                empty: function () {
                    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function (e) {
                    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
                },
                size: function (e) {
                    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e)
                }
            }), Object.assign(d.prototype, {
                center: function (e) {
                    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
                },
                empty: function () {
                    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function (e) {
                    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
                },
                isIntersectionSphere: function (e) {
                    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
                },
                size: function (e) {
                    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
                }
            }), la.prototype.center = function (e) {
                return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e)
            }, Object.assign(jl, {
                random16: function () {
                    return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
                },
                nearestPowerOfTwo: function (e) {
                    return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), jl.floorPowerOfTwo(e)
                },
                nextPowerOfTwo: function (e) {
                    return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), jl.ceilPowerOfTwo(e)
                }
            }), Object.assign(o.prototype, {
                flattenToArrayOffset: function (e, t) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
                },
                multiplyVector3: function (e) {
                    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
                },
                multiplyVector3Array: function () {
                    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
                },
                applyToBuffer: function (e) {
                    return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
                },
                applyToVector3Array: function () {
                    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
                }
            }), Object.assign(i.prototype, {
                extractPosition: function (e) {
                    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
                },
                flattenToArrayOffset: function (e, t) {
                    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
                },
                getPosition: function () {
                    var e;
                    return function () {
                        return void 0 === e && (e = new a), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), e.setFromMatrixColumn(this, 3)
                    }
                }(),
                setRotationFromQuaternion: function (e) {
                    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
                },
                multiplyToArray: function () {
                    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
                },
                multiplyVector3: function (e) {
                    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
                },
                multiplyVector4: function (e) {
                    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
                },
                multiplyVector3Array: function () {
                    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
                },
                rotateAxis: function (e) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
                },
                crossVector: function (e) {
                    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
                },
                translate: function () {
                    console.error("THREE.Matrix4: .translate() has been removed.")
                },
                rotateX: function () {
                    console.error("THREE.Matrix4: .rotateX() has been removed.")
                },
                rotateY: function () {
                    console.error("THREE.Matrix4: .rotateY() has been removed.")
                },
                rotateZ: function () {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.")
                },
                rotateByAxis: function () {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                },
                applyToBuffer: function (e) {
                    return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
                },
                applyToVector3Array: function () {
                    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
                },
                makeFrustum: function (e, t, n, i, r, a) {
                    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, i, n, r, a)
                }
            }), f.prototype.isIntersectionLine = function (e) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
            }, r.prototype.multiplyVector3 = function (e) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
            }, Object.assign(H.prototype, {
                isIntersectionBox: function (e) {
                    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
                },
                isIntersectionPlane: function (e) {
                    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
                },
                isIntersectionSphere: function (e) {
                    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
                }
            }), Object.assign(V.prototype, {
                area: function () {
                    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
                },
                barycoordFromPoint: function (e, t) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t)
                },
                midpoint: function (e) {
                    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e)
                },
                normal: function (e) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e)
                },
                plane: function (e) {
                    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e)
                }
            }), Object.assign(V, {
                barycoordFromPoint: function (e, t, n, i, r) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), V.getBarycoord(e, t, n, i, r)
                },
                normal: function (e, t, n, i) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), V.getNormal(e, t, n, i)
                }
            }), Object.assign(mr.prototype, {
                extractAllPoints: function (e) {
                    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e)
                },
                extrude: function (e) {
                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Wn(this, e)
                },
                makeGeometry: function (e) {
                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new ni(this, e)
                }
            }), Object.assign(n.prototype, {
                fromAttribute: function (e, t, n) {
                    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
                },
                distanceToManhattan: function (e) {
                    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
                        this.manhattanDistanceTo(e)
                },
                lengthManhattan: function () {
                    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(a.prototype, {
                setEulerFromRotationMatrix: function () {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                },
                setEulerFromQuaternion: function () {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                },
                getPositionFromMatrix: function (e) {
                    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
                },
                getScaleFromMatrix: function (e) {
                    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
                },
                getColumnFromMatrix: function (e, t) {
                    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
                },
                applyProjection: function (e) {
                    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e)
                },
                fromAttribute: function (e, t, n) {
                    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
                },
                distanceToManhattan: function (e) {
                    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
                },
                lengthManhattan: function () {
                    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(l.prototype, {
                fromAttribute: function (e, t, n) {
                    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
                },
                lengthManhattan: function () {
                    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(M.prototype, {
                computeTangents: function () {
                    console.error("THREE.Geometry: .computeTangents() has been removed.")
                },
                computeLineDistances: function () {
                    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
                }
            }), Object.assign(w.prototype, {
                getChildByName: function (e) {
                    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
                },
                renderDepth: function () {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                },
                translate: function (e, t) {
                    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
                },
                getWorldRotation: function () {
                    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
                }
            }), Object.defineProperties(w.prototype, {
                eulerOrder: {
                    get: function () {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                    },
                    set: function (e) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
                    }
                },
                useQuaternion: {
                    get: function () {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function () {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }), Object.defineProperties(Dt.prototype, {
                objects: {
                    get: function () {
                        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                    }
                }
            }), Object.defineProperty(zt.prototype, "useVertexTexture", {
                get: function () {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                },
                set: function () {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                }
            }), Object.defineProperty(Wi.prototype, "__arcLengthDivisions", {
                get: function () {
                    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
                },
                set: function (e) {
                    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e
                }
            }), wt.prototype.setLens = function (e, t) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
            }, Object.defineProperties(vr.prototype, {
                onlyShadow: {
                    set: function () {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
                    }
                },
                shadowCameraLeft: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
                    }
                },
                shadowCameraRight: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
                    }
                },
                shadowCameraTop: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
                    }
                },
                shadowCameraBottom: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
                    }
                },
                shadowCameraNear: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
                    }
                },
                shadowCameraFar: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
                    }
                },
                shadowCameraVisible: {
                    set: function () {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
                    }
                },
                shadowDarkness: {
                    set: function () {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
                    }
                },
                shadowMapHeight: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
                    }
                }
            }), Object.defineProperties(T.prototype, {
                length: {
                    get: function () {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                    }
                },
                copyIndicesArray: function () {
                    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
                }
            }), Object.assign(z.prototype, {
                addIndex: function (e) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
                },
                addDrawCall: function (e, t, n) {
                    void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
                },
                clearDrawCalls: function () {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
                },
                computeTangents: function () {
                    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                },
                computeOffsets: function () {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                }
            }), Object.defineProperties(z.prototype, {
                drawcalls: {
                    get: function () {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                    }
                },
                offsets: {
                    get: function () {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                    }
                }
            }), Object.assign(qn.prototype, {
                getArrays: function () {
                    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
                },
                addShapeList: function () {
                    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
                },
                addShape: function () {
                    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
                }
            }), Object.defineProperties(Qr.prototype, {
                dynamic: {
                    set: function () {
                        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                    }
                },
                onUpdate: {
                    value: function () {
                        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                    }
                }
            }), Object.defineProperties(F.prototype, {
                wrapAround: {
                    get: function () {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    },
                    set: function () {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    }
                },
                overdraw: {
                    get: function () {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    },
                    set: function () {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    }
                },
                wrapRGB: {
                    get: function () {
                        return console.warn("THREE.Material: .wrapRGB has been removed."), new v
                    }
                },
                shading: {
                    get: function () {
                        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                    },
                    set: function (e) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = e === bo
                    }
                }
            }), Object.defineProperties(vi.prototype, {
                metal: {
                    get: function () {
                        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                    },
                    set: function () {
                        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                    }
                }
            }), Object.defineProperties(G.prototype, {
                derivatives: {
                    get: function () {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                    },
                    set: function (e) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
                    }
                }
            }), Object.assign(Pt.prototype, {
                clearTarget: function (e, t, n, i) {
                    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, n, i)
                },
                animate: function (e) {
                    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e)
                },
                getCurrentRenderTarget: function () {
                    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
                },
                getMaxAnisotropy: function () {
                    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
                },
                getPrecision: function () {
                    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
                },
                resetGLState: function () {
                    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
                },
                supportsFloatTextures: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
                },
                supportsHalfFloatTextures: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
                },
                supportsStandardDerivatives: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
                },
                supportsCompressedTextureS3TC: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
                },
                supportsCompressedTexturePVRTC: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
                },
                supportsBlendMinMax: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
                },
                supportsVertexTextures: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
                },
                supportsInstancedArrays: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
                },
                enableScissorTest: function (e) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
                },
                initMaterial: function () {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                },
                addPrePlugin: function () {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                },
                addPostPlugin: function () {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                },
                updateShadowMap: function () {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                },
                setFaceCulling: function () {
                    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
                }
            }), Object.defineProperties(Pt.prototype, {
                shadowMapEnabled: {
                    get: function () {
                        return this.shadowMap.enabled
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
                    }
                },
                shadowMapType: {
                    get: function () {
                        return this.shadowMap.type
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
                    }
                },
                shadowMapCullFace: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(vt.prototype, {
                cullFace: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderReverseSided: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderSingleSided: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(c.prototype, {
                wrapS: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
                    }
                },
                wrapT: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
                    }
                },
                magFilter: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
                    }
                },
                minFilter: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
                    }
                },
                anisotropy: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
                    }
                },
                offset: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
                    }
                },
                repeat: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
                    }
                },
                format: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
                    }
                },
                type: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
                    }
                },
                generateMipmaps: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
                    }
                }
            }), Object.defineProperties(Et.prototype, {
                standing: {
                    set: function () {
                        console.warn("THREE.WebVRManager: .standing has been removed.")
                    }
                },
                userHeight: {
                    set: function () {
                        console.warn("THREE.WebVRManager: .userHeight has been removed.")
                    }
                }
            }), Hr.prototype.load = function (e) {
                console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                var t = this,
                    n = new Nr;
                return n.load(e, function (e) {
                    t.setBuffer(e)
                }), this
            }, Wr.prototype.getData = function () {
                return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
            }, jr.prototype.updateCubeMap = function (e, t) {
                return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t)
            };
            var Zh = {
                merge: function (e, t, n) {
                    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
                    var i;
                    t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), i = t.matrix, t = t.geometry), e.merge(t, i, n)
                },
                center: function (e) {
                    return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center()
                }
            };
            Fl.crossOrigin = void 0, Fl.loadTexture = function (e, t, n, i) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                var r = new Vi;
                r.setCrossOrigin(this.crossOrigin);
                var a = r.load(e, n, void 0, i);
                return t && (a.mapping = t), a
            }, Fl.loadTextureCube = function (e, t, n, i) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                var r = new Hi;
                r.setCrossOrigin(this.crossOrigin);
                var a = r.load(e, n, void 0, i);
                return t && (a.mapping = t), a
            }, Fl.loadCompressedTexture = function () {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            }, Fl.loadCompressedTextureCube = function () {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            };
            var Jh = {
                createMultiMaterialObject: function () {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                detach: function () {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                attach: function () {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                }
            };
            e.WebGLRenderTargetCube = u, e.WebGLRenderTarget = c, e.WebGLRenderer = Pt, e.ShaderLib = rh, e.UniformsLib = ih, e.UniformsUtils = th, e.ShaderChunk = eh, e.FogExp2 = Ct, e.Fog = At, e.Scene = Lt, e.Sprite = kt, e.LOD = Dt, e.SkinnedMesh = Nt, e.Skeleton = zt, e.Bone = Bt, e.Mesh = q, e.LineSegments = Ft, e.LineLoop = Gt, e.Line = jt, e.Points = Vt, e.Group = bt, e.VideoTexture = Wt, e.DataTexture = h, e.DataTexture3D = ae, e.CompressedTexture = qt, e.CubeTexture = re, e.CanvasTexture = Xt, e.DepthTexture = Yt, e.Texture = s, e.AnimationLoader = Ui, e.CompressedTextureLoader = ji, e.DataTextureLoader = Fi, e.CubeTextureLoader = Hi, e.TextureLoader = Vi, e.ObjectLoader = Rr, e.MaterialLoader = Pr, e.BufferGeometryLoader = Cr, e.DefaultLoadingManager = Lh, e.LoadingManager = Bi, e.JSONLoader = Lr, e.ImageLoader = Gi, e.ImageBitmapLoader = Ir, e.FontLoader = Br, e.FileLoader = Ni, e.Loader = Ar, e.LoaderUtils = Bh, e.Cache = Ah, e.AudioLoader = Nr, e.SpotLightShadow = xr, e.SpotLight = br, e.PointLight = _r, e.RectAreaLight = Sr, e.HemisphereLight = gr, e.DirectionalLightShadow = Mr, e.DirectionalLight = Tr, e.AmbientLight = Er, e.LightShadow = yr, e.Light = vr, e.StereoCamera = Ur, e.PerspectiveCamera = wt, e.OrthographicCamera = wr, e.CubeCamera = jr, e.ArrayCamera = Mt, e.Camera = _t, e.AudioListener = Gr, e.PositionalAudio = Vr, e.AudioContext = Hh, e.AudioAnalyser = Wr, e.Audio = Hr, e.VectorKeyframeTrack = Oi, e.StringKeyframeTrack = Ii, e.QuaternionKeyframeTrack = Ri, e.NumberKeyframeTrack = Ai, e.ColorKeyframeTrack = Ci, e.BooleanKeyframeTrack = Pi, e.PropertyMixer = qr, e.PropertyBinding = Yr, e.KeyframeTrack = Si, e.AnimationUtils = Ch, e.AnimationObjectGroup = Zr, e.AnimationMixer = $r, e.AnimationClip = ki, e.Uniform = Qr, e.InstancedBufferGeometry = Kr, e.BufferGeometry = z, e.Geometry = M, e.InterleavedBufferAttribute = It, e.InstancedInterleavedBuffer = ea, e.InterleavedBuffer = Rt, e.InstancedBufferAttribute = ta, e.Face3 = x, e.Object3D = w, e.Raycaster = na, e.Layers = _, e.EventDispatcher = t, e.Clock = Fr, e.QuaternionLinearInterpolant = Li, e.LinearInterpolant = Ti, e.DiscreteInterpolant = Ei, e.CubicInterpolant = Mi, e.Interpolant = wi, e.Triangle = V, e.Math = jl, e.Spherical = aa, e.Cylindrical = oa, e.Plane = f, e.Frustum = m, e.Sphere = p, e.Ray = H, e.Matrix4 = i, e.Matrix3 = o, e.Box3 = d, e.Box2 = sa, e.Line3 = la, e.Euler = b, e.Vector4 = l, e.Vector3 = a, e.Vector2 = n, e.Quaternion = r, e.Color = v, e.ImmediateRenderObject = ca, e.VertexNormalsHelper = ua, e.SpotLightHelper = ha, e.SkeletonHelper = pa, e.PointLightHelper = fa, e.RectAreaLightHelper = ma, e.HemisphereLightHelper = va, e.GridHelper = ga, e.PolarGridHelper = ya, e.FaceNormalsHelper = xa, e.DirectionalLightHelper = ba, e.CameraHelper = _a, e.BoxHelper = wa, e.Box3Helper = Ma, e.PlaneHelper = Ta, e.ArrowHelper = Ea, e.AxesHelper = Sa, e.Shape = mr, e.Path = fr, e.ShapePath = Or, e.Font = kr, e.CurvePath = pr, e.Curve = Wi, e.ImageUtils = Fl, e.ShapeUtils = Th, e.WebGLUtils = xt, e.WireframeGeometry = Zt, e.ParametricGeometry = Jt, e.ParametricBufferGeometry = $t, e.TetrahedronGeometry = en, e.TetrahedronBufferGeometry = tn, e.OctahedronGeometry = nn, e.OctahedronBufferGeometry = rn, e.IcosahedronGeometry = an, e.IcosahedronBufferGeometry = on, e.DodecahedronGeometry = sn, e.DodecahedronBufferGeometry = ln, e.PolyhedronGeometry = Qt, e.PolyhedronBufferGeometry = Kt, e.TubeGeometry = cn, e.TubeBufferGeometry = un, e.TorusKnotGeometry = hn, e.TorusKnotBufferGeometry = dn, e.TorusGeometry = pn, e.TorusBufferGeometry = fn, e.TextGeometry = Yn, e.TextBufferGeometry = Zn, e.SphereGeometry = Jn, e.SphereBufferGeometry = $n, e.RingGeometry = Qn, e.RingBufferGeometry = Kn, e.PlaneGeometry = U, e.PlaneBufferGeometry = j, e.LatheGeometry = ei, e.LatheBufferGeometry = ti, e.ShapeGeometry = ni, e.ShapeBufferGeometry = ii, e.ExtrudeGeometry = Wn, e.ExtrudeBufferGeometry = qn, e.EdgesGeometry = ai, e.ConeGeometry = li, e.ConeBufferGeometry = ci, e.CylinderGeometry = oi, e.CylinderBufferGeometry = si, e.CircleGeometry = ui, e.CircleBufferGeometry = hi, e.BoxGeometry = B, e.BoxBufferGeometry = N, e.ShadowMaterial = di, e.SpriteMaterial = Ot, e.RawShaderMaterial = pi, e.ShaderMaterial = G, e.PointsMaterial = Ht, e.MeshPhysicalMaterial = mi, e.MeshStandardMaterial = fi, e.MeshPhongMaterial = vi, e.MeshToonMaterial = gi, e.MeshNormalMaterial = yi, e.MeshLambertMaterial = xi, e.MeshDepthMaterial = ft, e.MeshDistanceMaterial = mt, e.MeshBasicMaterial = W, e.MeshMatcapMaterial = bi, e.LineDashedMaterial = _i, e.LineBasicMaterial = Ut, e.Material = F, e.Float64BufferAttribute = O, e.Float32BufferAttribute = I, e.Uint32BufferAttribute = R, e.Int32BufferAttribute = L, e.Uint16BufferAttribute = A, e.Int16BufferAttribute = C, e.Uint8ClampedBufferAttribute = P, e.Uint8BufferAttribute = S, e.Int8BufferAttribute = E, e.BufferAttribute = T, e.ArcCurve = Xi, e.CatmullRomCurve3 = Zi, e.CubicBezierCurve = or, e.CubicBezierCurve3 = sr, e.EllipseCurve = qi, e.LineCurve = lr, e.LineCurve3 = cr, e.QuadraticBezierCurve = ur, e.QuadraticBezierCurve3 = hr, e.SplineCurve = dr, e.REVISION = ao, e.MOUSE = oo, e.CullFaceNone = so, e.CullFaceBack = lo, e.CullFaceFront = co, e.CullFaceFrontBack = uo, e.FrontFaceDirectionCW = ho, e.FrontFaceDirectionCCW = po, e.BasicShadowMap = fo, e.PCFShadowMap = mo, e.PCFSoftShadowMap = vo, e.FrontSide = go, e.BackSide = yo, e.DoubleSide = xo, e.FlatShading = bo, e.SmoothShading = _o, e.NoColors = wo, e.FaceColors = Mo, e.VertexColors = To, e.NoBlending = Eo, e.NormalBlending = So, e.AdditiveBlending = Po, e.SubtractiveBlending = Co, e.MultiplyBlending = Ao, e.CustomBlending = Lo, e.AddEquation = Ro, e.SubtractEquation = Io, e.ReverseSubtractEquation = Oo, e.MinEquation = ko, e.MaxEquation = Do, e.ZeroFactor = zo, e.OneFactor = Bo, e.SrcColorFactor = No, e.OneMinusSrcColorFactor = Uo, e.SrcAlphaFactor = jo, e.OneMinusSrcAlphaFactor = Fo, e.DstAlphaFactor = Go, e.OneMinusDstAlphaFactor = Ho, e.DstColorFactor = Vo, e.OneMinusDstColorFactor = Wo, e.SrcAlphaSaturateFactor = qo, e.NeverDepth = Xo, e.AlwaysDepth = Yo, e.LessDepth = Zo, e.LessEqualDepth = Jo, e.EqualDepth = $o, e.GreaterEqualDepth = Qo, e.GreaterDepth = Ko, e.NotEqualDepth = es, e.MultiplyOperation = ts, e.MixOperation = ns, e.AddOperation = is, e.NoToneMapping = rs, e.LinearToneMapping = as, e.ReinhardToneMapping = os, e.Uncharted2ToneMapping = ss, e.CineonToneMapping = ls, e.UVMapping = cs, e.CubeReflectionMapping = us, e.CubeRefractionMapping = hs, e.EquirectangularReflectionMapping = ds, e.EquirectangularRefractionMapping = ps, e.SphericalReflectionMapping = fs, e.CubeUVReflectionMapping = ms, e.CubeUVRefractionMapping = vs, e.RepeatWrapping = gs, e.ClampToEdgeWrapping = ys, e.MirroredRepeatWrapping = xs, e.NearestFilter = bs, e.NearestMipMapNearestFilter = _s, e.NearestMipMapLinearFilter = ws, e.LinearFilter = Ms, e.LinearMipMapNearestFilter = Ts, e.LinearMipMapLinearFilter = Es, e.UnsignedByteType = Ss, e.ByteType = Ps, e.ShortType = Cs, e.UnsignedShortType = As, e.IntType = Ls, e.UnsignedIntType = Rs, e.FloatType = Is, e.HalfFloatType = Os, e.UnsignedShort4444Type = ks, e.UnsignedShort5551Type = Ds, e.UnsignedShort565Type = zs, e.UnsignedInt248Type = Bs, e.AlphaFormat = Ns, e.RGBFormat = Us, e.RGBAFormat = js, e.LuminanceFormat = Fs, e.LuminanceAlphaFormat = Gs, e.RGBEFormat = Hs, e.DepthFormat = Vs, e.DepthStencilFormat = Ws, e.RedFormat = qs, e.RGB_S3TC_DXT1_Format = Xs, e.RGBA_S3TC_DXT1_Format = Ys, e.RGBA_S3TC_DXT3_Format = Zs, e.RGBA_S3TC_DXT5_Format = Js, e.RGB_PVRTC_4BPPV1_Format = $s, e.RGB_PVRTC_2BPPV1_Format = Qs, e.RGBA_PVRTC_4BPPV1_Format = Ks, e.RGBA_PVRTC_2BPPV1_Format = el, e.RGB_ETC1_Format = tl, e.RGBA_ASTC_4x4_Format = nl, e.RGBA_ASTC_5x4_Format = il, e.RGBA_ASTC_5x5_Format = rl, e.RGBA_ASTC_6x5_Format = al, e.RGBA_ASTC_6x6_Format = ol, e.RGBA_ASTC_8x5_Format = sl, e.RGBA_ASTC_8x6_Format = ll, e.RGBA_ASTC_8x8_Format = cl, e.RGBA_ASTC_10x5_Format = ul, e.RGBA_ASTC_10x6_Format = hl, e.RGBA_ASTC_10x8_Format = dl, e.RGBA_ASTC_10x10_Format = pl, e.RGBA_ASTC_12x10_Format = fl, e.RGBA_ASTC_12x12_Format = ml, e.LoopOnce = vl, e.LoopRepeat = gl, e.LoopPingPong = yl, e.InterpolateDiscrete = xl, e.InterpolateLinear = bl, e.InterpolateSmooth = _l, e.ZeroCurvatureEnding = wl, e.ZeroSlopeEnding = Ml, e.WrapAroundEnding = Tl, e.TrianglesDrawMode = El, e.TriangleStripDrawMode = Sl, e.TriangleFanDrawMode = Pl, e.LinearEncoding = Cl, e.sRGBEncoding = Al, e.GammaEncoding = Ll, e.RGBEEncoding = Rl, e.LogLuvEncoding = Il, e.RGBM7Encoding = Ol, e.RGBM16Encoding = kl, e.RGBDEncoding = Dl, e.BasicDepthPacking = zl, e.RGBADepthPacking = Bl, e.TangentSpaceNormalMap = Nl, e.ObjectSpaceNormalMap = Ul, e.CubeGeometry = B, e.Face4 = Pa, e.LineStrip = Xh, e.LinePieces = Yh, e.MeshFaceMaterial = Ca, e.MultiMaterial = Aa, e.PointCloud = La, e.Particle = Ra, e.ParticleSystem = Ia, e.PointCloudMaterial = Oa, e.ParticleBasicMaterial = ka, e.ParticleSystemMaterial = Da, e.Vertex = za, e.DynamicBufferAttribute = Ba, e.Int8Attribute = Na, e.Uint8Attribute = Ua, e.Uint8ClampedAttribute = ja, e.Int16Attribute = Fa, e.Uint16Attribute = Ga, e.Int32Attribute = Ha, e.Uint32Attribute = Va, e.Float32Attribute = Wa, e.Float64Attribute = qa, e.ClosedSplineCurve3 = Xa, e.SplineCurve3 = Ya, e.Spline = Za, e.AxisHelper = Ja, e.BoundingBoxHelper = $a, e.EdgesHelper = Qa, e.WireframeHelper = Ka, e.XHRLoader = eo, e.BinaryTextureLoader = to, e.GeometryUtils = Zh, e.Projector = no, e.CanvasRenderer = io, e.SceneUtils = Jh, e.LensFlare = ro, Object.defineProperty(e, "__esModule", {
                value: !0
            })
        })
    }, {}],
    49: [function (e, t, n) {
        ! function (e, i) {
            "object" == typeof n && "undefined" != typeof t ? i(n) : "function" == typeof define && define.amd ? define(["exports"], i) : (e = e || self, i(e.THREE = {}))
        }(this, function (e) {
            "use strict";

            function t() {}

            function n(e, t) {
                this.x = e || 0, this.y = t || 0
            }

            function i() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }

            function r(e, t, n, i) {
                this._x = e || 0, this._y = t || 0, this._z = n || 0, this._w = void 0 !== i ? i : 1
            }

            function a(e, t, n) {
                this.x = e || 0, this.y = t || 0, this.z = n || 0
            }

            function o() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }

            function s(e, t, i, r, a, l, c, u, h, d) {
                Object.defineProperty(this, "id", {
                    value: Yl++
                }), this.uuid = Wl.generateUUID(), this.name = "", this.image = void 0 !== e ? e : s.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : s.DEFAULT_MAPPING, this.wrapS = void 0 !== i ? i : Ms, this.wrapT = void 0 !== r ? r : Ms, this.magFilter = void 0 !== a ? a : Cs, this.minFilter = void 0 !== l ? l : Ls, this.anisotropy = void 0 !== h ? h : 1, this.format = void 0 !== c ? c : Ws, this.type = void 0 !== u ? u : Rs, this.offset = new n(0, 0), this.repeat = new n(1, 1), this.center = new n(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new o, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== d ? d : Ol, this.version = 0, this.onUpdate = null
            }

            function l(e, t, n, i) {
                this.x = e || 0, this.y = t || 0, this.z = n || 0, this.w = void 0 !== i ? i : 1
            }

            function c(e, t, n) {
                this.width = e, this.height = t, this.scissor = new l(0, 0, e, t), this.scissorTest = !1, this.viewport = new l(0, 0, e, t), n = n || {}, this.texture = new s((void 0), (void 0), n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : Cs, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
            }

            function u(e, t, n) {
                c.call(this, e, t, n), this.samples = 4
            }

            function h(e, t, n) {
                c.call(this, e, t, n)
            }

            function d(e, t, n, i, r, a, o, l, c, u, h, d) {
                s.call(this, null, a, o, l, c, u, i, r, h, d), this.image = {
                    data: e,
                    width: t,
                    height: n
                }, this.magFilter = void 0 !== c ? c : Es, this.minFilter = void 0 !== u ? u : Es, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }

            function p(e, t) {
                this.min = void 0 !== e ? e : new a((+(1 / 0)), (+(1 / 0)), (+(1 / 0))), this.max = void 0 !== t ? t : new a((-(1 / 0)), (-(1 / 0)), (-(1 / 0)))
            }

            function f(e, t) {
                this.center = void 0 !== e ? e : new a, this.radius = void 0 !== t ? t : 0
            }

            function m(e, t) {
                this.normal = void 0 !== e ? e : new a(1, 0, 0), this.constant = void 0 !== t ? t : 0
            }

            function v(e, t, n, i, r, a) {
                this.planes = [void 0 !== e ? e : new m, void 0 !== t ? t : new m, void 0 !== n ? n : new m, void 0 !== i ? i : new m, void 0 !== r ? r : new m, void 0 !== a ? a : new m]
            }

            function g(e) {
                var t = {};
                for (var n in e) {
                    t[n] = {};
                    for (var i in e[n]) {
                        var r = e[n][i];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r
                    }
                }
                return t
            }

            function y(e) {
                for (var t = {}, n = 0; n < e.length; n++) {
                    var i = g(e[n]);
                    for (var r in i) t[r] = i[r]
                }
                return t
            }

            function x(e, t, n) {
                return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
            }

            function b() {
                function e(r, a) {
                    n !== !1 && (i(r, a), t.requestAnimationFrame(e))
                }
                var t = null,
                    n = !1,
                    i = null;
                return {
                    start: function () {
                        n !== !0 && null !== i && (t.requestAnimationFrame(e), n = !0)
                    },
                    stop: function () {
                        n = !1
                    },
                    setAnimationLoop: function (e) {
                        i = e
                    },
                    setContext: function (e) {
                        t = e
                    }
                }
            }

            function _(e) {
                function t(t, n) {
                    var i = t.array,
                        r = t.dynamic ? 35048 : 35044,
                        a = e.createBuffer();
                    e.bindBuffer(n, a), e.bufferData(n, i, r), t.onUploadCallback();
                    var o = 5126;
                    return i instanceof Float32Array ? o = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? o = 5123 : i instanceof Int16Array ? o = 5122 : i instanceof Uint32Array ? o = 5125 : i instanceof Int32Array ? o = 5124 : i instanceof Int8Array ? o = 5120 : i instanceof Uint8Array && (o = 5121), {
                        buffer: a,
                        type: o,
                        bytesPerElement: i.BYTES_PER_ELEMENT,
                        version: t.version
                    }
                }

                function n(t, n, i) {
                    var r = n.array,
                        a = n.updateRange;
                    e.bindBuffer(i, t), n.dynamic === !1 ? e.bufferData(i, r, 35044) : a.count === -1 ? e.bufferSubData(i, 0, r) : 0 === a.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (e.bufferSubData(i, a.offset * r.BYTES_PER_ELEMENT, r.subarray(a.offset, a.offset + a.count)), a.count = -1)
                }

                function i(e) {
                    return e.isInterleavedBufferAttribute && (e = e.data), o.get(e)
                }

                function r(t) {
                    t.isInterleavedBufferAttribute && (t = t.data);
                    var n = o.get(t);
                    n && (e.deleteBuffer(n.buffer), o["delete"](t))
                }

                function a(e, i) {
                    e.isInterleavedBufferAttribute && (e = e.data);
                    var r = o.get(e);
                    void 0 === r ? o.set(e, t(e, i)) : r.version < e.version && (n(r.buffer, e, i), r.version = e.version)
                }
                var o = new WeakMap;
                return {
                    get: i,
                    remove: r,
                    update: a
                }
            }

            function w(e, t, n, i, r, o) {
                this.a = e, this.b = t, this.c = n, this.normal = i && i.isVector3 ? i : new a, this.vertexNormals = Array.isArray(i) ? i : [], this.color = r && r.isColor ? r : new x, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== o ? o : 0
            }

            function M(e, t, n, i) {
                this._x = e || 0, this._y = t || 0, this._z = n || 0, this._order = i || M.DefaultOrder
            }

            function T() {
                this.mask = 1
            }

            function E() {
                function e() {
                    l.setFromEuler(s, !1)
                }

                function t() {
                    s.setFromQuaternion(l, void 0, !1)
                }
                Object.defineProperty(this, "id", {
                    value: hh++
                }), this.uuid = Wl.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = E.DefaultUp.clone();
                var n = new a,
                    s = new M,
                    l = new r,
                    c = new a(1, 1, 1);
                s.onChange(e), l.onChange(t), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: s
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: l
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: c
                    },
                    modelViewMatrix: {
                        value: new i
                    },
                    normalMatrix: {
                        value: new o
                    }
                }), this.matrix = new i, this.matrixWorld = new i, this.matrixAutoUpdate = E.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new T, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
            }

            function S() {
                Object.defineProperty(this, "id", {
                    value: dh += 2
                }), this.uuid = Wl.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function P(e, t, n) {
                if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = n === !0, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function C(e, t, n) {
                P.call(this, new Int8Array(e), t, n)
            }

            function A(e, t, n) {
                P.call(this, new Uint8Array(e), t, n)
            }

            function L(e, t, n) {
                P.call(this, new Uint8ClampedArray(e), t, n)
            }

            function R(e, t, n) {
                P.call(this, new Int16Array(e), t, n)
            }

            function I(e, t, n) {
                P.call(this, new Uint16Array(e), t, n)
            }

            function O(e, t, n) {
                P.call(this, new Int32Array(e), t, n)
            }

            function k(e, t, n) {
                P.call(this, new Uint32Array(e), t, n)
            }

            function D(e, t, n) {
                P.call(this, new Float32Array(e), t, n)
            }

            function z(e, t, n) {
                P.call(this, new Float64Array(e), t, n)
            }

            function B() {
                this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function N(e) {
                if (0 === e.length) return -(1 / 0);
                for (var t = e[0], n = 1, i = e.length; n < i; ++n) e[n] > t && (t = e[n]);
                return t
            }

            function U() {
                Object.defineProperty(this, "id", {
                    value: ph += 2
                }), this.uuid = Wl.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }

            function j(e, t, n, i, r, a) {
                S.call(this), this.type = "BoxGeometry", this.parameters = {
                    width: e,
                    height: t,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: a
                }, this.fromBufferGeometry(new F(e, t, n, i, r, a)), this.mergeVertices()
            }

            function F(e, t, n, i, r, o) {
                function s(e, t, n, i, r, o, s, m, v, g, y) {
                    var x, b, _ = o / v,
                        w = s / g,
                        M = o / 2,
                        T = s / 2,
                        E = m / 2,
                        S = v + 1,
                        P = g + 1,
                        C = 0,
                        A = 0,
                        L = new a;
                    for (b = 0; b < P; b++) {
                        var R = b * w - T;
                        for (x = 0; x < S; x++) {
                            var I = x * _ - M;
                            L[e] = I * i, L[t] = R * r, L[n] = E, u.push(L.x, L.y, L.z), L[e] = 0, L[t] = 0, L[n] = m > 0 ? 1 : -1, h.push(L.x, L.y, L.z), d.push(x / v), d.push(1 - b / g), C += 1
                        }
                    }
                    for (b = 0; b < g; b++)
                        for (x = 0; x < v; x++) {
                            var O = p + x + S * b,
                                k = p + x + S * (b + 1),
                                D = p + (x + 1) + S * (b + 1),
                                z = p + (x + 1) + S * b;
                            c.push(O, k, z), c.push(k, D, z), A += 6
                        }
                    l.addGroup(f, A, y), f += A, p += C
                }
                U.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                    width: e,
                    height: t,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: o
                };
                var l = this;
                e = e || 1, t = t || 1, n = n || 1, i = Math.floor(i) || 1, r = Math.floor(r) || 1, o = Math.floor(o) || 1;
                var c = [],
                    u = [],
                    h = [],
                    d = [],
                    p = 0,
                    f = 0;
                s("z", "y", "x", -1, -1, n, t, e, o, r, 0), s("z", "y", "x", 1, -1, n, t, -e, o, r, 1), s("x", "z", "y", 1, 1, e, n, t, i, o, 2), s("x", "z", "y", 1, -1, e, n, -t, i, o, 3), s("x", "y", "z", 1, -1, e, t, n, i, r, 4), s("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(c), this.addAttribute("position", new D(u, 3)), this.addAttribute("normal", new D(h, 3)), this.addAttribute("uv", new D(d, 2))
            }

            function G(e, t, n, i) {
                S.call(this), this.type = "PlaneGeometry", this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: n,
                    heightSegments: i
                }, this.fromBufferGeometry(new H(e, t, n, i)), this.mergeVertices()
            }

            function H(e, t, n, i) {
                U.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: n,
                    heightSegments: i
                }, e = e || 1, t = t || 1;
                var r, a, o = e / 2,
                    s = t / 2,
                    l = Math.floor(n) || 1,
                    c = Math.floor(i) || 1,
                    u = l + 1,
                    h = c + 1,
                    d = e / l,
                    p = t / c,
                    f = [],
                    m = [],
                    v = [],
                    g = [];
                for (a = 0; a < h; a++) {
                    var y = a * p - s;
                    for (r = 0; r < u; r++) {
                        var x = r * d - o;
                        m.push(x, -y, 0), v.push(0, 0, 1), g.push(r / l), g.push(1 - a / c)
                    }
                }
                for (a = 0; a < c; a++)
                    for (r = 0; r < l; r++) {
                        var b = r + u * a,
                            _ = r + u * (a + 1),
                            w = r + 1 + u * (a + 1),
                            M = r + 1 + u * a;
                        f.push(b, _, M), f.push(_, w, M)
                    }
                this.setIndex(f), this.addAttribute("position", new D(m, 3)), this.addAttribute("normal", new D(v, 3)), this.addAttribute("uv", new D(g, 2))
            }

            function V() {
                Object.defineProperty(this, "id", {
                    value: fh++
                }), this.uuid = Wl.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = Lo, this.side = _o, this.flatShading = !1, this.vertexTangents = !1, this.vertexColors = So, this.opacity = 1, this.transparent = !1, this.blendSrc = Vo, this.blendDst = Wo, this.blendEquation = Do, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = es, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0
            }

            function W(e) {
                V.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = mh, this.fragmentShader = vh, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
            }

            function q(e, t) {
                this.origin = void 0 !== e ? e : new a, this.direction = void 0 !== t ? t : new a
            }

            function X(e, t, n) {
                this.a = void 0 !== e ? e : new a, this.b = void 0 !== t ? t : new a, this.c = void 0 !== n ? n : new a
            }

            function Y(e) {
                V.call(this), this.type = "MeshBasicMaterial", this.color = new x(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = as, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(e)
            }

            function Z(e, t) {
                E.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new U, this.material = void 0 !== t ? t : new Y({
                    color: 16777215 * Math.random()
                }), this.drawMode = Ll, this.updateMorphTargets()
            }

            function J(e, t, n, i) {
                function r(t, i, r, d) {
                    var p = i.background;
                    if (null === p ? (a(l, c), u = null, h = 0) : p && p.isColor && (a(p, 1), d = !0, u = null, h = 0), (e.autoClear || d) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), p && (p.isCubeTexture || p.isWebGLRenderTargetCube)) {
                        void 0 === s && (s = new Z(new F(1, 1, 1), new W({
                            type: "BackgroundCubeMaterial",
                            uniforms: g(uh.cube.uniforms),
                            vertexShader: uh.cube.vertexShader,
                            fragmentShader: uh.cube.fragmentShader,
                            side: wo,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })), s.geometry.removeAttribute("normal"), s.geometry.removeAttribute("uv"), s.onBeforeRender = function (e, t, n) {
                            this.matrixWorld.copyPosition(n.matrixWorld)
                        }, Object.defineProperty(s.material, "map", {
                            get: function () {
                                return this.uniforms.tCube.value
                            }
                        }), n.update(s));
                        var f = p.isWebGLRenderTargetCube ? p.texture : p;
                        s.material.uniforms.tCube.value = f, s.material.uniforms.tFlip.value = p.isWebGLRenderTargetCube ? 1 : -1, u === p && h === f.version || (s.material.needsUpdate = !0, u = p, h = f.version), t.unshift(s, s.geometry, s.material, 0, 0, null)
                    } else p && p.isTexture && (void 0 === o && (o = new Z(new H(2, 2), new W({
                        type: "BackgroundMaterial",
                        uniforms: g(uh.background.uniforms),
                        vertexShader: uh.background.vertexShader,
                        fragmentShader: uh.background.fragmentShader,
                        side: _o,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), o.geometry.removeAttribute("normal"), Object.defineProperty(o.material, "map", {
                        get: function () {
                            return this.uniforms.t2D.value
                        }
                    }), n.update(o)), o.material.uniforms.t2D.value = p, p.matrixAutoUpdate === !0 && p.updateMatrix(), o.material.uniforms.uvTransform.value.copy(p.matrix), u === p && h === p.version || (o.material.needsUpdate = !0, u = p, h = p.version), t.unshift(o, o.geometry, o.material, 0, 0, null))
                }

                function a(e, n) {
                    t.buffers.color.setClear(e.r, e.g, e.b, n, i)
                }
                var o, s, l = new x(0),
                    c = 0,
                    u = null,
                    h = 0;
                return {
                    getClearColor: function () {
                        return l
                    },
                    setClearColor: function (e, t) {
                        l.set(e), c = void 0 !== t ? t : 1, a(l, c)
                    },
                    getClearAlpha: function () {
                        return c
                    },
                    setClearAlpha: function (e) {
                        c = e, a(l, c)
                    },
                    render: r
                }
            }

            function $(e, t, n, i) {
                function r(e) {
                    s = e
                }

                function a(t, i) {
                    e.drawArrays(s, t, i), n.update(i, s)
                }

                function o(r, a, o) {
                    var l;
                    if (i.isWebGL2) l = e;
                    else if (l = t.get("ANGLE_instanced_arrays"), null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    l[i.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](s, a, o, r.maxInstancedCount), n.update(o, s, r.maxInstancedCount)
                }
                var s;
                this.setMode = r, this.render = a, this.renderInstances = o
            }

            function Q(e, t, n) {
                function i() {
                    if (void 0 !== a) return a;
                    var n = t.get("EXT_texture_filter_anisotropic");
                    return a = null !== n ? e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                }

                function r(t) {
                    if ("highp" === t) {
                        if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                        t = "mediump"
                    }
                    return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                }
                var a, o = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext,
                    s = void 0 !== n.precision ? n.precision : "highp",
                    l = r(s);
                l !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", l, "instead."), s = l);
                var c = n.logarithmicDepthBuffer === !0,
                    u = e.getParameter(34930),
                    h = e.getParameter(35660),
                    d = e.getParameter(3379),
                    p = e.getParameter(34076),
                    f = e.getParameter(34921),
                    m = e.getParameter(36347),
                    v = e.getParameter(36348),
                    g = e.getParameter(36349),
                    y = h > 0,
                    x = o || !!t.get("OES_texture_float"),
                    b = y && x,
                    _ = o ? e.getParameter(36183) : 0;
                return {
                    isWebGL2: o,
                    getMaxAnisotropy: i,
                    getMaxPrecision: r,
                    precision: s,
                    logarithmicDepthBuffer: c,
                    maxTextures: u,
                    maxVertexTextures: h,
                    maxTextureSize: d,
                    maxCubemapSize: p,
                    maxAttributes: f,
                    maxVertexUniforms: m,
                    maxVaryings: v,
                    maxFragmentUniforms: g,
                    vertexTextures: y,
                    floatFragmentTextures: x,
                    floatVertexTextures: b,
                    maxSamples: _
                }
            }

            function K() {
                function e() {
                    u.value !== i && (u.value = i, u.needsUpdate = r > 0), n.numPlanes = r, n.numIntersection = 0
                }

                function t(e, t, i, r) {
                    var a = null !== e ? e.length : 0,
                        o = null;
                    if (0 !== a) {
                        if (o = u.value, r !== !0 || null === o) {
                            var s = i + 4 * a,
                                h = t.matrixWorldInverse;
                            c.getNormalMatrix(h), (null === o || o.length < s) && (o = new Float32Array(s));
                            for (var d = 0, p = i; d !== a; ++d, p += 4) l.copy(e[d]).applyMatrix4(h, c), l.normal.toArray(o, p), o[p + 3] = l.constant
                        }
                        u.value = o, u.needsUpdate = !0
                    }
                    return n.numPlanes = a, o
                }
                var n = this,
                    i = null,
                    r = 0,
                    a = !1,
                    s = !1,
                    l = new m,
                    c = new o,
                    u = {
                        value: null,
                        needsUpdate: !1
                    };
                this.uniform = u, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, n, o) {
                    var s = 0 !== e.length || n || 0 !== r || a;
                    return a = n, i = t(e, o, 0), r = e.length, s
                }, this.beginShadows = function () {
                    s = !0, t(null)
                }, this.endShadows = function () {
                    s = !1, e()
                }, this.setState = function (n, o, l, c, h, d) {
                    if (!a || null === n || 0 === n.length || s && !l) s ? t(null) : e();
                    else {
                        var p = s ? 0 : r,
                            f = 4 * p,
                            m = h.clippingState || null;
                        u.value = m, m = t(n, c, f, d);
                        for (var v = 0; v !== f; ++v) m[v] = i[v];
                        h.clippingState = m, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += p
                    }
                }
            }

            function ee(e) {
                var t = {};
                return {
                    get: function (n) {
                        if (void 0 !== t[n]) return t[n];
                        var i;
                        switch (n) {
                            case "WEBGL_depth_texture":
                                i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            default:
                                i = e.getExtension(n)
                        }
                        return null === i && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), t[n] = i, i
                    }
                }
            }

            function te(e, t, n) {
                function i(e) {
                    var r = e.target,
                        a = s[r.id];
                    null !== a.index && t.remove(a.index);
                    for (var o in a.attributes) t.remove(a.attributes[o]);
                    r.removeEventListener("dispose", i), delete s[r.id];
                    var c = l[a.id];
                    c && (t.remove(c), delete l[a.id]), n.memory.geometries--
                }

                function r(e, t) {
                    var r = s[t.id];
                    return r ? r : (t.addEventListener("dispose", i), t.isBufferGeometry ? r = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new U).setFromObject(e)), r = t._bufferGeometry), s[t.id] = r, n.memory.geometries++, r)
                }

                function a(e) {
                    var n = e.index,
                        i = e.attributes;
                    null !== n && t.update(n, 34963);
                    for (var r in i) t.update(i[r], 34962);
                    var a = e.morphAttributes;
                    for (var r in a)
                        for (var o = a[r], s = 0, l = o.length; s < l; s++) t.update(o[s], 34962)
                }

                function o(e) {
                    var n = l[e.id];
                    if (n) return n;
                    var i = [],
                        r = e.index,
                        a = e.attributes;
                    if (null !== r)
                        for (var o = r.array, s = 0, c = o.length; s < c; s += 3) {
                            var u = o[s + 0],
                                h = o[s + 1],
                                d = o[s + 2];
                            i.push(u, h, h, d, d, u)
                        } else
                            for (var o = a.position.array, s = 0, c = o.length / 3 - 1; s < c; s += 3) {
                                var u = s + 0,
                                    h = s + 1,
                                    d = s + 2;
                                i.push(u, h, h, d, d, u)
                            }
                    return n = new(N(i) > 65535 ? k : I)(i, 1), t.update(n, 34963), l[e.id] = n, n
                }
                var s = {},
                    l = {};
                return {
                    get: r,
                    update: a,
                    getWireframeAttribute: o
                }
            }

            function ne(e, t, n, i) {
                function r(e) {
                    l = e
                }

                function a(e) {
                    c = e.type, u = e.bytesPerElement
                }

                function o(t, i) {
                    e.drawElements(l, i, c, t * u), n.update(i, l)
                }

                function s(r, a, o) {
                    var s;
                    if (i.isWebGL2) s = e;
                    else {
                        var s = t.get("ANGLE_instanced_arrays");
                        if (null === s) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.")
                    }
                    s[i.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](l, o, c, a * u, r.maxInstancedCount), n.update(o, l, r.maxInstancedCount)
                }
                var l, c, u;
                this.setMode = r, this.setIndex = a, this.render = o, this.renderInstances = s
            }

            function ie(e) {
                function t(e, t, n) {
                    switch (n = n || 1, r.calls++, t) {
                        case 4:
                            r.triangles += n * (e / 3);
                            break;
                        case 5:
                        case 6:
                            r.triangles += n * (e - 2);
                            break;
                        case 1:
                            r.lines += n * (e / 2);
                            break;
                        case 3:
                            r.lines += n * (e - 1);
                            break;
                        case 2:
                            r.lines += n * e;
                            break;
                        case 0:
                            r.points += n * e;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", t)
                    }
                }

                function n() {
                    r.frame++, r.calls = 0, r.triangles = 0, r.points = 0, r.lines = 0
                }
                var i = {
                        geometries: 0,
                        textures: 0
                    },
                    r = {
                        frame: 0,
                        calls: 0,
                        triangles: 0,
                        points: 0,
                        lines: 0
                    };
                return {
                    memory: i,
                    render: r,
                    programs: null,
                    autoReset: !0,
                    reset: n,
                    update: t
                }
            }

            function re(e, t) {
                return Math.abs(t[1]) - Math.abs(e[1])
            }

            function ae(e) {
                function t(t, r, a, o) {
                    var s = t.morphTargetInfluences,
                        l = s.length,
                        c = n[r.id];
                    if (void 0 === c) {
                        c = [];
                        for (var u = 0; u < l; u++) c[u] = [u, 0];
                        n[r.id] = c
                    }
                    for (var h = a.morphTargets && r.morphAttributes.position, d = a.morphNormals && r.morphAttributes.normal, u = 0; u < l; u++) {
                        var p = c[u];
                        0 !== p[1] && (h && r.removeAttribute("morphTarget" + u), d && r.removeAttribute("morphNormal" + u))
                    }
                    for (var u = 0; u < l; u++) {
                        var p = c[u];
                        p[0] = u, p[1] = s[u]
                    }
                    c.sort(re);
                    for (var u = 0; u < 8; u++) {
                        var p = c[u];
                        if (p) {
                            var f = p[0],
                                m = p[1];
                            if (m) {
                                h && r.addAttribute("morphTarget" + u, h[f]), d && r.addAttribute("morphNormal" + u, d[f]), i[u] = m;
                                continue
                            }
                        }
                        i[u] = 0
                    }
                    o.getUniforms().setValue(e, "morphTargetInfluences", i)
                }
                var n = {},
                    i = new Float32Array(8);
                return {
                    update: t
                }
            }

            function oe(e, t) {
                function n(n) {
                    var i = t.render.frame,
                        a = n.geometry,
                        o = e.get(n, a);
                    return r[o.id] !== i && (a.isGeometry && o.updateFromObject(n), e.update(o), r[o.id] = i), o
                }

                function i() {
                    r = {}
                }
                var r = {};
                return {
                    update: n,
                    dispose: i
                }
            }

            function se(e, t, n, i, r, a, o, l, c, u) {
                e = void 0 !== e ? e : [], t = void 0 !== t ? t : ms, o = void 0 !== o ? o : Vs, s.call(this, e, t, n, i, r, a, o, l, c, u), this.flipY = !1
            }

            function le(e, t, n, i) {
                s.call(this, null), this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: i
                }, this.magFilter = Es, this.minFilter = Es, this.wrapR = Ms, this.generateMipmaps = !1, this.flipY = !1
            }

            function ce() {
                this.seq = [], this.map = {}
            }

            function ue(e, t, n) {
                var i = e[0];
                if (i <= 0 || i > 0) return e;
                var r = t * n,
                    a = bh[r];
                if (void 0 === a && (a = new Float32Array(r), bh[r] = a), 0 !== t) {
                    i.toArray(a, 0);
                    for (var o = 1, s = 0; o !== t; ++o) s += n, e[o].toArray(a, s)
                }
                return a
            }

            function he(e, t) {
                if (e.length !== t.length) return !1;
                for (var n = 0, i = e.length; n < i; n++)
                    if (e[n] !== t[n]) return !1;
                return !0
            }

            function de(e, t) {
                for (var n = 0, i = t.length; n < i; n++) e[n] = t[n]
            }

            function pe(e, t) {
                var n = _h[t];
                void 0 === n && (n = new Int32Array(t), _h[t] = n);
                for (var i = 0; i !== t; ++i) n[i] = e.allocTextureUnit();
                return n
            }

            function fe(e, t) {
                var n = this.cache;
                n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
            }

            function me(e, t) {
                var n = this.cache;
                n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
            }

            function ve(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
                else {
                    if (he(n, t)) return;
                    e.uniform2fv(this.addr, t), de(n, t)
                }
            }

            function ge(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
                else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
                else {
                    if (he(n, t)) return;
                    e.uniform3fv(this.addr, t), de(n, t)
                }
            }

            function ye(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
                else {
                    if (he(n, t)) return;
                    e.uniform4fv(this.addr, t), de(n, t)
                }
            }

            function xe(e, t) {
                var n = this.cache,
                    i = t.elements;
                if (void 0 === i) {
                    if (he(n, t)) return;
                    e.uniformMatrix2fv(this.addr, !1, t), de(n, t)
                } else {
                    if (he(n, i)) return;
                    Th.set(i), e.uniformMatrix2fv(this.addr, !1, Th), de(n, i)
                }
            }

            function be(e, t) {
                var n = this.cache,
                    i = t.elements;
                if (void 0 === i) {
                    if (he(n, t)) return;
                    e.uniformMatrix3fv(this.addr, !1, t), de(n, t)
                } else {
                    if (he(n, i)) return;
                    Mh.set(i), e.uniformMatrix3fv(this.addr, !1, Mh), de(n, i)
                }
            }

            function _e(e, t) {
                var n = this.cache,
                    i = t.elements;
                if (void 0 === i) {
                    if (he(n, t)) return;
                    e.uniformMatrix4fv(this.addr, !1, t), de(n, t)
                } else {
                    if (he(n, i)) return;
                    wh.set(i), e.uniformMatrix4fv(this.addr, !1, wh), de(n, i)
                }
            }

            function we(e, t, n) {
                var i = this.cache,
                    r = n.allocTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture2D(t || gh, r)
            }

            function Me(e, t, n) {
                var i = this.cache,
                    r = n.allocTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(t || yh, r)
            }

            function Te(e, t, n) {
                var i = this.cache,
                    r = n.allocTextureUnit();
                i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(t || xh, r)
            }

            function Ee(e, t) {
                var n = this.cache;
                he(n, t) || (e.uniform2iv(this.addr, t), de(n, t))
            }

            function Se(e, t) {
                var n = this.cache;
                he(n, t) || (e.uniform3iv(this.addr, t), de(n, t))
            }

            function Pe(e, t) {
                var n = this.cache;
                he(n, t) || (e.uniform4iv(this.addr, t), de(n, t))
            }

            function Ce(e) {
                switch (e) {
                    case 5126:
                        return fe;
                    case 35664:
                        return ve;
                    case 35665:
                        return ge;
                    case 35666:
                        return ye;
                    case 35674:
                        return xe;
                    case 35675:
                        return be;
                    case 35676:
                        return _e;
                    case 35678:
                    case 36198:
                        return we;
                    case 35679:
                        return Me;
                    case 35680:
                        return Te;
                    case 5124:
                    case 35670:
                        return me;
                    case 35667:
                    case 35671:
                        return Ee;
                    case 35668:
                    case 35672:
                        return Se;
                    case 35669:
                    case 35673:
                        return Pe
                }
            }

            function Ae(e, t) {
                var n = this.cache;
                he(n, t) || (e.uniform1fv(this.addr, t), de(n, t))
            }

            function Le(e, t) {
                var n = this.cache;
                he(n, t) || (e.uniform1iv(this.addr, t), de(n, t))
            }

            function Re(e, t) {
                var n = this.cache,
                    i = ue(t, this.size, 2);
                he(n, i) || (e.uniform2fv(this.addr, i), this.updateCache(i))
            }

            function Ie(e, t) {
                var n = this.cache,
                    i = ue(t, this.size, 3);
                he(n, i) || (e.uniform3fv(this.addr, i), this.updateCache(i))
            }

            function Oe(e, t) {
                var n = this.cache,
                    i = ue(t, this.size, 4);
                he(n, i) || (e.uniform4fv(this.addr, i), this.updateCache(i))
            }

            function ke(e, t) {
                var n = this.cache,
                    i = ue(t, this.size, 4);
                he(n, i) || (e.uniformMatrix2fv(this.addr, !1, i), this.updateCache(i))
            }

            function De(e, t) {
                var n = this.cache,
                    i = ue(t, this.size, 9);
                he(n, i) || (e.uniformMatrix3fv(this.addr, !1, i), this.updateCache(i))
            }

            function ze(e, t) {
                var n = this.cache,
                    i = ue(t, this.size, 16);
                he(n, i) || (e.uniformMatrix4fv(this.addr, !1, i), this.updateCache(i))
            }

            function Be(e, t, n) {
                var i = this.cache,
                    r = t.length,
                    a = pe(n, r);
                he(i, a) === !1 && (e.uniform1iv(this.addr, a), de(i, a));
                for (var o = 0; o !== r; ++o) n.setTexture2D(t[o] || gh, a[o])
            }

            function Ne(e, t, n) {
                var i = this.cache,
                    r = t.length,
                    a = pe(n, r);
                he(i, a) === !1 && (e.uniform1iv(this.addr, a), de(i, a));
                for (var o = 0; o !== r; ++o) n.setTextureCube(t[o] || xh, a[o])
            }

            function Ue(e) {
                switch (e) {
                    case 5126:
                        return Ae;
                    case 35664:
                        return Re;
                    case 35665:
                        return Ie;
                    case 35666:
                        return Oe;
                    case 35674:
                        return ke;
                    case 35675:
                        return De;
                    case 35676:
                        return ze;
                    case 35678:
                        return Be;
                    case 35680:
                        return Ne;
                    case 5124:
                    case 35670:
                        return Le;
                    case 35667:
                    case 35671:
                        return Ee;
                    case 35668:
                    case 35672:
                        return Se;
                    case 35669:
                    case 35673:
                        return Pe
                }
            }

            function je(e, t, n) {
                this.id = e, this.addr = n, this.cache = [], this.setValue = Ce(t.type)
            }

            function Fe(e, t, n) {
                this.id = e, this.addr = n, this.cache = [], this.size = t.size, this.setValue = Ue(t.type)
            }

            function Ge(e) {
                this.id = e, ce.call(this)
            }

            function He(e, t) {
                e.seq.push(t), e.map[t.id] = t
            }

            function Ve(e, t, n) {
                var i = e.name,
                    r = i.length;
                for (Eh.lastIndex = 0;;) {
                    var a = Eh.exec(i),
                        o = Eh.lastIndex,
                        s = a[1],
                        l = "]" === a[2],
                        c = a[3];
                    if (l && (s = 0 | s), void 0 === c || "[" === c && o + 2 === r) {
                        He(n, void 0 === c ? new je(s, e, t) : new Fe(s, e, t));
                        break
                    }
                    var u = n.map,
                        h = u[s];
                    void 0 === h && (h = new Ge(s), He(n, h)), n = h
                }
            }

            function We(e, t, n) {
                ce.call(this), this.renderer = n;
                for (var i = e.getProgramParameter(t, 35718), r = 0; r < i; ++r) {
                    var a = e.getActiveUniform(t, r),
                        o = e.getUniformLocation(t, a.name);
                    Ve(a, o, this)
                }
            }

            function qe(e) {
                for (var t = e.split("\n"), n = 0; n < t.length; n++) t[n] = n + 1 + ": " + t[n];
                return t.join("\n")
            }

            function Xe(e, t, n) {
                var i = e.createShader(t);
                return e.shaderSource(i, n), e.compileShader(i), e.getShaderParameter(i, 35713) === !1 && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== e.getShaderInfoLog(i) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === t ? "vertex" : "fragment", e.getShaderInfoLog(i), qe(n)), i
            }

            function Ye(e) {
                switch (e) {
                    case Ol:
                        return ["Linear", "( value )"];
                    case kl:
                        return ["sRGB", "( value )"];
                    case zl:
                        return ["RGBE", "( value )"];
                    case Nl:
                        return ["RGBM", "( value, 7.0 )"];
                    case Ul:
                        return ["RGBM", "( value, 16.0 )"];
                    case jl:
                        return ["RGBD", "( value, 256.0 )"];
                    case Dl:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    default:
                        throw new Error("unsupported encoding: " + e)
                }
            }

            function Ze(e, t) {
                var n = Ye(t);
                return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
            }

            function Je(e, t) {
                var n = Ye(t);
                return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
            }

            function $e(e, t) {
                var n;
                switch (t) {
                    case cs:
                        n = "Linear";
                        break;
                    case us:
                        n = "Reinhard";
                        break;
                    case hs:
                        n = "Uncharted2";
                        break;
                    case ds:
                        n = "OptimizedCineon";
                        break;
                    case ps:
                        n = "ACESFilmic";
                        break;
                    default:
                        throw new Error("unsupported toneMapping: " + t)
                }
                return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
            }

            function Qe(e, t, n) {
                e = e || {};
                var i = [e.derivatives || t.envMapCubeUV || t.bumpMap || t.normalMap && !t.objectSpaceNormalMap || t.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (e.fragDepth || t.logarithmicDepthBuffer) && n.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", e.drawBuffers && n.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (e.shaderTextureLOD || t.envMap) && n.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
                return i.filter(tt).join("\n")
            }

            function Ke(e) {
                var t = [];
                for (var n in e) {
                    var i = e[n];
                    i !== !1 && t.push("#define " + n + " " + i)
                }
                return t.join("\n")
            }

            function et(e, t) {
                for (var n = {}, i = e.getProgramParameter(t, 35721), r = 0; r < i; r++) {
                    var a = e.getActiveAttrib(t, r),
                        o = a.name;
                    n[o] = e.getAttribLocation(t, o)
                }
                return n
            }

            function tt(e) {
                return "" !== e
            }

            function nt(e, t) {
                return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
            }

            function it(e, t) {
                return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
            }

            function rt(e) {
                function t(e, t) {
                    var n = oh[t];
                    if (void 0 === n) throw new Error("Can not resolve #include <" + t + ">");
                    return rt(n)
                }
                var n = /^[ \t]*#include +<([\w\d.\/]+)>/gm;
                return e.replace(n, t)
            }

            function at(e) {
                function t(e, t, n, i) {
                    for (var r = "", a = parseInt(t); a < parseInt(n); a++) r += i.replace(/\[ i \]/g, "[ " + a + " ]");
                    return r
                }
                var n = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
                return e.replace(n, t)
            }

            function ot(e, t, n, i, r, a, o) {
                var s = e.context,
                    l = i.defines,
                    c = r.vertexShader,
                    u = r.fragmentShader,
                    h = "SHADOWMAP_TYPE_BASIC";
                a.shadowMapType === xo ? h = "SHADOWMAP_TYPE_PCF" : a.shadowMapType === bo && (h = "SHADOWMAP_TYPE_PCF_SOFT");
                var d = "ENVMAP_TYPE_CUBE",
                    p = "ENVMAP_MODE_REFLECTION",
                    f = "ENVMAP_BLENDING_MULTIPLY";
                if (a.envMap) {
                    switch (i.envMap.mapping) {
                        case ms:
                        case vs:
                            d = "ENVMAP_TYPE_CUBE";
                            break;
                        case bs:
                        case _s:
                            d = "ENVMAP_TYPE_CUBE_UV";
                            break;
                        case gs:
                        case ys:
                            d = "ENVMAP_TYPE_EQUIREC";
                            break;
                        case xs:
                            d = "ENVMAP_TYPE_SPHERE"
                    }
                    switch (i.envMap.mapping) {
                        case vs:
                        case ys:
                            p = "ENVMAP_MODE_REFRACTION"
                    }
                    switch (i.combine) {
                        case as:
                            f = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case os:
                            f = "ENVMAP_BLENDING_MIX";
                            break;
                        case ss:
                            f = "ENVMAP_BLENDING_ADD"
                    }
                }
                var m, v, g = e.gammaFactor > 0 ? e.gammaFactor : 1,
                    y = o.isWebGL2 ? "" : Qe(i.extensions, a, t),
                    x = Ke(l),
                    b = s.createProgram();
                if (i.isRawShaderMaterial ? (m = [x].filter(tt).join("\n"), m.length > 0 && (m += "\n"), v = [y, x].filter(tt).join("\n"), v.length > 0 && (v += "\n")) : (m = ["precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, x, a.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + g, "#define MAX_BONES " + a.maxBones, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + p : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.displacementMap && a.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexTangents ? "#define USE_TANGENT" : "", a.vertexColors ? "#define USE_COLOR" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.skinning ? "#define USE_SKINNING" : "", a.useVertexTexture ? "#define BONE_TEXTURE" : "", a.morphTargets ? "#define USE_MORPHTARGETS" : "", a.morphNormals && a.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + h : "", a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(tt).join("\n"), v = [y, "precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, x, a.alphaTest ? "#define ALPHATEST " + a.alphaTest + (a.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + g, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.matcap ? "#define USE_MATCAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + d : "", a.envMap ? "#define " + p : "", a.envMap ? "#define " + f : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexTangents ? "#define USE_TANGENT" : "", a.vertexColors ? "#define USE_COLOR" : "", a.gradientMap ? "#define USE_GRADIENTMAP" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + h : "", a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", a.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", a.envMap && (o.isWebGL2 || t.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", a.toneMapping !== ls ? "#define TONE_MAPPING" : "", a.toneMapping !== ls ? oh.tonemapping_pars_fragment : "", a.toneMapping !== ls ? $e("toneMapping", a.toneMapping) : "", a.dithering ? "#define DITHERING" : "", a.outputEncoding || a.mapEncoding || a.matcapEncoding || a.envMapEncoding || a.emissiveMapEncoding ? oh.encodings_pars_fragment : "", a.mapEncoding ? Ze("mapTexelToLinear", a.mapEncoding) : "", a.matcapEncoding ? Ze("matcapTexelToLinear", a.matcapEncoding) : "", a.envMapEncoding ? Ze("envMapTexelToLinear", a.envMapEncoding) : "", a.emissiveMapEncoding ? Ze("emissiveMapTexelToLinear", a.emissiveMapEncoding) : "", a.outputEncoding ? Je("linearToOutputTexel", a.outputEncoding) : "", a.depthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(tt).join("\n")), c = rt(c), c = nt(c, a), c = it(c, a), u = rt(u), u = nt(u, a), u = it(u, a), c = at(c), u = at(u), o.isWebGL2 && !i.isRawShaderMaterial) {
                    var _ = !1,
                        w = /^\s*#version\s+300\s+es\s*\n/;
                    i.isShaderMaterial && null !== c.match(w) && null !== u.match(w) && (_ = !0, c = c.replace(w, ""), u = u.replace(w, "")), m = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + m, v = ["#version 300 es\n", "#define varying in", _ ? "" : "out highp vec4 pc_fragColor;", _ ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v
                }
                var M = m + c,
                    T = v + u,
                    E = Xe(s, 35633, M),
                    S = Xe(s, 35632, T);
                s.attachShader(b, E), s.attachShader(b, S), void 0 !== i.index0AttributeName ? s.bindAttribLocation(b, 0, i.index0AttributeName) : a.morphTargets === !0 && s.bindAttribLocation(b, 0, "position"),
                    s.linkProgram(b);
                var P = s.getProgramInfoLog(b).trim(),
                    C = s.getShaderInfoLog(E).trim(),
                    A = s.getShaderInfoLog(S).trim(),
                    L = !0,
                    R = !0;
                s.getProgramParameter(b, 35714) === !1 ? (L = !1, console.error("THREE.WebGLProgram: shader error: ", s.getError(), "35715", s.getProgramParameter(b, 35715), "gl.getProgramInfoLog", P, C, A)) : "" !== P ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", P) : "" !== C && "" !== A || (R = !1), R && (this.diagnostics = {
                    runnable: L,
                    material: i,
                    programLog: P,
                    vertexShader: {
                        log: C,
                        prefix: m
                    },
                    fragmentShader: {
                        log: A,
                        prefix: v
                    }
                }), s.deleteShader(E), s.deleteShader(S);
                var I;
                this.getUniforms = function () {
                    return void 0 === I && (I = new We(s, b, e)), I
                };
                var O;
                return this.getAttributes = function () {
                    return void 0 === O && (O = et(s, b)), O
                }, this.destroy = function () {
                    s.deleteProgram(b), this.program = void 0
                }, Object.defineProperties(this, {
                    uniforms: {
                        get: function () {
                            return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                        }
                    },
                    attributes: {
                        get: function () {
                            return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                        }
                    }
                }), this.name = r.name, this.id = Sh++, this.code = n, this.usedTimes = 1, this.program = b, this.vertexShader = E, this.fragmentShader = S, this
            }

            function st(e, t, n) {
                function i(e) {
                    var t = e.skeleton,
                        i = t.bones;
                    if (n.floatVertexTextures) return 1024;
                    var r = n.maxVertexUniforms,
                        a = Math.floor((r - 20) / 4),
                        o = Math.min(a, i.length);
                    return o < i.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + i.length + " bones. This GPU supports " + o + "."), 0) : o
                }

                function r(e, t) {
                    var n;
                    return e ? e.isTexture ? n = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), n = e.texture.encoding) : n = Ol, n === Ol && t && (n = Dl), n
                }
                var a = [],
                    o = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "phong",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    },
                    s = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];
                this.getParameters = function (t, a, s, l, c, u, h) {
                    var d = o[t.type],
                        p = h.isSkinnedMesh ? i(h) : 0,
                        f = n.precision;
                    null !== t.precision && (f = n.getMaxPrecision(t.precision), f !== t.precision && console.warn("THREE.WebGLProgram.getParameters:", t.precision, "not supported, using", f, "instead."));
                    var m = e.getRenderTarget(),
                        v = {
                            shaderID: d,
                            precision: f,
                            supportsVertexTextures: n.vertexTextures,
                            outputEncoding: r(m ? m.texture : null, e.gammaOutput),
                            map: !!t.map,
                            mapEncoding: r(t.map, e.gammaInput),
                            matcap: !!t.matcap,
                            matcapEncoding: r(t.matcap, e.gammaInput),
                            envMap: !!t.envMap,
                            envMapMode: t.envMap && t.envMap.mapping,
                            envMapEncoding: r(t.envMap, e.gammaInput),
                            envMapCubeUV: !!t.envMap && (t.envMap.mapping === bs || t.envMap.mapping === _s),
                            lightMap: !!t.lightMap,
                            aoMap: !!t.aoMap,
                            emissiveMap: !!t.emissiveMap,
                            emissiveMapEncoding: r(t.emissiveMap, e.gammaInput),
                            bumpMap: !!t.bumpMap,
                            normalMap: !!t.normalMap,
                            objectSpaceNormalMap: t.normalMapType === Vl,
                            displacementMap: !!t.displacementMap,
                            roughnessMap: !!t.roughnessMap,
                            metalnessMap: !!t.metalnessMap,
                            specularMap: !!t.specularMap,
                            alphaMap: !!t.alphaMap,
                            gradientMap: !!t.gradientMap,
                            combine: t.combine,
                            vertexTangents: t.normalMap && t.vertexTangents,
                            vertexColors: t.vertexColors,
                            fog: !!l,
                            useFog: t.fog,
                            fogExp: l && l.isFogExp2,
                            flatShading: t.flatShading,
                            sizeAttenuation: t.sizeAttenuation,
                            logarithmicDepthBuffer: n.logarithmicDepthBuffer,
                            skinning: t.skinning && p > 0,
                            maxBones: p,
                            useVertexTexture: n.floatVertexTextures,
                            morphTargets: t.morphTargets,
                            morphNormals: t.morphNormals,
                            maxMorphTargets: e.maxMorphTargets,
                            maxMorphNormals: e.maxMorphNormals,
                            numDirLights: a.directional.length,
                            numPointLights: a.point.length,
                            numSpotLights: a.spot.length,
                            numRectAreaLights: a.rectArea.length,
                            numHemiLights: a.hemi.length,
                            numClippingPlanes: c,
                            numClipIntersection: u,
                            dithering: t.dithering,
                            shadowMapEnabled: e.shadowMap.enabled && h.receiveShadow && s.length > 0,
                            shadowMapType: e.shadowMap.type,
                            toneMapping: e.toneMapping,
                            physicallyCorrectLights: e.physicallyCorrectLights,
                            premultipliedAlpha: t.premultipliedAlpha,
                            alphaTest: t.alphaTest,
                            doubleSided: t.side === Mo,
                            flipSided: t.side === wo,
                            depthPacking: void 0 !== t.depthPacking && t.depthPacking
                        };
                    return v
                }, this.getProgramCode = function (t, n) {
                    var i = [];
                    if (n.shaderID ? i.push(n.shaderID) : (i.push(t.fragmentShader), i.push(t.vertexShader)), void 0 !== t.defines)
                        for (var r in t.defines) i.push(r), i.push(t.defines[r]);
                    for (var a = 0; a < s.length; a++) i.push(n[s[a]]);
                    return i.push(t.onBeforeCompile.toString()), i.push(e.gammaOutput), i.push(e.gammaFactor), i.join()
                }, this.acquireProgram = function (i, r, o, s) {
                    for (var l, c = 0, u = a.length; c < u; c++) {
                        var h = a[c];
                        if (h.code === s) {
                            l = h, ++l.usedTimes;
                            break
                        }
                    }
                    return void 0 === l && (l = new ot(e, t, s, i, r, o, n), a.push(l)), l
                }, this.releaseProgram = function (e) {
                    if (0 === --e.usedTimes) {
                        var t = a.indexOf(e);
                        a[t] = a[a.length - 1], a.pop(), e.destroy()
                    }
                }, this.programs = a
            }

            function lt() {
                function e(e) {
                    var t = r.get(e);
                    return void 0 === t && (t = {}, r.set(e, t)), t
                }

                function t(e) {
                    r["delete"](e)
                }

                function n(e, t, n) {
                    r.get(e)[t] = n
                }

                function i() {
                    r = new WeakMap
                }
                var r = new WeakMap;
                return {
                    get: e,
                    remove: t,
                    update: n,
                    dispose: i
                }
            }

            function ct(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program && t.program && e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
            }

            function ut(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
            }

            function ht() {
                function e() {
                    o = 0, s.length = 0, l.length = 0
                }

                function t(e, t, n, i, r, s) {
                    var l = a[o];
                    return void 0 === l ? (l = {
                        id: e.id,
                        object: e,
                        geometry: t,
                        material: n,
                        program: n.program,
                        groupOrder: i,
                        renderOrder: e.renderOrder,
                        z: r,
                        group: s
                    }, a[o] = l) : (l.id = e.id, l.object = e, l.geometry = t, l.material = n, l.program = n.program, l.groupOrder = i, l.renderOrder = e.renderOrder, l.z = r, l.group = s), o++, l
                }

                function n(e, n, i, r, a, o) {
                    var c = t(e, n, i, r, a, o);
                    (i.transparent === !0 ? l : s).push(c)
                }

                function i(e, n, i, r, a, o) {
                    var c = t(e, n, i, r, a, o);
                    (i.transparent === !0 ? l : s).unshift(c)
                }

                function r() {
                    s.length > 1 && s.sort(ct), l.length > 1 && l.sort(ut)
                }
                var a = [],
                    o = 0,
                    s = [],
                    l = [];
                return {
                    opaque: s,
                    transparent: l,
                    init: e,
                    push: n,
                    unshift: i,
                    sort: r
                }
            }

            function dt() {
                function e(t) {
                    var n = t.target;
                    n.removeEventListener("dispose", e), delete i[n.id]
                }

                function t(t, n) {
                    var r, a = i[t.id];
                    return void 0 === a ? (r = new ht, i[t.id] = {}, i[t.id][n.id] = r, t.addEventListener("dispose", e)) : (r = a[n.id], void 0 === r && (r = new ht, a[n.id] = r)), r
                }

                function n() {
                    i = {}
                }
                var i = {};
                return {
                    get: t,
                    dispose: n
                }
            }

            function pt() {
                var e = {};
                return {
                    get: function (t) {
                        if (void 0 !== e[t.id]) return e[t.id];
                        var i;
                        switch (t.type) {
                            case "DirectionalLight":
                                i = {
                                    direction: new a,
                                    color: new x,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new n
                                };
                                break;
                            case "SpotLight":
                                i = {
                                    position: new a,
                                    direction: new a,
                                    color: new x,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new n
                                };
                                break;
                            case "PointLight":
                                i = {
                                    position: new a,
                                    color: new x,
                                    distance: 0,
                                    decay: 0,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new n,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                };
                                break;
                            case "HemisphereLight":
                                i = {
                                    direction: new a,
                                    skyColor: new x,
                                    groundColor: new x
                                };
                                break;
                            case "RectAreaLight":
                                i = {
                                    color: new x,
                                    position: new a,
                                    halfWidth: new a,
                                    halfHeight: new a
                                }
                        }
                        return e[t.id] = i, i
                    }
                }
            }

            function ft() {
                function e(e, i, a) {
                    for (var l = 0, c = 0, u = 0, h = 0, d = 0, p = 0, f = 0, m = 0, v = a.matrixWorldInverse, g = 0, y = e.length; g < y; g++) {
                        var x = e[g],
                            b = x.color,
                            _ = x.intensity,
                            w = x.distance,
                            M = x.shadow && x.shadow.map ? x.shadow.map.texture : null;
                        if (x.isAmbientLight) l += b.r * _, c += b.g * _, u += b.b * _;
                        else if (x.isDirectionalLight) {
                            var T = t.get(x);
                            if (T.color.copy(x.color).multiplyScalar(x.intensity), T.direction.setFromMatrixPosition(x.matrixWorld), r.setFromMatrixPosition(x.target.matrixWorld), T.direction.sub(r), T.direction.transformDirection(v), T.shadow = x.castShadow, x.castShadow) {
                                var E = x.shadow;
                                T.shadowBias = E.bias, T.shadowRadius = E.radius, T.shadowMapSize = E.mapSize
                            }
                            n.directionalShadowMap[h] = M, n.directionalShadowMatrix[h] = x.shadow.matrix, n.directional[h] = T, h++
                        } else if (x.isSpotLight) {
                            var T = t.get(x);
                            if (T.position.setFromMatrixPosition(x.matrixWorld), T.position.applyMatrix4(v), T.color.copy(b).multiplyScalar(_), T.distance = w, T.direction.setFromMatrixPosition(x.matrixWorld), r.setFromMatrixPosition(x.target.matrixWorld), T.direction.sub(r), T.direction.transformDirection(v), T.coneCos = Math.cos(x.angle), T.penumbraCos = Math.cos(x.angle * (1 - x.penumbra)), T.decay = x.decay, T.shadow = x.castShadow, x.castShadow) {
                                var E = x.shadow;
                                T.shadowBias = E.bias, T.shadowRadius = E.radius, T.shadowMapSize = E.mapSize
                            }
                            n.spotShadowMap[p] = M, n.spotShadowMatrix[p] = x.shadow.matrix, n.spot[p] = T, p++
                        } else if (x.isRectAreaLight) {
                            var T = t.get(x);
                            T.color.copy(b).multiplyScalar(_), T.position.setFromMatrixPosition(x.matrixWorld), T.position.applyMatrix4(v), s.identity(), o.copy(x.matrixWorld), o.premultiply(v), s.extractRotation(o), T.halfWidth.set(.5 * x.width, 0, 0), T.halfHeight.set(0, .5 * x.height, 0), T.halfWidth.applyMatrix4(s), T.halfHeight.applyMatrix4(s), n.rectArea[f] = T, f++
                        } else if (x.isPointLight) {
                            var T = t.get(x);
                            if (T.position.setFromMatrixPosition(x.matrixWorld), T.position.applyMatrix4(v), T.color.copy(x.color).multiplyScalar(x.intensity), T.distance = x.distance, T.decay = x.decay, T.shadow = x.castShadow, x.castShadow) {
                                var E = x.shadow;
                                T.shadowBias = E.bias, T.shadowRadius = E.radius, T.shadowMapSize = E.mapSize, T.shadowCameraNear = E.camera.near, T.shadowCameraFar = E.camera.far
                            }
                            n.pointShadowMap[d] = M, n.pointShadowMatrix[d] = x.shadow.matrix, n.point[d] = T, d++
                        } else if (x.isHemisphereLight) {
                            var T = t.get(x);
                            T.direction.setFromMatrixPosition(x.matrixWorld), T.direction.transformDirection(v), T.direction.normalize(), T.skyColor.copy(x.color).multiplyScalar(_), T.groundColor.copy(x.groundColor).multiplyScalar(_), n.hemi[m] = T, m++
                        }
                    }
                    n.ambient[0] = l, n.ambient[1] = c, n.ambient[2] = u, n.directional.length = h, n.spot.length = p, n.rectArea.length = f, n.point.length = d, n.hemi.length = m, n.hash.stateID = n.id, n.hash.directionalLength = h, n.hash.pointLength = d, n.hash.spotLength = p, n.hash.rectAreaLength = f, n.hash.hemiLength = m, n.hash.shadowsLength = i.length
                }
                var t = new pt,
                    n = {
                        id: Ph++,
                        hash: {
                            stateID: -1,
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            shadowsLength: -1
                        },
                        ambient: [0, 0, 0],
                        directional: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        point: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    },
                    r = new a,
                    o = new i,
                    s = new i;
                return {
                    setup: e,
                    state: n
                }
            }

            function mt() {
                function e() {
                    a.length = 0, o.length = 0
                }

                function t(e) {
                    a.push(e)
                }

                function n(e) {
                    o.push(e)
                }

                function i(e) {
                    r.setup(a, o, e)
                }
                var r = new ft,
                    a = [],
                    o = [],
                    s = {
                        lightsArray: a,
                        shadowsArray: o,
                        lights: r
                    };
                return {
                    init: e,
                    state: s,
                    setupLights: i,
                    pushLight: t,
                    pushShadow: n
                }
            }

            function vt() {
                function e(t) {
                    var n = t.target;
                    n.removeEventListener("dispose", e), delete i[n.id]
                }

                function t(t, n) {
                    var r;
                    return void 0 === i[t.id] ? (r = new mt, i[t.id] = {}, i[t.id][n.id] = r, t.addEventListener("dispose", e)) : void 0 === i[t.id][n.id] ? (r = new mt, i[t.id][n.id] = r) : r = i[t.id][n.id], r
                }

                function n() {
                    i = {}
                }
                var i = {};
                return {
                    get: t,
                    dispose: n
                }
            }

            function gt(e) {
                V.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Fl, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(e)
            }

            function yt(e) {
                V.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new a, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(e)
            }

            function xt(e, t, r) {
                function o(t, n, i, r, a, o) {
                    var s = t.geometry,
                        l = null,
                        c = b,
                        u = t.customDepthMaterial;
                    if (i && (c = _, u = t.customDistanceMaterial), u) l = u;
                    else {
                        var h = !1;
                        n.morphTargets && (s && s.isBufferGeometry ? h = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0 : s && s.isGeometry && (h = s.morphTargets && s.morphTargets.length > 0)), t.isSkinnedMesh && n.skinning === !1 && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t);
                        var d = t.isSkinnedMesh && n.skinning,
                            p = 0;
                        h && (p |= g), d && (p |= y), l = c[p]
                    }
                    if (e.localClippingEnabled && n.clipShadows === !0 && 0 !== n.clippingPlanes.length) {
                        var f = l.uuid,
                            m = n.uuid,
                            v = w[f];
                        void 0 === v && (v = {}, w[f] = v);
                        var x = v[m];
                        void 0 === x && (x = l.clone(), v[m] = x), l = x
                    }
                    return l.visible = n.visible, l.wireframe = n.wireframe, l.side = null != n.shadowSide ? n.shadowSide : M[n.side], l.clipShadows = n.clipShadows, l.clippingPlanes = n.clippingPlanes, l.clipIntersection = n.clipIntersection, l.wireframeLinewidth = n.wireframeLinewidth, l.linewidth = n.linewidth, i && l.isMeshDistanceMaterial && (l.referencePosition.copy(r), l.nearDistance = a, l.farDistance = o), l
                }

                function s(n, i, r, a) {
                    if (n.visible !== !1) {
                        var l = n.layers.test(i.layers);
                        if (l && (n.isMesh || n.isLine || n.isPoints) && n.castShadow && (!n.frustumCulled || u.intersectsObject(n))) {
                            n.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, n.matrixWorld);
                            var c = t.update(n),
                                h = n.material;
                            if (Array.isArray(h))
                                for (var d = c.groups, p = 0, f = d.length; p < f; p++) {
                                    var v = d[p],
                                        g = h[v.materialIndex];
                                    if (g && g.visible) {
                                        var y = o(n, g, a, m, r.near, r.far);
                                        e.renderBufferDirect(r, null, c, y, n, v)
                                    }
                                } else if (h.visible) {
                                    var y = o(n, h, a, m, r.near, r.far);
                                    e.renderBufferDirect(r, null, c, y, n, null)
                                }
                        }
                        for (var x = n.children, b = 0, _ = x.length; b < _; b++) s(x[b], i, r, a)
                    }
                }
                for (var u = new v, h = new i, d = new n, p = new n(r, r), f = new a, m = new a, g = 1, y = 2, x = (g | y) + 1, b = new Array(x), _ = new Array(x), w = {}, M = {
                        0: wo,
                        1: _o,
                        2: Mo
                    }, T = [new a(1, 0, 0), new a((-1), 0, 0), new a(0, 0, 1), new a(0, 0, (-1)), new a(0, 1, 0), new a(0, (-1), 0)], E = [new a(0, 1, 0), new a(0, 1, 0), new a(0, 1, 0), new a(0, 1, 0), new a(0, 0, 1), new a(0, 0, (-1))], S = [new l, new l, new l, new l, new l, new l], P = 0; P !== x; ++P) {
                    var C = 0 !== (P & g),
                        A = 0 !== (P & y),
                        L = new gt({
                            depthPacking: Gl,
                            morphTargets: C,
                            skinning: A
                        });
                    b[P] = L;
                    var R = new yt({
                        morphTargets: C,
                        skinning: A
                    });
                    _[P] = R
                }
                var I = this;
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = xo, this.render = function (t, n, i) {
                    if (I.enabled !== !1 && (I.autoUpdate !== !1 || I.needsUpdate !== !1) && 0 !== t.length) {
                        var r = e.getRenderTarget(),
                            a = e.state;
                        a.setBlending(Ao), a.buffers.color.setClear(1, 1, 1, 1), a.buffers.depth.setTest(!0), a.setScissorTest(!1);
                        for (var o, l = 0, v = t.length; l < v; l++) {
                            var g = t[l],
                                y = g.shadow,
                                x = g && g.isPointLight;
                            if (void 0 !== y) {
                                var b = y.camera;
                                if (d.copy(y.mapSize), d.min(p), x) {
                                    var _ = d.x,
                                        w = d.y;
                                    S[0].set(2 * _, w, _, w), S[1].set(0, w, _, w), S[2].set(3 * _, w, _, w), S[3].set(_, w, _, w), S[4].set(3 * _, 0, _, w), S[5].set(_, 0, _, w), d.x *= 4, d.y *= 2
                                }
                                if (null === y.map) {
                                    var M = {
                                        minFilter: Es,
                                        magFilter: Es,
                                        format: Ws
                                    };
                                    y.map = new c(d.x, d.y, M), y.map.texture.name = g.name + ".shadowMap", b.updateProjectionMatrix()
                                }
                                y.isSpotLightShadow && y.update(g);
                                var P = y.map,
                                    C = y.matrix;
                                m.setFromMatrixPosition(g.matrixWorld), b.position.copy(m), x ? (o = 6, C.makeTranslation(-m.x, -m.y, -m.z)) : (o = 1, f.setFromMatrixPosition(g.target.matrixWorld), b.lookAt(f), b.updateMatrixWorld(), C.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), C.multiply(b.projectionMatrix), C.multiply(b.matrixWorldInverse)), e.setRenderTarget(P), e.clear();
                                for (var A = 0; A < o; A++) {
                                    if (x) {
                                        f.copy(b.position), f.add(T[A]), b.up.copy(E[A]), b.lookAt(f), b.updateMatrixWorld();
                                        var L = S[A];
                                        a.viewport(L)
                                    }
                                    h.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), u.setFromMatrix(h), s(n, i, b, x)
                                }
                            } else console.warn("THREE.WebGLShadowMap:", g, "has no shadow.")
                        }
                        I.needsUpdate = !1, e.setRenderTarget(r)
                    }
                }
            }

            function bt(e, t, n, i) {
                function r() {
                    var t = !1,
                        n = new l,
                        i = null,
                        r = new l(0, 0, 0, 0);
                    return {
                        setMask: function (n) {
                            i === n || t || (e.colorMask(n, n, n, n), i = n)
                        },
                        setLocked: function (e) {
                            t = e
                        },
                        setClear: function (t, i, a, o, s) {
                            s === !0 && (t *= o, i *= o, a *= o), n.set(t, i, a, o), r.equals(n) === !1 && (e.clearColor(t, i, a, o), r.copy(n))
                        },
                        reset: function () {
                            t = !1, i = null, r.set(-1, 0, 0, 0)
                        }
                    }
                }

                function a() {
                    var t = !1,
                        n = null,
                        i = null,
                        r = null;
                    return {
                        setTest: function (e) {
                            e ? p(2929) : f(2929)
                        },
                        setMask: function (i) {
                            n === i || t || (e.depthMask(i), n = i)
                        },
                        setFunc: function (t) {
                            if (i !== t) {
                                if (t) switch (t) {
                                    case $o:
                                        e.depthFunc(512);
                                        break;
                                    case Qo:
                                        e.depthFunc(519);
                                        break;
                                    case Ko:
                                        e.depthFunc(513);
                                        break;
                                    case es:
                                        e.depthFunc(515);
                                        break;
                                    case ts:
                                        e.depthFunc(514);
                                        break;
                                    case ns:
                                        e.depthFunc(518);
                                        break;
                                    case is:
                                        e.depthFunc(516);
                                        break;
                                    case rs:
                                        e.depthFunc(517);
                                        break;
                                    default:
                                        e.depthFunc(515)
                                } else e.depthFunc(515);
                                i = t
                            }
                        },
                        setLocked: function (e) {
                            t = e
                        },
                        setClear: function (t) {
                            r !== t && (e.clearDepth(t), r = t)
                        },
                        reset: function () {
                            t = !1, n = null, i = null, r = null
                        }
                    }
                }

                function o() {
                    var t = !1,
                        n = null,
                        i = null,
                        r = null,
                        a = null,
                        o = null,
                        s = null,
                        l = null,
                        c = null;
                    return {
                        setTest: function (e) {
                            e ? p(2960) : f(2960)
                        },
                        setMask: function (i) {
                            n === i || t || (e.stencilMask(i), n = i)
                        },
                        setFunc: function (t, n, o) {
                            i === t && r === n && a === o || (e.stencilFunc(t, n, o), i = t, r = n, a = o)
                        },
                        setOp: function (t, n, i) {
                            o === t && s === n && l === i || (e.stencilOp(t, n, i), o = t, s = n, l = i)
                        },
                        setLocked: function (e) {
                            t = e
                        },
                        setClear: function (t) {
                            c !== t && (e.clearStencil(t), c = t)
                        },
                        reset: function () {
                            t = !1, n = null, i = null, r = null, a = null, o = null, s = null, l = null, c = null
                        }
                    }
                }

                function s(t, n, i) {
                    var r = new Uint8Array(4),
                        a = e.createTexture();
                    e.bindTexture(t, a), e.texParameteri(t, 10241, 9728), e.texParameteri(t, 10240, 9728);
                    for (var o = 0; o < i; o++) e.texImage2D(n + o, 0, 6408, 1, 1, 0, 6408, 5121, r);
                    return a
                }

                function c() {
                    for (var e = 0, t = z.length; e < t; e++) z[e] = 0
                }

                function u(e) {
                    h(e, 0)
                }

                function h(n, r) {
                    if (z[n] = 1, 0 === B[n] && (e.enableVertexAttribArray(n), B[n] = 1), N[n] !== r) {
                        var a = i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays");
                        a[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), N[n] = r
                    }
                }

                function d() {
                    for (var t = 0, n = B.length; t !== n; ++t) B[t] !== z[t] && (e.disableVertexAttribArray(t), B[t] = 0)
                }

                function p(t) {
                    U[t] !== !0 && (e.enable(t), U[t] = !0)
                }

                function f(t) {
                    U[t] !== !1 && (e.disable(t), U[t] = !1)
                }

                function m() {
                    if (null === j && (j = [], t.get("WEBGL_compressed_texture_pvrtc") || t.get("WEBGL_compressed_texture_s3tc") || t.get("WEBGL_compressed_texture_etc1") || t.get("WEBGL_compressed_texture_astc")))
                        for (var n = e.getParameter(34467), i = 0; i < n.length; i++) j.push(n[i]);
                    return j
                }

                function v(t) {
                    return F !== t && (e.useProgram(t), F = t, !0)
                }

                function g(t, i, r, a, o, s, l, c) {
                    if (t === Ao) return void(G && (f(3042), G = !1));
                    if (G || (p(3042), G = !0), t === ko) o = o || i, s = s || r, l = l || a, i === V && o === X || (e.blendEquationSeparate(n.convert(i), n.convert(o)), V = i, X = o), r === W && a === q && s === Y && l === Z || (e.blendFuncSeparate(n.convert(r), n.convert(a), n.convert(s), n.convert(l)), W = r, q = a, Y = s, Z = l), H = t, J = null;
                    else if (t !== H || c !== J) {
                        if (V === Do && X === Do || (e.blendEquation(32774), V = Do, X = Do), c) switch (t) {
                            case Lo:
                                e.blendFuncSeparate(1, 771, 1, 771);
                                break;
                            case Ro:
                                e.blendFunc(1, 1);
                                break;
                            case Io:
                                e.blendFuncSeparate(0, 0, 769, 771);
                                break;
                            case Oo:
                                e.blendFuncSeparate(0, 768, 0, 770);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                        } else switch (t) {
                            case Lo:
                                e.blendFuncSeparate(770, 771, 1, 771);
                                break;
                            case Ro:
                                e.blendFunc(770, 1);
                                break;
                            case Io:
                                e.blendFunc(0, 769);
                                break;
                            case Oo:
                                e.blendFunc(0, 768);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                        }
                        W = null, q = null, Y = null, Z = null, H = t, J = c
                    }
                }

                function y(e, t) {
                    e.side === Mo ? f(2884) : p(2884);
                    var n = e.side === wo;
                    t && (n = !n), x(n), e.blending === Lo && e.transparent === !1 ? g(Ao) : g(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), O.setFunc(e.depthFunc), O.setTest(e.depthTest), O.setMask(e.depthWrite), I.setMask(e.colorWrite), w(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
                }

                function x(t) {
                    $ !== t && (t ? e.frontFace(2304) : e.frontFace(2305), $ = t)
                }

                function b(t) {
                    t !== ho ? (p(2884), t !== Q && (t === po ? e.cullFace(1029) : t === fo ? e.cullFace(1028) : e.cullFace(1032))) : f(2884), Q = t
                }

                function _(t) {
                    t !== K && (ie && e.lineWidth(t), K = t)
                }

                function w(t, n, i) {
                    t ? (p(32823), ee === n && te === i || (e.polygonOffset(n, i), ee = n, te = i)) : f(32823)
                }

                function M(e) {
                    e ? p(3089) : f(3089)
                }

                function T(t) {
                    void 0 === t && (t = 33984 + ne - 1), oe !== t && (e.activeTexture(t), oe = t)
                }

                function E(t, n) {
                    null === oe && T();
                    var i = se[oe];
                    void 0 === i && (i = {
                        type: void 0,
                        texture: void 0
                    }, se[oe] = i), i.type === t && i.texture === n || (e.bindTexture(t, n || ue[t]), i.type = t, i.texture = n)
                }

                function S() {
                    try {
                        e.compressedTexImage2D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                }

                function P() {
                    try {
                        e.texImage2D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                }

                function C() {
                    try {
                        e.texImage3D.apply(e, arguments)
                    } catch (t) {
                        console.error("THREE.WebGLState:", t)
                    }
                }

                function A(t) {
                    le.equals(t) === !1 && (e.scissor(t.x, t.y, t.z, t.w), le.copy(t))
                }

                function L(t) {
                    ce.equals(t) === !1 && (e.viewport(t.x, t.y, t.z, t.w), ce.copy(t))
                }

                function R() {
                    for (var t = 0; t < B.length; t++) 1 === B[t] && (e.disableVertexAttribArray(t), B[t] = 0);
                    U = {}, j = null, oe = null, se = {}, F = null, H = null, $ = null, Q = null, I.reset(), O.reset(), k.reset()
                }
                var I = new r,
                    O = new a,
                    k = new o,
                    D = e.getParameter(34921),
                    z = new Uint8Array(D),
                    B = new Uint8Array(D),
                    N = new Uint8Array(D),
                    U = {},
                    j = null,
                    F = null,
                    G = null,
                    H = null,
                    V = null,
                    W = null,
                    q = null,
                    X = null,
                    Y = null,
                    Z = null,
                    J = !1,
                    $ = null,
                    Q = null,
                    K = null,
                    ee = null,
                    te = null,
                    ne = e.getParameter(35661),
                    ie = !1,
                    re = 0,
                    ae = e.getParameter(7938);
                ae.indexOf("WebGL") !== -1 ? (re = parseFloat(/^WebGL\ ([0-9])/.exec(ae)[1]), ie = re >= 1) : ae.indexOf("OpenGL ES") !== -1 && (re = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(ae)[1]), ie = re >= 2);
                var oe = null,
                    se = {},
                    le = new l,
                    ce = new l,
                    ue = {};
                return ue[3553] = s(3553, 3553, 1), ue[34067] = s(34067, 34069, 6), I.setClear(0, 0, 0, 1), O.setClear(1), k.setClear(0), p(2929), O.setFunc(es), x(!1), b(po), p(2884), g(Ao), {
                    buffers: {
                        color: I,
                        depth: O,
                        stencil: k
                    },
                    initAttributes: c,
                    enableAttribute: u,
                    enableAttributeAndDivisor: h,
                    disableUnusedAttributes: d,
                    enable: p,
                    disable: f,
                    getCompressedTextureFormats: m,
                    useProgram: v,
                    setBlending: g,
                    setMaterial: y,
                    setFlipSided: x,
                    setCullFace: b,
                    setLineWidth: _,
                    setPolygonOffset: w,
                    setScissorTest: M,
                    activeTexture: T,
                    bindTexture: E,
                    compressedTexImage2D: S,
                    texImage2D: P,
                    texImage3D: C,
                    scissor: A,
                    viewport: L,
                    reset: R
                }
            }

            function _t(e, t, n, i, r, a, o) {
                function s(e, t) {
                    return B ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
                }

                function l(e, t, n, i) {
                    var r = 1;
                    if ((e.width > i || e.height > i) && (r = i / Math.max(e.width, e.height)), r < 1 || t === !0) {
                        if (e instanceof ImageBitmap || e instanceof HTMLImageElement || e instanceof HTMLCanvasElement) {
                            var a = t ? Wl.floorPowerOfTwo : Math.floor,
                                o = a(r * e.width),
                                l = a(r * e.height);
                            void 0 === D && (D = s(o, l));
                            var c = n ? s(o, l) : D;
                            c.width = o, c.height = l;
                            var u = c.getContext("2d");
                            return u.drawImage(e, 0, 0, o, l), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + o + "x" + l + ")."), B ? c.transferToImageBitmap() : c
                        }
                        return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e
                    }
                    return e
                }

                function c(e) {
                    return Wl.isPowerOfTwo(e.width) && Wl.isPowerOfTwo(e.height)
                }

                function u(e) {
                    return !r.isWebGL2 && (e.wrapS !== Ms || e.wrapT !== Ms || e.minFilter !== Es && e.minFilter !== Cs)
                }

                function h(e, t) {
                    return e.generateMipmaps && t && e.minFilter !== Es && e.minFilter !== Cs
                }

                function d(t, n, r, a) {
                    e.generateMipmap(t);
                    var o = i.get(n);
                    o.__maxMipLevel = Math.log(Math.max(r, a)) * Math.LOG2E
                }

                function p(e, n) {
                    if (!r.isWebGL2) return e;
                    var i = e;
                    return 6403 === e && (5126 === n && (i = 33326), 5131 === n && (i = 33325), 5121 === n && (i = 33321)), 6407 === e && (5126 === n && (i = 34837), 5131 === n && (i = 34843), 5121 === n && (i = 32849)), 6408 === e && (5126 === n && (i = 34836), 5131 === n && (i = 34842), 5121 === n && (i = 32856)), 33325 === i || 33326 === i || 34842 === i || 34836 === i ? t.get("EXT_color_buffer_float") : 34843 !== i && 34837 !== i || console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), i
                }

                function f(e) {
                    return e === Es || e === Ss || e === Ps ? 9728 : 9729
                }

                function m(e) {
                    var t = e.target;
                    t.removeEventListener("dispose", m), g(t), t.isVideoTexture && delete z[t.id], o.memory.textures--
                }

                function v(e) {
                    var t = e.target;
                    t.removeEventListener("dispose", v), y(t), o.memory.textures--
                }

                function g(t) {
                    var n = i.get(t);
                    void 0 !== n.__webglInit && (e.deleteTexture(n.__webglTexture), i.remove(t))
                }

                function y(t) {
                    var n = i.get(t),
                        r = i.get(t.texture);
                    if (t) {
                        if (void 0 !== r.__webglTexture && e.deleteTexture(r.__webglTexture), t.depthTexture && t.depthTexture.dispose(), t.isWebGLRenderTargetCube)
                            for (var a = 0; a < 6; a++) e.deleteFramebuffer(n.__webglFramebuffer[a]), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[a]);
                        else e.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer);
                        i.remove(t.texture), i.remove(t)
                    }
                }

                function x(e, t) {
                    var r = i.get(e);
                    if (e.isVideoTexture && k(e), e.version > 0 && r.__version !== e.version) {
                        var a = e.image;
                        if (void 0 === a) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                        else {
                            if (a.complete !== !1) return void E(r, e, t);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    n.activeTexture(33984 + t), n.bindTexture(3553, r.__webglTexture)
                }

                function b(e, t) {
                    var r = i.get(e);
                    return e.version > 0 && r.__version !== e.version ? void E(r, e, t) : (n.activeTexture(33984 + t), void n.bindTexture(32879, r.__webglTexture))
                }

                function _(t, o) {
                    var s = i.get(t);
                    if (6 === t.image.length)
                        if (t.version > 0 && s.__version !== t.version) {
                            T(s, t), n.activeTexture(33984 + o), n.bindTexture(34067, s.__webglTexture), e.pixelStorei(37440, t.flipY);
                            for (var u = t && t.isCompressedTexture, f = t.image[0] && t.image[0].isDataTexture, m = [], v = 0; v < 6; v++) u || f ? m[v] = f ? t.image[v].image : t.image[v] : m[v] = l(t.image[v], !1, !0, r.maxCubemapSize);
                            var g = m[0],
                                y = c(g) || r.isWebGL2,
                                x = a.convert(t.format),
                                b = a.convert(t.type),
                                _ = p(x, b);
                            M(34067, t, y);
                            for (var v = 0; v < 6; v++)
                                if (u)
                                    for (var w, E = m[v].mipmaps, S = 0, P = E.length; S < P; S++) w = E[S], t.format !== Ws && t.format !== Vs ? n.getCompressedTextureFormats().indexOf(x) > -1 ? n.compressedTexImage2D(34069 + v, S, _, w.width, w.height, 0, w.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + v, S, _, w.width, w.height, 0, x, b, w.data);
                                else f ? n.texImage2D(34069 + v, 0, _, m[v].width, m[v].height, 0, x, b, m[v].data) : n.texImage2D(34069 + v, 0, _, x, b, m[v]);
                            u ? s.__maxMipLevel = E.length - 1 : s.__maxMipLevel = 0, h(t, y) && d(34067, t, g.width, g.height), s.__version = t.version, t.onUpdate && t.onUpdate(t)
                        } else n.activeTexture(33984 + o), n.bindTexture(34067, s.__webglTexture)
                }

                function w(e, t) {
                    n.activeTexture(33984 + t), n.bindTexture(34067, i.get(e).__webglTexture)
                }

                function M(n, o, s) {
                    var l;
                    if (s ? (e.texParameteri(n, 10242, a.convert(o.wrapS)), e.texParameteri(n, 10243, a.convert(o.wrapT)), 32879 === n && e.texParameteri(n, 32882, a.convert(o.wrapR)), e.texParameteri(n, 10240, a.convert(o.magFilter)), e.texParameteri(n, 10241, a.convert(o.minFilter))) : (e.texParameteri(n, 10242, 33071), e.texParameteri(n, 10243, 33071), 32879 === n && e.texParameteri(n, 32882, 33071), o.wrapS === Ms && o.wrapT === Ms || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, 10240, f(o.magFilter)), e.texParameteri(n, 10241, f(o.minFilter)), o.minFilter !== Es && o.minFilter !== Cs && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), l = t.get("EXT_texture_filter_anisotropic")) {
                        if (o.type === Bs && null === t.get("OES_texture_float_linear")) return;
                        if (o.type === Ns && null === (r.isWebGL2 || t.get("OES_texture_half_float_linear"))) return;
                        (o.anisotropy > 1 || i.get(o).__currentAnisotropy) && (e.texParameterf(n, l.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), i.get(o).__currentAnisotropy = o.anisotropy)
                    }
                }

                function T(t, n) {
                    void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", m), t.__webglTexture = e.createTexture(), o.memory.textures++)
                }

                function E(t, i, o) {
                    var s = i.isDataTexture3D ? 32879 : 3553;
                    T(t, i), n.activeTexture(33984 + o), n.bindTexture(s, t.__webglTexture), e.pixelStorei(37440, i.flipY), e.pixelStorei(37441, i.premultiplyAlpha), e.pixelStorei(3317, i.unpackAlignment);
                    var f = u(i) && c(i.image) === !1,
                        m = l(i.image, f, !1, r.maxTextureSize),
                        v = c(m) || r.isWebGL2,
                        g = a.convert(i.format),
                        y = a.convert(i.type),
                        x = p(g, y);
                    M(s, i, v);
                    var b, _ = i.mipmaps;
                    if (i.isDepthTexture) {
                        if (x = 6402, i.type === Bs) {
                            if (!r.isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
                            x = 36012
                        } else r.isWebGL2 && (x = 33189);
                        i.format === Zs && 6402 === x && i.type !== ks && i.type !== zs && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = ks, y = a.convert(i.type)), i.format === Js && (x = 34041, i.type !== Gs && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = Gs, y = a.convert(i.type))), n.texImage2D(3553, 0, x, m.width, m.height, 0, g, y, null)
                    } else if (i.isDataTexture)
                        if (_.length > 0 && v) {
                            for (var w = 0, E = _.length; w < E; w++) b = _[w], n.texImage2D(3553, w, x, b.width, b.height, 0, g, y, b.data);
                            i.generateMipmaps = !1, t.__maxMipLevel = _.length - 1
                        } else n.texImage2D(3553, 0, x, m.width, m.height, 0, g, y, m.data), t.__maxMipLevel = 0;
                    else if (i.isCompressedTexture) {
                        for (var w = 0, E = _.length; w < E; w++) b = _[w], i.format !== Ws && i.format !== Vs ? n.getCompressedTextureFormats().indexOf(g) > -1 ? n.compressedTexImage2D(3553, w, x, b.width, b.height, 0, b.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, w, x, b.width, b.height, 0, g, y, b.data);
                        t.__maxMipLevel = _.length - 1
                    } else if (i.isDataTexture3D) n.texImage3D(32879, 0, x, m.width, m.height, m.depth, 0, g, y, m.data), t.__maxMipLevel = 0;
                    else if (_.length > 0 && v) {
                        for (var w = 0, E = _.length; w < E; w++) b = _[w], n.texImage2D(3553, w, x, g, y, b);
                        i.generateMipmaps = !1, t.__maxMipLevel = _.length - 1
                    } else n.texImage2D(3553, 0, x, g, y, m), t.__maxMipLevel = 0;
                    h(i, v) && d(3553, i, m.width, m.height), t.__version = i.version, i.onUpdate && i.onUpdate(i)
                }

                function S(t, r, o, s) {
                    var l = a.convert(r.texture.format),
                        c = a.convert(r.texture.type),
                        u = p(l, c);
                    n.texImage2D(s, 0, u, r.width, r.height, 0, l, c, null), e.bindFramebuffer(36160, t), e.framebufferTexture2D(36160, o, s, i.get(r.texture).__webglTexture, 0), e.bindFramebuffer(36160, null)
                }

                function P(t, n, i) {
                    if (e.bindRenderbuffer(36161, t), n.depthBuffer && !n.stencilBuffer) {
                        if (i) {
                            var r = O(n);
                            e.renderbufferStorageMultisample(36161, r, 33189, n.width, n.height)
                        } else e.renderbufferStorage(36161, 33189, n.width, n.height);
                        e.framebufferRenderbuffer(36160, 36096, 36161, t)
                    } else if (n.depthBuffer && n.stencilBuffer) {
                        if (i) {
                            var r = O(n);
                            e.renderbufferStorageMultisample(36161, r, 34041, n.width, n.height)
                        } else e.renderbufferStorage(36161, 34041, n.width, n.height);
                        e.framebufferRenderbuffer(36160, 33306, 36161, t)
                    } else {
                        var o = a.convert(n.texture.format),
                            s = a.convert(n.texture.type),
                            l = p(o, s);
                        if (i) {
                            var r = O(n);
                            e.renderbufferStorageMultisample(36161, r, l, n.width, n.height)
                        } else e.renderbufferStorage(36161, l, n.width, n.height)
                    }
                    e.bindRenderbuffer(36161, null)
                }

                function C(t, n) {
                    var r = n && n.isWebGLRenderTargetCube;
                    if (r) throw new Error("Depth Texture with cube render targets is not supported");
                    if (e.bindFramebuffer(36160, t), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), x(n.depthTexture, 0);
                    var a = i.get(n.depthTexture).__webglTexture;
                    if (n.depthTexture.format === Zs) e.framebufferTexture2D(36160, 36096, 3553, a, 0);
                    else {
                        if (n.depthTexture.format !== Js) throw new Error("Unknown depthTexture format");
                        e.framebufferTexture2D(36160, 33306, 3553, a, 0)
                    }
                }

                function A(t) {
                    var n = i.get(t),
                        r = t.isWebGLRenderTargetCube === !0;
                    if (t.depthTexture) {
                        if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                        C(n.__webglFramebuffer, t)
                    } else if (r) {
                        n.__webglDepthbuffer = [];
                        for (var a = 0; a < 6; a++) e.bindFramebuffer(36160, n.__webglFramebuffer[a]), n.__webglDepthbuffer[a] = e.createRenderbuffer(), P(n.__webglDepthbuffer[a], t)
                    } else e.bindFramebuffer(36160, n.__webglFramebuffer), n.__webglDepthbuffer = e.createRenderbuffer(), P(n.__webglDepthbuffer, t);
                    e.bindFramebuffer(36160, null)
                }

                function L(t) {
                    var s = i.get(t),
                        l = i.get(t.texture);
                    t.addEventListener("dispose", v), l.__webglTexture = e.createTexture(), o.memory.textures++;
                    var u = t.isWebGLRenderTargetCube === !0,
                        f = t.isWebGLMultisampleRenderTarget === !0,
                        m = c(t) || r.isWebGL2;
                    if (u) {
                        s.__webglFramebuffer = [];
                        for (var g = 0; g < 6; g++) s.__webglFramebuffer[g] = e.createFramebuffer()
                    } else if (s.__webglFramebuffer = e.createFramebuffer(), f)
                        if (r.isWebGL2) {
                            s.__webglMultisampledFramebuffer = e.createFramebuffer(), s.__webglColorRenderbuffer = e.createRenderbuffer(), e.bindRenderbuffer(36161, s.__webglColorRenderbuffer);
                            var y = a.convert(t.texture.format),
                                x = a.convert(t.texture.type),
                                b = p(y, x),
                                _ = O(t);
                            e.renderbufferStorageMultisample(36161, _, b, t.width, t.height), e.bindFramebuffer(36160, s.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(36160, 36064, 36161, s.__webglColorRenderbuffer), e.bindRenderbuffer(36161, null), t.depthBuffer && (s.__webglDepthRenderbuffer = e.createRenderbuffer(), P(s.__webglDepthRenderbuffer, t, !0)), e.bindFramebuffer(36160, null)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                    if (u) {
                        n.bindTexture(34067, l.__webglTexture), M(34067, t.texture, m);
                        for (var g = 0; g < 6; g++) S(s.__webglFramebuffer[g], t, 36064, 34069 + g);
                        h(t.texture, m) && d(34067, t.texture, t.width, t.height), n.bindTexture(34067, null)
                    } else n.bindTexture(3553, l.__webglTexture), M(3553, t.texture, m), S(s.__webglFramebuffer, t, 36064, 3553), h(t.texture, m) && d(3553, t.texture, t.width, t.height), n.bindTexture(3553, null);
                    t.depthBuffer && A(t)
                }

                function R(e) {
                    var t = e.texture,
                        a = c(e) || r.isWebGL2;
                    if (h(t, a)) {
                        var o = e.isWebGLRenderTargetCube ? 34067 : 3553,
                            s = i.get(t).__webglTexture;
                        n.bindTexture(o, s), d(o, t, e.width, e.height), n.bindTexture(o, null)
                    }
                }

                function I(t) {
                    if (t.isWebGLMultisampleRenderTarget)
                        if (r.isWebGL2) {
                            var n = i.get(t);
                            e.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, n.__webglFramebuffer);
                            var a = t.width,
                                o = t.height,
                                s = 16384;
                            t.depthBuffer && (s |= 256), t.stencilBuffer && (s |= 1024), e.blitFramebuffer(0, 0, a, o, 0, 0, a, o, s, 9728)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
                }

                function O(e) {
                    return r.isWebGL2 && e.isWebGLMultisampleRenderTarget ? Math.min(r.maxSamples, e.samples) : 0
                }

                function k(e) {
                    var t = e.id,
                        n = o.render.frame;
                    z[t] !== n && (z[t] = n, e.update())
                }
                var D, z = {},
                    B = "undefined" != typeof OffscreenCanvas;
                this.setTexture2D = x, this.setTexture3D = b, this.setTextureCube = _, this.setTextureCubeDynamic = w, this.setupRenderTarget = L, this.updateRenderTargetMipmap = R, this.updateMultisampleRenderTarget = I
            }

            function wt(e, t, n) {
                function i(e) {
                    var i;
                    if (e === ws) return 10497;
                    if (e === Ms) return 33071;
                    if (e === Ts) return 33648;
                    if (e === Es) return 9728;
                    if (e === Ss) return 9984;
                    if (e === Ps) return 9986;
                    if (e === Cs) return 9729;
                    if (e === As) return 9985;
                    if (e === Ls) return 9987;
                    if (e === Rs) return 5121;
                    if (e === Us) return 32819;
                    if (e === js) return 32820;
                    if (e === Fs) return 33635;
                    if (e === Is) return 5120;
                    if (e === Os) return 5122;
                    if (e === ks) return 5123;
                    if (e === Ds) return 5124;
                    if (e === zs) return 5125;
                    if (e === Bs) return 5126;
                    if (e === Ns) {
                        if (n.isWebGL2) return 5131;
                        if (i = t.get("OES_texture_half_float"), null !== i) return i.HALF_FLOAT_OES
                    }
                    if (e === Hs) return 6406;
                    if (e === Vs) return 6407;
                    if (e === Ws) return 6408;
                    if (e === qs) return 6409;
                    if (e === Xs) return 6410;
                    if (e === Zs) return 6402;
                    if (e === Js) return 34041;
                    if (e === $s) return 6403;
                    if (e === Do) return 32774;
                    if (e === zo) return 32778;
                    if (e === Bo) return 32779;
                    if (e === jo) return 0;
                    if (e === Fo) return 1;
                    if (e === Go) return 768;
                    if (e === Ho) return 769;
                    if (e === Vo) return 770;
                    if (e === Wo) return 771;
                    if (e === qo) return 772;
                    if (e === Xo) return 773;
                    if (e === Yo) return 774;
                    if (e === Zo) return 775;
                    if (e === Jo) return 776;
                    if ((e === Qs || e === Ks || e === el || e === tl) && (i = t.get("WEBGL_compressed_texture_s3tc"), null !== i)) {
                        if (e === Qs) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (e === Ks) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (e === el) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (e === tl) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if ((e === nl || e === il || e === rl || e === al) && (i = t.get("WEBGL_compressed_texture_pvrtc"), null !== i)) {
                        if (e === nl) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (e === il) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (e === rl) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (e === al) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (e === ol && (i = t.get("WEBGL_compressed_texture_etc1"), null !== i)) return i.COMPRESSED_RGB_ETC1_WEBGL;
                    if ((e === sl || e === ll || e === cl || e === ul || e === hl || e === dl || e === pl || e === fl || e === ml || e === vl || e === gl || e === yl || e === xl || e === bl) && (i = t.get("WEBGL_compressed_texture_astc"), null !== i)) return e;
                    if (e === No || e === Uo) {
                        if (n.isWebGL2) {
                            if (e === No) return 32775;
                            if (e === Uo) return 32776
                        }
                        if (i = t.get("EXT_blend_minmax"), null !== i) {
                            if (e === No) return i.MIN_EXT;
                            if (e === Uo) return i.MAX_EXT
                        }
                    }
                    if (e === Gs) {
                        if (n.isWebGL2) return 34042;
                        if (i = t.get("WEBGL_depth_texture"), null !== i) return i.UNSIGNED_INT_24_8_WEBGL
                    }
                    return 0
                }
                return {
                    convert: i
                }
            }

            function Mt() {
                E.call(this), this.type = "Group"
            }

            function Tt() {
                E.call(this), this.type = "Camera", this.matrixWorldInverse = new i, this.projectionMatrix = new i, this.projectionMatrixInverse = new i
            }

            function Et(e, t, n, i) {
                Tt.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== i ? i : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }

            function St(e) {
                Et.call(this), this.cameras = e || []
            }

            function Pt(e, t, n) {
                Ch.setFromMatrixPosition(t.matrixWorld), Ah.setFromMatrixPosition(n.matrixWorld);
                var i = Ch.distanceTo(Ah),
                    r = t.projectionMatrix.elements,
                    a = n.projectionMatrix.elements,
                    o = r[14] / (r[10] - 1),
                    s = r[14] / (r[10] + 1),
                    l = (r[9] + 1) / r[5],
                    c = (r[9] - 1) / r[5],
                    u = (r[8] - 1) / r[0],
                    h = (a[8] + 1) / a[0],
                    d = o * u,
                    p = o * h,
                    f = i / (-u + h),
                    m = f * -u;
                t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.getInverse(e.matrixWorld);
                var v = o + f,
                    g = s + f,
                    y = d - m,
                    x = p + (i - m),
                    b = l * s / g * v,
                    _ = c * s / g * v;
                e.projectionMatrix.makePerspective(y, x, b, _, v, g)
            }

            function Ct(e) {
                function t() {
                    return null !== h && h.isPresenting === !0
                }

                function o() {
                    if (t()) {
                        var n = h.getEyeParameters("left"),
                            i = n.renderWidth * g,
                            r = n.renderHeight * g;
                        S = e.getPixelRatio(), e.getSize(P), e.setDrawingBufferSize(2 * i, r, 1), A.start()
                    } else u.enabled && e.setDrawingBufferSize(P.width, P.height, S), A.stop()
                }

                function s(e) {
                    for (var t = navigator.getGamepads && navigator.getGamepads(), n = 0, i = 0, r = t.length; n < r; n++) {
                        var a = t[n];
                        if (a && ("Daydream Controller" === a.id || "Gear VR Controller" === a.id || "Oculus Go Controller" === a.id || "OpenVR Gamepad" === a.id || a.id.startsWith("Oculus Touch") || a.id.startsWith("Spatial Controller"))) {
                            if (i === e) return a;
                            i++
                        }
                    }
                }

                function c() {
                    for (var e = 0; e < f.length; e++) {
                        var t = f[e],
                            n = s(e);
                        if (void 0 !== n && void 0 !== n.pose) {
                            if (null === n.pose) return;
                            var i = n.pose;
                            i.hasPosition === !1 && t.position.set(.2, -.6, -.05), null !== i.position && t.position.fromArray(i.position), null !== i.orientation && t.quaternion.fromArray(i.orientation), t.matrix.compose(t.position, t.quaternion, t.scale), t.matrix.premultiply(m), t.matrix.decompose(t.position, t.quaternion, t.scale), t.matrixWorldNeedsUpdate = !0, t.visible = !0;
                            var r = "Daydream Controller" === n.id ? 0 : 1;
                            C[e] !== n.buttons[r].pressed && (C[e] = n.buttons[r].pressed, C[e] === !0 ? t.dispatchEvent({
                                type: "selectstart"
                            }) : (t.dispatchEvent({
                                type: "selectend"
                            }), t.dispatchEvent({
                                type: "select"
                            })))
                        } else t.visible = !1
                    }
                }
                var u = this,
                    h = null,
                    d = null,
                    p = null,
                    f = [],
                    m = new i,
                    v = new i,
                    g = 1,
                    y = "stage";
                "undefined" != typeof window && "VRFrameData" in window && (d = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", o, !1));
                var x = new i,
                    _ = new r,
                    w = new a,
                    M = new Et;
                M.bounds = new l(0, 0, .5, 1), M.layers.enable(1);
                var T = new Et;
                T.bounds = new l(.5, 0, .5, 1), T.layers.enable(2);
                var E = new St([M, T]);
                E.layers.enable(1), E.layers.enable(2);
                var S, P = new n,
                    C = [];
                this.enabled = !1, this.getController = function (e) {
                    var t = f[e];
                    return void 0 === t && (t = new Mt, t.matrixAutoUpdate = !1, t.visible = !1, f[e] = t), t
                }, this.getDevice = function () {
                    return h
                }, this.setDevice = function (e) {
                    void 0 !== e && (h = e), A.setContext(e)
                }, this.setFramebufferScaleFactor = function (e) {
                    g = e
                }, this.setFrameOfReferenceType = function (e) {
                    y = e
                }, this.setPoseTarget = function (e) {
                    void 0 !== e && (p = e)
                }, this.getCamera = function (e) {
                    var n = "stage" === y ? 1.6 : 0;
                    if (t() === !1) return e.position.set(0, n, 0), e.rotation.set(0, 0, 0), e;
                    if (h.depthNear = e.near, h.depthFar = e.far, h.getFrameData(d), "stage" === y) {
                        var i = h.stageParameters;
                        i ? m.fromArray(i.sittingToStandingTransform) : m.makeTranslation(0, n, 0)
                    }
                    var r = d.pose,
                        a = null !== p ? p : e;
                    a.matrix.copy(m), a.matrix.decompose(a.position, a.quaternion, a.scale), null !== r.orientation && (_.fromArray(r.orientation), a.quaternion.multiply(_)), null !== r.position && (_.setFromRotationMatrix(m), w.fromArray(r.position), w.applyQuaternion(_), a.position.add(w)), a.updateMatrixWorld(), M.near = e.near, T.near = e.near, M.far = e.far, T.far = e.far, M.matrixWorldInverse.fromArray(d.leftViewMatrix), T.matrixWorldInverse.fromArray(d.rightViewMatrix), v.getInverse(m), "stage" === y && (M.matrixWorldInverse.multiply(v), T.matrixWorldInverse.multiply(v));
                    var o = a.parent;
                    null !== o && (x.getInverse(o.matrixWorld), M.matrixWorldInverse.multiply(x), T.matrixWorldInverse.multiply(x)), M.matrixWorld.getInverse(M.matrixWorldInverse), T.matrixWorld.getInverse(T.matrixWorldInverse), M.projectionMatrix.fromArray(d.leftProjectionMatrix), T.projectionMatrix.fromArray(d.rightProjectionMatrix), Pt(E, M, T);
                    var s = h.getLayers();
                    if (s.length) {
                        var l = s[0];
                        null !== l.leftBounds && 4 === l.leftBounds.length && M.bounds.fromArray(l.leftBounds), null !== l.rightBounds && 4 === l.rightBounds.length && T.bounds.fromArray(l.rightBounds)
                    }
                    return c(), E
                }, this.getStandingMatrix = function () {
                    return m
                }, this.isPresenting = t;
                var A = new b;
                this.setAnimationLoop = function (e) {
                    A.setAnimationLoop(e)
                }, this.submitFrame = function () {
                    t() && h.submitFrame()
                }, this.dispose = function () {
                    "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", o)
                }
            }

            function At(e) {
                function t() {
                    return null !== u && null !== d
                }

                function n(e) {
                    var t = m[v.indexOf(e.inputSource)];
                    t && t.dispatchEvent({
                        type: e.type
                    })
                }

                function r() {
                    e.setFramebuffer(null), e.setRenderTarget(e.getRenderTarget()), w.stop()
                }

                function a(e, t) {
                    null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.getInverse(e.matrixWorld)
                }

                function o(e, t) {
                    if (f = t.getDevicePose(d), null !== f)
                        for (var n = u.baseLayer, i = t.views, r = 0; r < i.length; r++) {
                            var a = i[r],
                                o = n.getViewport(a),
                                s = f.getViewMatrix(a),
                                l = x.cameras[r];
                            l.matrix.fromArray(s).getInverse(l.matrix), l.projectionMatrix.fromArray(a.projectionMatrix), l.viewport.set(o.x, o.y, o.width, o.height), 0 === r && x.matrix.copy(l.matrix)
                        }
                    for (var r = 0; r < m.length; r++) {
                        var c = m[r],
                            h = v[r];
                        if (h) {
                            var p = t.getInputPose(h, d);
                            if (null !== p) {
                                "targetRay" in p ? c.matrix.elements = p.targetRay.transformMatrix : "pointerMatrix" in p && (c.matrix.elements = p.pointerMatrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.visible = !0;
                                continue
                            }
                        }
                        c.visible = !1
                    }
                    _ && _(e)
                }
                var s = e.context,
                    c = null,
                    u = null,
                    h = 1,
                    d = null,
                    p = "stage",
                    f = null,
                    m = [],
                    v = [],
                    g = new Et;
                g.layers.enable(1), g.viewport = new l;
                var y = new Et;
                y.layers.enable(2), y.viewport = new l;
                var x = new St([g, y]);
                x.layers.enable(1), x.layers.enable(2), this.enabled = !1, this.getController = function (e) {
                    var t = m[e];
                    return void 0 === t && (t = new Mt, t.matrixAutoUpdate = !1, t.visible = !1, m[e] = t), t
                }, this.getDevice = function () {
                    return c
                }, this.setDevice = function (e) {
                    void 0 !== e && (c = e), e instanceof XRDevice && s.setCompatibleXRDevice(e)
                }, this.setFramebufferScaleFactor = function (e) {
                    h = e
                }, this.setFrameOfReferenceType = function (e) {
                    p = e
                }, this.setSession = function (t) {
                    u = t, null !== u && (u.addEventListener("select", n), u.addEventListener("selectstart", n), u.addEventListener("selectend", n), u.addEventListener("end", r), u.baseLayer = new XRWebGLLayer(u, s, {
                        framebufferScaleFactor: h
                    }), u.requestFrameOfReference(p).then(function (t) {
                        d = t, e.setFramebuffer(u.baseLayer.framebuffer), w.setContext(u), w.start()
                    }), v = u.getInputSources(), u.addEventListener("inputsourceschange", function () {
                        v = u.getInputSources(), console.log(v);
                        for (var e = 0; e < m.length; e++) {
                            var t = m[e];
                            t.userData.inputSource = v[e]
                        }
                    }))
                }, this.getCamera = function (e) {
                    if (t()) {
                        var n = e.parent,
                            i = x.cameras;
                        a(x, n);
                        for (var r = 0; r < i.length; r++) a(i[r], n);
                        e.matrixWorld.copy(x.matrixWorld);
                        for (var o = e.children, r = 0, s = o.length; r < s; r++) o[r].updateMatrixWorld(!0);
                        return Pt(x, g, y), x
                    }
                    return e
                }, this.isPresenting = t;
                var _ = null,
                    w = new b;
                w.setAnimationLoop(o), this.setAnimationLoop = function (e) {
                    _ = e
                }, this.dispose = function () {}, this.getStandingMatrix = function () {
                    return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new i
                }, this.submitFrame = function () {}
            }

            function Lt(e) {
                function t() {
                    return null === pe ? Ee : 1
                }

                function r() {
                    Be = new ee(ce), Ne = new Q(ce, Be, e), Ne.isWebGL2 || (Be.get("WEBGL_depth_texture"), Be.get("OES_texture_float"), Be.get("OES_texture_half_float"), Be.get("OES_texture_half_float_linear"), Be.get("OES_standard_derivatives"), Be.get("OES_element_index_uint"), Be.get("ANGLE_instanced_arrays")), Be.get("OES_texture_float_linear"), et = new wt(ce, Be, Ne), Ue = new bt(ce, Be, et, Ne), Ue.scissor(be.copy(Pe).multiplyScalar(Ee)), Ue.viewport(xe.copy(Se).multiplyScalar(Ee)), je = new ie(ce), Fe = new lt, Ge = new _t(ce, Be, Ue, Fe, Ne, et, je), He = new _(ce), Ve = new te(ce, He, je), qe = new oe(Ve, je), $e = new ae(ce), Xe = new st(ue, Be, Ne), Ye = new dt, Ze = new vt, Je = new J(ue, Ue, qe, Y), Qe = new $(ce, Be, je, Ne), Ke = new ne(ce, Be, je, Ne), je.programs = Xe.programs, ue.context = ce, ue.capabilities = Ne, ue.extensions = Be, ue.properties = Fe, ue.renderLists = Ye, ue.state = Ue, ue.info = je
                }

                function o(e) {
                    e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), he = !0
                }

                function s() {
                    console.log("THREE.WebGLRenderer: Context Restored."), he = !1, r()
                }

                function c(e) {
                    var t = e.target;
                    t.removeEventListener("dispose", c), u(t)
                }

                function u(e) {
                    h(e), Fe.remove(e)
                }

                function h(e) {
                    var t = Fe.get(e).program;
                    e.program = void 0, void 0 !== t && Xe.releaseProgram(t)
                }

                function p(e, t) {
                    e.render(function (e) {
                        ue.renderBufferImmediate(e, t)
                    })
                }

                function f(e, t, n) {
                    if (n && n.isInstancedBufferGeometry && !Ne.isWebGL2 && null === Be.get("ANGLE_instanced_arrays")) return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    Ue.initAttributes();
                    var i = n.attributes,
                        r = t.getAttributes(),
                        a = e.defaultAttributeValues;
                    for (var o in r) {
                        var s = r[o];
                        if (s >= 0) {
                            var l = i[o];
                            if (void 0 !== l) {
                                var c = l.normalized,
                                    u = l.itemSize,
                                    h = He.get(l);
                                if (void 0 === h) continue;
                                var d = h.buffer,
                                    p = h.type,
                                    f = h.bytesPerElement;
                                if (l.isInterleavedBufferAttribute) {
                                    var m = l.data,
                                        v = m.stride,
                                        g = l.offset;
                                    m && m.isInstancedInterleavedBuffer ? (Ue.enableAttributeAndDivisor(s, m.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = m.meshPerAttribute * m.count)) : Ue.enableAttribute(s), ce.bindBuffer(34962, d), ce.vertexAttribPointer(s, u, p, c, v * f, g * f)
                                } else l.isInstancedBufferAttribute ? (Ue.enableAttributeAndDivisor(s, l.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = l.meshPerAttribute * l.count)) : Ue.enableAttribute(s), ce.bindBuffer(34962, d), ce.vertexAttribPointer(s, u, p, c, 0, 0)
                            } else if (void 0 !== a) {
                                var y = a[o];
                                if (void 0 !== y) switch (y.length) {
                                    case 2:
                                        ce.vertexAttrib2fv(s, y);
                                        break;
                                    case 3:
                                        ce.vertexAttrib3fv(s, y);
                                        break;
                                    case 4:
                                        ce.vertexAttrib4fv(s, y);
                                        break;
                                    default:
                                        ce.vertexAttrib1fv(s, y)
                                }
                            }
                        }
                    }
                    Ue.disableUnusedAttributes()
                }

                function m(e) {
                    tt.isPresenting() || it && it(e)
                }

                function y(e, t, n, i) {
                    if (e.visible !== !1) {
                        var r = e.layers.test(t.layers);
                        if (r)
                            if (e.isGroup) n = e.renderOrder;
                            else if (e.isLight) le.pushLight(e), e.castShadow && le.pushShadow(e);
                        else if (e.isSprite) {
                            if (!e.frustumCulled || Ae.intersectsSprite(e)) {
                                i && ke.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Oe);
                                var a = qe.update(e),
                                    o = e.material;
                                se.push(e, a, o, n, ke.z, null)
                            }
                        } else if (e.isImmediateRenderObject) i && ke.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Oe), se.push(e, null, e.material, n, ke.z, null);
                        else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.update(), !e.frustumCulled || Ae.intersectsObject(e))) {
                            i && ke.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Oe);
                            var a = qe.update(e),
                                o = e.material;
                            if (Array.isArray(o))
                                for (var s = a.groups, l = 0, c = s.length; l < c; l++) {
                                    var u = s[l],
                                        h = o[u.materialIndex];
                                    h && h.visible && se.push(e, a, h, n, ke.z, u)
                                } else o.visible && se.push(e, a, o, n, ke.z, null)
                        }
                        for (var d = e.children, l = 0, c = d.length; l < c; l++) y(d[l], t, n, i)
                    }
                }

                function x(e, t, n, i) {
                    for (var r = 0, a = e.length; r < a; r++) {
                        var o = e[r],
                            s = o.object,
                            l = o.geometry,
                            c = void 0 === i ? o.material : i,
                            u = o.group;
                        if (n.isArrayCamera) {
                            ye = n;
                            for (var h = n.cameras, d = 0, p = h.length; d < p; d++) {
                                var f = h[d];
                                if (s.layers.test(f.layers)) {
                                    if ("viewport" in f) Ue.viewport(xe.copy(f.viewport));
                                    else {
                                        var m = f.bounds,
                                            v = m.x * Me,
                                            g = m.y * Te,
                                            y = m.z * Me,
                                            x = m.w * Te;
                                        Ue.viewport(xe.set(v, g, y, x).multiplyScalar(Ee))
                                    }
                                    le.setupLights(f), w(s, t, f, l, c, u)
                                }
                            }
                        } else ye = null, w(s, t, n, l, c, u)
                    }
                }

                function w(e, t, n, i, r, a) {
                    if (e.onBeforeRender(ue, t, n, i, r, a), le = Ze.get(t, ye || n), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) {
                        Ue.setMaterial(r);
                        var o = T(n, t.fog, r, e);
                        ve.geometry = null, ve.program = null, ve.wireframe = !1, p(e, o)
                    } else ue.renderBufferDirect(n, t.fog, i, r, e, a);
                    e.onAfterRender(ue, t, n, i, r, a), le = Ze.get(t, ye || n)
                }

                function M(e, t, n) {
                    var i = Fe.get(e),
                        r = le.state.lights,
                        a = le.state.shadowsArray,
                        o = i.lightsHash,
                        s = r.state.hash,
                        l = Xe.getParameters(e, r.state, a, t, Le.numPlanes, Le.numIntersection, n),
                        u = Xe.getProgramCode(e, l),
                        d = i.program,
                        p = !0;
                    if (void 0 === d) e.addEventListener("dispose", c);
                    else if (d.code !== u) h(e);
                    else if (o.stateID !== s.stateID || o.directionalLength !== s.directionalLength || o.pointLength !== s.pointLength || o.spotLength !== s.spotLength || o.rectAreaLength !== s.rectAreaLength || o.hemiLength !== s.hemiLength || o.shadowsLength !== s.shadowsLength) o.stateID = s.stateID, o.directionalLength = s.directionalLength, o.pointLength = s.pointLength, o.spotLength = s.spotLength, o.rectAreaLength = s.rectAreaLength, o.hemiLength = s.hemiLength, o.shadowsLength = s.shadowsLength, p = !1;
                    else {
                        if (void 0 !== l.shaderID) return;
                        p = !1
                    }
                    if (p) {
                        if (l.shaderID) {
                            var f = uh[l.shaderID];
                            i.shader = {
                                name: e.type,
                                uniforms: g(f.uniforms),
                                vertexShader: f.vertexShader,
                                fragmentShader: f.fragmentShader
                            }
                        } else i.shader = {
                            name: e.type,
                            uniforms: e.uniforms,
                            vertexShader: e.vertexShader,
                            fragmentShader: e.fragmentShader
                        };
                        e.onBeforeCompile(i.shader, ue), u = Xe.getProgramCode(e, l), d = Xe.acquireProgram(e, i.shader, l, u), i.program = d, e.program = d
                    }
                    var m = d.getAttributes();
                    if (e.morphTargets) {
                        e.numSupportedMorphTargets = 0;
                        for (var v = 0; v < ue.maxMorphTargets; v++) m["morphTarget" + v] >= 0 && e.numSupportedMorphTargets++
                    }
                    if (e.morphNormals) {
                        e.numSupportedMorphNormals = 0;
                        for (var v = 0; v < ue.maxMorphNormals; v++) m["morphNormal" + v] >= 0 && e.numSupportedMorphNormals++
                    }
                    var y = i.shader.uniforms;
                    (e.isShaderMaterial || e.isRawShaderMaterial) && e.clipping !== !0 || (i.numClippingPlanes = Le.numPlanes, i.numIntersection = Le.numIntersection, y.clippingPlanes = Le.uniform), i.fog = t, void 0 === o && (i.lightsHash = o = {}), o.stateID = s.stateID, o.directionalLength = s.directionalLength, o.pointLength = s.pointLength, o.spotLength = s.spotLength, o.rectAreaLength = s.rectAreaLength, o.hemiLength = s.hemiLength, o.shadowsLength = s.shadowsLength, e.lights && (y.ambientLightColor.value = r.state.ambient, y.directionalLights.value = r.state.directional, y.spotLights.value = r.state.spot, y.rectAreaLights.value = r.state.rectArea, y.pointLights.value = r.state.point, y.hemisphereLights.value = r.state.hemi, y.directionalShadowMap.value = r.state.directionalShadowMap, y.directionalShadowMatrix.value = r.state.directionalShadowMatrix, y.spotShadowMap.value = r.state.spotShadowMap, y.spotShadowMatrix.value = r.state.spotShadowMatrix, y.pointShadowMap.value = r.state.pointShadowMap, y.pointShadowMatrix.value = r.state.pointShadowMatrix);
                    var x = i.program.getUniforms(),
                        b = We.seqWithValue(x.seq, y);
                    i.uniformsList = b
                }

                function T(e, t, n, i) {
                    we = 0;
                    var r = Fe.get(n),
                        a = le.state.lights,
                        o = r.lightsHash,
                        s = a.state.hash;
                    if (Re && (Ie || e !== ge)) {
                        var l = e === ge && n.id === me;
                        Le.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, e, r, l)
                    }
                    n.needsUpdate === !1 && (void 0 === r.program ? n.needsUpdate = !0 : n.fog && r.fog !== t ? n.needsUpdate = !0 : !n.lights || o.stateID === s.stateID && o.directionalLength === s.directionalLength && o.pointLength === s.pointLength && o.spotLength === s.spotLength && o.rectAreaLength === s.rectAreaLength && o.hemiLength === s.hemiLength && o.shadowsLength === s.shadowsLength ? void 0 === r.numClippingPlanes || r.numClippingPlanes === Le.numPlanes && r.numIntersection === Le.numIntersection || (n.needsUpdate = !0) : n.needsUpdate = !0), n.needsUpdate && (M(n, t, i), n.needsUpdate = !1);
                    var c = !1,
                        u = !1,
                        h = !1,
                        p = r.program,
                        f = p.getUniforms(),
                        m = r.shader.uniforms;
                    if (Ue.useProgram(p.program) && (c = !0, u = !0, h = !0), n.id !== me && (me = n.id, u = !0), c || ge !== e) {
                        if (f.setValue(ce, "projectionMatrix", e.projectionMatrix), Ne.logarithmicDepthBuffer && f.setValue(ce, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), ge !== e && (ge = e, u = !0, h = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) {
                            var v = f.map.cameraPosition;
                            void 0 !== v && v.setValue(ce, ke.setFromMatrixPosition(e.matrixWorld))
                        }(n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && f.setValue(ce, "viewMatrix", e.matrixWorldInverse)
                    }
                    if (n.skinning) {
                        f.setOptional(ce, i, "bindMatrix"), f.setOptional(ce, i, "bindMatrixInverse");
                        var g = i.skeleton;
                        if (g) {
                            var y = g.bones;
                            if (Ne.floatVertexTextures) {
                                if (void 0 === g.boneTexture) {
                                    var x = Math.sqrt(4 * y.length);
                                    x = Wl.ceilPowerOfTwo(x), x = Math.max(x, 4);
                                    var b = new Float32Array(x * x * 4);
                                    b.set(g.boneMatrices);
                                    var _ = new d(b, x, x, Ws, Bs);
                                    _.needsUpdate = !0, g.boneMatrices = b, g.boneTexture = _, g.boneTextureSize = x
                                }
                                f.setValue(ce, "boneTexture", g.boneTexture), f.setValue(ce, "boneTextureSize", g.boneTextureSize)
                            } else f.setOptional(ce, g, "boneMatrices")
                        }
                    }
                    return u && (f.setValue(ce, "toneMappingExposure", ue.toneMappingExposure), f.setValue(ce, "toneMappingWhitePoint", ue.toneMappingWhitePoint), n.lights && j(m, h), t && n.fog && L(m, t), n.isMeshBasicMaterial ? E(m, n) : n.isMeshLambertMaterial ? (E(m, n), R(m, n)) : n.isMeshPhongMaterial ? (E(m, n), n.isMeshToonMaterial ? O(m, n) : I(m, n)) : n.isMeshStandardMaterial ? (E(m, n), n.isMeshPhysicalMaterial ? D(m, n) : k(m, n)) : n.isMeshMatcapMaterial ? (E(m, n), z(m, n)) : n.isMeshDepthMaterial ? (E(m, n), B(m, n)) : n.isMeshDistanceMaterial ? (E(m, n), N(m, n)) : n.isMeshNormalMaterial ? (E(m, n), U(m, n)) : n.isLineBasicMaterial ? (S(m, n), n.isLineDashedMaterial && P(m, n)) : n.isPointsMaterial ? C(m, n) : n.isSpriteMaterial ? A(m, n) : n.isShadowMaterial && (m.color.value = n.color, m.opacity.value = n.opacity), void 0 !== m.ltc_1 && (m.ltc_1.value = ch.LTC_1), void 0 !== m.ltc_2 && (m.ltc_2.value = ch.LTC_2), We.upload(ce, r.uniformsList, m, ue)), n.isShaderMaterial && n.uniformsNeedUpdate === !0 && (We.upload(ce, r.uniformsList, m, ue), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && f.setValue(ce, "center", i.center), f.setValue(ce, "modelViewMatrix", i.modelViewMatrix), f.setValue(ce, "normalMatrix", i.normalMatrix), f.setValue(ce, "modelMatrix", i.matrixWorld), p
                }

                function E(e, t) {
                    e.opacity.value = t.opacity, t.color && (e.diffuse.value = t.color), t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.specularMap && (e.specularMap.value = t.specularMap), t.envMap && (e.envMap.value = t.envMap, e.flipEnvMap.value = t.envMap.isCubeTexture ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio, e.maxMipLevel.value = Fe.get(t.envMap).__maxMipLevel), t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity);
                    var n;
                    t.map ? n = t.map : t.specularMap ? n = t.specularMap : t.displacementMap ? n = t.displacementMap : t.normalMap ? n = t.normalMap : t.bumpMap ? n = t.bumpMap : t.roughnessMap ? n = t.roughnessMap : t.metalnessMap ? n = t.metalnessMap : t.alphaMap ? n = t.alphaMap : t.emissiveMap && (n = t.emissiveMap), void 0 !== n && (n.isWebGLRenderTarget && (n = n.texture), n.matrixAutoUpdate === !0 && n.updateMatrix(), e.uvTransform.value.copy(n.matrix))
                }

                function S(e, t) {
                    e.diffuse.value = t.color, e.opacity.value = t.opacity
                }

                function P(e, t) {
                    e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
                }

                function C(e, t) {
                    e.diffuse.value = t.color, e.opacity.value = t.opacity, e.size.value = t.size * Ee, e.scale.value = .5 * Te, e.map.value = t.map, null !== t.map && (t.map.matrixAutoUpdate === !0 && t.map.updateMatrix(), e.uvTransform.value.copy(t.map.matrix))
                }

                function A(e, t) {
                    e.diffuse.value = t.color, e.opacity.value = t.opacity, e.rotation.value = t.rotation, e.map.value = t.map, null !== t.map && (t.map.matrixAutoUpdate === !0 && t.map.updateMatrix(), e.uvTransform.value.copy(t.map.matrix))
                }

                function L(e, t) {
                    e.fogColor.value = t.color, t.isFog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
                }

                function R(e, t) {
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
                }

                function I(e, t) {
                    e.specular.value = t.specular, e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === wo && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === wo && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }

                function O(e, t) {
                    I(e, t), t.gradientMap && (e.gradientMap.value = t.gradientMap)
                }

                function k(e, t) {
                    e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === wo && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === wo && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
                }

                function D(e, t) {
                    k(e, t), e.reflectivity.value = t.reflectivity, e.clearCoat.value = t.clearCoat, e.clearCoatRoughness.value = t.clearCoatRoughness
                }

                function z(e, t) {
                    t.matcap && (e.matcap.value = t.matcap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === wo && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === wo && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }

                function B(e, t) {
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }

                function N(e, t) {
                    t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance
                }

                function U(e, t) {
                    t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === wo && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === wo && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }

                function j(e, t) {
                    e.ambientLightColor.needsUpdate = t, e.directionalLights.needsUpdate = t, e.pointLights.needsUpdate = t, e.spotLights.needsUpdate = t, e.rectAreaLights.needsUpdate = t, e.hemisphereLights.needsUpdate = t
                }

                function F() {
                    var e = we;
                    return e >= Ne.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + e + " texture units while this GPU supports only " + Ne.maxTextures), we += 1, e
                }
                console.log("THREE.WebGLRenderer", co), e = e || {};
                var G = void 0 !== e.canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                    H = void 0 !== e.context ? e.context : null,
                    V = void 0 !== e.alpha && e.alpha,
                    W = void 0 === e.depth || e.depth,
                    q = void 0 === e.stencil || e.stencil,
                    X = void 0 !== e.antialias && e.antialias,
                    Y = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
                    Z = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
                    re = void 0 !== e.powerPreference ? e.powerPreference : "default",
                    se = null,
                    le = null;
                this.domElement = G, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = cs, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
                var ce, ue = this,
                    he = !1,
                    de = null,
                    pe = null,
                    fe = null,
                    me = -1,
                    ve = {
                        geometry: null,
                        program: null,
                        wireframe: !1
                    },
                    ge = null,
                    ye = null,
                    xe = new l,
                    be = new l,
                    _e = null,
                    we = 0,
                    Me = G.width,
                    Te = G.height,
                    Ee = 1,
                    Se = new l(0, 0, Me, Te),
                    Pe = new l(0, 0, Me, Te),
                    Ce = !1,
                    Ae = new v,
                    Le = new K,
                    Re = !1,
                    Ie = !1,
                    Oe = new i,
                    ke = new a;
                try {
                    var De = {
                        alpha: V,
                        depth: W,
                        stencil: q,
                        antialias: X,
                        premultipliedAlpha: Y,
                        preserveDrawingBuffer: Z,
                        powerPreference: re
                    };
                    if (G.addEventListener("webglcontextlost", o, !1), G.addEventListener("webglcontextrestored", s, !1), ce = H || G.getContext("webgl", De) || G.getContext("experimental-webgl", De), null === ce) throw null !== G.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                    void 0 === ce.getShaderPrecisionFormat && (ce.getShaderPrecisionFormat = function () {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (ze) {
                    throw console.error("THREE.WebGLRenderer: " + ze.message), ze
                }
                var Be, Ne, Ue, je, Fe, Ge, He, Ve, qe, Xe, Ye, Ze, Je, $e, Qe, Ke, et;
                r();
                var tt = null;
                "undefined" != typeof navigator && (tt = "xr" in navigator ? new At(ue) : new Ct(ue)), this.vr = tt;
                var nt = new xt(ue, qe, Ne.maxTextureSize);
                this.shadowMap = nt, this.getContext = function () {
                    return ce
                }, this.getContextAttributes = function () {
                    return ce.getContextAttributes()
                }, this.forceContextLoss = function () {
                    var e = Be.get("WEBGL_lose_context");
                    e && e.loseContext()
                }, this.forceContextRestore = function () {
                    var e = Be.get("WEBGL_lose_context");
                    e && e.restoreContext()
                }, this.getPixelRatio = function () {
                    return Ee
                }, this.setPixelRatio = function (e) {
                    void 0 !== e && (Ee = e, this.setSize(Me, Te, !1))
                }, this.getSize = function (e) {
                    return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), e = new n), e.set(Me, Te)
                }, this.setSize = function (e, t, n) {
                    return tt.isPresenting() ? void console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (Me = e, Te = t, G.width = e * Ee, G.height = t * Ee, n !== !1 && (G.style.width = e + "px", G.style.height = t + "px"), void this.setViewport(0, 0, e, t))
                }, this.getDrawingBufferSize = function (e) {
                    return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), e = new n), e.set(Me * Ee, Te * Ee)
                }, this.setDrawingBufferSize = function (e, t, n) {
                    Me = e, Te = t, Ee = n, G.width = e * n, G.height = t * n, this.setViewport(0, 0, e, t)
                }, this.getCurrentViewport = function (e) {
                    return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), e = new l), e.copy(xe)
                }, this.getViewport = function (e) {
                    return e.copy(Se)
                }, this.setViewport = function (e, t, n, i) {
                    e.isVector4 ? Se.set(e.x, e.y, e.z, e.w) : Se.set(e, t, n, i), Ue.viewport(xe.copy(Se).multiplyScalar(Ee))
                }, this.getScissor = function (e) {
                    return e.copy(Pe)
                }, this.setScissor = function (e, t, n, i) {
                    e.isVector4 ? Pe.set(e.x, e.y, e.z, e.w) : Pe.set(e, t, n, i), Ue.scissor(be.copy(Pe).multiplyScalar(Ee))
                }, this.getScissorTest = function () {
                    return Ce
                }, this.setScissorTest = function (e) {
                    Ue.setScissorTest(Ce = e)
                }, this.getClearColor = function () {
                    return Je.getClearColor()
                }, this.setClearColor = function () {
                    Je.setClearColor.apply(Je, arguments)
                }, this.getClearAlpha = function () {
                    return Je.getClearAlpha()
                }, this.setClearAlpha = function () {
                    Je.setClearAlpha.apply(Je, arguments)
                }, this.clear = function (e, t, n) {
                    var i = 0;
                    (void 0 === e || e) && (i |= 16384), (void 0 === t || t) && (i |= 256), (void 0 === n || n) && (i |= 1024), ce.clear(i)
                }, this.clearColor = function () {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function () {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function () {
                    this.clear(!1, !1, !0)
                }, this.dispose = function () {
                    G.removeEventListener("webglcontextlost", o, !1), G.removeEventListener("webglcontextrestored", s, !1), Ye.dispose(), Ze.dispose(), Fe.dispose(), qe.dispose(), tt.dispose(), rt.stop()
                }, this.renderBufferImmediate = function (e, t) {
                    Ue.initAttributes();
                    var n = Fe.get(e);
                    e.hasPositions && !n.position && (n.position = ce.createBuffer()), e.hasNormals && !n.normal && (n.normal = ce.createBuffer()), e.hasUvs && !n.uv && (n.uv = ce.createBuffer()), e.hasColors && !n.color && (n.color = ce.createBuffer());
                    var i = t.getAttributes();
                    e.hasPositions && (ce.bindBuffer(34962, n.position),
                        ce.bufferData(34962, e.positionArray, 35048), Ue.enableAttribute(i.position), ce.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)), e.hasNormals && (ce.bindBuffer(34962, n.normal), ce.bufferData(34962, e.normalArray, 35048), Ue.enableAttribute(i.normal), ce.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (ce.bindBuffer(34962, n.uv), ce.bufferData(34962, e.uvArray, 35048), Ue.enableAttribute(i.uv), ce.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)), e.hasColors && (ce.bindBuffer(34962, n.color), ce.bufferData(34962, e.colorArray, 35048), Ue.enableAttribute(i.color), ce.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)), Ue.disableUnusedAttributes(), ce.drawArrays(4, 0, e.count), e.count = 0
                }, this.renderBufferDirect = function (e, n, i, r, a, o) {
                    var s = a.isMesh && a.matrixWorld.determinant() < 0;
                    Ue.setMaterial(r, s);
                    var l = T(e, n, r, a),
                        c = !1;
                    ve.geometry === i.id && ve.program === l.id && ve.wireframe === (r.wireframe === !0) || (ve.geometry = i.id, ve.program = l.id, ve.wireframe = r.wireframe === !0, c = !0), a.morphTargetInfluences && ($e.update(a, i, r, l), c = !0);
                    var u = i.index,
                        h = i.attributes.position,
                        d = 1;
                    r.wireframe === !0 && (u = Ve.getWireframeAttribute(i), d = 2);
                    var p, m = Qe;
                    null !== u && (p = He.get(u), m = Ke, m.setIndex(p)), c && (f(r, l, i), null !== u && ce.bindBuffer(34963, p.buffer));
                    var v = 1 / 0;
                    null !== u ? v = u.count : void 0 !== h && (v = h.count);
                    var g = i.drawRange.start * d,
                        y = i.drawRange.count * d,
                        x = null !== o ? o.start * d : 0,
                        b = null !== o ? o.count * d : 1 / 0,
                        _ = Math.max(g, x),
                        w = Math.min(v, g + y, x + b) - 1,
                        M = Math.max(0, w - _ + 1);
                    if (0 !== M) {
                        if (a.isMesh)
                            if (r.wireframe === !0) Ue.setLineWidth(r.wireframeLinewidth * t()), m.setMode(1);
                            else switch (a.drawMode) {
                                case Ll:
                                    m.setMode(4);
                                    break;
                                case Rl:
                                    m.setMode(5);
                                    break;
                                case Il:
                                    m.setMode(6)
                            } else if (a.isLine) {
                                var E = r.linewidth;
                                void 0 === E && (E = 1), Ue.setLineWidth(E * t()), a.isLineSegments ? m.setMode(1) : a.isLineLoop ? m.setMode(2) : m.setMode(3)
                            } else a.isPoints ? m.setMode(0) : a.isSprite && m.setMode(4);
                        i && i.isInstancedBufferGeometry ? i.maxInstancedCount > 0 && m.renderInstances(i, _, M) : m.render(_, M)
                    }
                }, this.compile = function (e, t) {
                    le = Ze.get(e, t), le.init(), e.traverse(function (e) {
                        e.isLight && (le.pushLight(e), e.castShadow && le.pushShadow(e))
                    }), le.setupLights(t), e.traverse(function (t) {
                        if (t.material)
                            if (Array.isArray(t.material))
                                for (var n = 0; n < t.material.length; n++) M(t.material[n], e.fog, t);
                            else M(t.material, e.fog, t)
                    })
                };
                var it = null,
                    rt = new b;
                rt.setAnimationLoop(m), "undefined" != typeof window && rt.setContext(window), this.setAnimationLoop = function (e) {
                    it = e, tt.setAnimationLoop(e), rt.start()
                }, this.render = function (e, t) {
                    var n, i;
                    if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), i = arguments[3]), !t || !t.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!he) {
                        ve.geometry = null, ve.program = null, ve.wireframe = !1, me = -1, ge = null, e.autoUpdate === !0 && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), tt.enabled && (t = tt.getCamera(t)), le = Ze.get(e, t), le.init(), e.onBeforeRender(ue, e, t, n || pe), Oe.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), Ae.setFromMatrix(Oe), Ie = this.localClippingEnabled, Re = Le.init(this.clippingPlanes, Ie, t), se = Ye.get(e, t), se.init(), y(e, t, 0, ue.sortObjects), ue.sortObjects === !0 && se.sort(), Re && Le.beginShadows();
                        var r = le.state.shadowsArray;
                        nt.render(r, e, t), le.setupLights(t), Re && Le.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), Je.render(se, e, t, i);
                        var a = se.opaque,
                            o = se.transparent;
                        if (e.overrideMaterial) {
                            var s = e.overrideMaterial;
                            a.length && x(a, e, t, s), o.length && x(o, e, t, s)
                        } else a.length && x(a, e, t), o.length && x(o, e, t);
                        null !== pe && (Ge.updateRenderTargetMipmap(pe), Ge.updateMultisampleRenderTarget(pe)), Ue.buffers.depth.setTest(!0), Ue.buffers.depth.setMask(!0), Ue.buffers.color.setMask(!0), Ue.setPolygonOffset(!1), e.onAfterRender(ue, e, t), tt.enabled && tt.submitFrame(), se = null, le = null
                    }
                }, this.allocTextureUnit = F, this.setTexture2D = function () {
                    var e = !1;
                    return function (t, n) {
                        t && t.isWebGLRenderTarget && (e || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), e = !0), t = t.texture), Ge.setTexture2D(t, n)
                    }
                }(), this.setTexture3D = function () {
                    return function (e, t) {
                        Ge.setTexture3D(e, t)
                    }
                }(), this.setTexture = function () {
                    var e = !1;
                    return function (t, n) {
                        e || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), e = !0), Ge.setTexture2D(t, n)
                    }
                }(), this.setTextureCube = function () {
                    var e = !1;
                    return function (t, n) {
                        t && t.isWebGLRenderTargetCube && (e || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), e = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? Ge.setTextureCube(t, n) : Ge.setTextureCubeDynamic(t, n)
                    }
                }(), this.setFramebuffer = function (e) {
                    de = e
                }, this.getRenderTarget = function () {
                    return pe
                }, this.setRenderTarget = function (e, t, n) {
                    pe = e, e && void 0 === Fe.get(e).__webglFramebuffer && Ge.setupRenderTarget(e);
                    var i = de,
                        r = !1;
                    if (e) {
                        var a = Fe.get(e).__webglFramebuffer;
                        e.isWebGLRenderTargetCube ? (i = a[t || 0], r = !0) : i = e.isWebGLMultisampleRenderTarget ? Fe.get(e).__webglMultisampledFramebuffer : a, xe.copy(e.viewport), be.copy(e.scissor), _e = e.scissorTest
                    } else xe.copy(Se).multiplyScalar(Ee), be.copy(Pe).multiplyScalar(Ee), _e = Ce;
                    if (fe !== i && (ce.bindFramebuffer(36160, i), fe = i), Ue.viewport(xe), Ue.scissor(be), Ue.setScissorTest(_e), r) {
                        var o = Fe.get(e.texture);
                        ce.framebufferTexture2D(36160, 36064, 34069 + t || 0, o.__webglTexture, n || 0)
                    }
                }, this.readRenderTargetPixels = function (e, t, n, i, r, a) {
                    if (!e || !e.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    var o = Fe.get(e).__webglFramebuffer;
                    if (o) {
                        var s = !1;
                        o !== fe && (ce.bindFramebuffer(36160, o), s = !0);
                        try {
                            var l = e.texture,
                                c = l.format,
                                u = l.type;
                            if (c !== Ws && et.convert(c) !== ce.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            if (!(u === Rs || et.convert(u) === ce.getParameter(35738) || u === Bs && (Ne.isWebGL2 || Be.get("OES_texture_float") || Be.get("WEBGL_color_buffer_float")) || u === Ns && (Ne.isWebGL2 ? Be.get("EXT_color_buffer_float") : Be.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            36053 === ce.checkFramebufferStatus(36160) ? t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && ce.readPixels(t, n, i, r, et.convert(c), et.convert(u), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                        } finally {
                            s && ce.bindFramebuffer(36160, fe)
                        }
                    }
                }, this.copyFramebufferToTexture = function (e, t, n) {
                    var i = t.image.width,
                        r = t.image.height,
                        a = et.convert(t.format);
                    this.setTexture2D(t, 0), ce.copyTexImage2D(3553, n || 0, a, e.x, e.y, i, r, 0)
                }, this.copyTextureToTexture = function (e, t, n, i) {
                    var r = t.image.width,
                        a = t.image.height,
                        o = et.convert(n.format),
                        s = et.convert(n.type);
                    this.setTexture2D(n, 0), t.isDataTexture ? ce.texSubImage2D(3553, i || 0, e.x, e.y, r, a, o, s, t.image.data) : ce.texSubImage2D(3553, i || 0, e.x, e.y, o, s, t.image)
                }
            }

            function Rt(e, t) {
                this.name = "", this.color = new x(e), this.density = void 0 !== t ? t : 25e-5
            }

            function It(e, t, n) {
                this.name = "", this.color = new x(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== n ? n : 1e3
            }

            function Ot() {
                E.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
            }

            function kt(e, t) {
                this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function Dt(e, t, n, i) {
                this.data = e, this.itemSize = t, this.offset = n, this.normalized = i === !0
            }

            function zt(e) {
                V.call(this), this.type = "SpriteMaterial", this.color = new x(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(e)
            }

            function Bt(e) {
                if (E.call(this), this.type = "Sprite", void 0 === Lh) {
                    Lh = new U;
                    var t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                        i = new kt(t, 5);
                    Lh.setIndex([0, 1, 2, 0, 2, 3]), Lh.addAttribute("position", new Dt(i, 3, 0, (!1))), Lh.addAttribute("uv", new Dt(i, 2, 3, (!1)))
                }
                this.geometry = Lh, this.material = void 0 !== e ? e : new zt, this.center = new n(.5, .5)
            }

            function Nt() {
                E.call(this), this.type = "LOD", Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    }
                })
            }

            function Ut(e, t) {
                e && e.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Z.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new i, this.bindMatrixInverse = new i
            }

            function jt(e, t) {
                if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === t) this.calculateInverses();
                else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
                else {
                    console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
                    for (var n = 0, r = this.bones.length; n < r; n++) this.boneInverses.push(new i)
                }
            }

            function Ft() {
                E.call(this), this.type = "Bone"
            }

            function Gt(e) {
                V.call(this), this.type = "LineBasicMaterial", this.color = new x(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(e)
            }

            function Ht(e, t, n) {
                1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), E.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new U, this.material = void 0 !== t ? t : new Gt({
                    color: 16777215 * Math.random()
                })
            }

            function Vt(e, t) {
                Ht.call(this, e, t), this.type = "LineSegments"
            }

            function Wt(e, t) {
                Ht.call(this, e, t), this.type = "LineLoop"
            }

            function qt(e) {
                V.call(this), this.type = "PointsMaterial", this.color = new x(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.lights = !1, this.setValues(e)
            }

            function Xt(e, t) {
                E.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new U, this.material = void 0 !== t ? t : new qt({
                    color: 16777215 * Math.random()
                })
            }

            function Yt(e, t, n, i, r, a, o, l, c) {
                s.call(this, e, t, n, i, r, a, o, l, c), this.format = void 0 !== o ? o : Vs, this.minFilter = void 0 !== a ? a : Cs, this.magFilter = void 0 !== r ? r : Cs, this.generateMipmaps = !1
            }

            function Zt(e, t, n, i, r, a, o, l, c, u, h, d) {
                s.call(this, null, a, o, l, c, u, i, r, h, d), this.image = {
                    width: t,
                    height: n
                }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
            }

            function Jt(e, t, n, i, r, a, o, l, c) {
                s.call(this, e, t, n, i, r, a, o, l, c), this.needsUpdate = !0
            }

            function $t(e, t, n, i, r, a, o, l, c, u) {
                if (u = void 0 !== u ? u : Zs, u !== Zs && u !== Js) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && u === Zs && (n = ks), void 0 === n && u === Js && (n = Gs), s.call(this, null, i, r, a, o, l, u, n, c), this.image = {
                    width: e,
                    height: t
                }, this.magFilter = void 0 !== o ? o : Es, this.minFilter = void 0 !== l ? l : Es, this.flipY = !1, this.generateMipmaps = !1
            }

            function Qt(e) {
                U.call(this), this.type = "WireframeGeometry";
                var t, n, i, r, o, s, l, c, u, h, d = [],
                    p = [0, 0],
                    f = {},
                    m = ["a", "b", "c"];
                if (e && e.isGeometry) {
                    var v = e.faces;
                    for (t = 0, i = v.length; t < i; t++) {
                        var g = v[t];
                        for (n = 0; n < 3; n++) l = g[m[n]], c = g[m[(n + 1) % 3]], p[0] = Math.min(l, c), p[1] = Math.max(l, c), u = p[0] + "," + p[1], void 0 === f[u] && (f[u] = {
                            index1: p[0],
                            index2: p[1]
                        })
                    }
                    for (u in f) s = f[u], h = e.vertices[s.index1], d.push(h.x, h.y, h.z), h = e.vertices[s.index2], d.push(h.x, h.y, h.z)
                } else if (e && e.isBufferGeometry) {
                    var y, x, b, _, w, M, T, E;
                    if (h = new a, null !== e.index) {
                        for (y = e.attributes.position, x = e.index, b = e.groups, 0 === b.length && (b = [{
                                start: 0,
                                count: x.count,
                                materialIndex: 0
                            }]), r = 0, o = b.length; r < o; ++r)
                            for (_ = b[r], w = _.start, M = _.count, t = w, i = w + M; t < i; t += 3)
                                for (n = 0; n < 3; n++) l = x.getX(t + n), c = x.getX(t + (n + 1) % 3), p[0] = Math.min(l, c), p[1] = Math.max(l, c), u = p[0] + "," + p[1], void 0 === f[u] && (f[u] = {
                                    index1: p[0],
                                    index2: p[1]
                                });
                        for (u in f) s = f[u], h.fromBufferAttribute(y, s.index1), d.push(h.x, h.y, h.z), h.fromBufferAttribute(y, s.index2), d.push(h.x, h.y, h.z)
                    } else
                        for (y = e.attributes.position, t = 0, i = y.count / 3; t < i; t++)
                            for (n = 0; n < 3; n++) T = 3 * t + n, h.fromBufferAttribute(y, T), d.push(h.x, h.y, h.z), E = 3 * t + (n + 1) % 3, h.fromBufferAttribute(y, E), d.push(h.x, h.y, h.z)
                }
                this.addAttribute("position", new D(d, 3))
            }

            function Kt(e, t, n) {
                S.call(this), this.type = "ParametricGeometry", this.parameters = {
                    func: e,
                    slices: t,
                    stacks: n
                }, this.fromBufferGeometry(new en(e, t, n)), this.mergeVertices()
            }

            function en(e, t, n) {
                U.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                    func: e,
                    slices: t,
                    stacks: n
                };
                var i, r, o = [],
                    s = [],
                    l = [],
                    c = [],
                    u = 1e-5,
                    h = new a,
                    d = new a,
                    p = new a,
                    f = new a,
                    m = new a;
                e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
                var v = t + 1;
                for (i = 0; i <= n; i++) {
                    var g = i / n;
                    for (r = 0; r <= t; r++) {
                        var y = r / t;
                        e(y, g, d), s.push(d.x, d.y, d.z), y - u >= 0 ? (e(y - u, g, p), f.subVectors(d, p)) : (e(y + u, g, p), f.subVectors(p, d)), g - u >= 0 ? (e(y, g - u, p), m.subVectors(d, p)) : (e(y, g + u, p), m.subVectors(p, d)), h.crossVectors(f, m).normalize(), l.push(h.x, h.y, h.z), c.push(y, g)
                    }
                }
                for (i = 0; i < n; i++)
                    for (r = 0; r < t; r++) {
                        var x = i * v + r,
                            b = i * v + r + 1,
                            _ = (i + 1) * v + r + 1,
                            w = (i + 1) * v + r;
                        o.push(x, b, w), o.push(b, _, w)
                    }
                this.setIndex(o), this.addAttribute("position", new D(s, 3)), this.addAttribute("normal", new D(l, 3)), this.addAttribute("uv", new D(c, 2))
            }

            function tn(e, t, n, i) {
                S.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                    vertices: e,
                    indices: t,
                    radius: n,
                    detail: i
                }, this.fromBufferGeometry(new nn(e, t, n, i)), this.mergeVertices()
            }

            function nn(e, t, i, r) {
                function o(e) {
                    for (var n = new a, i = new a, r = new a, o = 0; o < t.length; o += 3) d(t[o + 0], n), d(t[o + 1], i), d(t[o + 2], r), s(n, i, r, e)
                }

                function s(e, t, n, i) {
                    var r, a, o = Math.pow(2, i),
                        s = [];
                    for (r = 0; r <= o; r++) {
                        s[r] = [];
                        var l = e.clone().lerp(n, r / o),
                            c = t.clone().lerp(n, r / o),
                            u = o - r;
                        for (a = 0; a <= u; a++) 0 === a && r === o ? s[r][a] = l : s[r][a] = l.clone().lerp(c, a / u)
                    }
                    for (r = 0; r < o; r++)
                        for (a = 0; a < 2 * (o - r) - 1; a++) {
                            var d = Math.floor(a / 2);
                            a % 2 === 0 ? (h(s[r][d + 1]), h(s[r + 1][d]), h(s[r][d])) : (h(s[r][d + 1]), h(s[r + 1][d + 1]), h(s[r + 1][d]))
                        }
                }

                function l(e) {
                    for (var t = new a, n = 0; n < g.length; n += 3) t.x = g[n + 0], t.y = g[n + 1], t.z = g[n + 2], t.normalize().multiplyScalar(e), g[n + 0] = t.x, g[n + 1] = t.y, g[n + 2] = t.z
                }

                function c() {
                    for (var e = new a, t = 0; t < g.length; t += 3) {
                        e.x = g[t + 0], e.y = g[t + 1], e.z = g[t + 2];
                        var n = m(e) / 2 / Math.PI + .5,
                            i = v(e) / Math.PI + .5;
                        y.push(n, 1 - i)
                    }
                    p(), u()
                }

                function u() {
                    for (var e = 0; e < y.length; e += 6) {
                        var t = y[e + 0],
                            n = y[e + 2],
                            i = y[e + 4],
                            r = Math.max(t, n, i),
                            a = Math.min(t, n, i);
                        r > .9 && a < .1 && (t < .2 && (y[e + 0] += 1), n < .2 && (y[e + 2] += 1), i < .2 && (y[e + 4] += 1))
                    }
                }

                function h(e) {
                    g.push(e.x, e.y, e.z)
                }

                function d(t, n) {
                    var i = 3 * t;
                    n.x = e[i + 0], n.y = e[i + 1], n.z = e[i + 2]
                }

                function p() {
                    for (var e = new a, t = new a, i = new a, r = new a, o = new n, s = new n, l = new n, c = 0, u = 0; c < g.length; c += 9, u += 6) {
                        e.set(g[c + 0], g[c + 1], g[c + 2]), t.set(g[c + 3], g[c + 4], g[c + 5]), i.set(g[c + 6], g[c + 7], g[c + 8]), o.set(y[u + 0], y[u + 1]), s.set(y[u + 2], y[u + 3]), l.set(y[u + 4], y[u + 5]), r.copy(e).add(t).add(i).divideScalar(3);
                        var h = m(r);
                        f(o, u + 0, e, h), f(s, u + 2, t, h), f(l, u + 4, i, h)
                    }
                }

                function f(e, t, n, i) {
                    i < 0 && 1 === e.x && (y[t] = e.x - 1), 0 === n.x && 0 === n.z && (y[t] = i / 2 / Math.PI + .5)
                }

                function m(e) {
                    return Math.atan2(e.z, -e.x)
                }

                function v(e) {
                    return Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z))
                }
                U.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                    vertices: e,
                    indices: t,
                    radius: i,
                    detail: r
                }, i = i || 1, r = r || 0;
                var g = [],
                    y = [];
                o(r), l(i), c(), this.addAttribute("position", new D(g, 3)), this.addAttribute("normal", new D(g.slice(), 3)), this.addAttribute("uv", new D(y, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals()
            }

            function rn(e, t) {
                S.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }, this.fromBufferGeometry(new an(e, t)), this.mergeVertices()
            }

            function an(e, t) {
                var n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
                    i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
                nn.call(this, n, i, e, t), this.type = "TetrahedronBufferGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }

            function on(e, t) {
                S.call(this), this.type = "OctahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }, this.fromBufferGeometry(new sn(e, t)), this.mergeVertices()
            }

            function sn(e, t) {
                var n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
                    i = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
                nn.call(this, n, i, e, t), this.type = "OctahedronBufferGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }

            function ln(e, t) {
                S.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }, this.fromBufferGeometry(new cn(e, t)), this.mergeVertices()
            }

            function cn(e, t) {
                var n = (1 + Math.sqrt(5)) / 2,
                    i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1],
                    r = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
                nn.call(this, i, r, e, t), this.type = "IcosahedronBufferGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }

            function un(e, t) {
                S.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }, this.fromBufferGeometry(new hn(e, t)), this.mergeVertices()
            }

            function hn(e, t) {
                var n = (1 + Math.sqrt(5)) / 2,
                    i = 1 / n,
                    r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i],
                    a = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
                nn.call(this, r, a, e, t), this.type = "DodecahedronBufferGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }

            function dn(e, t, n, i, r, a) {
                S.call(this), this.type = "TubeGeometry", this.parameters = {
                    path: e,
                    tubularSegments: t,
                    radius: n,
                    radialSegments: i,
                    closed: r
                }, void 0 !== a && console.warn("THREE.TubeGeometry: taper has been removed.");
                var o = new pn(e, t, n, i, r);
                this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals, this.fromBufferGeometry(o), this.mergeVertices()
            }

            function pn(e, t, i, r, o) {
                function s() {
                    for (d = 0; d < t; d++) l(d);
                    l(o === !1 ? t : 0), u(), c()
                }

                function l(n) {
                    g = e.getPointAt(n / t, g);
                    var a = h.normals[n],
                        o = h.binormals[n];
                    for (p = 0; p <= r; p++) {
                        var s = p / r * Math.PI * 2,
                            l = Math.sin(s),
                            c = -Math.cos(s);
                        m.x = c * a.x + l * o.x, m.y = c * a.y + l * o.y, m.z = c * a.z + l * o.z, m.normalize(), x.push(m.x, m.y, m.z), f.x = g.x + i * m.x, f.y = g.y + i * m.y, f.z = g.z + i * m.z, y.push(f.x, f.y, f.z)
                    }
                }

                function c() {
                    for (p = 1; p <= t; p++)
                        for (d = 1; d <= r; d++) {
                            var e = (r + 1) * (p - 1) + (d - 1),
                                n = (r + 1) * p + (d - 1),
                                i = (r + 1) * p + d,
                                a = (r + 1) * (p - 1) + d;
                            _.push(e, n, a), _.push(n, i, a)
                        }
                }

                function u() {
                    for (d = 0; d <= t; d++)
                        for (p = 0; p <= r; p++) v.x = d / t, v.y = p / r, b.push(v.x, v.y)
                }
                U.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                    path: e,
                    tubularSegments: t,
                    radius: i,
                    radialSegments: r,
                    closed: o
                }, t = t || 64, i = i || 1, r = r || 8, o = o || !1;
                var h = e.computeFrenetFrames(t, o);
                this.tangents = h.tangents, this.normals = h.normals, this.binormals = h.binormals;
                var d, p, f = new a,
                    m = new a,
                    v = new n,
                    g = new a,
                    y = [],
                    x = [],
                    b = [],
                    _ = [];
                s(), this.setIndex(_), this.addAttribute("position", new D(y, 3)), this.addAttribute("normal", new D(x, 3)), this.addAttribute("uv", new D(b, 2))
            }

            function fn(e, t, n, i, r, a, o) {
                S.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    tubularSegments: n,
                    radialSegments: i,
                    p: r,
                    q: a
                }, void 0 !== o && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new mn(e, t, n, i, r, a)), this.mergeVertices()
            }

            function mn(e, t, n, i, r, o) {
                function s(e, t, n, i, r) {
                    var a = Math.cos(e),
                        o = Math.sin(e),
                        s = n / t * e,
                        l = Math.cos(s);
                    r.x = i * (2 + l) * .5 * a, r.y = i * (2 + l) * o * .5, r.z = i * Math.sin(s) * .5
                }
                U.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    tubularSegments: n,
                    radialSegments: i,
                    p: r,
                    q: o
                }, e = e || 1, t = t || .4, n = Math.floor(n) || 64, i = Math.floor(i) || 8, r = r || 2, o = o || 3;
                var l, c, u = [],
                    h = [],
                    d = [],
                    p = [],
                    f = new a,
                    m = new a,
                    v = new a,
                    g = new a,
                    y = new a,
                    x = new a,
                    b = new a;
                for (l = 0; l <= n; ++l) {
                    var _ = l / n * r * Math.PI * 2;
                    for (s(_, r, o, e, v), s(_ + .01, r, o, e, g), x.subVectors(g, v), b.addVectors(g, v), y.crossVectors(x, b), b.crossVectors(y, x), y.normalize(), b.normalize(), c = 0; c <= i; ++c) {
                        var w = c / i * Math.PI * 2,
                            M = -t * Math.cos(w),
                            T = t * Math.sin(w);
                        f.x = v.x + (M * b.x + T * y.x), f.y = v.y + (M * b.y + T * y.y), f.z = v.z + (M * b.z + T * y.z), h.push(f.x, f.y, f.z), m.subVectors(f, v).normalize(), d.push(m.x, m.y, m.z), p.push(l / n), p.push(c / i)
                    }
                }
                for (c = 1; c <= n; c++)
                    for (l = 1; l <= i; l++) {
                        var E = (i + 1) * (c - 1) + (l - 1),
                            S = (i + 1) * c + (l - 1),
                            P = (i + 1) * c + l,
                            C = (i + 1) * (c - 1) + l;
                        u.push(E, S, C), u.push(S, P, C)
                    }
                this.setIndex(u), this.addAttribute("position", new D(h, 3)), this.addAttribute("normal", new D(d, 3)), this.addAttribute("uv", new D(p, 2))
            }

            function vn(e, t, n, i, r) {
                S.call(this), this.type = "TorusGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    radialSegments: n,
                    tubularSegments: i,
                    arc: r
                }, this.fromBufferGeometry(new gn(e, t, n, i, r)), this.mergeVertices()
            }

            function gn(e, t, n, i, r) {
                U.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    radialSegments: n,
                    tubularSegments: i,
                    arc: r
                }, e = e || 1, t = t || .4, n = Math.floor(n) || 8, i = Math.floor(i) || 6, r = r || 2 * Math.PI;
                var o, s, l = [],
                    c = [],
                    u = [],
                    h = [],
                    d = new a,
                    p = new a,
                    f = new a;
                for (o = 0; o <= n; o++)
                    for (s = 0; s <= i; s++) {
                        var m = s / i * r,
                            v = o / n * Math.PI * 2;
                        p.x = (e + t * Math.cos(v)) * Math.cos(m), p.y = (e + t * Math.cos(v)) * Math.sin(m), p.z = t * Math.sin(v), c.push(p.x, p.y, p.z), d.x = e * Math.cos(m), d.y = e * Math.sin(m), f.subVectors(p, d).normalize(), u.push(f.x, f.y, f.z), h.push(s / i), h.push(o / n)
                    }
                for (o = 1; o <= n; o++)
                    for (s = 1; s <= i; s++) {
                        var g = (i + 1) * o + s - 1,
                            y = (i + 1) * (o - 1) + s - 1,
                            x = (i + 1) * (o - 1) + s,
                            b = (i + 1) * o + s;
                        l.push(g, y, b), l.push(y, x, b)
                    }
                this.setIndex(l), this.addAttribute("position", new D(c, 3)), this.addAttribute("normal", new D(u, 3)), this.addAttribute("uv", new D(h, 2))
            }

            function yn(e, t, n, i, r) {
                var a, o;
                if (r === Wn(e, t, n, i) > 0)
                    for (a = t; a < n; a += i) o = Gn(a, e[a], e[a + 1], o);
                else
                    for (a = n - i; a >= t; a -= i) o = Gn(a, e[a], e[a + 1], o);
                return o && zn(o, o.next) && (Hn(o), o = o.next), o
            }

            function xn(e, t) {
                if (!e) return e;
                t || (t = e);
                var n, i = e;
                do
                    if (n = !1, i.steiner || !zn(i, i.next) && 0 !== Dn(i.prev, i, i.next)) i = i.next;
                    else {
                        if (Hn(i), i = t = i.prev, i === i.next) break;
                        n = !0
                    } while (n || i !== t);
                return t
            }

            function bn(e, t, n, i, r, a, o) {
                if (e) {
                    !o && a && An(e, i, r, a);
                    for (var s, l, c = e; e.prev !== e.next;)
                        if (s = e.prev, l = e.next, a ? wn(e, i, r, a) : _n(e)) t.push(s.i / n), t.push(e.i / n), t.push(l.i / n), Hn(e), e = l.next, c = l.next;
                        else if (e = l, e === c) {
                        o ? 1 === o ? (e = Mn(e, t, n), bn(e, t, n, i, r, a, 2)) : 2 === o && Tn(e, t, n, i, r, a) : bn(xn(e), t, n, i, r, a, 1);
                        break
                    }
                }
            }

            function _n(e) {
                var t = e.prev,
                    n = e,
                    i = e.next;
                if (Dn(t, n, i) >= 0) return !1;
                for (var r = e.next.next; r !== e.prev;) {
                    if (On(t.x, t.y, n.x, n.y, i.x, i.y, r.x, r.y) && Dn(r.prev, r, r.next) >= 0) return !1;
                    r = r.next
                }
                return !0
            }

            function wn(e, t, n, i) {
                var r = e.prev,
                    a = e,
                    o = e.next;
                if (Dn(r, a, o) >= 0) return !1;
                for (var s = r.x < a.x ? r.x < o.x ? r.x : o.x : a.x < o.x ? a.x : o.x, l = r.y < a.y ? r.y < o.y ? r.y : o.y : a.y < o.y ? a.y : o.y, c = r.x > a.x ? r.x > o.x ? r.x : o.x : a.x > o.x ? a.x : o.x, u = r.y > a.y ? r.y > o.y ? r.y : o.y : a.y > o.y ? a.y : o.y, h = Rn(s, l, t, n, i), d = Rn(c, u, t, n, i), p = e.nextZ; p && p.z <= d;) {
                    if (p !== e.prev && p !== e.next && On(r.x, r.y, a.x, a.y, o.x, o.y, p.x, p.y) && Dn(p.prev, p, p.next) >= 0) return !1;
                    p = p.nextZ
                }
                for (p = e.prevZ; p && p.z >= h;) {
                    if (p !== e.prev && p !== e.next && On(r.x, r.y, a.x, a.y, o.x, o.y, p.x, p.y) && Dn(p.prev, p, p.next) >= 0) return !1;
                    p = p.prevZ
                }
                return !0
            }

            function Mn(e, t, n) {
                var i = e;
                do {
                    var r = i.prev,
                        a = i.next.next;
                    !zn(r, a) && Bn(r, i, i.next, a) && Un(r, a) && Un(a, r) && (t.push(r.i / n), t.push(i.i / n), t.push(a.i / n), Hn(i), Hn(i.next), i = e = a), i = i.next
                } while (i !== e);
                return i
            }

            function Tn(e, t, n, i, r, a) {
                var o = e;
                do {
                    for (var s = o.next.next; s !== o.prev;) {
                        if (o.i !== s.i && kn(o, s)) {
                            var l = Fn(o, s);
                            return o = xn(o, o.next), l = xn(l, l.next), bn(o, t, n, i, r, a), void bn(l, t, n, i, r, a)
                        }
                        s = s.next
                    }
                    o = o.next
                } while (o !== e)
            }

            function En(e, t, n, i) {
                var r, a, o, s, l, c = [];
                for (r = 0, a = t.length; r < a; r++) o = t[r] * i, s = r < a - 1 ? t[r + 1] * i : e.length, l = yn(e, o, s, i, !1), l === l.next && (l.steiner = !0), c.push(In(l));
                for (c.sort(Sn), r = 0; r < c.length; r++) Pn(c[r], n), n = xn(n, n.next);
                return n
            }

            function Sn(e, t) {
                return e.x - t.x
            }

            function Pn(e, t) {
                if (t = Cn(e, t)) {
                    var n = Fn(t, e);
                    xn(n, n.next)
                }
            }

            function Cn(e, t) {
                var n, i = t,
                    r = e.x,
                    a = e.y,
                    o = -(1 / 0);
                do {
                    if (a <= i.y && a >= i.next.y && i.next.y !== i.y) {
                        var s = i.x + (a - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                        if (s <= r && s > o) {
                            if (o = s, s === r) {
                                if (a === i.y) return i;
                                if (a === i.next.y) return i.next
                            }
                            n = i.x < i.next.x ? i : i.next
                        }
                    }
                    i = i.next
                } while (i !== t);
                if (!n) return null;
                if (r === o) return n.prev;
                var l, c = n,
                    u = n.x,
                    h = n.y,
                    d = 1 / 0;
                for (i = n.next; i !== c;) r >= i.x && i.x >= u && r !== i.x && On(a < h ? r : o, a, u, h, a < h ? o : r, a, i.x, i.y) && (l = Math.abs(a - i.y) / (r - i.x), (l < d || l === d && i.x > n.x) && Un(i, e) && (n = i, d = l)), i = i.next;
                return n
            }

            function An(e, t, n, i) {
                var r = e;
                do null === r.z && (r.z = Rn(r.x, r.y, t, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next; while (r !== e);
                r.prevZ.nextZ = null, r.prevZ = null, Ln(r)
            }

            function Ln(e) {
                var t, n, i, r, a, o, s, l, c = 1;
                do {
                    for (n = e, e = null, a = null, o = 0; n;) {
                        for (o++, i = n, s = 0, t = 0; t < c && (s++, i = i.nextZ, i); t++);
                        for (l = c; s > 0 || l > 0 && i;) 0 !== s && (0 === l || !i || n.z <= i.z) ? (r = n, n = n.nextZ, s--) : (r = i, i = i.nextZ, l--), a ? a.nextZ = r : e = r, r.prevZ = a, a = r;
                        n = i
                    }
                    a.nextZ = null, c *= 2
                } while (o > 1);
                return e
            }

            function Rn(e, t, n, i, r) {
                return e = 32767 * (e - n) * r, t = 32767 * (t - i) * r, e = 16711935 & (e | e << 8), e = 252645135 & (e | e << 4), e = 858993459 & (e | e << 2), e = 1431655765 & (e | e << 1), t = 16711935 & (t | t << 8), t = 252645135 & (t | t << 4), t = 858993459 & (t | t << 2), t = 1431655765 & (t | t << 1), e | t << 1
            }

            function In(e) {
                var t = e,
                    n = e;
                do t.x < n.x && (n = t), t = t.next; while (t !== e);
                return n
            }

            function On(e, t, n, i, r, a, o, s) {
                return (r - o) * (t - s) - (e - o) * (a - s) >= 0 && (e - o) * (i - s) - (n - o) * (t - s) >= 0 && (n - o) * (a - s) - (r - o) * (i - s) >= 0
            }

            function kn(e, t) {
                return e.next.i !== t.i && e.prev.i !== t.i && !Nn(e, t) && Un(e, t) && Un(t, e) && jn(e, t)
            }

            function Dn(e, t, n) {
                return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
            }

            function zn(e, t) {
                return e.x === t.x && e.y === t.y
            }

            function Bn(e, t, n, i) {
                return !!(zn(e, t) && zn(n, i) || zn(e, i) && zn(n, t)) || Dn(e, t, n) > 0 != Dn(e, t, i) > 0 && Dn(n, i, e) > 0 != Dn(n, i, t) > 0
            }

            function Nn(e, t) {
                var n = e;
                do {
                    if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && Bn(n, n.next, e, t)) return !0;
                    n = n.next
                } while (n !== e);
                return !1
            }

            function Un(e, t) {
                return Dn(e.prev, e, e.next) < 0 ? Dn(e, t, e.next) >= 0 && Dn(e, e.prev, t) >= 0 : Dn(e, t, e.prev) < 0 || Dn(e, e.next, t) < 0
            }

            function jn(e, t) {
                var n = e,
                    i = !1,
                    r = (e.x + t.x) / 2,
                    a = (e.y + t.y) / 2;
                do n.y > a != n.next.y > a && n.next.y !== n.y && r < (n.next.x - n.x) * (a - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next; while (n !== e);
                return i
            }

            function Fn(e, t) {
                var n = new Vn(e.i, e.x, e.y),
                    i = new Vn(t.i, t.x, t.y),
                    r = e.next,
                    a = t.prev;
                return e.next = t, t.prev = e, n.next = r, r.prev = n, i.next = n, n.prev = i, a.next = i, i.prev = a, i
            }

            function Gn(e, t, n, i) {
                var r = new Vn(e, t, n);
                return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
            }

            function Hn(e) {
                e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
            }

            function Vn(e, t, n) {
                this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }

            function Wn(e, t, n, i) {
                for (var r = 0, a = t, o = n - i; a < n; a += i) r += (e[o] - e[a]) * (e[a + 1] + e[o + 1]), o = a;
                return r
            }

            function qn(e) {
                var t = e.length;
                t > 2 && e[t - 1].equals(e[0]) && e.pop()
            }

            function Xn(e, t) {
                for (var n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
            }

            function Yn(e, t) {
                S.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                    shapes: e,
                    options: t
                }, this.fromBufferGeometry(new Zn(e, t)), this.mergeVertices()
            }

            function Zn(e, t) {
                function i(e) {
                    function i(e, t, n) {
                        return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(n).add(e)
                    }

                    function l(e, t, i) {
                        var r, a, o, s = e.x - t.x,
                            l = e.y - t.y,
                            c = i.x - e.x,
                            u = i.y - e.y,
                            h = s * s + l * l,
                            d = s * u - l * c;
                        if (Math.abs(d) > Number.EPSILON) {
                            var p = Math.sqrt(h),
                                f = Math.sqrt(c * c + u * u),
                                m = t.x - l / p,
                                v = t.y + s / p,
                                g = i.x - u / f,
                                y = i.y + c / f,
                                x = ((g - m) * u - (y - v) * c) / (s * u - l * c);
                            r = m + s * x - e.x, a = v + l * x - e.y;
                            var b = r * r + a * a;
                            if (b <= 2) return new n(r, a);
                            o = Math.sqrt(b / 2)
                        } else {
                            var _ = !1;
                            s > Number.EPSILON ? c > Number.EPSILON && (_ = !0) : s < -Number.EPSILON ? c < -Number.EPSILON && (_ = !0) : Math.sign(l) === Math.sign(u) && (_ = !0), _ ? (r = -l, a = s, o = Math.sqrt(h)) : (r = s, a = l, o = Math.sqrt(h / 2))
                        }
                        return new n(r / o, a / o)
                    }

                    function c() {
                        var e = o.length / 3;
                        if (_) {
                            var t = 0,
                                n = Y * t;
                            for ($ = 0; $ < Z; $++) X = j[$], p(X[2] + n, X[1] + n, X[0] + n);
                            for (t = x + 2 * T, n = Y * t, $ = 0; $ < Z; $++) X = j[$], p(X[0] + n, X[1] + n, X[2] + n)
                        } else {
                            for ($ = 0; $ < Z; $++) X = j[$], p(X[2], X[1], X[0]);
                            for ($ = 0; $ < Z; $++) X = j[$], p(X[0] + Y * x, X[1] + Y * x, X[2] + Y * x)
                        }
                        r.addGroup(e, o.length / 3 - e, 0)
                    }

                    function u() {
                        var e = o.length / 3,
                            t = 0;
                        for (h(F, t), t += F.length, k = 0, D = N.length; k < D; k++) O = N[k], h(O, t), t += O.length;
                        r.addGroup(e, o.length / 3 - e, 1)
                    }

                    function h(e, t) {
                        var n, i;
                        for ($ = e.length; --$ >= 0;) {
                            n = $, i = $ - 1, i < 0 && (i = e.length - 1);
                            var r = 0,
                                a = x + 2 * T;
                            for (r = 0; r < a; r++) {
                                var o = Y * r,
                                    s = Y * (r + 1),
                                    l = t + n + o,
                                    c = t + i + o,
                                    u = t + i + s,
                                    h = t + n + s;
                                f(l, c, u, h)
                            }
                        }
                    }

                    function d(e, t, n) {
                        g.push(e), g.push(t), g.push(n)
                    }

                    function p(e, t, n) {
                        m(e), m(t), m(n);
                        var i = o.length / 3,
                            a = S.generateTopUV(r, o, i - 3, i - 2, i - 1);
                        v(a[0]), v(a[1]), v(a[2])
                    }

                    function f(e, t, n, i) {
                        m(e), m(t), m(i), m(t), m(n), m(i);
                        var a = o.length / 3,
                            s = S.generateSideWallUV(r, o, a - 6, a - 3, a - 2, a - 1);
                        v(s[0]), v(s[1]), v(s[3]), v(s[1]), v(s[2]), v(s[3])
                    }

                    function m(e) {
                        o.push(g[3 * e + 0]), o.push(g[3 * e + 1]), o.push(g[3 * e + 2])
                    }

                    function v(e) {
                        s.push(e.x), s.push(e.y)
                    }
                    var g = [],
                        y = void 0 !== t.curveSegments ? t.curveSegments : 12,
                        x = void 0 !== t.steps ? t.steps : 1,
                        b = void 0 !== t.depth ? t.depth : 100,
                        _ = void 0 === t.bevelEnabled || t.bevelEnabled,
                        w = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
                        M = void 0 !== t.bevelSize ? t.bevelSize : w - 2,
                        T = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
                        E = t.extrudePath,
                        S = void 0 !== t.UVGenerator ? t.UVGenerator : Oh;
                    void 0 !== t.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), b = t.amount);
                    var P, C, A, L, R, I = !1;
                    E && (P = E.getSpacedPoints(x), I = !0, _ = !1, C = E.computeFrenetFrames(x, !1), A = new a, L = new a, R = new a), _ || (T = 0, w = 0, M = 0);
                    var O, k, D, z = e.extractPoints(y),
                        B = z.shape,
                        N = z.holes,
                        U = !Ih.isClockWise(B);
                    if (U)
                        for (B = B.reverse(), k = 0, D = N.length; k < D; k++) O = N[k], Ih.isClockWise(O) && (N[k] = O.reverse());
                    var j = Ih.triangulateShape(B, N),
                        F = B;
                    for (k = 0, D = N.length; k < D; k++) O = N[k], B = B.concat(O);
                    for (var G, H, V, W, q, X, Y = B.length, Z = j.length, J = [], $ = 0, Q = F.length, K = Q - 1, ee = $ + 1; $ < Q; $++, K++, ee++) K === Q && (K = 0), ee === Q && (ee = 0), J[$] = l(F[$], F[K], F[ee]);
                    var te, ne = [],
                        ie = J.concat();
                    for (k = 0, D = N.length; k < D; k++) {
                        for (O = N[k], te = [], $ = 0, Q = O.length, K = Q - 1, ee = $ + 1; $ < Q; $++, K++, ee++) K === Q && (K = 0), ee === Q && (ee = 0), te[$] = l(O[$], O[K], O[ee]);
                        ne.push(te), ie = ie.concat(te)
                    }
                    for (G = 0; G < T; G++) {
                        for (V = G / T, W = w * Math.cos(V * Math.PI / 2), H = M * Math.sin(V * Math.PI / 2), $ = 0, Q = F.length; $ < Q; $++) q = i(F[$], J[$], H), d(q.x, q.y, -W);
                        for (k = 0, D = N.length; k < D; k++)
                            for (O = N[k], te = ne[k], $ = 0, Q = O.length; $ < Q; $++) q = i(O[$], te[$], H), d(q.x, q.y, -W)
                    }
                    for (H = M, $ = 0; $ < Y; $++) q = _ ? i(B[$], ie[$], H) : B[$], I ? (L.copy(C.normals[0]).multiplyScalar(q.x), A.copy(C.binormals[0]).multiplyScalar(q.y), R.copy(P[0]).add(L).add(A), d(R.x, R.y, R.z)) : d(q.x, q.y, 0);
                    var re;
                    for (re = 1; re <= x; re++)
                        for ($ = 0; $ < Y; $++) q = _ ? i(B[$], ie[$], H) : B[$], I ? (L.copy(C.normals[re]).multiplyScalar(q.x), A.copy(C.binormals[re]).multiplyScalar(q.y), R.copy(P[re]).add(L).add(A), d(R.x, R.y, R.z)) : d(q.x, q.y, b / x * re);
                    for (G = T - 1; G >= 0; G--) {
                        for (V = G / T, W = w * Math.cos(V * Math.PI / 2), H = M * Math.sin(V * Math.PI / 2), $ = 0, Q = F.length; $ < Q; $++) q = i(F[$], J[$], H), d(q.x, q.y, b + W);
                        for (k = 0, D = N.length; k < D; k++)
                            for (O = N[k], te = ne[k], $ = 0, Q = O.length; $ < Q; $++) q = i(O[$], te[$], H), I ? d(q.x, q.y + P[x - 1].y, P[x - 1].x + W) : d(q.x, q.y, b + W)
                    }
                    c(), u()
                }
                U.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
                    shapes: e,
                    options: t
                }, e = Array.isArray(e) ? e : [e];
                for (var r = this, o = [], s = [], l = 0, c = e.length; l < c; l++) {
                    var u = e[l];
                    i(u)
                }
                this.addAttribute("position", new D(o, 3)), this.addAttribute("uv", new D(s, 2)), this.computeVertexNormals()
            }

            function Jn(e, t, n) {
                if (n.shapes = [], Array.isArray(e))
                    for (var i = 0, r = e.length; i < r; i++) {
                        var a = e[i];
                        n.shapes.push(a.uuid)
                    } else n.shapes.push(e.uuid);
                return void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON()), n
            }

            function $n(e, t) {
                S.call(this), this.type = "TextGeometry", this.parameters = {
                    text: e,
                    parameters: t
                }, this.fromBufferGeometry(new Qn(e, t)), this.mergeVertices()
            }

            function Qn(e, t) {
                t = t || {};
                var n = t.font;
                if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new S;
                var i = n.generateShapes(e, t.size);
                t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), Zn.call(this, i, t), this.type = "TextBufferGeometry"
            }

            function Kn(e, t, n, i, r, a, o) {
                S.call(this), this.type = "SphereGeometry", this.parameters = {
                    radius: e,
                    widthSegments: t,
                    heightSegments: n,
                    phiStart: i,
                    phiLength: r,
                    thetaStart: a,
                    thetaLength: o
                }, this.fromBufferGeometry(new ei(e, t, n, i, r, a, o)), this.mergeVertices()
            }

            function ei(e, t, n, i, r, o, s) {
                U.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                    radius: e,
                    widthSegments: t,
                    heightSegments: n,
                    phiStart: i,
                    phiLength: r,
                    thetaStart: o,
                    thetaLength: s
                }, e = e || 1, t = Math.max(3, Math.floor(t) || 8), n = Math.max(2, Math.floor(n) || 6), i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI, o = void 0 !== o ? o : 0, s = void 0 !== s ? s : Math.PI;
                var l, c, u = o + s,
                    h = 0,
                    d = [],
                    p = new a,
                    f = new a,
                    m = [],
                    v = [],
                    g = [],
                    y = [];
                for (c = 0; c <= n; c++) {
                    var x = [],
                        b = c / n;
                    for (l = 0; l <= t; l++) {
                        var _ = l / t;
                        p.x = -e * Math.cos(i + _ * r) * Math.sin(o + b * s), p.y = e * Math.cos(o + b * s), p.z = e * Math.sin(i + _ * r) * Math.sin(o + b * s), v.push(p.x, p.y, p.z), f.set(p.x, p.y, p.z).normalize(), g.push(f.x, f.y, f.z), y.push(_, 1 - b), x.push(h++)
                    }
                    d.push(x)
                }
                for (c = 0; c < n; c++)
                    for (l = 0; l < t; l++) {
                        var w = d[c][l + 1],
                            M = d[c][l],
                            T = d[c + 1][l],
                            E = d[c + 1][l + 1];
                        (0 !== c || o > 0) && m.push(w, M, E), (c !== n - 1 || u < Math.PI) && m.push(M, T, E)
                    }
                this.setIndex(m), this.addAttribute("position", new D(v, 3)), this.addAttribute("normal", new D(g, 3)),
                    this.addAttribute("uv", new D(y, 2))
            }

            function ti(e, t, n, i, r, a) {
                S.call(this), this.type = "RingGeometry", this.parameters = {
                    innerRadius: e,
                    outerRadius: t,
                    thetaSegments: n,
                    phiSegments: i,
                    thetaStart: r,
                    thetaLength: a
                }, this.fromBufferGeometry(new ni(e, t, n, i, r, a)), this.mergeVertices()
            }

            function ni(e, t, i, r, o, s) {
                U.call(this), this.type = "RingBufferGeometry", this.parameters = {
                    innerRadius: e,
                    outerRadius: t,
                    thetaSegments: i,
                    phiSegments: r,
                    thetaStart: o,
                    thetaLength: s
                }, e = e || .5, t = t || 1, o = void 0 !== o ? o : 0, s = void 0 !== s ? s : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8, r = void 0 !== r ? Math.max(1, r) : 1;
                var l, c, u, h = [],
                    d = [],
                    p = [],
                    f = [],
                    m = e,
                    v = (t - e) / r,
                    g = new a,
                    y = new n;
                for (c = 0; c <= r; c++) {
                    for (u = 0; u <= i; u++) l = o + u / i * s, g.x = m * Math.cos(l), g.y = m * Math.sin(l), d.push(g.x, g.y, g.z), p.push(0, 0, 1), y.x = (g.x / t + 1) / 2, y.y = (g.y / t + 1) / 2, f.push(y.x, y.y);
                    m += v
                }
                for (c = 0; c < r; c++) {
                    var x = c * (i + 1);
                    for (u = 0; u < i; u++) {
                        l = u + x;
                        var b = l,
                            _ = l + i + 1,
                            w = l + i + 2,
                            M = l + 1;
                        h.push(b, _, M), h.push(_, w, M)
                    }
                }
                this.setIndex(h), this.addAttribute("position", new D(d, 3)), this.addAttribute("normal", new D(p, 3)), this.addAttribute("uv", new D(f, 2))
            }

            function ii(e, t, n, i) {
                S.call(this), this.type = "LatheGeometry", this.parameters = {
                    points: e,
                    segments: t,
                    phiStart: n,
                    phiLength: i
                }, this.fromBufferGeometry(new ri(e, t, n, i)), this.mergeVertices()
            }

            function ri(e, t, i, r) {
                U.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                    points: e,
                    segments: t,
                    phiStart: i,
                    phiLength: r
                }, t = Math.floor(t) || 12, i = i || 0, r = r || 2 * Math.PI, r = Wl.clamp(r, 0, 2 * Math.PI);
                var o, s, l, c = [],
                    u = [],
                    h = [],
                    d = 1 / t,
                    p = new a,
                    f = new n;
                for (s = 0; s <= t; s++) {
                    var m = i + s * d * r,
                        v = Math.sin(m),
                        g = Math.cos(m);
                    for (l = 0; l <= e.length - 1; l++) p.x = e[l].x * v, p.y = e[l].y, p.z = e[l].x * g, u.push(p.x, p.y, p.z), f.x = s / t, f.y = l / (e.length - 1), h.push(f.x, f.y)
                }
                for (s = 0; s < t; s++)
                    for (l = 0; l < e.length - 1; l++) {
                        o = l + s * e.length;
                        var y = o,
                            x = o + e.length,
                            b = o + e.length + 1,
                            _ = o + 1;
                        c.push(y, x, _), c.push(x, b, _)
                    }
                if (this.setIndex(c), this.addAttribute("position", new D(u, 3)), this.addAttribute("uv", new D(h, 2)), this.computeVertexNormals(), r === 2 * Math.PI) {
                    var w = this.attributes.normal.array,
                        M = new a,
                        T = new a,
                        E = new a;
                    for (o = t * e.length * 3, s = 0, l = 0; s < e.length; s++, l += 3) M.x = w[l + 0], M.y = w[l + 1], M.z = w[l + 2], T.x = w[o + l + 0], T.y = w[o + l + 1], T.z = w[o + l + 2], E.addVectors(M, T).normalize(), w[l + 0] = w[o + l + 0] = E.x, w[l + 1] = w[o + l + 1] = E.y, w[l + 2] = w[o + l + 2] = E.z
                }
            }

            function ai(e, t) {
                S.call(this), this.type = "ShapeGeometry", "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = {
                    shapes: e,
                    curveSegments: t
                }, this.fromBufferGeometry(new oi(e, t)), this.mergeVertices()
            }

            function oi(e, t) {
                function n(e) {
                    var n, s, c, u = r.length / 3,
                        h = e.extractPoints(t),
                        d = h.shape,
                        p = h.holes;
                    for (Ih.isClockWise(d) === !1 && (d = d.reverse()), n = 0, s = p.length; n < s; n++) c = p[n], Ih.isClockWise(c) === !0 && (p[n] = c.reverse());
                    var f = Ih.triangulateShape(d, p);
                    for (n = 0, s = p.length; n < s; n++) c = p[n], d = d.concat(c);
                    for (n = 0, s = d.length; n < s; n++) {
                        var m = d[n];
                        r.push(m.x, m.y, 0), a.push(0, 0, 1), o.push(m.x, m.y)
                    }
                    for (n = 0, s = f.length; n < s; n++) {
                        var v = f[n],
                            g = v[0] + u,
                            y = v[1] + u,
                            x = v[2] + u;
                        i.push(g, y, x), l += 3
                    }
                }
                U.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                    shapes: e,
                    curveSegments: t
                }, t = t || 12;
                var i = [],
                    r = [],
                    a = [],
                    o = [],
                    s = 0,
                    l = 0;
                if (Array.isArray(e) === !1) n(e);
                else
                    for (var c = 0; c < e.length; c++) n(e[c]), this.addGroup(s, l, c), s += l, l = 0;
                this.setIndex(i), this.addAttribute("position", new D(r, 3)), this.addAttribute("normal", new D(a, 3)), this.addAttribute("uv", new D(o, 2))
            }

            function si(e, t) {
                if (t.shapes = [], Array.isArray(e))
                    for (var n = 0, i = e.length; n < i; n++) {
                        var r = e[n];
                        t.shapes.push(r.uuid)
                    } else t.shapes.push(e.uuid);
                return t
            }

            function li(e, t) {
                U.call(this), this.type = "EdgesGeometry", this.parameters = {
                    thresholdAngle: t
                }, t = void 0 !== t ? t : 1;
                var n, i, r, a, o = [],
                    s = Math.cos(Wl.DEG2RAD * t),
                    l = [0, 0],
                    c = {},
                    u = ["a", "b", "c"];
                e.isBufferGeometry ? (a = new S, a.fromBufferGeometry(e)) : a = e.clone(), a.mergeVertices(), a.computeFaceNormals();
                for (var h = a.vertices, d = a.faces, p = 0, f = d.length; p < f; p++)
                    for (var m = d[p], v = 0; v < 3; v++) n = m[u[v]], i = m[u[(v + 1) % 3]], l[0] = Math.min(n, i), l[1] = Math.max(n, i), r = l[0] + "," + l[1], void 0 === c[r] ? c[r] = {
                        index1: l[0],
                        index2: l[1],
                        face1: p,
                        face2: void 0
                    } : c[r].face2 = p;
                for (r in c) {
                    var g = c[r];
                    if (void 0 === g.face2 || d[g.face1].normal.dot(d[g.face2].normal) <= s) {
                        var y = h[g.index1];
                        o.push(y.x, y.y, y.z), y = h[g.index2], o.push(y.x, y.y, y.z)
                    }
                }
                this.addAttribute("position", new D(o, 3))
            }

            function ci(e, t, n, i, r, a, o, s) {
                S.call(this), this.type = "CylinderGeometry", this.parameters = {
                    radiusTop: e,
                    radiusBottom: t,
                    height: n,
                    radialSegments: i,
                    heightSegments: r,
                    openEnded: a,
                    thetaStart: o,
                    thetaLength: s
                }, this.fromBufferGeometry(new ui(e, t, n, i, r, a, o, s)), this.mergeVertices()
            }

            function ui(e, t, i, r, o, s, l, c) {
                function u() {
                    var n, s, u = new a,
                        h = new a,
                        _ = 0,
                        w = (t - e) / i;
                    for (s = 0; s <= o; s++) {
                        var M = [],
                            T = s / o,
                            E = T * (t - e) + e;
                        for (n = 0; n <= r; n++) {
                            var S = n / r,
                                P = S * c + l,
                                C = Math.sin(P),
                                A = Math.cos(P);
                            h.x = E * C, h.y = -T * i + x, h.z = E * A, f.push(h.x, h.y, h.z), u.set(C, w, A).normalize(), m.push(u.x, u.y, u.z), v.push(S, 1 - T), M.push(g++)
                        }
                        y.push(M)
                    }
                    for (n = 0; n < r; n++)
                        for (s = 0; s < o; s++) {
                            var L = y[s][n],
                                R = y[s + 1][n],
                                I = y[s + 1][n + 1],
                                O = y[s][n + 1];
                            p.push(L, R, O), p.push(R, I, O), _ += 6
                        }
                    d.addGroup(b, _, 0), b += _
                }

                function h(i) {
                    var o, s, u, h = new n,
                        y = new a,
                        _ = 0,
                        w = i === !0 ? e : t,
                        M = i === !0 ? 1 : -1;
                    for (s = g, o = 1; o <= r; o++) f.push(0, x * M, 0), m.push(0, M, 0), v.push(.5, .5), g++;
                    for (u = g, o = 0; o <= r; o++) {
                        var T = o / r,
                            E = T * c + l,
                            S = Math.cos(E),
                            P = Math.sin(E);
                        y.x = w * P, y.y = x * M, y.z = w * S, f.push(y.x, y.y, y.z), m.push(0, M, 0), h.x = .5 * S + .5, h.y = .5 * P * M + .5, v.push(h.x, h.y), g++
                    }
                    for (o = 0; o < r; o++) {
                        var C = s + o,
                            A = u + o;
                        i === !0 ? p.push(A, A + 1, C) : p.push(A + 1, A, C), _ += 3
                    }
                    d.addGroup(b, _, i === !0 ? 1 : 2), b += _
                }
                U.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                    radiusTop: e,
                    radiusBottom: t,
                    height: i,
                    radialSegments: r,
                    heightSegments: o,
                    openEnded: s,
                    thetaStart: l,
                    thetaLength: c
                };
                var d = this;
                e = void 0 !== e ? e : 1, t = void 0 !== t ? t : 1, i = i || 1, r = Math.floor(r) || 8, o = Math.floor(o) || 1, s = void 0 !== s && s, l = void 0 !== l ? l : 0, c = void 0 !== c ? c : 2 * Math.PI;
                var p = [],
                    f = [],
                    m = [],
                    v = [],
                    g = 0,
                    y = [],
                    x = i / 2,
                    b = 0;
                u(), s === !1 && (e > 0 && h(!0), t > 0 && h(!1)), this.setIndex(p), this.addAttribute("position", new D(f, 3)), this.addAttribute("normal", new D(m, 3)), this.addAttribute("uv", new D(v, 2))
            }

            function hi(e, t, n, i, r, a, o) {
                ci.call(this, 0, e, t, n, i, r, a, o), this.type = "ConeGeometry", this.parameters = {
                    radius: e,
                    height: t,
                    radialSegments: n,
                    heightSegments: i,
                    openEnded: r,
                    thetaStart: a,
                    thetaLength: o
                }
            }

            function di(e, t, n, i, r, a, o) {
                ui.call(this, 0, e, t, n, i, r, a, o), this.type = "ConeBufferGeometry", this.parameters = {
                    radius: e,
                    height: t,
                    radialSegments: n,
                    heightSegments: i,
                    openEnded: r,
                    thetaStart: a,
                    thetaLength: o
                }
            }

            function pi(e, t, n, i) {
                S.call(this), this.type = "CircleGeometry", this.parameters = {
                    radius: e,
                    segments: t,
                    thetaStart: n,
                    thetaLength: i
                }, this.fromBufferGeometry(new fi(e, t, n, i)), this.mergeVertices()
            }

            function fi(e, t, i, r) {
                U.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                    radius: e,
                    segments: t,
                    thetaStart: i,
                    thetaLength: r
                }, e = e || 1, t = void 0 !== t ? Math.max(3, t) : 8, i = void 0 !== i ? i : 0, r = void 0 !== r ? r : 2 * Math.PI;
                var o, s, l = [],
                    c = [],
                    u = [],
                    h = [],
                    d = new a,
                    p = new n;
                for (c.push(0, 0, 0), u.push(0, 0, 1), h.push(.5, .5), s = 0, o = 3; s <= t; s++, o += 3) {
                    var f = i + s / t * r;
                    d.x = e * Math.cos(f), d.y = e * Math.sin(f), c.push(d.x, d.y, d.z), u.push(0, 0, 1), p.x = (c[o] / e + 1) / 2, p.y = (c[o + 1] / e + 1) / 2, h.push(p.x, p.y)
                }
                for (o = 1; o <= t; o++) l.push(o, o + 1, 0);
                this.setIndex(l), this.addAttribute("position", new D(c, 3)), this.addAttribute("normal", new D(u, 3)), this.addAttribute("uv", new D(h, 2))
            }

            function mi(e) {
                V.call(this), this.type = "ShadowMaterial", this.color = new x(0), this.transparent = !0, this.setValues(e)
            }

            function vi(e) {
                W.call(this, e), this.type = "RawShaderMaterial"
            }

            function gi(e) {
                V.call(this), this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new x(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new x(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Hl, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function yi(e) {
                gi.call(this), this.defines = {
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(e)
            }

            function xi(e) {
                V.call(this), this.type = "MeshPhongMaterial", this.color = new x(16777215), this.specular = new x(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new x(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Hl, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = as, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function bi(e) {
                xi.call(this), this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(e)
            }

            function _i(e) {
                V.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Hl, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function wi(e) {
                V.call(this), this.type = "MeshLambertMaterial", this.color = new x(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new x(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = as, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }

            function Mi(e) {
                V.call(this), this.defines = {
                    MATCAP: ""
                }, this.type = "MeshMatcapMaterial", this.color = new x(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Hl, this.normalScale = new n(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.lights = !1, this.setValues(e)
            }

            function Ti(e) {
                Gt.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
            }

            function Ei(e, t, n, i) {
                this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n
            }

            function Si(e, t, n, i) {
                Ei.call(this, e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
            }

            function Pi(e, t, n, i) {
                Ei.call(this, e, t, n, i)
            }

            function Ci(e, t, n, i) {
                Ei.call(this, e, t, n, i)
            }

            function Ai(e, t, n, i) {
                if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                this.name = e, this.times = zh.convertArray(t, this.TimeBufferType), this.values = zh.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
            }

            function Li(e, t, n) {
                Ai.call(this, e, t, n)
            }

            function Ri(e, t, n, i) {
                Ai.call(this, e, t, n, i)
            }

            function Ii(e, t, n, i) {
                Ai.call(this, e, t, n, i)
            }

            function Oi(e, t, n, i) {
                Ei.call(this, e, t, n, i)
            }

            function ki(e, t, n, i) {
                Ai.call(this, e, t, n, i)
            }

            function Di(e, t, n, i) {
                Ai.call(this, e, t, n, i)
            }

            function zi(e, t, n, i) {
                Ai.call(this, e, t, n, i)
            }

            function Bi(e, t, n) {
                this.name = e, this.tracks = n, this.duration = void 0 !== t ? t : -1, this.uuid = Wl.generateUUID(), this.duration < 0 && this.resetDuration()
            }

            function Ni(e) {
                switch (e.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return Ii;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return zi;
                    case "color":
                        return Ri;
                    case "quaternion":
                        return ki;
                    case "bool":
                    case "boolean":
                        return Li;
                    case "string":
                        return Di
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
            }

            function Ui(e) {
                if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                var t = Ni(e.type);
                if (void 0 === e.times) {
                    var n = [],
                        i = [];
                    zh.flattenJSON(e.keys, n, i, "value"), e.times = n, e.values = i
                }
                return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
            }

            function ji(e, t, n) {
                var i = this,
                    r = !1,
                    a = 0,
                    o = 0,
                    s = void 0;
                this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function (e) {
                    o++, r === !1 && void 0 !== i.onStart && i.onStart(e, a, o), r = !0
                }, this.itemEnd = function (e) {
                    a++, void 0 !== i.onProgress && i.onProgress(e, a, o), a === o && (r = !1, void 0 !== i.onLoad && i.onLoad())
                }, this.itemError = function (e) {
                    void 0 !== i.onError && i.onError(e)
                }, this.resolveURL = function (e) {
                    return s ? s(e) : e
                }, this.setURLModifier = function (e) {
                    return s = e, this
                }
            }

            function Fi(e) {
                this.manager = void 0 !== e ? e : Nh
            }

            function Gi(e) {
                this.manager = void 0 !== e ? e : Nh
            }

            function Hi(e) {
                this.manager = void 0 !== e ? e : Nh, this._parser = null
            }

            function Vi(e) {
                this.manager = void 0 !== e ? e : Nh, this._parser = null
            }

            function Wi(e) {
                this.manager = void 0 !== e ? e : Nh
            }

            function qi(e) {
                this.manager = void 0 !== e ? e : Nh
            }

            function Xi(e) {
                this.manager = void 0 !== e ? e : Nh
            }

            function Yi() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }

            function Zi(e, t, n, i, r, a, o, s) {
                Yi.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = n || 1, this.yRadius = i || 1, this.aStartAngle = r || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = o || !1, this.aRotation = s || 0
            }

            function Ji(e, t, n, i, r, a) {
                Zi.call(this, e, t, n, n, i, r, a), this.type = "ArcCurve"
            }

            function $i() {
                function e(e, a, o, s) {
                    t = e, n = o, i = -3 * e + 3 * a - 2 * o - s, r = 2 * e - 2 * a + o + s
                }
                var t = 0,
                    n = 0,
                    i = 0,
                    r = 0;
                return {
                    initCatmullRom: function (t, n, i, r, a) {
                        e(n, i, a * (i - t), a * (r - n))
                    },
                    initNonuniformCatmullRom: function (t, n, i, r, a, o, s) {
                        var l = (n - t) / a - (i - t) / (a + o) + (i - n) / o,
                            c = (i - n) / o - (r - n) / (o + s) + (r - i) / s;
                        l *= o, c *= o, e(n, i, l, c)
                    },
                    calc: function (e) {
                        var a = e * e,
                            o = a * e;
                        return t + n * e + i * a + r * o
                    }
                }
            }

            function Qi(e, t, n, i) {
                Yi.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = n || "centripetal", this.tension = i || .5
            }

            function Ki(e, t, n, i, r) {
                var a = .5 * (i - t),
                    o = .5 * (r - n),
                    s = e * e,
                    l = e * s;
                return (2 * n - 2 * i + a + o) * l + (-3 * n + 3 * i - 2 * a - o) * s + a * e + n
            }

            function er(e, t) {
                var n = 1 - e;
                return n * n * t
            }

            function tr(e, t) {
                return 2 * (1 - e) * e * t
            }

            function nr(e, t) {
                return e * e * t
            }

            function ir(e, t, n, i) {
                return er(e, t) + tr(e, n) + nr(e, i)
            }

            function rr(e, t) {
                var n = 1 - e;
                return n * n * n * t
            }

            function ar(e, t) {
                var n = 1 - e;
                return 3 * n * n * e * t
            }

            function or(e, t) {
                return 3 * (1 - e) * e * e * t
            }

            function sr(e, t) {
                return e * e * e * t
            }

            function lr(e, t, n, i, r) {
                return rr(e, t) + ar(e, n) + or(e, i) + sr(e, r)
            }

            function cr(e, t, i, r) {
                Yi.call(this), this.type = "CubicBezierCurve", this.v0 = e || new n, this.v1 = t || new n, this.v2 = i || new n, this.v3 = r || new n
            }

            function ur(e, t, n, i) {
                Yi.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new a, this.v1 = t || new a, this.v2 = n || new a, this.v3 = i || new a
            }

            function hr(e, t) {
                Yi.call(this), this.type = "LineCurve", this.v1 = e || new n, this.v2 = t || new n
            }

            function dr(e, t) {
                Yi.call(this), this.type = "LineCurve3", this.v1 = e || new a, this.v2 = t || new a
            }

            function pr(e, t, i) {
                Yi.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new n, this.v1 = t || new n, this.v2 = i || new n
            }

            function fr(e, t, n) {
                Yi.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new a, this.v1 = t || new a, this.v2 = n || new a
            }

            function mr(e) {
                Yi.call(this), this.type = "SplineCurve", this.points = e || []
            }

            function vr() {
                Yi.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }

            function gr(e) {
                vr.call(this), this.type = "Path", this.currentPoint = new n, e && this.setFromPoints(e)
            }

            function yr(e) {
                gr.call(this, e), this.uuid = Wl.generateUUID(), this.type = "Shape", this.holes = []
            }

            function xr(e, t) {
                E.call(this), this.type = "Light", this.color = new x(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0
            }

            function br(e, t, n) {
                xr.call(this, e, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(E.DefaultUp), this.updateMatrix(), this.groundColor = new x(t)
            }

            function _r(e) {
                this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new n(512, 512), this.map = null, this.matrix = new i
            }

            function wr() {
                _r.call(this, new Et(50, 1, .5, 500))
            }

            function Mr(e, t, n, i, r, a) {
                xr.call(this, e, t), this.type = "SpotLight", this.position.copy(E.DefaultUp), this.updateMatrix(), this.target = new E, Object.defineProperty(this, "power", {
                    get: function () {
                        return this.intensity * Math.PI
                    },
                    set: function (e) {
                        this.intensity = e / Math.PI
                    }
                }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== i ? i : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new wr
            }

            function Tr(e, t, n, i) {
                xr.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", {
                    get: function () {
                        return 4 * this.intensity * Math.PI
                    },
                    set: function (e) {
                        this.intensity = e / (4 * Math.PI)
                    }
                }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== i ? i : 1, this.shadow = new _r(new Et(90, 1, .5, 500))
            }

            function Er(e, t, n, i, r, a) {
                Tt.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== e ? e : -1, this.right = void 0 !== t ? t : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== i ? i : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix()
            }

            function Sr() {
                _r.call(this, new Er((-5), 5, 5, (-5), .5, 500))
            }

            function Pr(e, t) {
                xr.call(this, e, t), this.type = "DirectionalLight", this.position.copy(E.DefaultUp), this.updateMatrix(), this.target = new E, this.shadow = new Sr
            }

            function Cr(e, t) {
                xr.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0
            }

            function Ar(e, t, n, i) {
                xr.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== i ? i : 10
            }

            function Lr(e) {
                this.manager = void 0 !== e ? e : Nh, this.textures = {}
            }

            function Rr(e) {
                this.manager = void 0 !== e ? e : Nh
            }

            function Ir(e) {
                this.manager = void 0 !== e ? e : Nh, this.resourcePath = ""
            }

            function Or(e) {
                "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== e ? e : Nh, this.options = void 0
            }

            function kr() {
                this.type = "ShapePath", this.color = new x, this.subPaths = [], this.currentPath = null
            }

            function Dr(e) {
                this.type = "Font", this.data = e
            }

            function zr(e, t, n) {
                for (var i = Array.from ? Array.from(e) : String(e).split(""), r = t / n.resolution, a = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r, o = [], s = 0, l = 0, c = 0; c < i.length; c++) {
                    var u = i[c];
                    if ("\n" === u) s = 0, l -= a;
                    else {
                        var h = Br(u, r, s, l, n);
                        s += h.offsetX, o.push(h.path)
                    }
                }
                return o
            }

            function Br(e, t, n, i, r) {
                var a = r.glyphs[e] || r.glyphs["?"];
                if (a) {
                    var o, s, l, c, u, h, d, p, f = new kr;
                    if (a.o)
                        for (var m = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), v = 0, g = m.length; v < g;) {
                            var y = m[v++];
                            switch (y) {
                                case "m":
                                    o = m[v++] * t + n, s = m[v++] * t + i, f.moveTo(o, s);
                                    break;
                                case "l":
                                    o = m[v++] * t + n, s = m[v++] * t + i, f.lineTo(o, s);
                                    break;
                                case "q":
                                    l = m[v++] * t + n, c = m[v++] * t + i, u = m[v++] * t + n, h = m[v++] * t + i, f.quadraticCurveTo(u, h, l, c);
                                    break;
                                case "b":
                                    l = m[v++] * t + n, c = m[v++] * t + i, u = m[v++] * t + n, h = m[v++] * t + i, d = m[v++] * t + n, p = m[v++] * t + i, f.bezierCurveTo(u, h, d, p, l, c)
                            }
                        }
                    return {
                        offsetX: a.ha * t,
                        path: f
                    }
                }
            }

            function Nr(e) {
                this.manager = void 0 !== e ? e : Nh
            }

            function Ur() {}

            function jr(e) {
                this.manager = void 0 !== e ? e : Nh
            }

            function Fr() {
                this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Et, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Et, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
            }

            function Gr(e, t, n, i) {
                E.call(this), this.type = "CubeCamera";
                var r = 90,
                    o = 1,
                    s = new Et(r, o, e, t);
                s.up.set(0, -1, 0), s.lookAt(new a(1, 0, 0)), this.add(s);
                var l = new Et(r, o, e, t);
                l.up.set(0, -1, 0), l.lookAt(new a((-1), 0, 0)), this.add(l);
                var c = new Et(r, o, e, t);
                c.up.set(0, 0, 1), c.lookAt(new a(0, 1, 0)), this.add(c);
                var u = new Et(r, o, e, t);
                u.up.set(0, 0, -1), u.lookAt(new a(0, (-1), 0)), this.add(u);
                var d = new Et(r, o, e, t);
                d.up.set(0, -1, 0), d.lookAt(new a(0, 0, 1)), this.add(d);
                var p = new Et(r, o, e, t);
                p.up.set(0, -1, 0), p.lookAt(new a(0, 0, (-1))), this.add(p), i = i || {
                    format: Vs,
                    magFilter: Cs,
                    minFilter: Cs
                }, this.renderTarget = new h(n, n, i), this.renderTarget.texture.name = "CubeCamera", this.update = function (e, t) {
                    null === this.parent && this.updateMatrixWorld();
                    var n = e.getRenderTarget(),
                        i = this.renderTarget,
                        r = i.texture.generateMipmaps;
                    i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0), e.render(t, s), e.setRenderTarget(i, 1), e.render(t, l), e.setRenderTarget(i, 2), e.render(t, c), e.setRenderTarget(i, 3), e.render(t, u), e.setRenderTarget(i, 4), e.render(t, d), i.texture.generateMipmaps = r, e.setRenderTarget(i, 5), e.render(t, p), e.setRenderTarget(n)
                }, this.clear = function (e, t, n, i) {
                    for (var r = e.getRenderTarget(), a = this.renderTarget, o = 0; o < 6; o++) e.setRenderTarget(a, o), e.clear(t, n, i);
                    e.setRenderTarget(r)
                }
            }

            function Hr(e) {
                this.autoStart = void 0 === e || e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }

            function Vr() {
                E.call(this), this.type = "AudioListener", this.context = $h.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0
            }

            function Wr(e) {
                E.call(this), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
            }

            function qr(e) {
                Wr.call(this, e), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
            }

            function Xr(e, t) {
                this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
            }

            function Yr(e, t, n) {
                this.binding = e, this.valueSize = n;
                var i, r = Float64Array;
                switch (t) {
                    case "quaternion":
                        i = this._slerp;
                        break;
                    case "string":
                    case "bool":
                        r = Array, i = this._select;
                        break;
                    default:
                        i = this._lerp
                }
                this.buffer = new r(4 * n), this._mixBufferRegion = i, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
            }

            function Zr(e, t, n) {
                var i = n || Jr.parseTrackName(t);
                this._targetGroup = e, this._bindings = e.subscribe_(t, i)
            }

            function Jr(e, t, n) {
                this.path = t, this.parsedPath = n || Jr.parseTrackName(t), this.node = Jr.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e
            }

            function $r() {
                this.uuid = Wl.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                var e = {};
                this._indicesByUUID = e;
                for (var t = 0, n = arguments.length; t !== n; ++t) e[arguments[t].uuid] = t;
                this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                var i = this;
                this.stats = {
                    objects: {
                        get total() {
                            return i._objects.length
                        },
                        get inUse() {
                            return this.total - i.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return i._bindings.length
                    }
                }
            }

            function Qr(e, t, n) {
                this._mixer = e, this._clip = t, this._localRoot = n || null;
                for (var i = t.tracks, r = i.length, a = new Array(r), o = {
                        endingStart: Pl,
                        endingEnd: Pl
                    }, s = 0; s !== r; ++s) {
                    var l = i[s].createInterpolant(null);
                    a[s] = l, l.settings = o
                }
                this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = wl, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }

            function Kr(e) {
                this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }

            function ea(e) {
                "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e
            }

            function ta() {
                U.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
            }

            function na(e, t, n) {
                kt.call(this, e, t), this.meshPerAttribute = n || 1
            }

            function ia(e, t, n, i) {
                "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), P.call(this, e, t, n), this.meshPerAttribute = i || 1
            }

            function ra(e, t, n, i) {
                this.ray = new q(e, t), this.near = n || 0, this.far = i || 1 / 0, this.params = {
                    Mesh: {},
                    Line: {},
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }, Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function () {
                            return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                        }
                    }
                })
            }

            function aa(e, t) {
                return e.distance - t.distance
            }

            function oa(e, t, n, i) {
                if (e.visible !== !1 && (e.raycast(t, n), i === !0))
                    for (var r = e.children, a = 0, o = r.length; a < o; a++) oa(r[a], t, n, !0)
            }

            function sa(e, t, n) {
                return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== n ? n : 0, this
            }

            function la(e, t, n) {
                return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== n ? n : 0, this
            }

            function ca(e, t) {
                this.min = void 0 !== e ? e : new n((+(1 / 0)), (+(1 / 0))), this.max = void 0 !== t ? t : new n((-(1 / 0)), (-(1 / 0)))
            }

            function ua(e, t) {
                this.start = void 0 !== e ? e : new a, this.end = void 0 !== t ? t : new a
            }

            function ha(e) {
                E.call(this), this.material = e, this.render = function () {}
            }

            function da(e, t, n, i) {
                this.object = e, this.size = void 0 !== t ? t : 1;
                var r = void 0 !== n ? n : 16711680,
                    a = void 0 !== i ? i : 1,
                    o = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? o = 3 * s.faces.length : s && s.isBufferGeometry && (o = s.attributes.normal.count);
                var l = new U,
                    c = new D(2 * o * 3, 3);
                l.addAttribute("position", c), Vt.call(this, l, new Gt({
                    color: r,
                    linewidth: a
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function pa(e, t) {
                E.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t;
                for (var n = new U, i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, a = 1, o = 32; r < o; r++, a++) {
                    var s = r / o * Math.PI * 2,
                        l = a / o * Math.PI * 2;
                    i.push(Math.cos(s), Math.sin(s), 1, Math.cos(l), Math.sin(l), 1)
                }
                n.addAttribute("position", new D(i, 3));
                var c = new Gt({
                    fog: !1
                });
                this.cone = new Vt(n, c), this.add(this.cone), this.update()
            }

            function fa(e) {
                var t = [];
                e && e.isBone && t.push(e);
                for (var n = 0; n < e.children.length; n++) t.push.apply(t, fa(e.children[n]));
                return t
            }

            function ma(e) {
                for (var t = fa(e), n = new U, i = [], r = [], a = new x(0, 0, 1), o = new x(0, 1, 0), s = 0; s < t.length; s++) {
                    var l = t[s];
                    l.parent && l.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(o.r, o.g, o.b))
                }
                n.addAttribute("position", new D(i, 3)), n.addAttribute("color", new D(r, 3));
                var c = new Gt({
                    vertexColors: Co,
                    depthTest: !1,
                    depthWrite: !1,
                    transparent: !0
                });
                Vt.call(this, n, c), this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
            }

            function va(e, t, n) {
                this.light = e, this.light.updateMatrixWorld(), this.color = n;
                var i = new ei(t, 4, 2),
                    r = new Y({
                        wireframe: !0,
                        fog: !1
                    });
                Z.call(this, i, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
            }

            function ga(e, t) {
                this.type = "RectAreaLightHelper", this.light = e, this.color = t;
                var n = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],
                    i = new U;
                i.addAttribute("position", new D(n, 3)), i.computeBoundingSphere();
                var r = new Gt({
                    fog: !1
                });
                Ht.call(this, i, r);
                var a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
                    o = new U;
                o.addAttribute("position", new D(a, 3)), o.computeBoundingSphere(), this.add(new Z(o, new Y({
                    side: wo,
                    fog: !1
                }))), this.update()
            }

            function ya(e, t, n) {
                E.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
                var i = new sn(t);
                i.rotateY(.5 * Math.PI), this.material = new Y({
                    wireframe: !0,
                    fog: !1
                }), void 0 === this.color && (this.material.vertexColors = Co);
                var r = i.getAttribute("position"),
                    a = new Float32Array(3 * r.count);
                i.addAttribute("color", new P(a, 3)), this.add(new Z(i, this.material)), this.update()
            }

            function xa(e, t, n, i) {
                e = e || 10, t = t || 10, n = new x(void 0 !== n ? n : 4473924), i = new x(void 0 !== i ? i : 8947848);
                for (var r = t / 2, a = e / t, o = e / 2, s = [], l = [], c = 0, u = 0, h = -o; c <= t; c++, h += a) {
                    s.push(-o, 0, h, o, 0, h), s.push(h, 0, -o, h, 0, o);
                    var d = c === r ? n : i;
                    d.toArray(l, u), u += 3, d.toArray(l, u), u += 3, d.toArray(l, u), u += 3, d.toArray(l, u), u += 3
                }
                var p = new U;
                p.addAttribute("position", new D(s, 3)), p.addAttribute("color", new D(l, 3));
                var f = new Gt({
                    vertexColors: Co
                });
                Vt.call(this, p, f)
            }

            function ba(e, t, n, i, r, a) {
                e = e || 10, t = t || 16, n = n || 8, i = i || 64, r = new x(void 0 !== r ? r : 4473924), a = new x(void 0 !== a ? a : 8947848);
                var o, s, l, c, u, h, d, p = [],
                    f = [];
                for (c = 0; c <= t; c++) l = c / t * (2 * Math.PI), o = Math.sin(l) * e, s = Math.cos(l) * e, p.push(0, 0, 0), p.push(o, 0, s), d = 1 & c ? r : a, f.push(d.r, d.g, d.b), f.push(d.r, d.g, d.b);
                for (c = 0; c <= n; c++)
                    for (d = 1 & c ? r : a, h = e - e / n * c, u = 0; u < i; u++) l = u / i * (2 * Math.PI), o = Math.sin(l) * h, s = Math.cos(l) * h, p.push(o, 0, s), f.push(d.r, d.g, d.b), l = (u + 1) / i * (2 * Math.PI), o = Math.sin(l) * h, s = Math.cos(l) * h, p.push(o, 0, s), f.push(d.r, d.g, d.b);
                var m = new U;
                m.addAttribute("position", new D(p, 3)), m.addAttribute("color", new D(f, 3));
                var v = new Gt({
                    vertexColors: Co
                });
                Vt.call(this, m, v)
            }

            function _a(e, t, n, i) {
                this.audio = e, this.range = t || 1, this.divisionsInnerAngle = n || 16, this.divisionsOuterAngle = i || 2;
                var r = new U,
                    a = this.divisionsInnerAngle + 2 * this.divisionsOuterAngle,
                    o = new Float32Array(3 * (3 * a + 3));
                r.addAttribute("position", new P(o, 3));
                var s = new Gt({
                        color: 65280
                    }),
                    l = new Gt({
                        color: 16776960
                    });
                Ht.call(this, r, [l, s]), this.update()
            }

            function wa(e, t, n, i) {
                this.object = e, this.size = void 0 !== t ? t : 1;
                var r = void 0 !== n ? n : 16776960,
                    a = void 0 !== i ? i : 1,
                    o = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? o = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
                var l = new U,
                    c = new D(2 * o * 3, 3);
                l.addAttribute("position", c), Vt.call(this, l, new Gt({
                    color: r,
                    linewidth: a
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function Ma(e, t, n) {
                E.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === t && (t = 1);
                var i = new U;
                i.addAttribute("position", new D([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
                var r = new Gt({
                    fog: !1
                });
                this.lightPlane = new Ht(i, r), this.add(this.lightPlane), i = new U, i.addAttribute("position", new D([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Ht(i, r), this.add(this.targetLine), this.update()
            }

            function Ta(e) {
                function t(e, t, i) {
                    n(e, i), n(t, i)
                }

                function n(e, t) {
                    a.push(0, 0, 0), o.push(t.r, t.g, t.b), void 0 === s[e] && (s[e] = []), s[e].push(a.length / 3 - 1)
                }
                var i = new U,
                    r = new Gt({
                        color: 16777215,
                        vertexColors: Po
                    }),
                    a = [],
                    o = [],
                    s = {},
                    l = new x(16755200),
                    c = new x(16711680),
                    u = new x(43775),
                    h = new x(16777215),
                    d = new x(3355443);
                t("n1", "n2", l), t("n2", "n4", l), t("n4", "n3", l), t("n3", "n1", l), t("f1", "f2", l), t("f2", "f4", l), t("f4", "f3", l), t("f3", "f1", l), t("n1", "f1", l), t("n2", "f2", l), t("n3", "f3", l), t("n4", "f4", l), t("p", "n1", c), t("p", "n2", c), t("p", "n3", c), t("p", "n4", c), t("u1", "u2", u), t("u2", "u3", u), t("u3", "u1", u), t("c", "t", h), t("p", "c", d), t("cn1", "cn2", d), t("cn3", "cn4", d), t("cf1", "cf2", d), t("cf3", "cf4", d), i.addAttribute("position", new D(a, 3)), i.addAttribute("color", new D(o, 3)), Vt.call(this, i, r), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
            }

            function Ea(e, t) {
                this.object = e, void 0 === t && (t = 16776960);
                var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    i = new Float32Array(24),
                    r = new U;
                r.setIndex(new P(n, 1)), r.addAttribute("position", new P(i, 3)), Vt.call(this, r, new Gt({
                    color: t
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function Sa(e, t) {
                this.type = "Box3Helper", this.box = e;
                var n = void 0 !== t ? t : 16776960,
                    i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],
                    a = new U;
                a.setIndex(new P(i, 1)), a.addAttribute("position", new D(r, 3)), Vt.call(this, a, new Gt({
                    color: n
                })), this.geometry.computeBoundingSphere()
            }

            function Pa(e, t, n) {
                this.type = "PlaneHelper", this.plane = e, this.size = void 0 === t ? 1 : t;
                var i = void 0 !== n ? n : 16776960,
                    r = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0],
                    a = new U;
                a.addAttribute("position", new D(r, 3)), a.computeBoundingSphere(), Ht.call(this, a, new Gt({
                    color: i
                }));
                var o = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
                    s = new U;
                s.addAttribute("position", new D(o, 3)), s.computeBoundingSphere(), this.add(new Z(s, new Y({
                    color: i,
                    opacity: .2,
                    transparent: !0,
                    depthWrite: !1
                })))
            }

            function Ca(e, t, n, i, r, o) {
                E.call(this), void 0 === e && (e = new a(0, 0, 1)), void 0 === t && (t = new a(0, 0, 0)), void 0 === n && (n = 1), void 0 === i && (i = 16776960), void 0 === r && (r = .2 * n), void 0 === o && (o = .2 * r), void 0 === Kh && (Kh = new U, Kh.addAttribute("position", new D([0, 0, 0, 0, 1, 0], 3)), ed = new ui(0, .5, 1, 5, 1), ed.translate(0, -.5, 0)), this.position.copy(t), this.line = new Ht(Kh, new Gt({
                    color: i
                })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Z(ed, new Y({
                    color: i
                })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, r, o)
            }

            function Aa(e) {
                e = e || 1;
                var t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
                    n = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],
                    i = new U;
                i.addAttribute("position", new D(t, 3)), i.addAttribute("color", new D(n, 3));
                var r = new Gt({
                    vertexColors: Co
                });
                Vt.call(this, i, r)
            }

            function La(e, t, n, i, r, a, o) {
                return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new w(e, t, n, r, a, o)
            }

            function Ra(e) {
                return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e
            }

            function Ia(e) {
                return void 0 === e && (e = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, e.materials = e, e.clone = function () {
                    return e.slice()
                }, e
            }

            function Oa(e, t) {
                return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Xt(e, t)
            }

            function ka(e) {
                return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Bt(e)
            }

            function Da(e, t) {
                return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Xt(e, t)
            }

            function za(e) {
                return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new qt(e)
            }

            function Ba(e) {
                return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new qt(e)
            }

            function Na(e) {
                return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new qt(e)
            }

            function Ua(e, t, n) {
                return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new a(e, t, n)
            }

            function ja(e, t) {
                return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new P(e, t).setDynamic(!0)
            }

            function Fa(e, t) {
                return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new C(e, t)
            }

            function Ga(e, t) {
                return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new A(e, t)
            }

            function Ha(e, t) {
                return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new L(e, t)
            }

            function Va(e, t) {
                return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new R(e, t)
            }

            function Wa(e, t) {
                return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new I(e, t)
            }

            function qa(e, t) {
                return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new O(e, t)
            }

            function Xa(e, t) {
                return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new k(e, t)
            }

            function Ya(e, t) {
                return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new D(e, t)
            }

            function Za(e, t) {
                return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new z(e, t)
            }

            function Ja(e) {
                console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Qi.call(this, e), this.type = "catmullrom", this.closed = !0
            }

            function $a(e) {
                console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Qi.call(this, e), this.type = "catmullrom"
            }

            function Qa(e) {
                console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Qi.call(this, e), this.type = "catmullrom"
            }

            function Ka(e) {
                return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Aa(e)
            }

            function eo(e, t) {
                return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Ea(e, t)
            }

            function to(e, t) {
                return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Vt(new li(e.geometry), new Gt({
                    color: void 0 !== t ? t : 16777215
                }))
            }

            function no(e, t) {
                return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Vt(new Qt(e.geometry), new Gt({
                    color: void 0 !== t ? t : 16777215
                }))
            }

            function io(e) {
                return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Fi(e)
            }

            function ro(e) {
                return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Vi(e)
            }

            function ao() {
                console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function (e, t) {
                    console.warn("THREE.Projector: .projectVector() is now vector.project()."), e.project(t)
                }, this.unprojectVector = function (e, t) {
                    console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), e.unproject(t)
                }, this.pickingRay = function () {
                    console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
                }
            }

            function oo() {
                console.error("THREE.CanvasRenderer has been removed")
            }

            function so() {
                console.error("THREE.JSONLoader has been removed.")
            }

            function lo() {
                console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
            }
            void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (e) {
                return "number" == typeof e && isFinite(e) && Math.floor(e) === e
            }), void 0 === Math.sign && (Math.sign = function (e) {
                return e < 0 ? -1 : e > 0 ? 1 : +e
            }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
                get: function () {
                    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
                }
            }), void 0 === Object.assign && ! function () {
                Object.assign = function (e) {
                    if (void 0 === e || null === e) throw new TypeError("Cannot convert undefined or null to object");
                    for (var t = Object(e), n = 1; n < arguments.length; n++) {
                        var i = arguments[n];
                        if (void 0 !== i && null !== i)
                            for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (t[r] = i[r])
                    }
                    return t
                }
            }(), Object.assign(t.prototype, {
                addEventListener: function (e, t) {
                    void 0 === this._listeners && (this._listeners = {});
                    var n = this._listeners;
                    void 0 === n[e] && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t)
                },
                hasEventListener: function (e, t) {
                    if (void 0 === this._listeners) return !1;
                    var n = this._listeners;
                    return void 0 !== n[e] && n[e].indexOf(t) !== -1
                },
                removeEventListener: function (e, t) {
                    if (void 0 !== this._listeners) {
                        var n = this._listeners,
                            i = n[e];
                        if (void 0 !== i) {
                            var r = i.indexOf(t);
                            r !== -1 && i.splice(r, 1)
                        }
                    }
                },
                dispatchEvent: function (e) {
                    if (void 0 !== this._listeners) {
                        var t = this._listeners,
                            n = t[e.type];
                        if (void 0 !== n) {
                            e.target = this;
                            for (var i = n.slice(0), r = 0, a = i.length; r < a; r++) i[r].call(this, e)
                        }
                    }
                }
            });
            var co = "102",
                uo = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2
                },
                ho = 0,
                po = 1,
                fo = 2,
                mo = 3,
                vo = 0,
                go = 1,
                yo = 0,
                xo = 1,
                bo = 2,
                _o = 0,
                wo = 1,
                Mo = 2,
                To = 1,
                Eo = 2,
                So = 0,
                Po = 1,
                Co = 2,
                Ao = 0,
                Lo = 1,
                Ro = 2,
                Io = 3,
                Oo = 4,
                ko = 5,
                Do = 100,
                zo = 101,
                Bo = 102,
                No = 103,
                Uo = 104,
                jo = 200,
                Fo = 201,
                Go = 202,
                Ho = 203,
                Vo = 204,
                Wo = 205,
                qo = 206,
                Xo = 207,
                Yo = 208,
                Zo = 209,
                Jo = 210,
                $o = 0,
                Qo = 1,
                Ko = 2,
                es = 3,
                ts = 4,
                ns = 5,
                is = 6,
                rs = 7,
                as = 0,
                os = 1,
                ss = 2,
                ls = 0,
                cs = 1,
                us = 2,
                hs = 3,
                ds = 4,
                ps = 5,
                fs = 300,
                ms = 301,
                vs = 302,
                gs = 303,
                ys = 304,
                xs = 305,
                bs = 306,
                _s = 307,
                ws = 1e3,
                Ms = 1001,
                Ts = 1002,
                Es = 1003,
                Ss = 1004,
                Ps = 1005,
                Cs = 1006,
                As = 1007,
                Ls = 1008,
                Rs = 1009,
                Is = 1010,
                Os = 1011,
                ks = 1012,
                Ds = 1013,
                zs = 1014,
                Bs = 1015,
                Ns = 1016,
                Us = 1017,
                js = 1018,
                Fs = 1019,
                Gs = 1020,
                Hs = 1021,
                Vs = 1022,
                Ws = 1023,
                qs = 1024,
                Xs = 1025,
                Ys = Ws,
                Zs = 1026,
                Js = 1027,
                $s = 1028,
                Qs = 33776,
                Ks = 33777,
                el = 33778,
                tl = 33779,
                nl = 35840,
                il = 35841,
                rl = 35842,
                al = 35843,
                ol = 36196,
                sl = 37808,
                ll = 37809,
                cl = 37810,
                ul = 37811,
                hl = 37812,
                dl = 37813,
                pl = 37814,
                fl = 37815,
                ml = 37816,
                vl = 37817,
                gl = 37818,
                yl = 37819,
                xl = 37820,
                bl = 37821,
                _l = 2200,
                wl = 2201,
                Ml = 2202,
                Tl = 2300,
                El = 2301,
                Sl = 2302,
                Pl = 2400,
                Cl = 2401,
                Al = 2402,
                Ll = 0,
                Rl = 1,
                Il = 2,
                Ol = 3e3,
                kl = 3001,
                Dl = 3007,
                zl = 3002,
                Bl = 3003,
                Nl = 3004,
                Ul = 3005,
                jl = 3006,
                Fl = 3200,
                Gl = 3201,
                Hl = 0,
                Vl = 1,
                Wl = {
                    DEG2RAD: Math.PI / 180,
                    RAD2DEG: 180 / Math.PI,
                    generateUUID: function () {
                        for (var e = [], t = 0; t < 256; t++) e[t] = (t < 16 ? "0" : "") + t.toString(16);
                        return function () {
                            var t = 4294967295 * Math.random() | 0,
                                n = 4294967295 * Math.random() | 0,
                                i = 4294967295 * Math.random() | 0,
                                r = 4294967295 * Math.random() | 0,
                                a = e[255 & t] + e[t >> 8 & 255] + e[t >> 16 & 255] + e[t >> 24 & 255] + "-" + e[255 & n] + e[n >> 8 & 255] + "-" + e[n >> 16 & 15 | 64] + e[n >> 24 & 255] + "-" + e[63 & i | 128] + e[i >> 8 & 255] + "-" + e[i >> 16 & 255] + e[i >> 24 & 255] + e[255 & r] + e[r >> 8 & 255] + e[r >> 16 & 255] + e[r >> 24 & 255];
                            return a.toUpperCase()
                        }
                    }(),
                    clamp: function (e, t, n) {
                        return Math.max(t, Math.min(n, e))
                    },
                    euclideanModulo: function (e, t) {
                        return (e % t + t) % t
                    },
                    mapLinear: function (e, t, n, i, r) {
                        return i + (e - t) * (r - i) / (n - t)
                    },
                    lerp: function (e, t, n) {
                        return (1 - n) * e + n * t
                    },
                    smoothstep: function (e, t, n) {
                        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t), e * e * (3 - 2 * e))
                    },
                    smootherstep: function (e, t, n) {
                        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t), e * e * e * (e * (6 * e - 15) + 10))
                    },
                    randInt: function (e, t) {
                        return e + Math.floor(Math.random() * (t - e + 1))
                    },
                    randFloat: function (e, t) {
                        return e + Math.random() * (t - e)
                    },
                    randFloatSpread: function (e) {
                        return e * (.5 - Math.random())
                    },
                    degToRad: function (e) {
                        return e * Wl.DEG2RAD
                    },
                    radToDeg: function (e) {
                        return e * Wl.RAD2DEG
                    },
                    isPowerOfTwo: function (e) {
                        return 0 === (e & e - 1) && 0 !== e
                    },
                    ceilPowerOfTwo: function (e) {
                        return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
                    },
                    floorPowerOfTwo: function (e) {
                        return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
                    }
                };
            Object.defineProperties(n.prototype, {
                width: {
                    get: function () {
                        return this.x
                    },
                    set: function (e) {
                        this.x = e
                    }
                },
                height: {
                    get: function () {
                        return this.y
                    },
                    set: function (e) {
                        this.y = e
                    }
                }
            }), Object.assign(n.prototype, {
                isVector2: !0,
                set: function (e, t) {
                    return this.x = e, this.y = t, this
                },
                setScalar: function (e) {
                    return this.x = e, this.y = e, this
                },
                setX: function (e) {
                    return this.x = e, this
                },
                setY: function (e) {
                    return this.y = e, this
                },
                setComponent: function (e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                },
                getComponent: function (e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                clone: function () {
                    return new this.constructor(this.x, this.y)
                },
                copy: function (e) {
                    return this.x = e.x, this.y = e.y, this
                },
                add: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
                },
                addScalar: function (e) {
                    return this.x += e, this.y += e, this
                },
                addVectors: function (e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this
                },
                addScaledVector: function (e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this
                },
                sub: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
                },
                subScalar: function (e) {
                    return this.x -= e, this.y -= e, this
                },
                subVectors: function (e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this
                },
                multiply: function (e) {
                    return this.x *= e.x, this.y *= e.y, this
                },
                multiplyScalar: function (e) {
                    return this.x *= e, this.y *= e, this
                },
                divide: function (e) {
                    return this.x /= e.x, this.y /= e.y, this
                },
                divideScalar: function (e) {
                    return this.multiplyScalar(1 / e)
                },
                applyMatrix3: function (e) {
                    var t = this.x,
                        n = this.y,
                        i = e.elements;
                    return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this
                },
                min: function (e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
                },
                max: function (e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
                },
                clamp: function (e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
                },
                clampScalar: function () {
                    var e = new n,
                        t = new n;
                    return function (n, i) {
                        return e.set(n, n), t.set(i, i), this.clamp(e, t)
                    }
                }(),
                clampLength: function (e, t) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                },
                floor: function () {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                },
                ceil: function () {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                },
                round: function () {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                },
                roundToZero: function () {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                },
                negate: function () {
                    return this.x = -this.x, this.y = -this.y, this
                },
                dot: function (e) {
                    return this.x * e.x + this.y * e.y
                },
                cross: function (e) {
                    return this.x * e.y - this.y * e.x
                },
                lengthSq: function () {
                    return this.x * this.x + this.y * this.y
                },
                length: function () {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                manhattanLength: function () {
                    return Math.abs(this.x) + Math.abs(this.y)
                },
                normalize: function () {
                    return this.divideScalar(this.length() || 1)
                },
                angle: function () {
                    var e = Math.atan2(this.y, this.x);
                    return e < 0 && (e += 2 * Math.PI), e
                },
                distanceTo: function (e) {
                    return Math.sqrt(this.distanceToSquared(e))
                },
                distanceToSquared: function (e) {
                    var t = this.x - e.x,
                        n = this.y - e.y;
                    return t * t + n * n
                },
                manhattanDistanceTo: function (e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                },
                setLength: function (e) {
                    return this.normalize().multiplyScalar(e)
                },
                lerp: function (e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
                },
                lerpVectors: function (e, t, n) {
                    return this.subVectors(t, e).multiplyScalar(n).add(e)
                },
                equals: function (e) {
                    return e.x === this.x && e.y === this.y
                },
                fromArray: function (e, t) {
                    return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e
                },
                fromBufferAttribute: function (e, t, n) {
                    return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this
                },
                rotateAround: function (e, t) {
                    var n = Math.cos(t),
                        i = Math.sin(t),
                        r = this.x - e.x,
                        a = this.y - e.y;
                    return this.x = r * n - a * i + e.x, this.y = r * i + a * n + e.y, this
                }
            }), Object.assign(i.prototype, {
                isMatrix4: !0,
                set: function (e, t, n, i, r, a, o, s, l, c, u, h, d, p, f, m) {
                    var v = this.elements;
                    return v[0] = e, v[4] = t, v[8] = n, v[12] = i, v[1] = r, v[5] = a, v[9] = o, v[13] = s, v[2] = l, v[6] = c, v[10] = u, v[14] = h, v[3] = d, v[7] = p, v[11] = f, v[15] = m, this
                },
                identity: function () {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                clone: function () {
                    return (new i).fromArray(this.elements)
                },
                copy: function (e) {
                    var t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
                },
                copyPosition: function (e) {
                    var t = this.elements,
                        n = e.elements;
                    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
                },
                extractBasis: function (e, t, n) {
                    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                },
                makeBasis: function (e, t, n) {
                    return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
                },
                extractRotation: function () {
                    var e = new a;
                    return function (t) {
                        var n = this.elements,
                            i = t.elements,
                            r = 1 / e.setFromMatrixColumn(t, 0).length(),
                            a = 1 / e.setFromMatrixColumn(t, 1).length(),
                            o = 1 / e.setFromMatrixColumn(t, 2).length();
                        return n[0] = i[0] * r, n[1] = i[1] * r, n[2] = i[2] * r, n[3] = 0, n[4] = i[4] * a, n[5] = i[5] * a, n[6] = i[6] * a, n[7] = 0, n[8] = i[8] * o, n[9] = i[9] * o, n[10] = i[10] * o, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this
                    }
                }(),
                makeRotationFromEuler: function (e) {
                    e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var t = this.elements,
                        n = e.x,
                        i = e.y,
                        r = e.z,
                        a = Math.cos(n),
                        o = Math.sin(n),
                        s = Math.cos(i),
                        l = Math.sin(i),
                        c = Math.cos(r),
                        u = Math.sin(r);
                    if ("XYZ" === e.order) {
                        var h = a * c,
                            d = a * u,
                            p = o * c,
                            f = o * u;
                        t[0] = s * c, t[4] = -s * u, t[8] = l, t[1] = d + p * l, t[5] = h - f * l, t[9] = -o * s, t[2] = f - h * l, t[6] = p + d * l, t[10] = a * s
                    } else if ("YXZ" === e.order) {
                        var m = s * c,
                            v = s * u,
                            g = l * c,
                            y = l * u;
                        t[0] = m + y * o, t[4] = g * o - v, t[8] = a * l, t[1] = a * u, t[5] = a * c, t[9] = -o, t[2] = v * o - g, t[6] = y + m * o, t[10] = a * s
                    } else if ("ZXY" === e.order) {
                        var m = s * c,
                            v = s * u,
                            g = l * c,
                            y = l * u;
                        t[0] = m - y * o, t[4] = -a * u, t[8] = g + v * o, t[1] = v + g * o, t[5] = a * c, t[9] = y - m * o, t[2] = -a * l, t[6] = o, t[10] = a * s
                    } else if ("ZYX" === e.order) {
                        var h = a * c,
                            d = a * u,
                            p = o * c,
                            f = o * u;
                        t[0] = s * c, t[4] = p * l - d, t[8] = h * l + f, t[1] = s * u, t[5] = f * l + h, t[9] = d * l - p, t[2] = -l, t[6] = o * s, t[10] = a * s
                    } else if ("YZX" === e.order) {
                        var x = a * s,
                            b = a * l,
                            _ = o * s,
                            w = o * l;
                        t[0] = s * c, t[4] = w - x * u, t[8] = _ * u + b, t[1] = u, t[5] = a * c, t[9] = -o * c, t[2] = -l * c, t[6] = b * u + _, t[10] = x - w * u
                    } else if ("XZY" === e.order) {
                        var x = a * s,
                            b = a * l,
                            _ = o * s,
                            w = o * l;
                        t[0] = s * c, t[4] = -u, t[8] = l * c, t[1] = x * u + w, t[5] = a * c, t[9] = b * u - _, t[2] = _ * u - b, t[6] = o * c, t[10] = w * u + x
                    }
                    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                },
                makeRotationFromQuaternion: function () {
                    var e = new a(0, 0, 0),
                        t = new a(1, 1, 1);
                    return function (n) {
                        return this.compose(e, n, t)
                    }
                }(),
                lookAt: function () {
                    var e = new a,
                        t = new a,
                        n = new a;
                    return function (i, r, a) {
                        var o = this.elements;
                        return n.subVectors(i, r), 0 === n.lengthSq() && (n.z = 1), n.normalize(), e.crossVectors(a, n), 0 === e.lengthSq() && (1 === Math.abs(a.z) ? n.x += 1e-4 : n.z += 1e-4, n.normalize(), e.crossVectors(a, n)), e.normalize(), t.crossVectors(n, e), o[0] = e.x, o[4] = t.x, o[8] = n.x, o[1] = e.y, o[5] = t.y, o[9] = n.y, o[2] = e.z, o[6] = t.z, o[10] = n.z, this
                    }
                }(),
                multiply: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
                },
                premultiply: function (e) {
                    return this.multiplyMatrices(e, this)
                },
                multiplyMatrices: function (e, t) {
                    var n = e.elements,
                        i = t.elements,
                        r = this.elements,
                        a = n[0],
                        o = n[4],
                        s = n[8],
                        l = n[12],
                        c = n[1],
                        u = n[5],
                        h = n[9],
                        d = n[13],
                        p = n[2],
                        f = n[6],
                        m = n[10],
                        v = n[14],
                        g = n[3],
                        y = n[7],
                        x = n[11],
                        b = n[15],
                        _ = i[0],
                        w = i[4],
                        M = i[8],
                        T = i[12],
                        E = i[1],
                        S = i[5],
                        P = i[9],
                        C = i[13],
                        A = i[2],
                        L = i[6],
                        R = i[10],
                        I = i[14],
                        O = i[3],
                        k = i[7],
                        D = i[11],
                        z = i[15];
                    return r[0] = a * _ + o * E + s * A + l * O, r[4] = a * w + o * S + s * L + l * k, r[8] = a * M + o * P + s * R + l * D, r[12] = a * T + o * C + s * I + l * z, r[1] = c * _ + u * E + h * A + d * O, r[5] = c * w + u * S + h * L + d * k, r[9] = c * M + u * P + h * R + d * D, r[13] = c * T + u * C + h * I + d * z, r[2] = p * _ + f * E + m * A + v * O, r[6] = p * w + f * S + m * L + v * k, r[10] = p * M + f * P + m * R + v * D, r[14] = p * T + f * C + m * I + v * z, r[3] = g * _ + y * E + x * A + b * O, r[7] = g * w + y * S + x * L + b * k, r[11] = g * M + y * P + x * R + b * D, r[15] = g * T + y * C + x * I + b * z, this
                },
                multiplyScalar: function (e) {
                    var t = this.elements;
                    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
                },
                applyToBufferAttribute: function () {
                    var e = new a;
                    return function (t) {
                        for (var n = 0, i = t.count; n < i; n++) e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.applyMatrix4(this), t.setXYZ(n, e.x, e.y, e.z);
                        return t
                    }
                }(),
                determinant: function () {
                    var e = this.elements,
                        t = e[0],
                        n = e[4],
                        i = e[8],
                        r = e[12],
                        a = e[1],
                        o = e[5],
                        s = e[9],
                        l = e[13],
                        c = e[2],
                        u = e[6],
                        h = e[10],
                        d = e[14],
                        p = e[3],
                        f = e[7],
                        m = e[11],
                        v = e[15];
                    return p * (+r * s * u - i * l * u - r * o * h + n * l * h + i * o * d - n * s * d) + f * (+t * s * d - t * l * h + r * a * h - i * a * d + i * l * c - r * s * c) + m * (+t * l * u - t * o * d - r * a * u + n * a * d + r * o * c - n * l * c) + v * (-i * o * c - t * s * u + t * o * h + i * a * u - n * a * h + n * s * c)
                },
                transpose: function () {
                    var e, t = this.elements;
                    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                },
                setPosition: function (e) {
                    var t = this.elements;
                    return t[12] = e.x, t[13] = e.y, t[14] = e.z, this
                },
                getInverse: function (e, t) {
                    var n = this.elements,
                        i = e.elements,
                        r = i[0],
                        a = i[1],
                        o = i[2],
                        s = i[3],
                        l = i[4],
                        c = i[5],
                        u = i[6],
                        h = i[7],
                        d = i[8],
                        p = i[9],
                        f = i[10],
                        m = i[11],
                        v = i[12],
                        g = i[13],
                        y = i[14],
                        x = i[15],
                        b = p * y * h - g * f * h + g * u * m - c * y * m - p * u * x + c * f * x,
                        _ = v * f * h - d * y * h - v * u * m + l * y * m + d * u * x - l * f * x,
                        w = d * g * h - v * p * h + v * c * m - l * g * m - d * c * x + l * p * x,
                        M = v * p * u - d * g * u - v * c * f + l * g * f + d * c * y - l * p * y,
                        T = r * b + a * _ + o * w + s * M;
                    if (0 === T) {
                        var E = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                        if (t === !0) throw new Error(E);
                        return console.warn(E), this.identity()
                    }
                    var S = 1 / T;
                    return n[0] = b * S, n[1] = (g * f * s - p * y * s - g * o * m + a * y * m + p * o * x - a * f * x) * S, n[2] = (c * y * s - g * u * s + g * o * h - a * y * h - c * o * x + a * u * x) * S, n[3] = (p * u * s - c * f * s - p * o * h + a * f * h + c * o * m - a * u * m) * S, n[4] = _ * S, n[5] = (d * y * s - v * f * s + v * o * m - r * y * m - d * o * x + r * f * x) * S, n[6] = (v * u * s - l * y * s - v * o * h + r * y * h + l * o * x - r * u * x) * S, n[7] = (l * f * s - d * u * s + d * o * h - r * f * h - l * o * m + r * u * m) * S, n[8] = w * S, n[9] = (v * p * s - d * g * s - v * a * m + r * g * m + d * a * x - r * p * x) * S, n[10] = (l * g * s - v * c * s + v * a * h - r * g * h - l * a * x + r * c * x) * S, n[11] = (d * c * s - l * p * s - d * a * h + r * p * h + l * a * m - r * c * m) * S, n[12] = M * S, n[13] = (d * g * o - v * p * o + v * a * f - r * g * f - d * a * y + r * p * y) * S, n[14] = (v * c * o - l * g * o - v * a * u + r * g * u + l * a * y - r * c * y) * S, n[15] = (l * p * o - d * c * o + d * a * u - r * p * u - l * a * f + r * c * f) * S, this
                },
                scale: function (e) {
                    var t = this.elements,
                        n = e.x,
                        i = e.y,
                        r = e.z;
                    return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this
                },
                getMaxScaleOnAxis: function () {
                    var e = this.elements,
                        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                        n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                        i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                    return Math.sqrt(Math.max(t, n, i))
                },
                makeTranslation: function (e, t, n) {
                    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
                },
                makeRotationX: function (e) {
                    var t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
                },
                makeRotationY: function (e) {
                    var t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
                },
                makeRotationZ: function (e) {
                    var t = Math.cos(e),
                        n = Math.sin(e);
                    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                makeRotationAxis: function (e, t) {
                    var n = Math.cos(t),
                        i = Math.sin(t),
                        r = 1 - n,
                        a = e.x,
                        o = e.y,
                        s = e.z,
                        l = r * a,
                        c = r * o;
                    return this.set(l * a + n, l * o - i * s, l * s + i * o, 0, l * o + i * s, c * o + n, c * s - i * a, 0, l * s - i * o, c * s + i * a, r * s * s + n, 0, 0, 0, 0, 1), this
                },
                makeScale: function (e, t, n) {
                    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                },
                makeShear: function (e, t, n) {
                    return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1), this
                },
                compose: function (e, t, n) {
                    var i = this.elements,
                        r = t._x,
                        a = t._y,
                        o = t._z,
                        s = t._w,
                        l = r + r,
                        c = a + a,
                        u = o + o,
                        h = r * l,
                        d = r * c,
                        p = r * u,
                        f = a * c,
                        m = a * u,
                        v = o * u,
                        g = s * l,
                        y = s * c,
                        x = s * u,
                        b = n.x,
                        _ = n.y,
                        w = n.z;
                    return i[0] = (1 - (f + v)) * b, i[1] = (d + x) * b, i[2] = (p - y) * b, i[3] = 0, i[4] = (d - x) * _, i[5] = (1 - (h + v)) * _, i[6] = (m + g) * _, i[7] = 0, i[8] = (p + y) * w, i[9] = (m - g) * w, i[10] = (1 - (h + f)) * w, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
                },
                decompose: function () {
                    var e = new a,
                        t = new i;
                    return function (n, i, r) {
                        var a = this.elements,
                            o = e.set(a[0], a[1], a[2]).length(),
                            s = e.set(a[4], a[5], a[6]).length(),
                            l = e.set(a[8], a[9], a[10]).length(),
                            c = this.determinant();
                        c < 0 && (o = -o), n.x = a[12], n.y = a[13], n.z = a[14], t.copy(this);
                        var u = 1 / o,
                            h = 1 / s,
                            d = 1 / l;
                        return t.elements[0] *= u, t.elements[1] *= u, t.elements[2] *= u, t.elements[4] *= h, t.elements[5] *= h, t.elements[6] *= h, t.elements[8] *= d, t.elements[9] *= d, t.elements[10] *= d, i.setFromRotationMatrix(t), r.x = o, r.y = s, r.z = l, this
                    }
                }(),
                makePerspective: function (e, t, n, i, r, a) {
                    void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    var o = this.elements,
                        s = 2 * r / (t - e),
                        l = 2 * r / (n - i),
                        c = (t + e) / (t - e),
                        u = (n + i) / (n - i),
                        h = -(a + r) / (a - r),
                        d = -2 * a * r / (a - r);
                    return o[0] = s, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = l, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = h, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
                },
                makeOrthographic: function (e, t, n, i, r, a) {
                    var o = this.elements,
                        s = 1 / (t - e),
                        l = 1 / (n - i),
                        c = 1 / (a - r),
                        u = (t + e) * s,
                        h = (n + i) * l,
                        d = (a + r) * c;
                    return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -h, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
                },
                equals: function (e) {
                    for (var t = this.elements, n = e.elements, i = 0; i < 16; i++)
                        if (t[i] !== n[i]) return !1;
                    return !0
                },
                fromArray: function (e, t) {
                    void 0 === t && (t = 0);
                    for (var n = 0; n < 16; n++) this.elements[n] = e[n + t];
                    return this
                },
                toArray: function (e, t) {
                    void 0 === e && (e = []), void 0 === t && (t = 0);
                    var n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
                }
            }), Object.assign(r, {
                slerp: function (e, t, n, i) {
                    return n.copy(e).slerp(t, i)
                },
                slerpFlat: function (e, t, n, i, r, a, o) {
                    var s = n[i + 0],
                        l = n[i + 1],
                        c = n[i + 2],
                        u = n[i + 3],
                        h = r[a + 0],
                        d = r[a + 1],
                        p = r[a + 2],
                        f = r[a + 3];
                    if (u !== f || s !== h || l !== d || c !== p) {
                        var m = 1 - o,
                            v = s * h + l * d + c * p + u * f,
                            g = v >= 0 ? 1 : -1,
                            y = 1 - v * v;
                        if (y > Number.EPSILON) {
                            var x = Math.sqrt(y),
                                b = Math.atan2(x, v * g);
                            m = Math.sin(m * b) / x, o = Math.sin(o * b) / x
                        }
                        var _ = o * g;
                        if (s = s * m + h * _, l = l * m + d * _, c = c * m + p * _, u = u * m + f * _, m === 1 - o) {
                            var w = 1 / Math.sqrt(s * s + l * l + c * c + u * u);
                            s *= w, l *= w, c *= w, u *= w
                        }
                    }
                    e[t] = s, e[t + 1] = l, e[t + 2] = c, e[t + 3] = u
                }
            }), Object.defineProperties(r.prototype, {
                x: {
                    get: function () {
                        return this._x
                    },
                    set: function (e) {
                        this._x = e, this.onChangeCallback()
                    }
                },
                y: {
                    get: function () {
                        return this._y
                    },
                    set: function (e) {
                        this._y = e, this.onChangeCallback()
                    }
                },
                z: {
                    get: function () {
                        return this._z
                    },
                    set: function (e) {
                        this._z = e, this.onChangeCallback()
                    }
                },
                w: {
                    get: function () {
                        return this._w
                    },
                    set: function (e) {
                        this._w = e, this.onChangeCallback()
                    }
                }
            }), Object.assign(r.prototype, {
                isQuaternion: !0,
                set: function (e, t, n, i) {
                    return this._x = e, this._y = t, this._z = n, this._w = i, this.onChangeCallback(), this
                },
                clone: function () {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                },
                copy: function (e) {
                    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this
                },
                setFromEuler: function (e, t) {
                    if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    var n = e._x,
                        i = e._y,
                        r = e._z,
                        a = e.order,
                        o = Math.cos,
                        s = Math.sin,
                        l = o(n / 2),
                        c = o(i / 2),
                        u = o(r / 2),
                        h = s(n / 2),
                        d = s(i / 2),
                        p = s(r / 2);
                    return "XYZ" === a ? (this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p) : "YXZ" === a ? (this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p) : "ZXY" === a ? (this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p) : "ZYX" === a ? (this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p) : "YZX" === a ? (this._x = h * c * u + l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u - h * d * p) : "XZY" === a && (this._x = h * c * u - l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u + h * d * p), t !== !1 && this.onChangeCallback(), this
                },
                setFromAxisAngle: function (e, t) {
                    var n = t / 2,
                        i = Math.sin(n);
                    return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this.onChangeCallback(), this
                },
                setFromRotationMatrix: function (e) {
                    var t, n = e.elements,
                        i = n[0],
                        r = n[4],
                        a = n[8],
                        o = n[1],
                        s = n[5],
                        l = n[9],
                        c = n[2],
                        u = n[6],
                        h = n[10],
                        d = i + s + h;
                    return d > 0 ? (t = .5 / Math.sqrt(d + 1), this._w = .25 / t, this._x = (u - l) * t, this._y = (a - c) * t, this._z = (o - r) * t) : i > s && i > h ? (t = 2 * Math.sqrt(1 + i - s - h), this._w = (u - l) / t, this._x = .25 * t, this._y = (r + o) / t, this._z = (a + c) / t) : s > h ? (t = 2 * Math.sqrt(1 + s - i - h), this._w = (a - c) / t, this._x = (r + o) / t, this._y = .25 * t, this._z = (l + u) / t) : (t = 2 * Math.sqrt(1 + h - i - s), this._w = (o - r) / t, this._x = (a + c) / t, this._y = (l + u) / t, this._z = .25 * t), this.onChangeCallback(), this
                },
                setFromUnitVectors: function () {
                    var e, t = new a,
                        n = 1e-6;
                    return function (i, r) {
                        return void 0 === t && (t = new a), e = i.dot(r) + 1, e < n ? (e = 0, Math.abs(i.x) > Math.abs(i.z) ? t.set(-i.y, i.x, 0) : t.set(0, -i.z, i.y)) : t.crossVectors(i, r), this._x = t.x, this._y = t.y, this._z = t.z, this._w = e, this.normalize()
                    }
                }(),
                angleTo: function (e) {
                    return 2 * Math.acos(Math.abs(Wl.clamp(this.dot(e), -1, 1)))
                },
                rotateTowards: function (e, t) {
                    var n = this.angleTo(e);
                    if (0 === n) return this;
                    var i = Math.min(1, t / n);
                    return this.slerp(e, i), this
                },
                inverse: function () {
                    return this.conjugate()
                },
                conjugate: function () {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
                },
                dot: function (e) {
                    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                },
                lengthSq: function () {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                },
                length: function () {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                },
                normalize: function () {
                    var e = this.length();
                    return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this.onChangeCallback(), this
                },
                multiply: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
                },
                premultiply: function (e) {
                    return this.multiplyQuaternions(e, this)
                },
                multiplyQuaternions: function (e, t) {
                    var n = e._x,
                        i = e._y,
                        r = e._z,
                        a = e._w,
                        o = t._x,
                        s = t._y,
                        l = t._z,
                        c = t._w;
                    return this._x = n * c + a * o + i * l - r * s, this._y = i * c + a * s + r * o - n * l, this._z = r * c + a * l + n * s - i * o, this._w = a * c - n * o - i * s - r * l, this.onChangeCallback(), this
                },
                slerp: function (e, t) {
                    if (0 === t) return this;
                    if (1 === t) return this.copy(e);
                    var n = this._x,
                        i = this._y,
                        r = this._z,
                        a = this._w,
                        o = a * e._w + n * e._x + i * e._y + r * e._z;
                    if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = a, this._x = n, this._y = i, this._z = r, this;
                    var s = 1 - o * o;
                    if (s <= Number.EPSILON) {
                        var l = 1 - t;
                        return this._w = l * a + t * this._w, this._x = l * n + t * this._x, this._y = l * i + t * this._y, this._z = l * r + t * this._z, this.normalize()
                    }
                    var c = Math.sqrt(s),
                        u = Math.atan2(c, o),
                        h = Math.sin((1 - t) * u) / c,
                        d = Math.sin(t * u) / c;
                    return this._w = a * h + this._w * d, this._x = n * h + this._x * d, this._y = i * h + this._y * d, this._z = r * h + this._z * d, this.onChangeCallback(), this
                },
                equals: function (e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                },
                fromArray: function (e, t) {
                    return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this.onChangeCallback(), this
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
                },
                onChange: function (e) {
                    return this.onChangeCallback = e, this
                },
                onChangeCallback: function () {}
            }), Object.assign(a.prototype, {
                isVector3: !0,
                set: function (e, t, n) {
                    return this.x = e, this.y = t, this.z = n, this
                },
                setScalar: function (e) {
                    return this.x = e, this.y = e, this.z = e, this
                },
                setX: function (e) {
                    return this.x = e, this
                },
                setY: function (e) {
                    return this.y = e, this
                },
                setZ: function (e) {
                    return this.z = e, this
                },
                setComponent: function (e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                },
                getComponent: function (e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                clone: function () {
                    return new this.constructor(this.x, this.y, this.z)
                },
                copy: function (e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this
                },
                add: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
                },
                addScalar: function (e) {
                    return this.x += e, this.y += e, this.z += e, this
                },
                addVectors: function (e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
                },
                addScaledVector: function (e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
                },
                sub: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
                },
                subScalar: function (e) {
                    return this.x -= e, this.y -= e, this.z -= e, this
                },
                subVectors: function (e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
                },
                multiply: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
                },
                multiplyScalar: function (e) {
                    return this.x *= e, this.y *= e, this.z *= e, this
                },
                multiplyVectors: function (e, t) {
                    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
                },
                applyEuler: function () {
                    var e = new r;
                    return function (t) {
                        return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(e.setFromEuler(t))
                    }
                }(),
                applyAxisAngle: function () {
                    var e = new r;
                    return function (t, n) {
                        return this.applyQuaternion(e.setFromAxisAngle(t, n))
                    }
                }(),
                applyMatrix3: function (e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.elements;
                    return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this
                },
                applyMatrix4: function (e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.elements,
                        a = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
                    return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * a, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * a, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * a, this
                },
                applyQuaternion: function (e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.x,
                        a = e.y,
                        o = e.z,
                        s = e.w,
                        l = s * t + a * i - o * n,
                        c = s * n + o * t - r * i,
                        u = s * i + r * n - a * t,
                        h = -r * t - a * n - o * i;
                    return this.x = l * s + h * -r + c * -o - u * -a, this.y = c * s + h * -a + u * -r - l * -o, this.z = u * s + h * -o + l * -a - c * -r, this
                },
                project: function (e) {
                    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
                },
                unproject: function () {
                    var e = new i;
                    return function (t) {
                        return this.applyMatrix4(e.getInverse(t.projectionMatrix)).applyMatrix4(t.matrixWorld)
                    }
                }(),
                transformDirection: function (e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = e.elements;
                    return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize()
                },
                divide: function (e) {
                    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
                },
                divideScalar: function (e) {
                    return this.multiplyScalar(1 / e)
                },
                min: function (e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
                },
                max: function (e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
                },
                clamp: function (e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
                },
                clampScalar: function () {
                    var e = new a,
                        t = new a;
                    return function (n, i) {
                        return e.set(n, n, n), t.set(i, i, i), this.clamp(e, t)
                    }
                }(),
                clampLength: function (e, t) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                },
                floor: function () {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                },
                ceil: function () {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                },
                round: function () {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                },
                roundToZero: function () {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
                        this
                },
                negate: function () {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                },
                dot: function (e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z
                },
                lengthSq: function () {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                },
                length: function () {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                },
                manhattanLength: function () {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                },
                normalize: function () {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function (e) {
                    return this.normalize().multiplyScalar(e)
                },
                lerp: function (e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
                },
                lerpVectors: function (e, t, n) {
                    return this.subVectors(t, e).multiplyScalar(n).add(e)
                },
                cross: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e)
                },
                crossVectors: function (e, t) {
                    var n = e.x,
                        i = e.y,
                        r = e.z,
                        a = t.x,
                        o = t.y,
                        s = t.z;
                    return this.x = i * s - r * o, this.y = r * a - n * s, this.z = n * o - i * a, this
                },
                projectOnVector: function (e) {
                    var t = e.dot(this) / e.lengthSq();
                    return this.copy(e).multiplyScalar(t)
                },
                projectOnPlane: function () {
                    var e = new a;
                    return function (t) {
                        return e.copy(this).projectOnVector(t), this.sub(e)
                    }
                }(),
                reflect: function () {
                    var e = new a;
                    return function (t) {
                        return this.sub(e.copy(t).multiplyScalar(2 * this.dot(t)))
                    }
                }(),
                angleTo: function (e) {
                    var t = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq());
                    return Math.acos(Wl.clamp(t, -1, 1))
                },
                distanceTo: function (e) {
                    return Math.sqrt(this.distanceToSquared(e))
                },
                distanceToSquared: function (e) {
                    var t = this.x - e.x,
                        n = this.y - e.y,
                        i = this.z - e.z;
                    return t * t + n * n + i * i
                },
                manhattanDistanceTo: function (e) {
                    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                },
                setFromSpherical: function (e) {
                    return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
                },
                setFromSphericalCoords: function (e, t, n) {
                    var i = Math.sin(t) * e;
                    return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this
                },
                setFromCylindrical: function (e) {
                    return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
                },
                setFromCylindricalCoords: function (e, t, n) {
                    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
                },
                setFromMatrixPosition: function (e) {
                    var t = e.elements;
                    return this.x = t[12], this.y = t[13], this.z = t[14], this
                },
                setFromMatrixScale: function (e) {
                    var t = this.setFromMatrixColumn(e, 0).length(),
                        n = this.setFromMatrixColumn(e, 1).length(),
                        i = this.setFromMatrixColumn(e, 2).length();
                    return this.x = t, this.y = n, this.z = i, this
                },
                setFromMatrixColumn: function (e, t) {
                    return this.fromArray(e.elements, 4 * t)
                },
                equals: function (e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z
                },
                fromArray: function (e, t) {
                    return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
                },
                fromBufferAttribute: function (e, t, n) {
                    return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
                }
            }), Object.assign(o.prototype, {
                isMatrix3: !0,
                set: function (e, t, n, i, r, a, o, s, l) {
                    var c = this.elements;
                    return c[0] = e, c[1] = i, c[2] = o, c[3] = t, c[4] = r, c[5] = s, c[6] = n, c[7] = a, c[8] = l, this
                },
                identity: function () {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                },
                clone: function () {
                    return (new this.constructor).fromArray(this.elements)
                },
                copy: function (e) {
                    var t = this.elements,
                        n = e.elements;
                    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
                },
                setFromMatrix4: function (e) {
                    var t = e.elements;
                    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
                },
                applyToBufferAttribute: function () {
                    var e = new a;
                    return function (t) {
                        for (var n = 0, i = t.count; n < i; n++) e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.applyMatrix3(this), t.setXYZ(n, e.x, e.y, e.z);
                        return t
                    }
                }(),
                multiply: function (e) {
                    return this.multiplyMatrices(this, e)
                },
                premultiply: function (e) {
                    return this.multiplyMatrices(e, this)
                },
                multiplyMatrices: function (e, t) {
                    var n = e.elements,
                        i = t.elements,
                        r = this.elements,
                        a = n[0],
                        o = n[3],
                        s = n[6],
                        l = n[1],
                        c = n[4],
                        u = n[7],
                        h = n[2],
                        d = n[5],
                        p = n[8],
                        f = i[0],
                        m = i[3],
                        v = i[6],
                        g = i[1],
                        y = i[4],
                        x = i[7],
                        b = i[2],
                        _ = i[5],
                        w = i[8];
                    return r[0] = a * f + o * g + s * b, r[3] = a * m + o * y + s * _, r[6] = a * v + o * x + s * w, r[1] = l * f + c * g + u * b, r[4] = l * m + c * y + u * _, r[7] = l * v + c * x + u * w, r[2] = h * f + d * g + p * b, r[5] = h * m + d * y + p * _, r[8] = h * v + d * x + p * w, this
                },
                multiplyScalar: function (e) {
                    var t = this.elements;
                    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
                },
                determinant: function () {
                    var e = this.elements,
                        t = e[0],
                        n = e[1],
                        i = e[2],
                        r = e[3],
                        a = e[4],
                        o = e[5],
                        s = e[6],
                        l = e[7],
                        c = e[8];
                    return t * a * c - t * o * l - n * r * c + n * o * s + i * r * l - i * a * s
                },
                getInverse: function (e, t) {
                    e && e.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                    var n = e.elements,
                        i = this.elements,
                        r = n[0],
                        a = n[1],
                        o = n[2],
                        s = n[3],
                        l = n[4],
                        c = n[5],
                        u = n[6],
                        h = n[7],
                        d = n[8],
                        p = d * l - c * h,
                        f = c * u - d * s,
                        m = h * s - l * u,
                        v = r * p + a * f + o * m;
                    if (0 === v) {
                        var g = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                        if (t === !0) throw new Error(g);
                        return console.warn(g), this.identity()
                    }
                    var y = 1 / v;
                    return i[0] = p * y, i[1] = (o * h - d * a) * y, i[2] = (c * a - o * l) * y, i[3] = f * y, i[4] = (d * r - o * u) * y, i[5] = (o * s - c * r) * y, i[6] = m * y, i[7] = (a * u - h * r) * y, i[8] = (l * r - a * s) * y, this
                },
                transpose: function () {
                    var e, t = this.elements;
                    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
                },
                getNormalMatrix: function (e) {
                    return this.setFromMatrix4(e).getInverse(this).transpose()
                },
                transposeIntoArray: function (e) {
                    var t = this.elements;
                    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
                },
                setUvTransform: function (e, t, n, i, r, a, o) {
                    var s = Math.cos(r),
                        l = Math.sin(r);
                    this.set(n * s, n * l, -n * (s * a + l * o) + a + e, -i * l, i * s, -i * (-l * a + s * o) + o + t, 0, 0, 1)
                },
                scale: function (e, t) {
                    var n = this.elements;
                    return n[0] *= e, n[3] *= e, n[6] *= e, n[1] *= t, n[4] *= t, n[7] *= t, this
                },
                rotate: function (e) {
                    var t = Math.cos(e),
                        n = Math.sin(e),
                        i = this.elements,
                        r = i[0],
                        a = i[3],
                        o = i[6],
                        s = i[1],
                        l = i[4],
                        c = i[7];
                    return i[0] = t * r + n * s, i[3] = t * a + n * l, i[6] = t * o + n * c, i[1] = -n * r + t * s, i[4] = -n * a + t * l, i[7] = -n * o + t * c, this
                },
                translate: function (e, t) {
                    var n = this.elements;
                    return n[0] += e * n[2], n[3] += e * n[5], n[6] += e * n[8], n[1] += t * n[2], n[4] += t * n[5], n[7] += t * n[8], this
                },
                equals: function (e) {
                    for (var t = this.elements, n = e.elements, i = 0; i < 9; i++)
                        if (t[i] !== n[i]) return !1;
                    return !0
                },
                fromArray: function (e, t) {
                    void 0 === t && (t = 0);
                    for (var n = 0; n < 9; n++) this.elements[n] = e[n + t];
                    return this
                },
                toArray: function (e, t) {
                    void 0 === e && (e = []), void 0 === t && (t = 0);
                    var n = this.elements;
                    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
                }
            });
            var ql, Xl = {
                    getDataURL: function (e) {
                        var t;
                        if ("undefined" == typeof HTMLCanvasElement) return e.src;
                        if (e instanceof HTMLCanvasElement) t = e;
                        else {
                            void 0 === ql && (ql = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), ql.width = e.width, ql.height = e.height;
                            var n = ql.getContext("2d");
                            e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = ql
                        }
                        return t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
                    }
                },
                Yl = 0;
            s.DEFAULT_IMAGE = void 0, s.DEFAULT_MAPPING = fs, s.prototype = Object.assign(Object.create(t.prototype), {
                constructor: s,
                isTexture: !0,
                updateMatrix: function () {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
                },
                toJSON: function (e) {
                    var t = void 0 === e || "string" == typeof e;
                    if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                    var n = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    if (void 0 !== this.image) {
                        var i = this.image;
                        if (void 0 === i.uuid && (i.uuid = Wl.generateUUID()), !t && void 0 === e.images[i.uuid]) {
                            var r;
                            if (Array.isArray(i)) {
                                r = [];
                                for (var a = 0, o = i.length; a < o; a++) r.push(Xl.getDataURL(i[a]))
                            } else r = Xl.getDataURL(i);
                            e.images[i.uuid] = {
                                uuid: i.uuid,
                                url: r
                            }
                        }
                        n.image = i.uuid
                    }
                    return t || (e.textures[this.uuid] = n), n
                },
                dispose: function () {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                },
                transformUv: function (e) {
                    if (this.mapping !== fs) return e;
                    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                        case ws:
                            e.x = e.x - Math.floor(e.x);
                            break;
                        case Ms:
                            e.x = e.x < 0 ? 0 : 1;
                            break;
                        case Ts:
                            1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                    }
                    if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                        case ws:
                            e.y = e.y - Math.floor(e.y);
                            break;
                        case Ms:
                            e.y = e.y < 0 ? 0 : 1;
                            break;
                        case Ts:
                            1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                    }
                    return this.flipY && (e.y = 1 - e.y), e
                }
            }), Object.defineProperty(s.prototype, "needsUpdate", {
                set: function (e) {
                    e === !0 && this.version++
                }
            }), Object.assign(l.prototype, {
                isVector4: !0,
                set: function (e, t, n, i) {
                    return this.x = e, this.y = t, this.z = n, this.w = i, this
                },
                setScalar: function (e) {
                    return this.x = e, this.y = e, this.z = e, this.w = e, this
                },
                setX: function (e) {
                    return this.x = e, this
                },
                setY: function (e) {
                    return this.y = e, this
                },
                setZ: function (e) {
                    return this.z = e, this
                },
                setW: function (e) {
                    return this.w = e, this
                },
                setComponent: function (e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        case 3:
                            this.w = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                    return this
                },
                getComponent: function (e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                clone: function () {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                },
                copy: function (e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
                },
                add: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
                },
                addScalar: function (e) {
                    return this.x += e, this.y += e, this.z += e, this.w += e, this
                },
                addVectors: function (e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
                },
                addScaledVector: function (e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
                },
                sub: function (e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
                },
                subScalar: function (e) {
                    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
                },
                subVectors: function (e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
                },
                multiplyScalar: function (e) {
                    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
                },
                applyMatrix4: function (e) {
                    var t = this.x,
                        n = this.y,
                        i = this.z,
                        r = this.w,
                        a = e.elements;
                    return this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * r, this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * r, this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * r, this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * r, this
                },
                divideScalar: function (e) {
                    return this.multiplyScalar(1 / e)
                },
                setAxisAngleFromQuaternion: function (e) {
                    this.w = 2 * Math.acos(e.w);
                    var t = Math.sqrt(1 - e.w * e.w);
                    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
                },
                setAxisAngleFromRotationMatrix: function (e) {
                    var t, n, i, r, a = .01,
                        o = .1,
                        s = e.elements,
                        l = s[0],
                        c = s[4],
                        u = s[8],
                        h = s[1],
                        d = s[5],
                        p = s[9],
                        f = s[2],
                        m = s[6],
                        v = s[10];
                    if (Math.abs(c - h) < a && Math.abs(u - f) < a && Math.abs(p - m) < a) {
                        if (Math.abs(c + h) < o && Math.abs(u + f) < o && Math.abs(p + m) < o && Math.abs(l + d + v - 3) < o) return this.set(1, 0, 0, 0), this;
                        t = Math.PI;
                        var g = (l + 1) / 2,
                            y = (d + 1) / 2,
                            x = (v + 1) / 2,
                            b = (c + h) / 4,
                            _ = (u + f) / 4,
                            w = (p + m) / 4;
                        return g > y && g > x ? g < a ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(g), i = b / n, r = _ / n) : y > x ? y < a ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(y), n = b / i, r = w / i) : x < a ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(x), n = _ / r, i = w / r), this.set(n, i, r, t), this
                    }
                    var M = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c));
                    return Math.abs(M) < .001 && (M = 1), this.x = (m - p) / M, this.y = (u - f) / M, this.z = (h - c) / M, this.w = Math.acos((l + d + v - 1) / 2), this
                },
                min: function (e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
                },
                max: function (e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
                },
                clamp: function (e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
                },
                clampScalar: function () {
                    var e, t;
                    return function (n, i) {
                        return void 0 === e && (e = new l, t = new l), e.set(n, n, n, n), t.set(i, i, i, i), this.clamp(e, t)
                    }
                }(),
                clampLength: function (e, t) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                },
                floor: function () {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                },
                ceil: function () {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                },
                round: function () {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                },
                roundToZero: function () {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                },
                negate: function () {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                },
                dot: function (e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                },
                lengthSq: function () {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                },
                length: function () {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                },
                manhattanLength: function () {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                },
                normalize: function () {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function (e) {
                    return this.normalize().multiplyScalar(e)
                },
                lerp: function (e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
                },
                lerpVectors: function (e, t, n) {
                    return this.subVectors(t, e).multiplyScalar(n).add(e)
                },
                equals: function (e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                },
                fromArray: function (e, t) {
                    return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
                },
                fromBufferAttribute: function (e, t, n) {
                    return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
                }
            }), c.prototype = Object.assign(Object.create(t.prototype), {
                constructor: c,
                isWebGLRenderTarget: !0,
                setSize: function (e, t) {
                    this.width === e && this.height === t || (this.width = e, this.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this
                },
                dispose: function () {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), u.prototype = Object.assign(Object.create(c.prototype), {
                constructor: u,
                isWebGLMultisampleRenderTarget: !0,
                copy: function (e) {
                    return c.prototype.copy.call(this, e), this.samples = e.samples, this
                }
            }), h.prototype = Object.create(c.prototype), h.prototype.constructor = h, h.prototype.isWebGLRenderTargetCube = !0, d.prototype = Object.create(s.prototype), d.prototype.constructor = d, d.prototype.isDataTexture = !0, Object.assign(p.prototype, {
                isBox3: !0,
                set: function (e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                },
                setFromArray: function (e) {
                    for (var t = +(1 / 0), n = +(1 / 0), i = +(1 / 0), r = -(1 / 0), a = -(1 / 0), o = -(1 / 0), s = 0, l = e.length; s < l; s += 3) {
                        var c = e[s],
                            u = e[s + 1],
                            h = e[s + 2];
                        c < t && (t = c), u < n && (n = u), h < i && (i = h), c > r && (r = c), u > a && (a = u), h > o && (o = h)
                    }
                    return this.min.set(t, n, i), this.max.set(r, a, o), this
                },
                setFromBufferAttribute: function (e) {
                    for (var t = +(1 / 0), n = +(1 / 0), i = +(1 / 0), r = -(1 / 0), a = -(1 / 0), o = -(1 / 0), s = 0, l = e.count; s < l; s++) {
                        var c = e.getX(s),
                            u = e.getY(s),
                            h = e.getZ(s);
                        c < t && (t = c), u < n && (n = u), h < i && (i = h), c > r && (r = c), u > a && (a = u), h > o && (o = h)
                    }
                    return this.min.set(t, n, i), this.max.set(r, a, o), this
                },
                setFromPoints: function (e) {
                    this.makeEmpty();
                    for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                },
                setFromCenterAndSize: function () {
                    var e = new a;
                    return function (t, n) {
                        var i = e.copy(n).multiplyScalar(.5);
                        return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
                    }
                }(),
                setFromObject: function (e) {
                    return this.makeEmpty(), this.expandByObject(e)
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                },
                makeEmpty: function () {
                    return this.min.x = this.min.y = this.min.z = +(1 / 0), this.max.x = this.max.y = this.max.z = -(1 / 0), this
                },
                isEmpty: function () {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                },
                getCenter: function (e) {
                    return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new a), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function (e) {
                    return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"), e = new a), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                },
                expandByPoint: function (e) {
                    return this.min.min(e), this.max.max(e), this
                },
                expandByVector: function (e) {
                    return this.min.sub(e), this.max.add(e), this
                },
                expandByScalar: function (e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                },
                expandByObject: function () {
                    function e(e) {
                        var a = e.geometry;
                        if (void 0 !== a)
                            if (a.isGeometry) {
                                var o = a.vertices;
                                for (n = 0, i = o.length; n < i; n++) r.copy(o[n]), r.applyMatrix4(e.matrixWorld), t.expandByPoint(r)
                            } else if (a.isBufferGeometry) {
                            var s = a.attributes.position;
                            if (void 0 !== s)
                                for (n = 0, i = s.count; n < i; n++) r.fromBufferAttribute(s, n).applyMatrix4(e.matrixWorld), t.expandByPoint(r)
                        }
                    }
                    var t, n, i, r = new a;
                    return function (n) {
                        return t = this, n.updateMatrixWorld(!0), n.traverse(e), this
                    }
                }(),
                containsPoint: function (e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
                },
                containsBox: function (e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                },
                getParameter: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new a), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                },
                intersectsBox: function (e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
                },
                intersectsSphere: function () {
                    var e = new a;
                    return function (t) {
                        return this.clampPoint(t.center, e), e.distanceToSquared(t.center) <= t.radius * t.radius
                    }
                }(),
                intersectsPlane: function (e) {
                    var t, n;
                    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
                },
                intersectsTriangle: function () {
                    function e(e) {
                        var r, a;
                        for (r = 0, a = e.length - 3; r <= a; r += 3) {
                            l.fromArray(e, r);
                            var o = u.x * Math.abs(l.x) + u.y * Math.abs(l.y) + u.z * Math.abs(l.z),
                                s = t.dot(l),
                                c = n.dot(l),
                                h = i.dot(l);
                            if (Math.max(-Math.max(s, c, h), Math.min(s, c, h)) > o) return !1
                        }
                        return !0
                    }
                    var t = new a,
                        n = new a,
                        i = new a,
                        r = new a,
                        o = new a,
                        s = new a,
                        l = new a,
                        c = new a,
                        u = new a,
                        h = new a;
                    return function (a) {
                        if (this.isEmpty()) return !1;
                        this.getCenter(c), u.subVectors(this.max, c), t.subVectors(a.a, c), n.subVectors(a.b, c), i.subVectors(a.c, c), r.subVectors(n, t), o.subVectors(i, n), s.subVectors(t, i);
                        var l = [0, -r.z, r.y, 0, -o.z, o.y, 0, -s.z, s.y, r.z, 0, -r.x, o.z, 0, -o.x, s.z, 0, -s.x, -r.y, r.x, 0, -o.y, o.x, 0, -s.y, s.x, 0];
                        return !!e(l) && (l = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!e(l) && (h.crossVectors(r, o), l = [h.x, h.y, h.z], e(l)))
                    }
                }(),
                clampPoint: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new a), t.copy(e).clamp(this.min, this.max)
                },
                distanceToPoint: function () {
                    var e = new a;
                    return function (t) {
                        var n = e.copy(t).clamp(this.min, this.max);
                        return n.sub(t).length()
                    }
                }(),
                getBoundingSphere: function () {
                    var e = new a;
                    return function (t) {
                        return void 0 === t && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), t = new f), this.getCenter(t.center), t.radius = .5 * this.getSize(e).length(), t
                    }
                }(),
                intersect: function (e) {
                    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
                },
                union: function (e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                },
                applyMatrix4: function () {
                    var e = [new a, new a, new a, new a, new a, new a, new a, new a];
                    return function (t) {
                        return this.isEmpty() ? this : (e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(e), this)
                    }
                }(),
                translate: function (e) {
                    return this.min.add(e), this.max.add(e), this
                },
                equals: function (e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }), Object.assign(f.prototype, {
                set: function (e, t) {
                    return this.center.copy(e), this.radius = t, this
                },
                setFromPoints: function () {
                    var e = new p;
                    return function (t, n) {
                        var i = this.center;
                        void 0 !== n ? i.copy(n) : e.setFromPoints(t).getCenter(i);
                        for (var r = 0, a = 0, o = t.length; a < o; a++) r = Math.max(r, i.distanceToSquared(t[a]));
                        return this.radius = Math.sqrt(r), this
                    }
                }(),
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.center.copy(e.center), this.radius = e.radius, this
                },
                empty: function () {
                    return this.radius <= 0
                },
                containsPoint: function (e) {
                    return e.distanceToSquared(this.center) <= this.radius * this.radius
                },
                distanceToPoint: function (e) {
                    return e.distanceTo(this.center) - this.radius
                },
                intersectsSphere: function (e) {
                    var t = this.radius + e.radius;
                    return e.center.distanceToSquared(this.center) <= t * t
                },
                intersectsBox: function (e) {
                    return e.intersectsSphere(this)
                },
                intersectsPlane: function (e) {
                    return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                },
                clampPoint: function (e, t) {
                    var n = this.center.distanceToSquared(e);
                    return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new a), t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
                },
                getBoundingBox: function (e) {
                    return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new p), e.set(this.center, this.center), e.expandByScalar(this.radius), e
                },
                applyMatrix4: function (e) {
                    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
                },
                translate: function (e) {
                    return this.center.add(e), this
                },
                equals: function (e) {
                    return e.center.equals(this.center) && e.radius === this.radius
                }
            }), Object.assign(m.prototype, {
                set: function (e, t) {
                    return this.normal.copy(e), this.constant = t, this
                },
                setComponents: function (e, t, n, i) {
                    return this.normal.set(e, t, n), this.constant = i, this
                },
                setFromNormalAndCoplanarPoint: function (e, t) {
                    return this.normal.copy(e), this.constant = -t.dot(this.normal), this
                },
                setFromCoplanarPoints: function () {
                    var e = new a,
                        t = new a;
                    return function (n, i, r) {
                        var a = e.subVectors(r, i).cross(t.subVectors(n, i)).normalize();
                        return this.setFromNormalAndCoplanarPoint(a, n), this
                    }
                }(),
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.normal.copy(e.normal), this.constant = e.constant, this
                },
                normalize: function () {
                    var e = 1 / this.normal.length();
                    return this.normal.multiplyScalar(e), this.constant *= e, this
                },
                negate: function () {
                    return this.constant *= -1, this.normal.negate(), this
                },
                distanceToPoint: function (e) {
                    return this.normal.dot(e) + this.constant
                },
                distanceToSphere: function (e) {
                    return this.distanceToPoint(e.center) - e.radius
                },
                projectPoint: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new a), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
                },
                intersectLine: function () {
                    var e = new a;
                    return function (t, n) {
                        void 0 === n && (console.warn("THREE.Plane: .intersectLine() target is now required"), n = new a);
                        var i = t.delta(e),
                            r = this.normal.dot(i);
                        if (0 !== r) {
                            var o = -(t.start.dot(this.normal) + this.constant) / r;
                            if (!(o < 0 || o > 1)) return n.copy(i).multiplyScalar(o).add(t.start)
                        } else if (0 === this.distanceToPoint(t.start)) return n.copy(t.start)
                    }
                }(),
                intersectsLine: function (e) {
                    var t = this.distanceToPoint(e.start),
                        n = this.distanceToPoint(e.end);
                    return t < 0 && n > 0 || n < 0 && t > 0
                },
                intersectsBox: function (e) {
                    return e.intersectsPlane(this)
                },
                intersectsSphere: function (e) {
                    return e.intersectsPlane(this)
                },
                coplanarPoint: function (e) {
                    return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new a), e.copy(this.normal).multiplyScalar(-this.constant)
                },
                applyMatrix4: function () {
                    var e = new a,
                        t = new o;
                    return function (n, i) {
                        var r = i || t.getNormalMatrix(n),
                            a = this.coplanarPoint(e).applyMatrix4(n),
                            o = this.normal.applyMatrix3(r).normalize();
                        return this.constant = -a.dot(o), this
                    }
                }(),
                translate: function (e) {
                    return this.constant -= e.dot(this.normal), this
                },
                equals: function (e) {
                    return e.normal.equals(this.normal) && e.constant === this.constant
                }
            }), Object.assign(v.prototype, {
                set: function (e, t, n, i, r, a) {
                    var o = this.planes;
                    return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(a), this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    for (var t = this.planes, n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                    return this
                },
                setFromMatrix: function (e) {
                    var t = this.planes,
                        n = e.elements,
                        i = n[0],
                        r = n[1],
                        a = n[2],
                        o = n[3],
                        s = n[4],
                        l = n[5],
                        c = n[6],
                        u = n[7],
                        h = n[8],
                        d = n[9],
                        p = n[10],
                        f = n[11],
                        m = n[12],
                        v = n[13],
                        g = n[14],
                        y = n[15];
                    return t[0].setComponents(o - i, u - s, f - h, y - m).normalize(), t[1].setComponents(o + i, u + s, f + h, y + m).normalize(), t[2].setComponents(o + r, u + l, f + d, y + v).normalize(), t[3].setComponents(o - r, u - l, f - d, y - v).normalize(), t[4].setComponents(o - a, u - c, f - p, y - g).normalize(), t[5].setComponents(o + a, u + c, f + p, y + g).normalize(), this
                },
                intersectsObject: function () {
                    var e = new f;
                    return function (t) {
                        var n = t.geometry;
                        return null === n.boundingSphere && n.computeBoundingSphere(), e.copy(n.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
                    }
                }(),
                intersectsSprite: function () {
                    var e = new f;
                    return function (t) {
                        return e.center.set(0, 0, 0), e.radius = .7071067811865476, e.applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
                    }
                }(),
                intersectsSphere: function (e) {
                    for (var t = this.planes, n = e.center, i = -e.radius, r = 0; r < 6; r++) {
                        var a = t[r].distanceToPoint(n);
                        if (a < i) return !1
                    }
                    return !0
                },
                intersectsBox: function () {
                    var e = new a;
                    return function (t) {
                        for (var n = this.planes, i = 0; i < 6; i++) {
                            var r = n[i];
                            if (e.x = r.normal.x > 0 ? t.max.x : t.min.x, e.y = r.normal.y > 0 ? t.max.y : t.min.y, e.z = r.normal.z > 0 ? t.max.z : t.min.z, r.distanceToPoint(e) < 0) return !1
                        }
                        return !0
                    }
                }(),
                containsPoint: function (e) {
                    for (var t = this.planes, n = 0; n < 6; n++)
                        if (t[n].distanceToPoint(e) < 0) return !1;
                    return !0
                }
            });
            var Zl = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                Jl = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                $l = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                Ql = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                Kl = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                ec = "vec3 transformed = vec3( position );",
                tc = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                nc = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
                ic = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                rc = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                ac = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                oc = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
                sc = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
                lc = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                cc = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                uc = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                hc = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
                dc = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
                pc = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
                fc = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                mc = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                vc = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
                gc = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                yc = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                xc = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                bc = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                _c = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                wc = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                Mc = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                Tc = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                Ec = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
                Sc = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                Pc = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                Cc = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                Ac = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
                Lc = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
                Rc = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                Ic = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
                Oc = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                kc = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                Dc = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                zc = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                Bc = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
                Nc = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor;\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                Uc = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
                jc = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
                Fc = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",
                Gc = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                Hc = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
                Vc = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                Wc = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",
                qc = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                Xc = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                Yc = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
                Zc = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
                Jc = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                $c = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                Qc = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
                Kc = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                eu = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                tu = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif",
                nu = "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
                iu = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
                ru = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                au = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                ou = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",
                su = "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                lu = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                cu = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                uu = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                hu = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                du = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
                pu = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
                fu = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                mu = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                vu = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                gu = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                yu = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                xu = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                bu = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                _u = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                wu = "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
                Mu = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
                Tu = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
                Eu = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                Su = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                Pu = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
                Cu = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
                Au = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",
                Lu = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                Ru = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                Iu = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                Ou = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                ku = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
                Du = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
                zu = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                Bu = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                Nu = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                Uu = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                ju = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                Fu = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                Gu = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                Hu = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                Vu = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                Wu = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                qu = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                Xu = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                Yu = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                Zu = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                Ju = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                $u = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                Qu = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                Ku = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                eh = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                th = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                nh = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
                ih = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                rh = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                ah = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                oh = {
                    alphamap_fragment: Zl,
                    alphamap_pars_fragment: Jl,
                    alphatest_fragment: $l,
                    aomap_fragment: Ql,
                    aomap_pars_fragment: Kl,
                    begin_vertex: ec,
                    beginnormal_vertex: tc,
                    bsdfs: nc,
                    bumpmap_pars_fragment: ic,
                    clipping_planes_fragment: rc,
                    clipping_planes_pars_fragment: ac,
                    clipping_planes_pars_vertex: oc,
                    clipping_planes_vertex: sc,
                    color_fragment: lc,
                    color_pars_fragment: cc,
                    color_pars_vertex: uc,
                    color_vertex: hc,
                    common: dc,
                    cube_uv_reflection_fragment: pc,
                    defaultnormal_vertex: fc,
                    displacementmap_pars_vertex: mc,
                    displacementmap_vertex: vc,
                    emissivemap_fragment: gc,
                    emissivemap_pars_fragment: yc,
                    encodings_fragment: xc,
                    encodings_pars_fragment: bc,
                    envmap_fragment: _c,
                    envmap_pars_fragment: wc,
                    envmap_pars_vertex: Mc,
                    envmap_physical_pars_fragment: kc,
                    envmap_vertex: Tc,
                    fog_vertex: Ec,
                    fog_pars_vertex: Sc,
                    fog_fragment: Pc,
                    fog_pars_fragment: Cc,
                    gradientmap_pars_fragment: Ac,
                    lightmap_fragment: Lc,
                    lightmap_pars_fragment: Rc,
                    lights_lambert_vertex: Ic,
                    lights_pars_begin: Oc,
                    lights_phong_fragment: Dc,
                    lights_phong_pars_fragment: zc,
                    lights_physical_fragment: Bc,
                    lights_physical_pars_fragment: Nc,
                    lights_fragment_begin: Uc,
                    lights_fragment_maps: jc,
                    lights_fragment_end: Fc,
                    logdepthbuf_fragment: Gc,
                    logdepthbuf_pars_fragment: Hc,
                    logdepthbuf_pars_vertex: Vc,
                    logdepthbuf_vertex: Wc,
                    map_fragment: qc,
                    map_pars_fragment: Xc,
                    map_particle_fragment: Yc,
                    map_particle_pars_fragment: Zc,
                    metalnessmap_fragment: Jc,
                    metalnessmap_pars_fragment: $c,
                    morphnormal_vertex: Qc,
                    morphtarget_pars_vertex: Kc,
                    morphtarget_vertex: eu,
                    normal_fragment_begin: tu,
                    normal_fragment_maps: nu,
                    normalmap_pars_fragment: iu,
                    packing: ru,
                    premultiplied_alpha_fragment: au,
                    project_vertex: ou,
                    dithering_fragment: su,
                    dithering_pars_fragment: lu,
                    roughnessmap_fragment: cu,
                    roughnessmap_pars_fragment: uu,
                    shadowmap_pars_fragment: hu,
                    shadowmap_pars_vertex: du,
                    shadowmap_vertex: pu,
                    shadowmask_pars_fragment: fu,
                    skinbase_vertex: mu,
                    skinning_pars_vertex: vu,
                    skinning_vertex: gu,
                    skinnormal_vertex: yu,
                    specularmap_fragment: xu,
                    specularmap_pars_fragment: bu,
                    tonemapping_fragment: _u,
                    tonemapping_pars_fragment: wu,
                    uv_pars_fragment: Mu,
                    uv_pars_vertex: Tu,
                    uv_vertex: Eu,
                    uv2_pars_fragment: Su,
                    uv2_pars_vertex: Pu,
                    uv2_vertex: Cu,
                    worldpos_vertex: Au,
                    background_frag: Lu,
                    background_vert: Ru,
                    cube_frag: Iu,
                    cube_vert: Ou,
                    depth_frag: ku,
                    depth_vert: Du,
                    distanceRGBA_frag: zu,
                    distanceRGBA_vert: Bu,
                    equirect_frag: Nu,
                    equirect_vert: Uu,
                    linedashed_frag: ju,
                    linedashed_vert: Fu,
                    meshbasic_frag: Gu,
                    meshbasic_vert: Hu,
                    meshlambert_frag: Vu,
                    meshlambert_vert: Wu,
                    meshmatcap_frag: qu,
                    meshmatcap_vert: Xu,
                    meshphong_frag: Yu,
                    meshphong_vert: Zu,
                    meshphysical_frag: Ju,
                    meshphysical_vert: $u,
                    normal_frag: Qu,
                    normal_vert: Ku,
                    points_frag: eh,
                    points_vert: th,
                    shadow_frag: nh,
                    shadow_vert: ih,
                    sprite_frag: rh,
                    sprite_vert: ah
                },
                sh = {
                    clone: g,
                    merge: y
                },
                lh = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                };
            Object.assign(x.prototype, {
                isColor: !0,
                r: 1,
                g: 1,
                b: 1,
                set: function (e) {
                    return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
                },
                setScalar: function (e) {
                    return this.r = e, this.g = e, this.b = e, this
                },
                setHex: function (e) {
                    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
                },
                setRGB: function (e, t, n) {
                    return this.r = e, this.g = t, this.b = n, this
                },
                setHSL: function () {
                    function e(e, t, n) {
                        return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
                    }
                    return function (t, n, i) {
                        if (t = Wl.euclideanModulo(t, 1), n = Wl.clamp(n, 0, 1), i = Wl.clamp(i, 0, 1), 0 === n) this.r = this.g = this.b = i;
                        else {
                            var r = i <= .5 ? i * (1 + n) : i + n - i * n,
                                a = 2 * i - r;
                            this.r = e(a, r, t + 1 / 3), this.g = e(a, r, t), this.b = e(a, r, t - 1 / 3)
                        }
                        return this
                    }
                }(),
                setStyle: function (e) {
                    function t(t) {
                        void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                    }
                    var n;
                    if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
                        var i, r = n[1],
                            a = n[2];
                        switch (r) {
                            case "rgb":
                            case "rgba":
                                if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, t(i[5]), this;
                                if (i = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, t(i[5]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) {
                                    var o = parseFloat(i[1]) / 360,
                                        s = parseInt(i[2], 10) / 100,
                                        l = parseInt(i[3], 10) / 100;
                                    return t(i[5]), this.setHSL(o, s, l)
                                }
                        }
                    } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
                        var c = n[1],
                            u = c.length;
                        if (3 === u) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this;
                        if (6 === u) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this
                    }
                    if (e && e.length > 0) {
                        var c = lh[e];
                        void 0 !== c ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + e)
                    }
                    return this
                },
                clone: function () {
                    return new this.constructor(this.r, this.g, this.b)
                },
                copy: function (e) {
                    return this.r = e.r, this.g = e.g, this.b = e.b, this
                },
                copyGammaToLinear: function (e, t) {
                    return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
                },
                copyLinearToGamma: function (e, t) {
                    void 0 === t && (t = 2);
                    var n = t > 0 ? 1 / t : 1;
                    return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this
                },
                convertGammaToLinear: function (e) {
                    return this.copyGammaToLinear(this, e), this
                },
                convertLinearToGamma: function (e) {
                    return this.copyLinearToGamma(this, e), this
                },
                copySRGBToLinear: function () {
                    function e(e) {
                        return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
                    }
                    return function (t) {
                        return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this
                    }
                }(),
                copyLinearToSRGB: function () {
                    function e(e) {
                        return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
                    }
                    return function (t) {
                        return this.r = e(t.r), this.g = e(t.g), this.b = e(t.b), this
                    }
                }(),
                convertSRGBToLinear: function () {
                    return this.copySRGBToLinear(this), this
                },
                convertLinearToSRGB: function () {
                    return this.copyLinearToSRGB(this), this
                },
                getHex: function () {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                },
                getHexString: function () {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                },
                getHSL: function (e) {
                    void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"), e = {
                        h: 0,
                        s: 0,
                        l: 0
                    });
                    var t, n, i = this.r,
                        r = this.g,
                        a = this.b,
                        o = Math.max(i, r, a),
                        s = Math.min(i, r, a),
                        l = (s + o) / 2;
                    if (s === o) t = 0, n = 0;
                    else {
                        var c = o - s;
                        switch (n = l <= .5 ? c / (o + s) : c / (2 - o - s), o) {
                            case i:
                                t = (r - a) / c + (r < a ? 6 : 0);
                                break;
                            case r:
                                t = (a - i) / c + 2;
                                break;
                            case a:
                                t = (i - r) / c + 4
                        }
                        t /= 6
                    }
                    return e.h = t, e.s = n, e.l = l, e
                },
                getStyle: function () {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                },
                offsetHSL: function () {
                    var e = {};
                    return function (t, n, i) {
                        return this.getHSL(e), e.h += t, e.s += n, e.l += i, this.setHSL(e.h, e.s, e.l), this
                    }
                }(),
                add: function (e) {
                    return this.r += e.r, this.g += e.g, this.b += e.b, this
                },
                addColors: function (e, t) {
                    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
                },
                addScalar: function (e) {
                    return this.r += e, this.g += e, this.b += e, this
                },
                sub: function (e) {
                    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
                },
                multiply: function (e) {
                    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
                },
                multiplyScalar: function (e) {
                    return this.r *= e, this.g *= e, this.b *= e, this
                },
                lerp: function (e, t) {
                    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
                },
                lerpHSL: function () {
                    var e = {
                            h: 0,
                            s: 0,
                            l: 0
                        },
                        t = {
                            h: 0,
                            s: 0,
                            l: 0
                        };
                    return function (n, i) {
                        this.getHSL(e), n.getHSL(t);
                        var r = Wl.lerp(e.h, t.h, i),
                            a = Wl.lerp(e.s, t.s, i),
                            o = Wl.lerp(e.l, t.l, i);
                        return this.setHSL(r, a, o), this
                    }
                }(),
                equals: function (e) {
                    return e.r === this.r && e.g === this.g && e.b === this.b
                },
                fromArray: function (e, t) {
                    return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
                },
                toJSON: function () {
                    return this.getHex()
                }
            });
            var ch = {
                    common: {
                        diffuse: {
                            value: new x(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new o
                        },
                        alphaMap: {
                            value: null
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        refractionRatio: {
                            value: .98
                        },
                        maxMipLevel: {
                            value: 0
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new n(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new x(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        }
                    },
                    points: {
                        diffuse: {
                            value: new x(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new o
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new x(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new n(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new o
                        }
                    }
                },
                uh = {
                    basic: {
                        uniforms: y([ch.common, ch.specularmap, ch.envmap, ch.aomap, ch.lightmap, ch.fog]),
                        vertexShader: oh.meshbasic_vert,
                        fragmentShader: oh.meshbasic_frag
                    },
                    lambert: {
                        uniforms: y([ch.common, ch.specularmap, ch.envmap, ch.aomap, ch.lightmap, ch.emissivemap, ch.fog, ch.lights, {
                            emissive: {
                                value: new x(0)
                            }
                        }]),
                        vertexShader: oh.meshlambert_vert,
                        fragmentShader: oh.meshlambert_frag
                    },
                    phong: {
                        uniforms: y([ch.common, ch.specularmap, ch.envmap, ch.aomap, ch.lightmap, ch.emissivemap, ch.bumpmap, ch.normalmap, ch.displacementmap, ch.gradientmap, ch.fog, ch.lights, {
                            emissive: {
                                value: new x(0)
                            },
                            specular: {
                                value: new x(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: oh.meshphong_vert,
                        fragmentShader: oh.meshphong_frag
                    },
                    standard: {
                        uniforms: y([ch.common, ch.envmap, ch.aomap, ch.lightmap, ch.emissivemap, ch.bumpmap, ch.normalmap, ch.displacementmap, ch.roughnessmap, ch.metalnessmap, ch.fog, ch.lights, {
                            emissive: {
                                value: new x(0)
                            },
                            roughness: {
                                value: .5
                            },
                            metalness: {
                                value: .5
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: oh.meshphysical_vert,
                        fragmentShader: oh.meshphysical_frag
                    },
                    matcap: {
                        uniforms: y([ch.common, ch.bumpmap, ch.normalmap, ch.displacementmap, ch.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: oh.meshmatcap_vert,
                        fragmentShader: oh.meshmatcap_frag
                    },
                    points: {
                        uniforms: y([ch.points, ch.fog]),
                        vertexShader: oh.points_vert,
                        fragmentShader: oh.points_frag
                    },
                    dashed: {
                        uniforms: y([ch.common, ch.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: oh.linedashed_vert,
                        fragmentShader: oh.linedashed_frag
                    },
                    depth: {
                        uniforms: y([ch.common, ch.displacementmap]),
                        vertexShader: oh.depth_vert,
                        fragmentShader: oh.depth_frag
                    },
                    normal: {
                        uniforms: y([ch.common, ch.bumpmap, ch.normalmap, ch.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: oh.normal_vert,
                        fragmentShader: oh.normal_frag
                    },
                    sprite: {
                        uniforms: y([ch.sprite, ch.fog]),
                        vertexShader: oh.sprite_vert,
                        fragmentShader: oh.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new o
                            },
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: oh.background_vert,
                        fragmentShader: oh.background_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: oh.cube_vert,
                        fragmentShader: oh.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: oh.equirect_vert,
                        fragmentShader: oh.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: y([ch.common, ch.displacementmap, {
                            referencePosition: {
                                value: new a
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: oh.distanceRGBA_vert,
                        fragmentShader: oh.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: y([ch.lights, ch.fog, {
                            color: {
                                value: new x(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: oh.shadow_vert,
                        fragmentShader: oh.shadow_frag
                    }
                };
            uh.physical = {
                uniforms: y([uh.standard.uniforms, {
                    clearCoat: {
                        value: 0
                    },
                    clearCoatRoughness: {
                        value: 0
                    }
                }]),
                vertexShader: oh.meshphysical_vert,
                fragmentShader: oh.meshphysical_frag
            }, Object.assign(w.prototype, {
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
                    for (var t = 0, n = e.vertexNormals.length; t < n; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
                    for (var t = 0, n = e.vertexColors.length; t < n; t++) this.vertexColors[t] = e.vertexColors[t].clone();
                    return this
                }
            }), M.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], M.DefaultOrder = "XYZ", Object.defineProperties(M.prototype, {
                x: {
                    get: function () {
                        return this._x
                    },
                    set: function (e) {
                        this._x = e, this.onChangeCallback()
                    }
                },
                y: {
                    get: function () {
                        return this._y
                    },
                    set: function (e) {
                        this._y = e, this.onChangeCallback()
                    }
                },
                z: {
                    get: function () {
                        return this._z
                    },
                    set: function (e) {
                        this._z = e, this.onChangeCallback()
                    }
                },
                order: {
                    get: function () {
                        return this._order
                    },
                    set: function (e) {
                        this._order = e, this.onChangeCallback()
                    }
                }
            }), Object.assign(M.prototype, {
                isEuler: !0,
                set: function (e, t, n, i) {
                    return this._x = e, this._y = t, this._z = n, this._order = i || this._order, this.onChangeCallback(), this
                },
                clone: function () {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                },
                copy: function (e) {
                    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this
                },
                setFromRotationMatrix: function (e, t, n) {
                    var i = Wl.clamp,
                        r = e.elements,
                        a = r[0],
                        o = r[4],
                        s = r[8],
                        l = r[1],
                        c = r[5],
                        u = r[9],
                        h = r[2],
                        d = r[6],
                        p = r[10];
                    return t = t || this._order, "XYZ" === t ? (this._y = Math.asin(i(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(d, c), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-i(u, -1, 1)), Math.abs(u) < .99999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, a), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(i(d, -1, 1)), Math.abs(d) < .99999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, a))) : "ZYX" === t ? (this._y = Math.asin(-i(h, -1, 1)), Math.abs(h) < .99999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(l, a)) : (this._x = 0, this._z = Math.atan2(-o, c))) : "YZX" === t ? (this._z = Math.asin(i(l, -1, 1)), Math.abs(l) < .99999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-h, a)) : (this._x = 0, this._y = Math.atan2(s, p))) : "XZY" === t ? (this._z = Math.asin(-i(o, -1, 1)), Math.abs(o) < .99999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-u, p), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, n !== !1 && this.onChangeCallback(), this
                },
                setFromQuaternion: function () {
                    var e = new i;
                    return function (t, n, i) {
                        return e.makeRotationFromQuaternion(t), this.setFromRotationMatrix(e, n, i)
                    }
                }(),
                setFromVector3: function (e, t) {
                    return this.set(e.x, e.y, e.z, t || this._order)
                },
                reorder: function () {
                    var e = new r;
                    return function (t) {
                        return e.setFromEuler(this), this.setFromQuaternion(e, t)
                    }
                }(),
                equals: function (e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                },
                fromArray: function (e) {
                    return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this.onChangeCallback(), this
                },
                toArray: function (e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
                },
                toVector3: function (e) {
                    return e ? e.set(this._x, this._y, this._z) : new a(this._x, this._y, this._z)
                },
                onChange: function (e) {
                    return this.onChangeCallback = e, this
                },
                onChangeCallback: function () {}
            }), Object.assign(T.prototype, {
                set: function (e) {
                    this.mask = 1 << e | 0
                },
                enable: function (e) {
                    this.mask |= 1 << e | 0
                },
                toggle: function (e) {
                    this.mask ^= 1 << e | 0
                },
                disable: function (e) {
                    this.mask &= ~(1 << e | 0)
                },
                test: function (e) {
                    return 0 !== (this.mask & e.mask)
                }
            });
            var hh = 0;
            E.DefaultUp = new a(0, 1, 0), E.DefaultMatrixAutoUpdate = !0, E.prototype = Object.assign(Object.create(t.prototype), {
                constructor: E,
                isObject3D: !0,
                onBeforeRender: function () {},
                onAfterRender: function () {},
                applyMatrix: function (e) {
                    this.matrix.multiplyMatrices(e, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                applyQuaternion: function (e) {
                    return this.quaternion.premultiply(e), this
                },
                setRotationFromAxisAngle: function (e, t) {
                    this.quaternion.setFromAxisAngle(e, t)
                },
                setRotationFromEuler: function (e) {
                    this.quaternion.setFromEuler(e, !0)
                },
                setRotationFromMatrix: function (e) {
                    this.quaternion.setFromRotationMatrix(e)
                },
                setRotationFromQuaternion: function (e) {
                    this.quaternion.copy(e)
                },
                rotateOnAxis: function () {
                    var e = new r;
                    return function (t, n) {
                        return e.setFromAxisAngle(t, n), this.quaternion.multiply(e), this
                    }
                }(),
                rotateOnWorldAxis: function () {
                    var e = new r;
                    return function (t, n) {
                        return e.setFromAxisAngle(t, n), this.quaternion.premultiply(e), this
                    }
                }(),
                rotateX: function () {
                    var e = new a(1, 0, 0);
                    return function (t) {
                        return this.rotateOnAxis(e, t)
                    }
                }(),
                rotateY: function () {
                    var e = new a(0, 1, 0);
                    return function (t) {
                        return this.rotateOnAxis(e, t)
                    }
                }(),
                rotateZ: function () {
                    var e = new a(0, 0, 1);
                    return function (t) {
                        return this.rotateOnAxis(e, t)
                    }
                }(),
                translateOnAxis: function () {
                    var e = new a;
                    return function (t, n) {
                        return e.copy(t).applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(n)), this
                    }
                }(),
                translateX: function () {
                    var e = new a(1, 0, 0);
                    return function (t) {
                        return this.translateOnAxis(e, t)
                    }
                }(),
                translateY: function () {
                    var e = new a(0, 1, 0);
                    return function (t) {
                        return this.translateOnAxis(e, t)
                    }
                }(),
                translateZ: function () {
                    var e = new a(0, 0, 1);
                    return function (t) {
                        return this.translateOnAxis(e, t)
                    }
                }(),
                localToWorld: function (e) {
                    return e.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: function () {
                    var e = new i;
                    return function (t) {
                        return t.applyMatrix4(e.getInverse(this.matrixWorld))
                    }
                }(),
                lookAt: function () {
                    var e = new r,
                        t = new i,
                        n = new a,
                        o = new a;
                    return function (i, r, a) {
                        i.isVector3 ? n.copy(i) : n.set(i, r, a);
                        var s = this.parent;
                        this.updateWorldMatrix(!0, !1), o.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? t.lookAt(o, n, this.up) : t.lookAt(n, o, this.up), this.quaternion.setFromRotationMatrix(t), s && (t.extractRotation(s.matrixWorld), e.setFromRotationMatrix(t), this.quaternion.premultiply(e.inverse()))
                    }
                }(),
                add: function (e) {
                    if (arguments.length > 1) {
                        for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                        return this
                    }
                    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({
                        type: "added"
                    }), this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
                },
                remove: function (e) {
                    if (arguments.length > 1) {
                        for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                        return this
                    }
                    var n = this.children.indexOf(e);
                    return n !== -1 && (e.parent = null, e.dispatchEvent({
                        type: "removed"
                    }), this.children.splice(n, 1)), this
                },
                getObjectById: function (e) {
                    return this.getObjectByProperty("id", e)
                },
                getObjectByName: function (e) {
                    return this.getObjectByProperty("name", e)
                },
                getObjectByProperty: function (e, t) {
                    if (this[e] === t) return this;
                    for (var n = 0, i = this.children.length; n < i; n++) {
                        var r = this.children[n],
                            a = r.getObjectByProperty(e, t);
                        if (void 0 !== a) return a
                    }
                },
                getWorldPosition: function (e) {
                    return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new a), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: function () {
                    var e = new a,
                        t = new a;
                    return function (n) {
                        return void 0 === n && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), n = new r), this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, n, t), n
                    }
                }(),
                getWorldScale: function () {
                    var e = new a,
                        t = new r;
                    return function (n) {
                        return void 0 === n && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), n = new a), this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, t, n), n
                    }
                }(),
                getWorldDirection: function (e) {
                    void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e = new a), this.updateMatrixWorld(!0);
                    var t = this.matrixWorld.elements;
                    return e.set(t[8], t[9], t[10]).normalize()
                },
                raycast: function () {},
                traverse: function (e) {
                    e(this);
                    for (var t = this.children, n = 0, i = t.length; n < i; n++) t[n].traverse(e)
                },
                traverseVisible: function (e) {
                    if (this.visible !== !1) {
                        e(this);
                        for (var t = this.children, n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e)
                    }
                },
                traverseAncestors: function (e) {
                    var t = this.parent;
                    null !== t && (e(t), t.traverseAncestors(e))
                },
                updateMatrix: function () {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function (e) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
                    for (var t = this.children, n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e)
                },
                updateWorldMatrix: function (e, t) {
                    var n = this.parent;
                    if (e === !0 && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0)
                        for (var i = this.children, r = 0, a = i.length; r < a; r++) i[r].updateWorldMatrix(!1, !0)
                },
                toJSON: function (e) {
                    function t(t, n) {
                        return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
                    }

                    function n(e) {
                        var t = [];
                        for (var n in e) {
                            var i = e[n];
                            delete i.metadata, t.push(i)
                        }
                        return t
                    }
                    var i = void 0 === e || "string" == typeof e,
                        r = {};
                    i && (e = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {}
                    }, r.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    var a = {};
                    if (a.uuid = this.uuid, a.type = this.type, "" !== this.name && (a.name = this.name), this.castShadow === !0 && (a.castShadow = !0), this.receiveShadow === !0 && (a.receiveShadow = !0), this.visible === !1 && (a.visible = !1), this.frustumCulled === !1 && (a.frustumCulled = !1), 0 !== this.renderOrder && (a.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (a.userData = this.userData), a.layers = this.layers.mask, a.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (a.matrixAutoUpdate = !1), this.isMesh && this.drawMode !== Ll && (a.drawMode = this.drawMode), this.isMesh || this.isLine || this.isPoints) {
                        a.geometry = t(e.geometries, this.geometry);
                        var o = this.geometry.parameters;
                        if (void 0 !== o && void 0 !== o.shapes) {
                            var s = o.shapes;
                            if (Array.isArray(s))
                                for (var l = 0, c = s.length; l < c; l++) {
                                    var u = s[l];
                                    t(e.shapes, u)
                                } else t(e.shapes, s)
                        }
                    }
                    if (void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            for (var h = [], l = 0, c = this.material.length; l < c; l++) h.push(t(e.materials, this.material[l]));
                            a.material = h
                        } else a.material = t(e.materials, this.material);
                    if (this.children.length > 0) {
                        a.children = [];
                        for (var l = 0; l < this.children.length; l++) a.children.push(this.children[l].toJSON(e).object)
                    }
                    if (i) {
                        var d = n(e.geometries),
                            p = n(e.materials),
                            f = n(e.textures),
                            m = n(e.images),
                            s = n(e.shapes);
                        d.length > 0 && (r.geometries = d), p.length > 0 && (r.materials = p), f.length > 0 && (r.textures = f), m.length > 0 && (r.images = m), s.length > 0 && (r.shapes = s)
                    }
                    return r.object = a, r
                },
                clone: function (e) {
                    return (new this.constructor).copy(this, e)
                },
                copy: function (e, t) {
                    if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
                        for (var n = 0; n < e.children.length; n++) {
                            var i = e.children[n];
                            this.add(i.clone())
                        }
                    return this
                }
            });
            var dh = 0;
            S.prototype = Object.assign(Object.create(t.prototype), {
                constructor: S,
                isGeometry: !0,
                applyMatrix: function (e) {
                    for (var t = (new o).getNormalMatrix(e), n = 0, i = this.vertices.length; n < i; n++) {
                        var r = this.vertices[n];
                        r.applyMatrix4(e)
                    }
                    for (var n = 0, i = this.faces.length; n < i; n++) {
                        var a = this.faces[n];
                        a.normal.applyMatrix3(t).normalize();
                        for (var s = 0, l = a.vertexNormals.length; s < l; s++) a.vertexNormals[s].applyMatrix3(t).normalize()
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
                },
                rotateX: function () {
                    var e = new i;
                    return function (t) {
                        return e.makeRotationX(t), this.applyMatrix(e), this
                    }
                }(),
                rotateY: function () {
                    var e = new i;
                    return function (t) {
                        return e.makeRotationY(t), this.applyMatrix(e), this
                    }
                }(),
                rotateZ: function () {
                    var e = new i;
                    return function (t) {
                        return e.makeRotationZ(t), this.applyMatrix(e), this
                    }
                }(),
                translate: function () {
                    var e = new i;
                    return function (t, n, i) {
                        return e.makeTranslation(t, n, i), this.applyMatrix(e), this
                    }
                }(),
                scale: function () {
                    var e = new i;
                    return function (t, n, i) {
                        return e.makeScale(t, n, i), this.applyMatrix(e), this
                    }
                }(),
                lookAt: function () {
                    var e = new E;
                    return function (t) {
                        e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix)
                    }
                }(),
                fromBufferGeometry: function (e) {
                    function t(e, t, r, o) {
                        var s = void 0 === c ? [] : [i.colors[e].clone(), i.colors[t].clone(), i.colors[r].clone()],
                            d = void 0 === l ? [] : [(new a).fromArray(l, 3 * e), (new a).fromArray(l, 3 * t), (new a).fromArray(l, 3 * r)],
                            p = new w(e, t, r, d, s, o);
                        i.faces.push(p), void 0 !== u && i.faceVertexUvs[0].push([(new n).fromArray(u, 2 * e), (new n).fromArray(u, 2 * t), (new n).fromArray(u, 2 * r)]), void 0 !== h && i.faceVertexUvs[1].push([(new n).fromArray(h, 2 * e), (new n).fromArray(h, 2 * t), (new n).fromArray(h, 2 * r)])
                    }
                    var i = this,
                        r = null !== e.index ? e.index.array : void 0,
                        o = e.attributes,
                        s = o.position.array,
                        l = void 0 !== o.normal ? o.normal.array : void 0,
                        c = void 0 !== o.color ? o.color.array : void 0,
                        u = void 0 !== o.uv ? o.uv.array : void 0,
                        h = void 0 !== o.uv2 ? o.uv2.array : void 0;
                    void 0 !== h && (this.faceVertexUvs[1] = []);
                    for (var d = 0, p = 0; d < s.length; d += 3, p += 2) i.vertices.push((new a).fromArray(s, d)), void 0 !== c && i.colors.push((new x).fromArray(c, d));
                    var f = e.groups;
                    if (f.length > 0)
                        for (var d = 0; d < f.length; d++)
                            for (var m = f[d], v = m.start, g = m.count, p = v, y = v + g; p < y; p += 3) void 0 !== r ? t(r[p], r[p + 1], r[p + 2], m.materialIndex) : t(p, p + 1, p + 2, m.materialIndex);
                    else if (void 0 !== r)
                        for (var d = 0; d < r.length; d += 3) t(r[d], r[d + 1], r[d + 2]);
                    else
                        for (var d = 0; d < s.length / 3; d += 3) t(d, d + 1, d + 2);
                    return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
                },
                center: function () {
                    var e = new a;
                    return function () {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(e).negate(), this.translate(e.x, e.y, e.z), this
                    }
                }(),
                normalize: function () {
                    this.computeBoundingSphere();
                    var e = this.boundingSphere.center,
                        t = this.boundingSphere.radius,
                        n = 0 === t ? 1 : 1 / t,
                        r = new i;
                    return r.set(n, 0, 0, -n * e.x, 0, n, 0, -n * e.y, 0, 0, n, -n * e.z, 0, 0, 0, 1), this.applyMatrix(r), this
                },
                computeFaceNormals: function () {
                    for (var e = new a, t = new a, n = 0, i = this.faces.length; n < i; n++) {
                        var r = this.faces[n],
                            o = this.vertices[r.a],
                            s = this.vertices[r.b],
                            l = this.vertices[r.c];
                        e.subVectors(l, s), t.subVectors(o, s), e.cross(t), e.normalize(), r.normal.copy(e)
                    }
                },
                computeVertexNormals: function (e) {
                    void 0 === e && (e = !0);
                    var t, n, i, r, o, s;
                    for (s = new Array(this.vertices.length), t = 0, n = this.vertices.length; t < n; t++) s[t] = new a;
                    if (e) {
                        var l, c, u, h = new a,
                            d = new a;
                        for (i = 0, r = this.faces.length; i < r; i++) o = this.faces[i], l = this.vertices[o.a], c = this.vertices[o.b], u = this.vertices[o.c], h.subVectors(u, c), d.subVectors(l, c), h.cross(d), s[o.a].add(h), s[o.b].add(h), s[o.c].add(h)
                    } else
                        for (this.computeFaceNormals(), i = 0, r = this.faces.length; i < r; i++) o = this.faces[i], s[o.a].add(o.normal), s[o.b].add(o.normal), s[o.c].add(o.normal);
                    for (t = 0, n = this.vertices.length; t < n; t++) s[t].normalize();
                    for (i = 0, r = this.faces.length; i < r; i++) {
                        o = this.faces[i];
                        var p = o.vertexNormals;
                        3 === p.length ? (p[0].copy(s[o.a]), p[1].copy(s[o.b]), p[2].copy(s[o.c])) : (p[0] = s[o.a].clone(), p[1] = s[o.b].clone(), p[2] = s[o.c].clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeFlatVertexNormals: function () {
                    var e, t, n;
                    for (this.computeFaceNormals(), e = 0, t = this.faces.length; e < t; e++) {
                        n = this.faces[e];
                        var i = n.vertexNormals;
                        3 === i.length ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal)) : (i[0] = n.normal.clone(), i[1] = n.normal.clone(), i[2] = n.normal.clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function () {
                    var e, t, n, i, r;
                    for (n = 0, i = this.faces.length; n < i; n++)
                        for (r = this.faces[n], r.__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), e = 0, t = r.vertexNormals.length; e < t; e++) r.__originalVertexNormals[e] ? r.__originalVertexNormals[e].copy(r.vertexNormals[e]) : r.__originalVertexNormals[e] = r.vertexNormals[e].clone();
                    var o = new S;
                    for (o.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) {
                        if (!this.morphNormals[e]) {
                            this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
                            var s, l, c = this.morphNormals[e].faceNormals,
                                u = this.morphNormals[e].vertexNormals;
                            for (n = 0, i = this.faces.length; n < i; n++) s = new a, l = {
                                a: new a,
                                b: new a,
                                c: new a
                            }, c.push(s), u.push(l)
                        }
                        var h = this.morphNormals[e];
                        o.vertices = this.morphTargets[e].vertices, o.computeFaceNormals(), o.computeVertexNormals();
                        var s, l;
                        for (n = 0, i = this.faces.length; n < i; n++) r = this.faces[n], s = h.faceNormals[n], l = h.vertexNormals[n], s.copy(r.normal), l.a.copy(r.vertexNormals[0]), l.b.copy(r.vertexNormals[1]), l.c.copy(r.vertexNormals[2])
                    }
                    for (n = 0, i = this.faces.length; n < i; n++) r = this.faces[n],
                        r.normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals
                },
                computeBoundingBox: function () {
                    null === this.boundingBox && (this.boundingBox = new p), this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function () {
                    null === this.boundingSphere && (this.boundingSphere = new f), this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function (e, t, n) {
                    if (!e || !e.isGeometry) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e);
                    var i, r = this.vertices.length,
                        a = this.vertices,
                        s = e.vertices,
                        l = this.faces,
                        c = e.faces,
                        u = this.faceVertexUvs[0],
                        h = e.faceVertexUvs[0],
                        d = this.colors,
                        p = e.colors;
                    void 0 === n && (n = 0), void 0 !== t && (i = (new o).getNormalMatrix(t));
                    for (var f = 0, m = s.length; f < m; f++) {
                        var v = s[f],
                            g = v.clone();
                        void 0 !== t && g.applyMatrix4(t), a.push(g)
                    }
                    for (var f = 0, m = p.length; f < m; f++) d.push(p[f].clone());
                    for (f = 0, m = c.length; f < m; f++) {
                        var y, x, b, _ = c[f],
                            M = _.vertexNormals,
                            T = _.vertexColors;
                        y = new w(_.a + r, _.b + r, _.c + r), y.normal.copy(_.normal), void 0 !== i && y.normal.applyMatrix3(i).normalize();
                        for (var E = 0, S = M.length; E < S; E++) x = M[E].clone(), void 0 !== i && x.applyMatrix3(i).normalize(), y.vertexNormals.push(x);
                        y.color.copy(_.color);
                        for (var E = 0, S = T.length; E < S; E++) b = T[E], y.vertexColors.push(b.clone());
                        y.materialIndex = _.materialIndex + n, l.push(y)
                    }
                    for (f = 0, m = h.length; f < m; f++) {
                        var P = h[f],
                            C = [];
                        if (void 0 !== P) {
                            for (var E = 0, S = P.length; E < S; E++) C.push(P[E].clone());
                            u.push(C)
                        }
                    }
                },
                mergeMesh: function (e) {
                    return e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), void this.merge(e.geometry, e.matrix)) : void console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e)
                },
                mergeVertices: function () {
                    var e, t, n, i, r, a, o, s, l = {},
                        c = [],
                        u = [],
                        h = 4,
                        d = Math.pow(10, h);
                    for (n = 0, i = this.vertices.length; n < i; n++) e = this.vertices[n], t = Math.round(e.x * d) + "_" + Math.round(e.y * d) + "_" + Math.round(e.z * d), void 0 === l[t] ? (l[t] = n, c.push(this.vertices[n]), u[n] = c.length - 1) : u[n] = u[l[t]];
                    var p = [];
                    for (n = 0, i = this.faces.length; n < i; n++) {
                        r = this.faces[n], r.a = u[r.a], r.b = u[r.b], r.c = u[r.c], a = [r.a, r.b, r.c];
                        for (var f = 0; f < 3; f++)
                            if (a[f] === a[(f + 1) % 3]) {
                                p.push(n);
                                break
                            }
                    }
                    for (n = p.length - 1; n >= 0; n--) {
                        var m = p[n];
                        for (this.faces.splice(m, 1), o = 0, s = this.faceVertexUvs.length; o < s; o++) this.faceVertexUvs[o].splice(m, 1)
                    }
                    var v = this.vertices.length - c.length;
                    return this.vertices = c, v
                },
                setFromPoints: function (e) {
                    this.vertices = [];
                    for (var t = 0, n = e.length; t < n; t++) {
                        var i = e[t];
                        this.vertices.push(new a(i.x, i.y, i.z || 0))
                    }
                    return this
                },
                sortFacesByMaterialIndex: function () {
                    function e(e, t) {
                        return e.materialIndex - t.materialIndex
                    }
                    for (var t = this.faces, n = t.length, i = 0; i < n; i++) t[i]._id = i;
                    t.sort(e);
                    var r, a, o = this.faceVertexUvs[0],
                        s = this.faceVertexUvs[1];
                    o && o.length === n && (r = []), s && s.length === n && (a = []);
                    for (var i = 0; i < n; i++) {
                        var l = t[i]._id;
                        r && r.push(o[l]), a && a.push(s[l])
                    }
                    r && (this.faceVertexUvs[0] = r), a && (this.faceVertexUvs[1] = a)
                },
                toJSON: function () {
                    function e(e, t, n) {
                        return n ? e | 1 << t : e & ~(1 << t)
                    }

                    function t(e) {
                        var t = e.x.toString() + e.y.toString() + e.z.toString();
                        return void 0 !== d[t] ? d[t] : (d[t] = h.length / 3, h.push(e.x, e.y, e.z), d[t])
                    }

                    function n(e) {
                        var t = e.r.toString() + e.g.toString() + e.b.toString();
                        return void 0 !== f[t] ? f[t] : (f[t] = p.length, p.push(e.getHex()), f[t])
                    }

                    function i(e) {
                        var t = e.x.toString() + e.y.toString();
                        return void 0 !== v[t] ? v[t] : (v[t] = m.length / 2, m.push(e.x, e.y), v[t])
                    }
                    var r = {
                        metadata: {
                            version: 4.5,
                            type: "Geometry",
                            generator: "Geometry.toJSON"
                        }
                    };
                    if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), void 0 !== this.parameters) {
                        var a = this.parameters;
                        for (var o in a) void 0 !== a[o] && (r[o] = a[o]);
                        return r
                    }
                    for (var s = [], l = 0; l < this.vertices.length; l++) {
                        var c = this.vertices[l];
                        s.push(c.x, c.y, c.z)
                    }
                    for (var u = [], h = [], d = {}, p = [], f = {}, m = [], v = {}, l = 0; l < this.faces.length; l++) {
                        var g = this.faces[l],
                            y = !0,
                            x = !1,
                            b = void 0 !== this.faceVertexUvs[0][l],
                            _ = g.normal.length() > 0,
                            w = g.vertexNormals.length > 0,
                            M = 1 !== g.color.r || 1 !== g.color.g || 1 !== g.color.b,
                            T = g.vertexColors.length > 0,
                            E = 0;
                        if (E = e(E, 0, 0), E = e(E, 1, y), E = e(E, 2, x), E = e(E, 3, b), E = e(E, 4, _), E = e(E, 5, w), E = e(E, 6, M), E = e(E, 7, T), u.push(E), u.push(g.a, g.b, g.c), u.push(g.materialIndex), b) {
                            var S = this.faceVertexUvs[0][l];
                            u.push(i(S[0]), i(S[1]), i(S[2]))
                        }
                        if (_ && u.push(t(g.normal)), w) {
                            var P = g.vertexNormals;
                            u.push(t(P[0]), t(P[1]), t(P[2]))
                        }
                        if (M && u.push(n(g.color)), T) {
                            var C = g.vertexColors;
                            u.push(n(C[0]), n(C[1]), n(C[2]))
                        }
                    }
                    return r.data = {}, r.data.vertices = s, r.data.normals = h, p.length > 0 && (r.data.colors = p), m.length > 0 && (r.data.uvs = [m]), r.data.faces = u, r
                },
                clone: function () {
                    return (new S).copy(this)
                },
                copy: function (e) {
                    var t, n, i, r, a, o;
                    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
                    var s = e.vertices;
                    for (t = 0, n = s.length; t < n; t++) this.vertices.push(s[t].clone());
                    var l = e.colors;
                    for (t = 0, n = l.length; t < n; t++) this.colors.push(l[t].clone());
                    var c = e.faces;
                    for (t = 0, n = c.length; t < n; t++) this.faces.push(c[t].clone());
                    for (t = 0, n = e.faceVertexUvs.length; t < n; t++) {
                        var u = e.faceVertexUvs[t];
                        for (void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []), i = 0, r = u.length; i < r; i++) {
                            var h = u[i],
                                d = [];
                            for (a = 0, o = h.length; a < o; a++) {
                                var p = h[a];
                                d.push(p.clone())
                            }
                            this.faceVertexUvs[t].push(d)
                        }
                    }
                    var f = e.morphTargets;
                    for (t = 0, n = f.length; t < n; t++) {
                        var m = {};
                        if (m.name = f[t].name, void 0 !== f[t].vertices)
                            for (m.vertices = [], i = 0, r = f[t].vertices.length; i < r; i++) m.vertices.push(f[t].vertices[i].clone());
                        if (void 0 !== f[t].normals)
                            for (m.normals = [], i = 0, r = f[t].normals.length; i < r; i++) m.normals.push(f[t].normals[i].clone());
                        this.morphTargets.push(m)
                    }
                    var v = e.morphNormals;
                    for (t = 0, n = v.length; t < n; t++) {
                        var g = {};
                        if (void 0 !== v[t].vertexNormals)
                            for (g.vertexNormals = [], i = 0, r = v[t].vertexNormals.length; i < r; i++) {
                                var y = v[t].vertexNormals[i],
                                    x = {};
                                x.a = y.a.clone(), x.b = y.b.clone(), x.c = y.c.clone(), g.vertexNormals.push(x)
                            }
                        if (void 0 !== v[t].faceNormals)
                            for (g.faceNormals = [], i = 0, r = v[t].faceNormals.length; i < r; i++) g.faceNormals.push(v[t].faceNormals[i].clone());
                        this.morphNormals.push(g)
                    }
                    var b = e.skinWeights;
                    for (t = 0, n = b.length; t < n; t++) this.skinWeights.push(b[t].clone());
                    var _ = e.skinIndices;
                    for (t = 0, n = _.length; t < n; t++) this.skinIndices.push(_[t].clone());
                    var w = e.lineDistances;
                    for (t = 0, n = w.length; t < n; t++) this.lineDistances.push(w[t]);
                    var M = e.boundingBox;
                    null !== M && (this.boundingBox = M.clone());
                    var T = e.boundingSphere;
                    return null !== T && (this.boundingSphere = T.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
                },
                dispose: function () {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Object.defineProperty(P.prototype, "needsUpdate", {
                set: function (e) {
                    e === !0 && this.version++
                }
            }), Object.assign(P.prototype, {
                isBufferAttribute: !0,
                onUploadCallback: function () {},
                setArray: function (e) {
                    if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    return this.count = void 0 !== e ? e.length / this.itemSize : 0, this.array = e, this
                },
                setDynamic: function (e) {
                    return this.dynamic = e, this
                },
                copy: function (e) {
                    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.dynamic = e.dynamic, this
                },
                copyAt: function (e, t, n) {
                    e *= this.itemSize, n *= t.itemSize;
                    for (var i = 0, r = this.itemSize; i < r; i++) this.array[e + i] = t.array[n + i];
                    return this
                },
                copyArray: function (e) {
                    return this.array.set(e), this
                },
                copyColorsArray: function (e) {
                    for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
                        var a = e[i];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), a = new x), t[n++] = a.r, t[n++] = a.g, t[n++] = a.b
                    }
                    return this
                },
                copyVector2sArray: function (e) {
                    for (var t = this.array, i = 0, r = 0, a = e.length; r < a; r++) {
                        var o = e[r];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), o = new n), t[i++] = o.x, t[i++] = o.y
                    }
                    return this
                },
                copyVector3sArray: function (e) {
                    for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
                        var o = e[i];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), o = new a), t[n++] = o.x, t[n++] = o.y, t[n++] = o.z
                    }
                    return this
                },
                copyVector4sArray: function (e) {
                    for (var t = this.array, n = 0, i = 0, r = e.length; i < r; i++) {
                        var a = e[i];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), a = new l), t[n++] = a.x, t[n++] = a.y, t[n++] = a.z, t[n++] = a.w
                    }
                    return this
                },
                set: function (e, t) {
                    return void 0 === t && (t = 0), this.array.set(e, t), this
                },
                getX: function (e) {
                    return this.array[e * this.itemSize]
                },
                setX: function (e, t) {
                    return this.array[e * this.itemSize] = t, this
                },
                getY: function (e) {
                    return this.array[e * this.itemSize + 1]
                },
                setY: function (e, t) {
                    return this.array[e * this.itemSize + 1] = t, this
                },
                getZ: function (e) {
                    return this.array[e * this.itemSize + 2]
                },
                setZ: function (e, t) {
                    return this.array[e * this.itemSize + 2] = t, this
                },
                getW: function (e) {
                    return this.array[e * this.itemSize + 3]
                },
                setW: function (e, t) {
                    return this.array[e * this.itemSize + 3] = t, this
                },
                setXY: function (e, t, n) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this
                },
                setXYZ: function (e, t, n, i) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this
                },
                setXYZW: function (e, t, n, i, r) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this
                },
                onUpload: function (e) {
                    return this.onUploadCallback = e, this
                },
                clone: function () {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                }
            }), C.prototype = Object.create(P.prototype), C.prototype.constructor = C, A.prototype = Object.create(P.prototype), A.prototype.constructor = A, L.prototype = Object.create(P.prototype), L.prototype.constructor = L, R.prototype = Object.create(P.prototype), R.prototype.constructor = R, I.prototype = Object.create(P.prototype), I.prototype.constructor = I, O.prototype = Object.create(P.prototype), O.prototype.constructor = O, k.prototype = Object.create(P.prototype), k.prototype.constructor = k, D.prototype = Object.create(P.prototype), D.prototype.constructor = D, z.prototype = Object.create(P.prototype), z.prototype.constructor = z, Object.assign(B.prototype, {
                computeGroups: function (e) {
                    for (var t, n = [], i = void 0, r = e.faces, a = 0; a < r.length; a++) {
                        var o = r[a];
                        o.materialIndex !== i && (i = o.materialIndex, void 0 !== t && (t.count = 3 * a - t.start, n.push(t)), t = {
                            start: 3 * a,
                            materialIndex: i
                        })
                    }
                    void 0 !== t && (t.count = 3 * a - t.start, n.push(t)), this.groups = n
                },
                fromGeometry: function (e) {
                    var t, i = e.faces,
                        r = e.vertices,
                        a = e.faceVertexUvs,
                        o = a[0] && a[0].length > 0,
                        s = a[1] && a[1].length > 0,
                        l = e.morphTargets,
                        c = l.length;
                    if (c > 0) {
                        t = [];
                        for (var u = 0; u < c; u++) t[u] = {
                            name: l[u].name,
                            data: []
                        };
                        this.morphTargets.position = t
                    }
                    var h, d = e.morphNormals,
                        p = d.length;
                    if (p > 0) {
                        h = [];
                        for (var u = 0; u < p; u++) h[u] = {
                            name: d[u].name,
                            data: []
                        };
                        this.morphTargets.normal = h
                    }
                    var f = e.skinIndices,
                        m = e.skinWeights,
                        v = f.length === r.length,
                        g = m.length === r.length;
                    r.length > 0 && 0 === i.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
                    for (var u = 0; u < i.length; u++) {
                        var y = i[u];
                        this.vertices.push(r[y.a], r[y.b], r[y.c]);
                        var x = y.vertexNormals;
                        if (3 === x.length) this.normals.push(x[0], x[1], x[2]);
                        else {
                            var b = y.normal;
                            this.normals.push(b, b, b)
                        }
                        var _ = y.vertexColors;
                        if (3 === _.length) this.colors.push(_[0], _[1], _[2]);
                        else {
                            var w = y.color;
                            this.colors.push(w, w, w)
                        }
                        if (o === !0) {
                            var M = a[0][u];
                            void 0 !== M ? this.uvs.push(M[0], M[1], M[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", u), this.uvs.push(new n, new n, new n))
                        }
                        if (s === !0) {
                            var M = a[1][u];
                            void 0 !== M ? this.uvs2.push(M[0], M[1], M[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", u), this.uvs2.push(new n, new n, new n))
                        }
                        for (var T = 0; T < c; T++) {
                            var E = l[T].vertices;
                            t[T].data.push(E[y.a], E[y.b], E[y.c])
                        }
                        for (var T = 0; T < p; T++) {
                            var S = d[T].vertexNormals[u];
                            h[T].data.push(S.a, S.b, S.c)
                        }
                        v && this.skinIndices.push(f[y.a], f[y.b], f[y.c]), g && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
                    }
                    return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
                }
            });
            var ph = 1;
            U.prototype = Object.assign(Object.create(t.prototype), {
                constructor: U,
                isBufferGeometry: !0,
                getIndex: function () {
                    return this.index
                },
                setIndex: function (e) {
                    Array.isArray(e) ? this.index = new(N(e) > 65535 ? k : I)(e, 1) : this.index = e
                },
                addAttribute: function (e, t) {
                    return t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : (this.attributes[e] = t, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(e, new P(arguments[1], arguments[2])))
                },
                getAttribute: function (e) {
                    return this.attributes[e]
                },
                removeAttribute: function (e) {
                    return delete this.attributes[e], this
                },
                addGroup: function (e, t, n) {
                    this.groups.push({
                        start: e,
                        count: t,
                        materialIndex: void 0 !== n ? n : 0
                    })
                },
                clearGroups: function () {
                    this.groups = []
                },
                setDrawRange: function (e, t) {
                    this.drawRange.start = e, this.drawRange.count = t
                },
                applyMatrix: function (e) {
                    var t = this.attributes.position;
                    void 0 !== t && (e.applyToBufferAttribute(t), t.needsUpdate = !0);
                    var n = this.attributes.normal;
                    if (void 0 !== n) {
                        var i = (new o).getNormalMatrix(e);
                        i.applyToBufferAttribute(n), n.needsUpdate = !0
                    }
                    var r = this.attributes.tangent;
                    if (void 0 !== r) {
                        var i = (new o).getNormalMatrix(e);
                        i.applyToBufferAttribute(r), r.needsUpdate = !0
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                },
                rotateX: function () {
                    var e = new i;
                    return function (t) {
                        return e.makeRotationX(t), this.applyMatrix(e), this
                    }
                }(),
                rotateY: function () {
                    var e = new i;
                    return function (t) {
                        return e.makeRotationY(t), this.applyMatrix(e), this
                    }
                }(),
                rotateZ: function () {
                    var e = new i;
                    return function (t) {
                        return e.makeRotationZ(t), this.applyMatrix(e), this
                    }
                }(),
                translate: function () {
                    var e = new i;
                    return function (t, n, i) {
                        return e.makeTranslation(t, n, i), this.applyMatrix(e), this
                    }
                }(),
                scale: function () {
                    var e = new i;
                    return function (t, n, i) {
                        return e.makeScale(t, n, i), this.applyMatrix(e), this
                    }
                }(),
                lookAt: function () {
                    var e = new E;
                    return function (t) {
                        e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix)
                    }
                }(),
                center: function () {
                    var e = new a;
                    return function () {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(e).negate(), this.translate(e.x, e.y, e.z), this
                    }
                }(),
                setFromObject: function (e) {
                    var t = e.geometry;
                    if (e.isPoints || e.isLine) {
                        var n = new D(3 * t.vertices.length, 3),
                            i = new D(3 * t.colors.length, 3);
                        if (this.addAttribute("position", n.copyVector3sArray(t.vertices)), this.addAttribute("color", i.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) {
                            var r = new D(t.lineDistances.length, 1);
                            this.addAttribute("lineDistance", r.copyArray(t.lineDistances))
                        }
                        null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
                    } else e.isMesh && t && t.isGeometry && this.fromGeometry(t);
                    return this
                },
                setFromPoints: function (e) {
                    for (var t = [], n = 0, i = e.length; n < i; n++) {
                        var r = e[n];
                        t.push(r.x, r.y, r.z || 0)
                    }
                    return this.addAttribute("position", new D(t, 3)), this
                },
                updateFromObject: function (e) {
                    var t = e.geometry;
                    if (e.isMesh) {
                        var n = t.__directGeometry;
                        if (t.elementsNeedUpdate === !0 && (n = void 0, t.elementsNeedUpdate = !1), void 0 === n) return this.fromGeometry(t);
                        n.verticesNeedUpdate = t.verticesNeedUpdate, n.normalsNeedUpdate = t.normalsNeedUpdate, n.colorsNeedUpdate = t.colorsNeedUpdate, n.uvsNeedUpdate = t.uvsNeedUpdate, n.groupsNeedUpdate = t.groupsNeedUpdate, t.verticesNeedUpdate = !1, t.normalsNeedUpdate = !1, t.colorsNeedUpdate = !1, t.uvsNeedUpdate = !1, t.groupsNeedUpdate = !1, t = n
                    }
                    var i;
                    return t.verticesNeedUpdate === !0 && (i = this.attributes.position, void 0 !== i && (i.copyVector3sArray(t.vertices), i.needsUpdate = !0), t.verticesNeedUpdate = !1), t.normalsNeedUpdate === !0 && (i = this.attributes.normal, void 0 !== i && (i.copyVector3sArray(t.normals), i.needsUpdate = !0), t.normalsNeedUpdate = !1), t.colorsNeedUpdate === !0 && (i = this.attributes.color, void 0 !== i && (i.copyColorsArray(t.colors), i.needsUpdate = !0), t.colorsNeedUpdate = !1), t.uvsNeedUpdate && (i = this.attributes.uv, void 0 !== i && (i.copyVector2sArray(t.uvs), i.needsUpdate = !0), t.uvsNeedUpdate = !1), t.lineDistancesNeedUpdate && (i = this.attributes.lineDistance, void 0 !== i && (i.copyArray(t.lineDistances), i.needsUpdate = !0), t.lineDistancesNeedUpdate = !1), t.groupsNeedUpdate && (t.computeGroups(e.geometry), this.groups = t.groups, t.groupsNeedUpdate = !1), this
                },
                fromGeometry: function (e) {
                    return e.__directGeometry = (new B).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry)
                },
                fromDirectGeometry: function (e) {
                    var t = new Float32Array(3 * e.vertices.length);
                    if (this.addAttribute("position", new P(t, 3).copyVector3sArray(e.vertices)), e.normals.length > 0) {
                        var n = new Float32Array(3 * e.normals.length);
                        this.addAttribute("normal", new P(n, 3).copyVector3sArray(e.normals))
                    }
                    if (e.colors.length > 0) {
                        var i = new Float32Array(3 * e.colors.length);
                        this.addAttribute("color", new P(i, 3).copyColorsArray(e.colors))
                    }
                    if (e.uvs.length > 0) {
                        var r = new Float32Array(2 * e.uvs.length);
                        this.addAttribute("uv", new P(r, 2).copyVector2sArray(e.uvs))
                    }
                    if (e.uvs2.length > 0) {
                        var a = new Float32Array(2 * e.uvs2.length);
                        this.addAttribute("uv2", new P(a, 2).copyVector2sArray(e.uvs2))
                    }
                    this.groups = e.groups;
                    for (var o in e.morphTargets) {
                        for (var s = [], l = e.morphTargets[o], c = 0, u = l.length; c < u; c++) {
                            var h = l[c],
                                d = new D(3 * h.data.length, 3);
                            d.name = h.name, s.push(d.copyVector3sArray(h.data))
                        }
                        this.morphAttributes[o] = s
                    }
                    if (e.skinIndices.length > 0) {
                        var p = new D(4 * e.skinIndices.length, 4);
                        this.addAttribute("skinIndex", p.copyVector4sArray(e.skinIndices))
                    }
                    if (e.skinWeights.length > 0) {
                        var f = new D(4 * e.skinWeights.length, 4);
                        this.addAttribute("skinWeight", f.copyVector4sArray(e.skinWeights))
                    }
                    return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
                },
                computeBoundingBox: function () {
                    null === this.boundingBox && (this.boundingBox = new p);
                    var e = this.attributes.position;
                    void 0 !== e ? this.boundingBox.setFromBufferAttribute(e) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                },
                computeBoundingSphere: function () {
                    var e = new p,
                        t = new a;
                    return function () {
                        null === this.boundingSphere && (this.boundingSphere = new f);
                        var n = this.attributes.position;
                        if (n) {
                            var i = this.boundingSphere.center;
                            e.setFromBufferAttribute(n), e.getCenter(i);
                            for (var r = 0, a = 0, o = n.count; a < o; a++) t.x = n.getX(a), t.y = n.getY(a), t.z = n.getZ(a), r = Math.max(r, i.distanceToSquared(t));
                            this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                }(),
                computeFaceNormals: function () {},
                computeVertexNormals: function () {
                    var e = this.index,
                        t = this.attributes;
                    if (t.position) {
                        var n = t.position.array;
                        if (void 0 === t.normal) this.addAttribute("normal", new P(new Float32Array(n.length), 3));
                        else
                            for (var i = t.normal.array, r = 0, o = i.length; r < o; r++) i[r] = 0;
                        var s, l, c, u = t.normal.array,
                            h = new a,
                            d = new a,
                            p = new a,
                            f = new a,
                            m = new a;
                        if (e)
                            for (var v = e.array, r = 0, o = e.count; r < o; r += 3) s = 3 * v[r + 0], l = 3 * v[r + 1], c = 3 * v[r + 2], h.fromArray(n, s), d.fromArray(n, l), p.fromArray(n, c), f.subVectors(p, d), m.subVectors(h, d), f.cross(m), u[s] += f.x, u[s + 1] += f.y, u[s + 2] += f.z, u[l] += f.x, u[l + 1] += f.y, u[l + 2] += f.z, u[c] += f.x, u[c + 1] += f.y, u[c + 2] += f.z;
                        else
                            for (var r = 0, o = n.length; r < o; r += 9) h.fromArray(n, r), d.fromArray(n, r + 3), p.fromArray(n, r + 6), f.subVectors(p, d), m.subVectors(h, d), f.cross(m), u[r] = f.x, u[r + 1] = f.y, u[r + 2] = f.z, u[r + 3] = f.x, u[r + 4] = f.y, u[r + 5] = f.z, u[r + 6] = f.x, u[r + 7] = f.y, u[r + 8] = f.z;
                        this.normalizeNormals(), t.normal.needsUpdate = !0
                    }
                },
                merge: function (e, t) {
                    if (!e || !e.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
                    void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                    var n = this.attributes;
                    for (var i in n)
                        if (void 0 !== e.attributes[i])
                            for (var r = n[i], a = r.array, o = e.attributes[i], s = o.array, l = o.itemSize, c = 0, u = l * t; c < s.length; c++, u++) a[u] = s[c];
                    return this
                },
                normalizeNormals: function () {
                    var e = new a;
                    return function () {
                        for (var t = this.attributes.normal, n = 0, i = t.count; n < i; n++) e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.normalize(), t.setXYZ(n, e.x, e.y, e.z)
                    }
                }(),
                toNonIndexed: function () {
                    function e(e, t) {
                        for (var n = e.array, i = e.itemSize, r = new n.constructor(t.length * i), a = 0, o = 0, s = 0, l = t.length; s < l; s++) {
                            a = t[s] * i;
                            for (var c = 0; c < i; c++) r[o++] = n[a++]
                        }
                        return new P(r, i)
                    }
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                    var t = new U,
                        n = this.index.array,
                        i = this.attributes;
                    for (var r in i) {
                        var a = i[r],
                            o = e(a, n);
                        t.addAttribute(r, o)
                    }
                    var s = this.morphAttributes;
                    for (r in s) {
                        for (var l = [], c = s[r], u = 0, h = c.length; u < h; u++) {
                            var a = c[u],
                                o = e(a, n);
                            l.push(o)
                        }
                        t.morphAttributes[r] = l
                    }
                    for (var d = this.groups, u = 0, p = d.length; u < p; u++) {
                        var f = d[u];
                        t.addGroup(f.start, f.count, f.materialIndex)
                    }
                    return t
                },
                toJSON: function () {
                    var e = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
                        var t = this.parameters;
                        for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
                        return e
                    }
                    e.data = {
                        attributes: {}
                    };
                    var i = this.index;
                    null !== i && (e.data.index = {
                        type: i.array.constructor.name,
                        array: Array.prototype.slice.call(i.array)
                    });
                    var r = this.attributes;
                    for (var n in r) {
                        var a = r[n],
                            o = {
                                itemSize: a.itemSize,
                                type: a.array.constructor.name,
                                array: Array.prototype.slice.call(a.array),
                                normalized: a.normalized
                            };
                        "" !== a.name && (o.name = a.name), e.data.attributes[n] = o
                    }
                    var s = {},
                        l = !1;
                    for (var n in this.morphAttributes) {
                        for (var c = this.morphAttributes[n], u = [], h = 0, d = c.length; h < d; h++) {
                            var a = c[h],
                                o = {
                                    itemSize: a.itemSize,
                                    type: a.array.constructor.name,
                                    array: Array.prototype.slice.call(a.array),
                                    normalized: a.normalized
                                };
                            "" !== a.name && (o.name = a.name), u.push(o)
                        }
                        u.length > 0 && (s[n] = u, l = !0)
                    }
                    l && (e.data.morphAttributes = s);
                    var p = this.groups;
                    p.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(p)));
                    var f = this.boundingSphere;
                    return null !== f && (e.data.boundingSphere = {
                        center: f.center.toArray(),
                        radius: f.radius
                    }), e
                },
                clone: function () {
                    return (new U).copy(this)
                },
                copy: function (e) {
                    var t, n, i;
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name;
                    var r = e.index;
                    null !== r && this.setIndex(r.clone());
                    var a = e.attributes;
                    for (t in a) {
                        var o = a[t];
                        this.addAttribute(t, o.clone())
                    }
                    var s = e.morphAttributes;
                    for (t in s) {
                        var l = [],
                            c = s[t];
                        for (n = 0, i = c.length; n < i; n++) l.push(c[n].clone());
                        this.morphAttributes[t] = l
                    }
                    var u = e.groups;
                    for (n = 0, i = u.length; n < i; n++) {
                        var h = u[n];
                        this.addGroup(h.start, h.count, h.materialIndex)
                    }
                    var d = e.boundingBox;
                    null !== d && (this.boundingBox = d.clone());
                    var p = e.boundingSphere;
                    return null !== p && (this.boundingSphere = p.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
                },
                dispose: function () {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), j.prototype = Object.create(S.prototype), j.prototype.constructor = j, F.prototype = Object.create(U.prototype), F.prototype.constructor = F, G.prototype = Object.create(S.prototype), G.prototype.constructor = G, H.prototype = Object.create(U.prototype), H.prototype.constructor = H;
            var fh = 0;
            V.prototype = Object.assign(Object.create(t.prototype), {
                constructor: V,
                isMaterial: !0,
                onBeforeCompile: function () {},
                setValues: function (e) {
                    if (void 0 !== e)
                        for (var t in e) {
                            var n = e[t];
                            if (void 0 !== n)
                                if ("shading" !== t) {
                                    var i = this[t];
                                    void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                                } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === To;
                            else console.warn("THREE.Material: '" + t + "' parameter is undefined.")
                        }
                },
                toJSON: function (e) {
                    function t(e) {
                        var t = [];
                        for (var n in e) {
                            var i = e[n];
                            delete i.metadata, t.push(i)
                        }
                        return t
                    }
                    var n = void 0 === e || "string" == typeof e;
                    n && (e = {
                        textures: {},
                        images: {}
                    });
                    var i = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };
                    if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearCoat && (i.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (i.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, i.reflectivity = this.reflectivity, void 0 !== this.combine && (i.combine = this.combine), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (i.size = this.size), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== Lo && (i.blending = this.blending), this.flatShading === !0 && (i.flatShading = this.flatShading), this.side !== _o && (i.side = this.side), this.vertexColors !== So && (i.vertexColors = this.vertexColors), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, 0 !== this.rotation && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), this.morphTargets === !0 && (i.morphTargets = !0), this.skinning === !0 && (i.skinning = !0), this.visible === !1 && (i.visible = !1), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), n) {
                        var r = t(e.textures),
                            a = t(e.images);
                        r.length > 0 && (i.textures = r), a.length > 0 && (i.images = a)
                    }
                    return i
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    this.name = e.name, this.fog = e.fog, this.lights = e.lights, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.userData = JSON.parse(JSON.stringify(e.userData)), this.clipShadows = e.clipShadows, this.clipIntersection = e.clipIntersection;
                    var t = e.clippingPlanes,
                        n = null;
                    if (null !== t) {
                        var i = t.length;
                        n = new Array(i);
                        for (var r = 0; r !== i; ++r) n[r] = t[r].clone()
                    }
                    return this.clippingPlanes = n, this.shadowSide = e.shadowSide, this
                },
                dispose: function () {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });
            var mh = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                vh = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
            W.prototype = Object.create(V.prototype), W.prototype.constructor = W, W.prototype.isShaderMaterial = !0, W.prototype.copy = function (e) {
                return V.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = g(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this
            }, W.prototype.toJSON = function (e) {
                var t = V.prototype.toJSON.call(this, e);
                t.uniforms = {};
                for (var n in this.uniforms) {
                    var i = this.uniforms[n],
                        r = i.value;
                    r && r.isTexture ? t.uniforms[n] = {
                        type: "t",
                        value: r.toJSON(e).uuid
                    } : r && r.isColor ? t.uniforms[n] = {
                        type: "c",
                        value: r.getHex()
                    } : r && r.isVector2 ? t.uniforms[n] = {
                        type: "v2",
                        value: r.toArray()
                    } : r && r.isVector3 ? t.uniforms[n] = {
                        type: "v3",
                        value: r.toArray()
                    } : r && r.isVector4 ? t.uniforms[n] = {
                        type: "v4",
                        value: r.toArray()
                    } : r && r.isMatrix3 ? t.uniforms[n] = {
                        type: "m3",
                        value: r.toArray()
                    } : r && r.isMatrix4 ? t.uniforms[n] = {
                        type: "m4",
                        value: r.toArray()
                    } : t.uniforms[n] = {
                        value: r
                    }
                }
                Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader;
                var a = {};
                for (var o in this.extensions) this.extensions[o] === !0 && (a[o] = !0);
                return Object.keys(a).length > 0 && (t.extensions = a), t
            }, Object.assign(q.prototype, {
                set: function (e, t) {
                    return this.origin.copy(e), this.direction.copy(t), this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.origin.copy(e.origin), this.direction.copy(e.direction), this
                },
                at: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"), t = new a), t.copy(this.direction).multiplyScalar(e).add(this.origin)
                },
                lookAt: function (e) {
                    return this.direction.copy(e).sub(this.origin).normalize(), this
                },
                recast: function () {
                    var e = new a;
                    return function (t) {
                        return this.origin.copy(this.at(t, e)), this
                    }
                }(),
                closestPointToPoint: function (e, t) {
                    void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new a), t.subVectors(e, this.origin);
                    var n = t.dot(this.direction);
                    return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
                },
                distanceToPoint: function (e) {
                    return Math.sqrt(this.distanceSqToPoint(e))
                },
                distanceSqToPoint: function () {
                    var e = new a;
                    return function (t) {
                        var n = e.subVectors(t, this.origin).dot(this.direction);
                        return n < 0 ? this.origin.distanceToSquared(t) : (e.copy(this.direction).multiplyScalar(n).add(this.origin), e.distanceToSquared(t))
                    }
                }(),
                distanceSqToSegment: function () {
                    var e = new a,
                        t = new a,
                        n = new a;
                    return function (i, r, a, o) {
                        e.copy(i).add(r).multiplyScalar(.5),
                            t.copy(r).sub(i).normalize(), n.copy(this.origin).sub(e);
                        var s, l, c, u, h = .5 * i.distanceTo(r),
                            d = -this.direction.dot(t),
                            p = n.dot(this.direction),
                            f = -n.dot(t),
                            m = n.lengthSq(),
                            v = Math.abs(1 - d * d);
                        if (v > 0)
                            if (s = d * f - p, l = d * p - f, u = h * v, s >= 0)
                                if (l >= -u)
                                    if (l <= u) {
                                        var g = 1 / v;
                                        s *= g, l *= g, c = s * (s + d * l + 2 * p) + l * (d * s + l + 2 * f) + m
                                    } else l = h, s = Math.max(0, -(d * l + p)), c = -s * s + l * (l + 2 * f) + m;
                        else l = -h, s = Math.max(0, -(d * l + p)), c = -s * s + l * (l + 2 * f) + m;
                        else l <= -u ? (s = Math.max(0, -(-d * h + p)), l = s > 0 ? -h : Math.min(Math.max(-h, -f), h), c = -s * s + l * (l + 2 * f) + m) : l <= u ? (s = 0, l = Math.min(Math.max(-h, -f), h), c = l * (l + 2 * f) + m) : (s = Math.max(0, -(d * h + p)), l = s > 0 ? h : Math.min(Math.max(-h, -f), h), c = -s * s + l * (l + 2 * f) + m);
                        else l = d > 0 ? -h : h, s = Math.max(0, -(d * l + p)), c = -s * s + l * (l + 2 * f) + m;
                        return a && a.copy(this.direction).multiplyScalar(s).add(this.origin), o && o.copy(t).multiplyScalar(l).add(e), c
                    }
                }(),
                intersectSphere: function () {
                    var e = new a;
                    return function (t, n) {
                        e.subVectors(t.center, this.origin);
                        var i = e.dot(this.direction),
                            r = e.dot(e) - i * i,
                            a = t.radius * t.radius;
                        if (r > a) return null;
                        var o = Math.sqrt(a - r),
                            s = i - o,
                            l = i + o;
                        return s < 0 && l < 0 ? null : s < 0 ? this.at(l, n) : this.at(s, n)
                    }
                }(),
                intersectsSphere: function (e) {
                    return this.distanceSqToPoint(e.center) <= e.radius * e.radius
                },
                distanceToPlane: function (e) {
                    var t = e.normal.dot(this.direction);
                    if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                    var n = -(this.origin.dot(e.normal) + e.constant) / t;
                    return n >= 0 ? n : null
                },
                intersectPlane: function (e, t) {
                    var n = this.distanceToPlane(e);
                    return null === n ? null : this.at(n, t)
                },
                intersectsPlane: function (e) {
                    var t = e.distanceToPoint(this.origin);
                    if (0 === t) return !0;
                    var n = e.normal.dot(this.direction);
                    return n * t < 0
                },
                intersectBox: function (e, t) {
                    var n, i, r, a, o, s, l = 1 / this.direction.x,
                        c = 1 / this.direction.y,
                        u = 1 / this.direction.z,
                        h = this.origin;
                    return l >= 0 ? (n = (e.min.x - h.x) * l, i = (e.max.x - h.x) * l) : (n = (e.max.x - h.x) * l, i = (e.min.x - h.x) * l), c >= 0 ? (r = (e.min.y - h.y) * c, a = (e.max.y - h.y) * c) : (r = (e.max.y - h.y) * c, a = (e.min.y - h.y) * c), n > a || r > i ? null : ((r > n || n !== n) && (n = r), (a < i || i !== i) && (i = a), u >= 0 ? (o = (e.min.z - h.z) * u, s = (e.max.z - h.z) * u) : (o = (e.max.z - h.z) * u, s = (e.min.z - h.z) * u), n > s || o > i ? null : ((o > n || n !== n) && (n = o), (s < i || i !== i) && (i = s), i < 0 ? null : this.at(n >= 0 ? n : i, t)))
                },
                intersectsBox: function () {
                    var e = new a;
                    return function (t) {
                        return null !== this.intersectBox(t, e)
                    }
                }(),
                intersectTriangle: function () {
                    var e = new a,
                        t = new a,
                        n = new a,
                        i = new a;
                    return function (r, a, o, s, l) {
                        t.subVectors(a, r), n.subVectors(o, r), i.crossVectors(t, n);
                        var c, u = this.direction.dot(i);
                        if (u > 0) {
                            if (s) return null;
                            c = 1
                        } else {
                            if (!(u < 0)) return null;
                            c = -1, u = -u
                        }
                        e.subVectors(this.origin, r);
                        var h = c * this.direction.dot(n.crossVectors(e, n));
                        if (h < 0) return null;
                        var d = c * this.direction.dot(t.cross(e));
                        if (d < 0) return null;
                        if (h + d > u) return null;
                        var p = -c * e.dot(i);
                        return p < 0 ? null : this.at(p / u, l)
                    }
                }(),
                applyMatrix4: function (e) {
                    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
                },
                equals: function (e) {
                    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                }
            }), Object.assign(X, {
                getNormal: function () {
                    var e = new a;
                    return function (t, n, i, r) {
                        void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), r = new a), r.subVectors(i, n), e.subVectors(t, n), r.cross(e);
                        var o = r.lengthSq();
                        return o > 0 ? r.multiplyScalar(1 / Math.sqrt(o)) : r.set(0, 0, 0)
                    }
                }(),
                getBarycoord: function () {
                    var e = new a,
                        t = new a,
                        n = new a;
                    return function (i, r, o, s, l) {
                        e.subVectors(s, r), t.subVectors(o, r), n.subVectors(i, r);
                        var c = e.dot(e),
                            u = e.dot(t),
                            h = e.dot(n),
                            d = t.dot(t),
                            p = t.dot(n),
                            f = c * d - u * u;
                        if (void 0 === l && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), l = new a), 0 === f) return l.set(-2, -1, -1);
                        var m = 1 / f,
                            v = (d * h - u * p) * m,
                            g = (c * p - u * h) * m;
                        return l.set(1 - v - g, g, v)
                    }
                }(),
                containsPoint: function () {
                    var e = new a;
                    return function (t, n, i, r) {
                        return X.getBarycoord(t, n, i, r, e), e.x >= 0 && e.y >= 0 && e.x + e.y <= 1
                    }
                }(),
                getUV: function () {
                    var e = new a;
                    return function (t, n, i, r, a, o, s, l) {
                        return this.getBarycoord(t, n, i, r, e), l.set(0, 0), l.addScaledVector(a, e.x), l.addScaledVector(o, e.y), l.addScaledVector(s, e.z), l
                    }
                }()
            }), Object.assign(X.prototype, {
                set: function (e, t, n) {
                    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
                },
                setFromPointsAndIndices: function (e, t, n, i) {
                    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
                },
                getArea: function () {
                    var e = new a,
                        t = new a;
                    return function () {
                        return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), .5 * e.cross(t).length()
                    }
                }(),
                getMidpoint: function (e) {
                    return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new a), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                },
                getNormal: function (e) {
                    return X.getNormal(this.a, this.b, this.c, e)
                },
                getPlane: function (e) {
                    return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new a), e.setFromCoplanarPoints(this.a, this.b, this.c)
                },
                getBarycoord: function (e, t) {
                    return X.getBarycoord(e, this.a, this.b, this.c, t)
                },
                containsPoint: function (e) {
                    return X.containsPoint(e, this.a, this.b, this.c)
                },
                getUV: function (e, t, n, i, r) {
                    return X.getUV(e, this.a, this.b, this.c, t, n, i, r)
                },
                intersectsBox: function (e) {
                    return e.intersectsTriangle(this)
                },
                closestPointToPoint: function () {
                    var e = new a,
                        t = new a,
                        n = new a,
                        i = new a,
                        r = new a,
                        o = new a;
                    return function (s, l) {
                        void 0 === l && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), l = new a);
                        var c, u, h = this.a,
                            d = this.b,
                            p = this.c;
                        e.subVectors(d, h), t.subVectors(p, h), i.subVectors(s, h);
                        var f = e.dot(i),
                            m = t.dot(i);
                        if (f <= 0 && m <= 0) return l.copy(h);
                        r.subVectors(s, d);
                        var v = e.dot(r),
                            g = t.dot(r);
                        if (v >= 0 && g <= v) return l.copy(d);
                        var y = f * g - v * m;
                        if (y <= 0 && f >= 0 && v <= 0) return c = f / (f - v), l.copy(h).addScaledVector(e, c);
                        o.subVectors(s, p);
                        var x = e.dot(o),
                            b = t.dot(o);
                        if (b >= 0 && x <= b) return l.copy(p);
                        var _ = x * m - f * b;
                        if (_ <= 0 && m >= 0 && b <= 0) return u = m / (m - b), l.copy(h).addScaledVector(t, u);
                        var w = v * b - x * g;
                        if (w <= 0 && g - v >= 0 && x - b >= 0) return n.subVectors(p, d), u = (g - v) / (g - v + (x - b)), l.copy(d).addScaledVector(n, u);
                        var M = 1 / (w + _ + y);
                        return c = _ * M, u = y * M, l.copy(h).addScaledVector(e, c).addScaledVector(t, u)
                    }
                }(),
                equals: function (e) {
                    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                }
            }), Y.prototype = Object.create(V.prototype), Y.prototype.constructor = Y, Y.prototype.isMeshBasicMaterial = !0, Y.prototype.copy = function (e) {
                return V.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this
            }, Z.prototype = Object.assign(Object.create(E.prototype), {
                constructor: Z,
                isMesh: !0,
                setDrawMode: function (e) {
                    this.drawMode = e
                },
                copy: function (e) {
                    return E.prototype.copy.call(this, e), this.drawMode = e.drawMode, void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this
                },
                updateMorphTargets: function () {
                    var e, t, n, i = this.geometry;
                    if (i.isBufferGeometry) {
                        var r = i.morphAttributes,
                            a = Object.keys(r);
                        if (a.length > 0) {
                            var o = r[a[0]];
                            if (void 0 !== o)
                                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = o.length; e < t; e++) n = o[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                        }
                    } else {
                        var s = i.morphTargets;
                        void 0 !== s && s.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                },
                raycast: function () {
                    function e(e, t, n, i, r, a, o, s) {
                        var l;
                        if (l = t.side === wo ? i.intersectTriangle(o, a, r, !0, s) : i.intersectTriangle(r, a, o, t.side !== Mo, s), null === l) return null;
                        x.copy(s), x.applyMatrix4(e.matrixWorld);
                        var c = n.ray.origin.distanceTo(x);
                        return c < n.near || c > n.far ? null : {
                            distance: c,
                            point: x.clone(),
                            object: e
                        }
                    }

                    function t(t, i, r, a, o, s, h, d, p) {
                        l.fromBufferAttribute(o, h), c.fromBufferAttribute(o, d), u.fromBufferAttribute(o, p);
                        var f = e(t, i, r, a, l, c, u, y);
                        if (f) {
                            s && (m.fromBufferAttribute(s, h), v.fromBufferAttribute(s, d), g.fromBufferAttribute(s, p), f.uv = X.getUV(y, l, c, u, m, v, g, new n));
                            var x = new w(h, d, p);
                            X.getNormal(l, c, u, x.normal), f.face = x
                        }
                        return f
                    }
                    var r = new i,
                        o = new q,
                        s = new f,
                        l = new a,
                        c = new a,
                        u = new a,
                        h = new a,
                        d = new a,
                        p = new a,
                        m = new n,
                        v = new n,
                        g = new n,
                        y = new a,
                        x = new a;
                    return function (i, a) {
                        var f = this.geometry,
                            x = this.material,
                            b = this.matrixWorld;
                        if (void 0 !== x && (null === f.boundingSphere && f.computeBoundingSphere(), s.copy(f.boundingSphere), s.applyMatrix4(b), i.ray.intersectsSphere(s) !== !1 && (r.getInverse(b), o.copy(i.ray).applyMatrix4(r), null === f.boundingBox || o.intersectsBox(f.boundingBox) !== !1))) {
                            var _;
                            if (f.isBufferGeometry) {
                                var w, M, T, E, S, P, C, A, L, R, I, O = f.index,
                                    k = f.attributes.position,
                                    D = f.attributes.uv,
                                    z = f.groups,
                                    B = f.drawRange;
                                if (null !== O)
                                    if (Array.isArray(x))
                                        for (E = 0, P = z.length; E < P; E++)
                                            for (A = z[E], L = x[A.materialIndex], R = Math.max(A.start, B.start), I = Math.min(A.start + A.count, B.start + B.count), S = R, C = I; S < C; S += 3) w = O.getX(S), M = O.getX(S + 1), T = O.getX(S + 2), _ = t(this, L, i, o, k, D, w, M, T), _ && (_.faceIndex = Math.floor(S / 3), _.face.materialIndex = A.materialIndex, a.push(_));
                                    else
                                        for (R = Math.max(0, B.start), I = Math.min(O.count, B.start + B.count), E = R, P = I; E < P; E += 3) w = O.getX(E), M = O.getX(E + 1), T = O.getX(E + 2), _ = t(this, x, i, o, k, D, w, M, T), _ && (_.faceIndex = Math.floor(E / 3), a.push(_));
                                else if (void 0 !== k)
                                    if (Array.isArray(x))
                                        for (E = 0, P = z.length; E < P; E++)
                                            for (A = z[E], L = x[A.materialIndex], R = Math.max(A.start, B.start), I = Math.min(A.start + A.count, B.start + B.count), S = R, C = I; S < C; S += 3) w = S, M = S + 1, T = S + 2, _ = t(this, L, i, o, k, D, w, M, T), _ && (_.faceIndex = Math.floor(S / 3), _.face.materialIndex = A.materialIndex, a.push(_));
                                    else
                                        for (R = Math.max(0, B.start), I = Math.min(k.count, B.start + B.count), E = R, P = I; E < P; E += 3) w = E, M = E + 1, T = E + 2, _ = t(this, x, i, o, k, D, w, M, T), _ && (_.faceIndex = Math.floor(E / 3), a.push(_))
                            } else if (f.isGeometry) {
                                var N, U, j, F, G = Array.isArray(x),
                                    H = f.vertices,
                                    V = f.faces,
                                    W = f.faceVertexUvs[0];
                                W.length > 0 && (F = W);
                                for (var q = 0, Y = V.length; q < Y; q++) {
                                    var Z = V[q],
                                        J = G ? x[Z.materialIndex] : x;
                                    if (void 0 !== J) {
                                        if (N = H[Z.a], U = H[Z.b], j = H[Z.c], J.morphTargets === !0) {
                                            var $ = f.morphTargets,
                                                Q = this.morphTargetInfluences;
                                            l.set(0, 0, 0), c.set(0, 0, 0), u.set(0, 0, 0);
                                            for (var K = 0, ee = $.length; K < ee; K++) {
                                                var te = Q[K];
                                                if (0 !== te) {
                                                    var ne = $[K].vertices;
                                                    l.addScaledVector(h.subVectors(ne[Z.a], N), te), c.addScaledVector(d.subVectors(ne[Z.b], U), te), u.addScaledVector(p.subVectors(ne[Z.c], j), te)
                                                }
                                            }
                                            l.add(N), c.add(U), u.add(j), N = l, U = c, j = u
                                        }
                                        if (_ = e(this, J, i, o, N, U, j, y)) {
                                            if (F && F[q]) {
                                                var ie = F[q];
                                                m.copy(ie[0]), v.copy(ie[1]), g.copy(ie[2]), _.uv = X.getUV(y, N, U, j, m, v, g, new n)
                                            }
                                            _.face = Z, _.faceIndex = q, a.push(_)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }(),
                clone: function () {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), se.prototype = Object.create(s.prototype), se.prototype.constructor = se, se.prototype.isCubeTexture = !0, Object.defineProperty(se.prototype, "images", {
                get: function () {
                    return this.image
                },
                set: function (e) {
                    this.image = e
                }
            }), le.prototype = Object.create(s.prototype), le.prototype.constructor = le, le.prototype.isDataTexture3D = !0;
            var gh = new s,
                yh = new le,
                xh = new se,
                bh = [],
                _h = [],
                wh = new Float32Array(16),
                Mh = new Float32Array(9),
                Th = new Float32Array(4);
            Fe.prototype.updateCache = function (e) {
                var t = this.cache;
                e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), de(t, e)
            }, Ge.prototype.setValue = function (e, t, n) {
                for (var i = this.seq, r = 0, a = i.length; r !== a; ++r) {
                    var o = i[r];
                    o.setValue(e, t[o.id], n)
                }
            };
            var Eh = /([\w\d_]+)(\])?(\[|\.)?/g;
            We.prototype.setValue = function (e, t, n) {
                var i = this.map[t];
                void 0 !== i && i.setValue(e, n, this.renderer)
            }, We.prototype.setOptional = function (e, t, n) {
                var i = t[n];
                void 0 !== i && this.setValue(e, n, i)
            }, We.upload = function (e, t, n, i) {
                for (var r = 0, a = t.length; r !== a; ++r) {
                    var o = t[r],
                        s = n[o.id];
                    s.needsUpdate !== !1 && o.setValue(e, s.value, i)
                }
            }, We.seqWithValue = function (e, t) {
                for (var n = [], i = 0, r = e.length; i !== r; ++i) {
                    var a = e[i];
                    a.id in t && n.push(a)
                }
                return n
            };
            var Sh = 0,
                Ph = 0;
            gt.prototype = Object.create(V.prototype), gt.prototype.constructor = gt, gt.prototype.isMeshDepthMaterial = !0, gt.prototype.copy = function (e) {
                return V.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
            }, yt.prototype = Object.create(V.prototype), yt.prototype.constructor = yt, yt.prototype.isMeshDistanceMaterial = !0, yt.prototype.copy = function (e) {
                return V.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
            }, Mt.prototype = Object.assign(Object.create(E.prototype), {
                constructor: Mt,
                isGroup: !0
            }), Tt.prototype = Object.assign(Object.create(E.prototype), {
                constructor: Tt,
                isCamera: !0,
                copy: function (e, t) {
                    return E.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this
                },
                getWorldDirection: function (e) {
                    void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e = new a), this.updateMatrixWorld(!0);
                    var t = this.matrixWorld.elements;
                    return e.set(-t[8], -t[9], -t[10]).normalize()
                },
                updateMatrixWorld: function (e) {
                    E.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld)
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                }
            }), Et.prototype = Object.assign(Object.create(Tt.prototype), {
                constructor: Et,
                isPerspectiveCamera: !0,
                copy: function (e, t) {
                    return Tt.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
                },
                setFocalLength: function (e) {
                    var t = .5 * this.getFilmHeight() / e;
                    this.fov = 2 * Wl.RAD2DEG * Math.atan(t), this.updateProjectionMatrix()
                },
                getFocalLength: function () {
                    var e = Math.tan(.5 * Wl.DEG2RAD * this.fov);
                    return .5 * this.getFilmHeight() / e
                },
                getEffectiveFOV: function () {
                    return 2 * Wl.RAD2DEG * Math.atan(Math.tan(.5 * Wl.DEG2RAD * this.fov) / this.zoom)
                },
                getFilmWidth: function () {
                    return this.filmGauge * Math.min(this.aspect, 1)
                },
                getFilmHeight: function () {
                    return this.filmGauge / Math.max(this.aspect, 1)
                },
                setViewOffset: function (e, t, n, i, r, a) {
                    this.aspect = e / t, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
                },
                clearViewOffset: function () {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function () {
                    var e = this.near,
                        t = e * Math.tan(.5 * Wl.DEG2RAD * this.fov) / this.zoom,
                        n = 2 * t,
                        i = this.aspect * n,
                        r = -.5 * i,
                        a = this.view;
                    if (null !== this.view && this.view.enabled) {
                        var o = a.fullWidth,
                            s = a.fullHeight;
                        r += a.offsetX * i / o, t -= a.offsetY * n / s, i *= a.width / o, n *= a.height / s
                    }
                    var l = this.filmOffset;
                    0 !== l && (r += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function (e) {
                    var t = E.prototype.toJSON.call(this, e);
                    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
                }
            }), St.prototype = Object.assign(Object.create(Et.prototype), {
                constructor: St,
                isArrayCamera: !0
            });
            var Ch = new a,
                Ah = new a;
            Object.assign(Rt.prototype, {
                isFogExp2: !0,
                clone: function () {
                    return new Rt(this.color, this.density)
                },
                toJSON: function () {
                    return {
                        type: "FogExp2",
                        color: this.color.getHex(),
                        density: this.density
                    }
                }
            }), Object.assign(It.prototype, {
                isFog: !0,
                clone: function () {
                    return new It(this.color, this.near, this.far)
                },
                toJSON: function () {
                    return {
                        type: "Fog",
                        color: this.color.getHex(),
                        near: this.near,
                        far: this.far
                    }
                }
            }), Ot.prototype = Object.assign(Object.create(E.prototype), {
                constructor: Ot,
                isScene: !0,
                copy: function (e, t) {
                    return E.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
                },
                toJSON: function (e) {
                    var t = E.prototype.toJSON.call(this, e);
                    return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t
                },
                dispose: function () {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Object.defineProperty(kt.prototype, "needsUpdate", {
                set: function (e) {
                    e === !0 && this.version++
                }
            }), Object.assign(kt.prototype, {
                isInterleavedBuffer: !0,
                onUploadCallback: function () {},
                setArray: function (e) {
                    if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    return this.count = void 0 !== e ? e.length / this.stride : 0, this.array = e, this
                },
                setDynamic: function (e) {
                    return this.dynamic = e, this
                },
                copy: function (e) {
                    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.dynamic = e.dynamic, this
                },
                copyAt: function (e, t, n) {
                    e *= this.stride, n *= t.stride;
                    for (var i = 0, r = this.stride; i < r; i++) this.array[e + i] = t.array[n + i];
                    return this
                },
                set: function (e, t) {
                    return void 0 === t && (t = 0), this.array.set(e, t), this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                onUpload: function (e) {
                    return this.onUploadCallback = e, this
                }
            }), Object.defineProperties(Dt.prototype, {
                count: {
                    get: function () {
                        return this.data.count
                    }
                },
                array: {
                    get: function () {
                        return this.data.array
                    }
                }
            }), Object.assign(Dt.prototype, {
                isInterleavedBufferAttribute: !0,
                setX: function (e, t) {
                    return this.data.array[e * this.data.stride + this.offset] = t, this
                },
                setY: function (e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 1] = t, this
                },
                setZ: function (e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 2] = t, this
                },
                setW: function (e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 3] = t, this
                },
                getX: function (e) {
                    return this.data.array[e * this.data.stride + this.offset]
                },
                getY: function (e) {
                    return this.data.array[e * this.data.stride + this.offset + 1]
                },
                getZ: function (e) {
                    return this.data.array[e * this.data.stride + this.offset + 2]
                },
                getW: function (e) {
                    return this.data.array[e * this.data.stride + this.offset + 3]
                },
                setXY: function (e, t, n) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
                },
                setXYZ: function (e, t, n, i) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this
                },
                setXYZW: function (e, t, n, i, r) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this
                }
            }), zt.prototype = Object.create(V.prototype), zt.prototype.constructor = zt, zt.prototype.isSpriteMaterial = !0, zt.prototype.copy = function (e) {
                return V.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this
            };
            var Lh;
            Bt.prototype = Object.assign(Object.create(E.prototype), {
                constructor: Bt,
                isSprite: !0,
                raycast: function () {
                    function e(e, t, n, i, r, a) {
                        s.subVectors(e, n).addScalar(.5).multiply(i), void 0 !== r ? (l.x = a * s.x - r * s.y, l.y = r * s.x + a * s.y) : l.copy(s), e.copy(t), e.x += l.x, e.y += l.y, e.applyMatrix4(c)
                    }
                    var t = new a,
                        r = new a,
                        o = new a,
                        s = new n,
                        l = new n,
                        c = new i,
                        u = new a,
                        h = new a,
                        d = new a,
                        p = new n,
                        f = new n,
                        m = new n;
                    return function (i, a) {
                        r.setFromMatrixScale(this.matrixWorld), c.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), o.setFromMatrixPosition(this.modelViewMatrix);
                        var s, l, v = this.material.rotation;
                        0 !== v && (l = Math.cos(v), s = Math.sin(v));
                        var g = this.center;
                        e(u.set(-.5, -.5, 0), o, g, r, s, l), e(h.set(.5, -.5, 0), o, g, r, s, l), e(d.set(.5, .5, 0), o, g, r, s, l), p.set(0, 0), f.set(1, 0), m.set(1, 1);
                        var y = i.ray.intersectTriangle(u, h, d, !1, t);
                        if (null !== y || (e(h.set(-.5, .5, 0), o, g, r, s, l), f.set(0, 1), y = i.ray.intersectTriangle(u, d, h, !1, t), null !== y)) {
                            var x = i.ray.origin.distanceTo(t);
                            x < i.near || x > i.far || a.push({
                                distance: x,
                                point: t.clone(),
                                uv: X.getUV(t, u, h, d, p, f, m, new n),
                                face: null,
                                object: this
                            })
                        }
                    }
                }(),
                clone: function () {
                    return new this.constructor(this.material).copy(this)
                },
                copy: function (e) {
                    return E.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this
                }
            }), Nt.prototype = Object.assign(Object.create(E.prototype), {
                constructor: Nt,
                copy: function (e) {
                    E.prototype.copy.call(this, e, !1);
                    for (var t = e.levels, n = 0, i = t.length; n < i; n++) {
                        var r = t[n];
                        this.addLevel(r.object.clone(), r.distance)
                    }
                    return this
                },
                addLevel: function (e, t) {
                    void 0 === t && (t = 0), t = Math.abs(t);
                    for (var n = this.levels, i = 0; i < n.length && !(t < n[i].distance); i++);
                    n.splice(i, 0, {
                        distance: t,
                        object: e
                    }), this.add(e)
                },
                getObjectForDistance: function (e) {
                    for (var t = this.levels, n = 1, i = t.length; n < i && !(e < t[n].distance); n++);
                    return t[n - 1].object
                },
                raycast: function () {
                    var e = new a;
                    return function (t, n) {
                        e.setFromMatrixPosition(this.matrixWorld);
                        var i = t.ray.origin.distanceTo(e);
                        this.getObjectForDistance(i).raycast(t, n)
                    }
                }(),
                update: function () {
                    var e = new a,
                        t = new a;
                    return function (n) {
                        var i = this.levels;
                        if (i.length > 1) {
                            e.setFromMatrixPosition(n.matrixWorld), t.setFromMatrixPosition(this.matrixWorld);
                            var r = e.distanceTo(t);
                            i[0].object.visible = !0;
                            for (var a = 1, o = i.length; a < o && r >= i[a].distance; a++) i[a - 1].object.visible = !1, i[a].object.visible = !0;
                            for (; a < o; a++) i[a].object.visible = !1
                        }
                    }
                }(),
                toJSON: function (e) {
                    var t = E.prototype.toJSON.call(this, e);
                    t.object.levels = [];
                    for (var n = this.levels, i = 0, r = n.length; i < r; i++) {
                        var a = n[i];
                        t.object.levels.push({
                            object: a.object.uuid,
                            distance: a.distance
                        })
                    }
                    return t
                }
            }), Ut.prototype = Object.assign(Object.create(Z.prototype), {
                constructor: Ut,
                isSkinnedMesh: !0,
                bind: function (e, t) {
                    this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
                },
                pose: function () {
                    this.skeleton.pose()
                },
                normalizeSkinWeights: function () {
                    for (var e = new l, t = this.geometry.attributes.skinWeight, n = 0, i = t.count; n < i; n++) {
                        e.x = t.getX(n), e.y = t.getY(n), e.z = t.getZ(n), e.w = t.getW(n);
                        var r = 1 / e.manhattanLength();
                        r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
                    }
                },
                updateMatrixWorld: function (e) {
                    Z.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                },
                clone: function () {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), Object.assign(jt.prototype, {
                calculateInverses: function () {
                    this.boneInverses = [];
                    for (var e = 0, t = this.bones.length; e < t; e++) {
                        var n = new i;
                        this.bones[e] && n.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(n)
                    }
                },
                pose: function () {
                    var e, t, n;
                    for (t = 0, n = this.bones.length; t < n; t++) e = this.bones[t], e && e.matrixWorld.getInverse(this.boneInverses[t]);
                    for (t = 0, n = this.bones.length; t < n; t++) e = this.bones[t], e && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
                },
                update: function () {
                    var e = new i,
                        t = new i;
                    return function () {
                        for (var n = this.bones, i = this.boneInverses, r = this.boneMatrices, a = this.boneTexture, o = 0, s = n.length; o < s; o++) {
                            var l = n[o] ? n[o].matrixWorld : t;
                            e.multiplyMatrices(l, i[o]), e.toArray(r, 16 * o)
                        }
                        void 0 !== a && (a.needsUpdate = !0)
                    }
                }(),
                clone: function () {
                    return new jt(this.bones, this.boneInverses)
                },
                getBoneByName: function (e) {
                    for (var t = 0, n = this.bones.length; t < n; t++) {
                        var i = this.bones[t];
                        if (i.name === e) return i
                    }
                }
            }), Ft.prototype = Object.assign(Object.create(E.prototype), {
                constructor: Ft,
                isBone: !0
            }), Gt.prototype = Object.create(V.prototype), Gt.prototype.constructor = Gt, Gt.prototype.isLineBasicMaterial = !0, Gt.prototype.copy = function (e) {
                return V.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this
            }, Ht.prototype = Object.assign(Object.create(E.prototype), {
                constructor: Ht,
                isLine: !0,
                computeLineDistances: function () {
                    var e = new a,
                        t = new a;
                    return function () {
                        var n = this.geometry;
                        if (n.isBufferGeometry)
                            if (null === n.index) {
                                for (var i = n.attributes.position, r = [0], a = 1, o = i.count; a < o; a++) e.fromBufferAttribute(i, a - 1), t.fromBufferAttribute(i, a), r[a] = r[a - 1], r[a] += e.distanceTo(t);
                                n.addAttribute("lineDistance", new D(r, 1))
                            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else if (n.isGeometry) {
                            var s = n.vertices,
                                r = n.lineDistances;
                            r[0] = 0;
                            for (var a = 1, o = s.length; a < o; a++) r[a] = r[a - 1], r[a] += s[a - 1].distanceTo(s[a])
                        }
                        return this
                    }
                }(),
                raycast: function () {
                    var e = new i,
                        t = new q,
                        n = new f;
                    return function (i, r) {
                        var o = i.linePrecision,
                            s = this.geometry,
                            l = this.matrixWorld;
                        if (null === s.boundingSphere && s.computeBoundingSphere(), n.copy(s.boundingSphere), n.applyMatrix4(l), n.radius += o, i.ray.intersectsSphere(n) !== !1) {
                            e.getInverse(l), t.copy(i.ray).applyMatrix4(e);
                            var c = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                u = c * c,
                                h = new a,
                                d = new a,
                                p = new a,
                                f = new a,
                                m = this && this.isLineSegments ? 2 : 1;
                            if (s.isBufferGeometry) {
                                var v = s.index,
                                    g = s.attributes,
                                    y = g.position.array;
                                if (null !== v)
                                    for (var x = v.array, b = 0, _ = x.length - 1; b < _; b += m) {
                                        var w = x[b],
                                            M = x[b + 1];
                                        h.fromArray(y, 3 * w), d.fromArray(y, 3 * M);
                                        var T = t.distanceSqToSegment(h, d, f, p);
                                        if (!(T > u)) {
                                            f.applyMatrix4(this.matrixWorld);
                                            var E = i.ray.origin.distanceTo(f);
                                            E < i.near || E > i.far || r.push({
                                                distance: E,
                                                point: p.clone().applyMatrix4(this.matrixWorld),
                                                index: b,
                                                face: null,
                                                faceIndex: null,
                                                object: this
                                            })
                                        }
                                    } else
                                        for (var b = 0, _ = y.length / 3 - 1; b < _; b += m) {
                                            h.fromArray(y, 3 * b), d.fromArray(y, 3 * b + 3);
                                            var T = t.distanceSqToSegment(h, d, f, p);
                                            if (!(T > u)) {
                                                f.applyMatrix4(this.matrixWorld);
                                                var E = i.ray.origin.distanceTo(f);
                                                E < i.near || E > i.far || r.push({
                                                    distance: E,
                                                    point: p.clone().applyMatrix4(this.matrixWorld),
                                                    index: b,
                                                    face: null,
                                                    faceIndex: null,
                                                    object: this
                                                })
                                            }
                                        }
                            } else if (s.isGeometry)
                                for (var S = s.vertices, P = S.length, b = 0; b < P - 1; b += m) {
                                    var T = t.distanceSqToSegment(S[b], S[b + 1], f, p);
                                    if (!(T > u)) {
                                        f.applyMatrix4(this.matrixWorld);
                                        var E = i.ray.origin.distanceTo(f);
                                        E < i.near || E > i.far || r.push({
                                            distance: E,
                                            point: p.clone().applyMatrix4(this.matrixWorld),
                                            index: b,
                                            face: null,
                                            faceIndex: null,
                                            object: this
                                        })
                                    }
                                }
                        }
                    }
                }(),
                copy: function (e) {
                    return E.prototype.copy.call(this, e), this.geometry.copy(e.geometry), this.material.copy(e.material), this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                }
            }), Vt.prototype = Object.assign(Object.create(Ht.prototype), {
                constructor: Vt,
                isLineSegments: !0,
                computeLineDistances: function () {
                    var e = new a,
                        t = new a;
                    return function () {
                        var n = this.geometry;
                        if (n.isBufferGeometry)
                            if (null === n.index) {
                                for (var i = n.attributes.position, r = [], a = 0, o = i.count; a < o; a += 2) e.fromBufferAttribute(i, a), t.fromBufferAttribute(i, a + 1), r[a] = 0 === a ? 0 : r[a - 1], r[a + 1] = r[a] + e.distanceTo(t);
                                n.addAttribute("lineDistance", new D(r, 1))
                            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else if (n.isGeometry)
                            for (var s = n.vertices, r = n.lineDistances, a = 0, o = s.length; a < o; a += 2) e.copy(s[a]), t.copy(s[a + 1]), r[a] = 0 === a ? 0 : r[a - 1], r[a + 1] = r[a] + e.distanceTo(t);
                        return this
                    }
                }()
            }), Wt.prototype = Object.assign(Object.create(Ht.prototype), {
                constructor: Wt,
                isLineLoop: !0
            }), qt.prototype = Object.create(V.prototype), qt.prototype.constructor = qt, qt.prototype.isPointsMaterial = !0, qt.prototype.copy = function (e) {
                return V.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this
            }, Xt.prototype = Object.assign(Object.create(E.prototype), {
                constructor: Xt,
                isPoints: !0,
                raycast: function () {
                    var e = new i,
                        t = new q,
                        n = new f;
                    return function (i, r) {
                        function o(e, n) {
                            var a = t.distanceSqToPoint(e);
                            if (a < d) {
                                t.closestPointToPoint(e, f), f.applyMatrix4(c);
                                var o = i.ray.origin.distanceTo(f);
                                if (o < i.near || o > i.far) return;
                                r.push({
                                    distance: o,
                                    distanceToRay: Math.sqrt(a),
                                    point: f.clone(),
                                    index: n,
                                    face: null,
                                    object: s
                                })
                            }
                        }
                        var s = this,
                            l = this.geometry,
                            c = this.matrixWorld,
                            u = i.params.Points.threshold;
                        if (null === l.boundingSphere && l.computeBoundingSphere(), n.copy(l.boundingSphere), n.applyMatrix4(c), n.radius += u, i.ray.intersectsSphere(n) !== !1) {
                            e.getInverse(c), t.copy(i.ray).applyMatrix4(e);
                            var h = u / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                d = h * h,
                                p = new a,
                                f = new a;
                            if (l.isBufferGeometry) {
                                var m = l.index,
                                    v = l.attributes,
                                    g = v.position.array;
                                if (null !== m)
                                    for (var y = m.array, x = 0, b = y.length; x < b; x++) {
                                        var _ = y[x];
                                        p.fromArray(g, 3 * _), o(p, _)
                                    } else
                                        for (var x = 0, w = g.length / 3; x < w; x++) p.fromArray(g, 3 * x), o(p, x)
                            } else
                                for (var M = l.vertices, x = 0, w = M.length; x < w; x++) o(M[x], x)
                        }
                    }
                }(),
                clone: function () {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), Yt.prototype = Object.assign(Object.create(s.prototype), {
                constructor: Yt,
                isVideoTexture: !0,
                update: function () {
                    var e = this.image;
                    e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }), Zt.prototype = Object.create(s.prototype), Zt.prototype.constructor = Zt, Zt.prototype.isCompressedTexture = !0, Jt.prototype = Object.create(s.prototype), Jt.prototype.constructor = Jt, Jt.prototype.isCanvasTexture = !0, $t.prototype = Object.create(s.prototype), $t.prototype.constructor = $t, $t.prototype.isDepthTexture = !0, Qt.prototype = Object.create(U.prototype), Qt.prototype.constructor = Qt, Kt.prototype = Object.create(S.prototype), Kt.prototype.constructor = Kt, en.prototype = Object.create(U.prototype), en.prototype.constructor = en, tn.prototype = Object.create(S.prototype), tn.prototype.constructor = tn, nn.prototype = Object.create(U.prototype), nn.prototype.constructor = nn, rn.prototype = Object.create(S.prototype), rn.prototype.constructor = rn, an.prototype = Object.create(nn.prototype), an.prototype.constructor = an, on.prototype = Object.create(S.prototype), on.prototype.constructor = on, sn.prototype = Object.create(nn.prototype), sn.prototype.constructor = sn, ln.prototype = Object.create(S.prototype), ln.prototype.constructor = ln, cn.prototype = Object.create(nn.prototype), cn.prototype.constructor = cn, un.prototype = Object.create(S.prototype), un.prototype.constructor = un, hn.prototype = Object.create(nn.prototype), hn.prototype.constructor = hn, dn.prototype = Object.create(S.prototype), dn.prototype.constructor = dn, pn.prototype = Object.create(U.prototype), pn.prototype.constructor = pn, pn.prototype.toJSON = function () {
                var e = U.prototype.toJSON.call(this);
                return e.path = this.parameters.path.toJSON(), e
            }, fn.prototype = Object.create(S.prototype), fn.prototype.constructor = fn, mn.prototype = Object.create(U.prototype), mn.prototype.constructor = mn, vn.prototype = Object.create(S.prototype), vn.prototype.constructor = vn, gn.prototype = Object.create(U.prototype), gn.prototype.constructor = gn;
            var Rh = {
                    triangulate: function (e, t, n) {
                        n = n || 2;
                        var i = t && t.length,
                            r = i ? t[0] * n : e.length,
                            a = yn(e, 0, r, n, !0),
                            o = [];
                        if (!a) return o;
                        var s, l, c, u, h, d, p;
                        if (i && (a = En(e, t, a, n)), e.length > 80 * n) {
                            s = c = e[0], l = u = e[1];
                            for (var f = n; f < r; f += n) h = e[f], d = e[f + 1], h < s && (s = h), d < l && (l = d), h > c && (c = h), d > u && (u = d);
                            p = Math.max(c - s, u - l), p = 0 !== p ? 1 / p : 0
                        }
                        return bn(a, o, n, s, l, p), o
                    }
                },
                Ih = {
                    area: function (e) {
                        for (var t = e.length, n = 0, i = t - 1, r = 0; r < t; i = r++) n += e[i].x * e[r].y - e[r].x * e[i].y;
                        return .5 * n
                    },
                    isClockWise: function (e) {
                        return Ih.area(e) < 0
                    },
                    triangulateShape: function (e, t) {
                        var n = [],
                            i = [],
                            r = [];
                        qn(e), Xn(n, e);
                        var a = e.length;
                        t.forEach(qn);
                        for (var o = 0; o < t.length; o++) i.push(a), a += t[o].length, Xn(n, t[o]);
                        for (var s = Rh.triangulate(n, i), o = 0; o < s.length; o += 3) r.push(s.slice(o, o + 3));
                        return r
                    }
                };
            Yn.prototype = Object.create(S.prototype), Yn.prototype.constructor = Yn, Yn.prototype.toJSON = function () {
                var e = S.prototype.toJSON.call(this),
                    t = this.parameters.shapes,
                    n = this.parameters.options;
                return Jn(t, n, e)
            }, Zn.prototype = Object.create(U.prototype), Zn.prototype.constructor = Zn, Zn.prototype.toJSON = function () {
                var e = U.prototype.toJSON.call(this),
                    t = this.parameters.shapes,
                    n = this.parameters.options;
                return Jn(t, n, e)
            };
            var Oh = {
                generateTopUV: function (e, t, i, r, a) {
                    var o = t[3 * i],
                        s = t[3 * i + 1],
                        l = t[3 * r],
                        c = t[3 * r + 1],
                        u = t[3 * a],
                        h = t[3 * a + 1];
                    return [new n(o, s), new n(l, c), new n(u, h)]
                },
                generateSideWallUV: function (e, t, i, r, a, o) {
                    var s = t[3 * i],
                        l = t[3 * i + 1],
                        c = t[3 * i + 2],
                        u = t[3 * r],
                        h = t[3 * r + 1],
                        d = t[3 * r + 2],
                        p = t[3 * a],
                        f = t[3 * a + 1],
                        m = t[3 * a + 2],
                        v = t[3 * o],
                        g = t[3 * o + 1],
                        y = t[3 * o + 2];
                    return Math.abs(l - h) < .01 ? [new n(s, 1 - c), new n(u, 1 - d), new n(p, 1 - m), new n(v, 1 - y)] : [new n(l, 1 - c), new n(h, 1 - d), new n(f, 1 - m), new n(g, 1 - y)]
                }
            };
            $n.prototype = Object.create(S.prototype), $n.prototype.constructor = $n, Qn.prototype = Object.create(Zn.prototype), Qn.prototype.constructor = Qn, Kn.prototype = Object.create(S.prototype), Kn.prototype.constructor = Kn, ei.prototype = Object.create(U.prototype), ei.prototype.constructor = ei, ti.prototype = Object.create(S.prototype), ti.prototype.constructor = ti, ni.prototype = Object.create(U.prototype), ni.prototype.constructor = ni, ii.prototype = Object.create(S.prototype), ii.prototype.constructor = ii, ri.prototype = Object.create(U.prototype), ri.prototype.constructor = ri, ai.prototype = Object.create(S.prototype), ai.prototype.constructor = ai, ai.prototype.toJSON = function () {
                var e = S.prototype.toJSON.call(this),
                    t = this.parameters.shapes;
                return si(t, e)
            }, oi.prototype = Object.create(U.prototype), oi.prototype.constructor = oi, oi.prototype.toJSON = function () {
                var e = U.prototype.toJSON.call(this),
                    t = this.parameters.shapes;
                return si(t, e)
            }, li.prototype = Object.create(U.prototype), li.prototype.constructor = li, ci.prototype = Object.create(S.prototype), ci.prototype.constructor = ci, ui.prototype = Object.create(U.prototype), ui.prototype.constructor = ui, hi.prototype = Object.create(ci.prototype), hi.prototype.constructor = hi, di.prototype = Object.create(ui.prototype), di.prototype.constructor = di, pi.prototype = Object.create(S.prototype), pi.prototype.constructor = pi, fi.prototype = Object.create(U.prototype), fi.prototype.constructor = fi;
            var kh = Object.freeze({
                WireframeGeometry: Qt,
                ParametricGeometry: Kt,
                ParametricBufferGeometry: en,
                TetrahedronGeometry: rn,
                TetrahedronBufferGeometry: an,
                OctahedronGeometry: on,
                OctahedronBufferGeometry: sn,
                IcosahedronGeometry: ln,
                IcosahedronBufferGeometry: cn,
                DodecahedronGeometry: un,
                DodecahedronBufferGeometry: hn,
                PolyhedronGeometry: tn,
                PolyhedronBufferGeometry: nn,
                TubeGeometry: dn,
                TubeBufferGeometry: pn,
                TorusKnotGeometry: fn,
                TorusKnotBufferGeometry: mn,
                TorusGeometry: vn,
                TorusBufferGeometry: gn,
                TextGeometry: $n,
                TextBufferGeometry: Qn,
                SphereGeometry: Kn,
                SphereBufferGeometry: ei,
                RingGeometry: ti,
                RingBufferGeometry: ni,
                PlaneGeometry: G,
                PlaneBufferGeometry: H,
                LatheGeometry: ii,
                LatheBufferGeometry: ri,
                ShapeGeometry: ai,
                ShapeBufferGeometry: oi,
                ExtrudeGeometry: Yn,
                ExtrudeBufferGeometry: Zn,
                EdgesGeometry: li,
                ConeGeometry: hi,
                ConeBufferGeometry: di,
                CylinderGeometry: ci,
                CylinderBufferGeometry: ui,
                CircleGeometry: pi,
                CircleBufferGeometry: fi,
                BoxGeometry: j,
                BoxBufferGeometry: F
            });
            mi.prototype = Object.create(V.prototype), mi.prototype.constructor = mi, mi.prototype.isShadowMaterial = !0, mi.prototype.copy = function (e) {
                return V.prototype.copy.call(this, e), this.color.copy(e.color), this
            }, vi.prototype = Object.create(W.prototype), vi.prototype.constructor = vi, vi.prototype.isRawShaderMaterial = !0, gi.prototype = Object.create(V.prototype), gi.prototype.constructor = gi, gi.prototype.isMeshStandardMaterial = !0, gi.prototype.copy = function (e) {
                return V.prototype.copy.call(this, e), this.defines = {
                    STANDARD: ""
                }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, yi.prototype = Object.create(gi.prototype), yi.prototype.constructor = yi, yi.prototype.isMeshPhysicalMaterial = !0, yi.prototype.copy = function (e) {
                return gi.prototype.copy.call(this, e), this.defines = {
                    PHYSICAL: ""
                }, this.reflectivity = e.reflectivity, this.clearCoat = e.clearCoat, this.clearCoatRoughness = e.clearCoatRoughness, this
            }, xi.prototype = Object.create(V.prototype), xi.prototype.constructor = xi, xi.prototype.isMeshPhongMaterial = !0, xi.prototype.copy = function (e) {
                return V.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, bi.prototype = Object.create(xi.prototype), bi.prototype.constructor = bi, bi.prototype.isMeshToonMaterial = !0, bi.prototype.copy = function (e) {
                return xi.prototype.copy.call(this, e), this.gradientMap = e.gradientMap, this
            }, _i.prototype = Object.create(V.prototype), _i.prototype.constructor = _i, _i.prototype.isMeshNormalMaterial = !0, _i.prototype.copy = function (e) {
                return V.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, wi.prototype = Object.create(V.prototype), wi.prototype.constructor = wi, wi.prototype.isMeshLambertMaterial = !0, wi.prototype.copy = function (e) {
                return V.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, Mi.prototype = Object.create(V.prototype), Mi.prototype.constructor = Mi, Mi.prototype.isMeshMatcapMaterial = !0, Mi.prototype.copy = function (e) {
                return V.prototype.copy.call(this, e), this.defines = {
                    MATCAP: ""
                }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, Ti.prototype = Object.create(Gt.prototype), Ti.prototype.constructor = Ti, Ti.prototype.isLineDashedMaterial = !0, Ti.prototype.copy = function (e) {
                return Gt.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
            };
            var Dh = Object.freeze({
                    ShadowMaterial: mi,
                    SpriteMaterial: zt,
                    RawShaderMaterial: vi,
                    ShaderMaterial: W,
                    PointsMaterial: qt,
                    MeshPhysicalMaterial: yi,
                    MeshStandardMaterial: gi,
                    MeshPhongMaterial: xi,
                    MeshToonMaterial: bi,
                    MeshNormalMaterial: _i,
                    MeshLambertMaterial: wi,
                    MeshDepthMaterial: gt,
                    MeshDistanceMaterial: yt,
                    MeshBasicMaterial: Y,
                    MeshMatcapMaterial: Mi,
                    LineDashedMaterial: Ti,
                    LineBasicMaterial: Gt,
                    Material: V
                }),
                zh = {
                    arraySlice: function (e, t, n) {
                        return zh.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
                    },
                    convertArray: function (e, t, n) {
                        return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
                    },
                    isTypedArray: function (e) {
                        return ArrayBuffer.isView(e) && !(e instanceof DataView)
                    },
                    getKeyframeOrder: function (e) {
                        function t(t, n) {
                            return e[t] - e[n]
                        }
                        for (var n = e.length, i = new Array(n), r = 0; r !== n; ++r) i[r] = r;
                        return i.sort(t), i
                    },
                    sortedArray: function (e, t, n) {
                        for (var i = e.length, r = new e.constructor(i), a = 0, o = 0; o !== i; ++a)
                            for (var s = n[a] * t, l = 0; l !== t; ++l) r[o++] = e[s + l];
                        return r
                    },
                    flattenJSON: function (e, t, n, i) {
                        for (var r = 1, a = e[0]; void 0 !== a && void 0 === a[i];) a = e[r++];
                        if (void 0 !== a) {
                            var o = a[i];
                            if (void 0 !== o)
                                if (Array.isArray(o)) {
                                    do o = a[i], void 0 !== o && (t.push(a.time), n.push.apply(n, o)), a = e[r++]; while (void 0 !== a)
                                } else if (void 0 !== o.toArray) {
                                do o = a[i], void 0 !== o && (t.push(a.time), o.toArray(n, n.length)), a = e[r++]; while (void 0 !== a)
                            } else
                                do o = a[i], void 0 !== o && (t.push(a.time), n.push(o)), a = e[r++]; while (void 0 !== a)
                        }
                    }
                };
            Object.assign(Ei.prototype, {
                evaluate: function (e) {
                    var t = this.parameterPositions,
                        n = this._cachedIndex,
                        i = t[n],
                        r = t[n - 1];
                    e: {
                        t: {
                            var a;n: {
                                i: if (!(e < i)) {
                                    for (var o = n + 2;;) {
                                        if (void 0 === i) {
                                            if (e < r) break i;
                                            return n = t.length, this._cachedIndex = n, this.afterEnd_(n - 1, e, r)
                                        }
                                        if (n === o) break;
                                        if (r = i, i = t[++n], e < i) break t
                                    }
                                    a = t.length;
                                    break n
                                } {
                                    if (e >= r) break e;
                                    var s = t[1];
                                    e < s && (n = 2, r = s);
                                    for (var o = n - 2;;) {
                                        if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, i);
                                        if (n === o) break;
                                        if (i = r, r = t[--n - 1], e >= r) break t
                                    }
                                    a = n, n = 0
                                }
                            }
                            for (; n < a;) {
                                var l = n + a >>> 1;
                                e < t[l] ? a = l : n = l + 1
                            }
                            if (i = t[n], r = t[n - 1], void 0 === r) return this._cachedIndex = 0,
                            this.beforeStart_(0, e, i);
                            if (void 0 === i) return n = t.length,
                            this._cachedIndex = n,
                            this.afterEnd_(n - 1, r, e)
                        }
                        this._cachedIndex = n,
                        this.intervalChanged_(n, r, i)
                    }
                    return this.interpolate_(n, r, e, i)
                },
                settings: null,
                DefaultSettings_: {},
                getSettings_: function () {
                    return this.settings || this.DefaultSettings_
                },
                copySampleValue_: function (e) {
                    for (var t = this.resultBuffer, n = this.sampleValues, i = this.valueSize, r = e * i, a = 0; a !== i; ++a) t[a] = n[r + a];
                    return t
                },
                interpolate_: function () {
                    throw new Error("call to abstract method")
                },
                intervalChanged_: function () {}
            }), Object.assign(Ei.prototype, {
                beforeStart_: Ei.prototype.copySampleValue_,
                afterEnd_: Ei.prototype.copySampleValue_
            }), Si.prototype = Object.assign(Object.create(Ei.prototype), {
                constructor: Si,
                DefaultSettings_: {
                    endingStart: Pl,
                    endingEnd: Pl
                },
                intervalChanged_: function (e, t, n) {
                    var i = this.parameterPositions,
                        r = e - 2,
                        a = e + 1,
                        o = i[r],
                        s = i[a];
                    if (void 0 === o) switch (this.getSettings_().endingStart) {
                        case Cl:
                            r = e, o = 2 * t - n;
                            break;
                        case Al:
                            r = i.length - 2, o = t + i[r] - i[r + 1];
                            break;
                        default:
                            r = e, o = n
                    }
                    if (void 0 === s) switch (this.getSettings_().endingEnd) {
                        case Cl:
                            a = e, s = 2 * n - t;
                            break;
                        case Al:
                            a = 1, s = n + i[1] - i[0];
                            break;
                        default:
                            a = e - 1, s = t
                    }
                    var l = .5 * (n - t),
                        c = this.valueSize;
                    this._weightPrev = l / (t - o), this._weightNext = l / (s - n), this._offsetPrev = r * c, this._offsetNext = a * c
                },
                interpolate_: function (e, t, n, i) {
                    for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, c = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, d = this._weightNext, p = (n - t) / (i - t), f = p * p, m = f * p, v = -h * m + 2 * h * f - h * p, g = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1, y = (-1 - d) * m + (1.5 + d) * f + .5 * p, x = d * m - d * f, b = 0; b !== o; ++b) r[b] = v * a[c + b] + g * a[l + b] + y * a[s + b] + x * a[u + b];
                    return r
                }
            }), Pi.prototype = Object.assign(Object.create(Ei.prototype), {
                constructor: Pi,
                interpolate_: function (e, t, n, i) {
                    for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, c = (n - t) / (i - t), u = 1 - c, h = 0; h !== o; ++h) r[h] = a[l + h] * u + a[s + h] * c;
                    return r
                }
            }), Ci.prototype = Object.assign(Object.create(Ei.prototype), {
                constructor: Ci,
                interpolate_: function (e) {
                    return this.copySampleValue_(e - 1)
                }
            }), Object.assign(Ai, {
                toJSON: function (e) {
                    var t, n = e.constructor;
                    if (void 0 !== n.toJSON) t = n.toJSON(e);
                    else {
                        t = {
                            name: e.name,
                            times: zh.convertArray(e.times, Array),
                            values: zh.convertArray(e.values, Array)
                        };
                        var i = e.getInterpolation();
                        i !== e.DefaultInterpolation && (t.interpolation = i)
                    }
                    return t.type = e.ValueTypeName, t
                }
            }), Object.assign(Ai.prototype, {
                constructor: Ai,
                TimeBufferType: Float32Array,
                ValueBufferType: Float32Array,
                DefaultInterpolation: El,
                InterpolantFactoryMethodDiscrete: function (e) {
                    return new Ci(this.times, this.values, this.getValueSize(), e)
                },
                InterpolantFactoryMethodLinear: function (e) {
                    return new Pi(this.times, this.values, this.getValueSize(), e)
                },
                InterpolantFactoryMethodSmooth: function (e) {
                    return new Si(this.times, this.values, this.getValueSize(), e)
                },
                setInterpolation: function (e) {
                    var t;
                    switch (e) {
                        case Tl:
                            t = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case El:
                            t = this.InterpolantFactoryMethodLinear;
                            break;
                        case Sl:
                            t = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === t) {
                        var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (e === this.DefaultInterpolation) throw new Error(n);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        return console.warn("THREE.KeyframeTrack:", n), this
                    }
                    return this.createInterpolant = t, this
                },
                getInterpolation: function () {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return Tl;
                        case this.InterpolantFactoryMethodLinear:
                            return El;
                        case this.InterpolantFactoryMethodSmooth:
                            return Sl
                    }
                },
                getValueSize: function () {
                    return this.values.length / this.times.length
                },
                shift: function (e) {
                    if (0 !== e)
                        for (var t = this.times, n = 0, i = t.length; n !== i; ++n) t[n] += e;
                    return this
                },
                scale: function (e) {
                    if (1 !== e)
                        for (var t = this.times, n = 0, i = t.length; n !== i; ++n) t[n] *= e;
                    return this
                },
                trim: function (e, t) {
                    for (var n = this.times, i = n.length, r = 0, a = i - 1; r !== i && n[r] < e;) ++r;
                    for (; a !== -1 && n[a] > t;) --a;
                    if (++a, 0 !== r || a !== i) {
                        r >= a && (a = Math.max(a, 1), r = a - 1);
                        var o = this.getValueSize();
                        this.times = zh.arraySlice(n, r, a), this.values = zh.arraySlice(this.values, r * o, a * o)
                    }
                    return this
                },
                validate: function () {
                    var e = !0,
                        t = this.getValueSize();
                    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                    var n = this.times,
                        i = this.values,
                        r = n.length;
                    0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                    for (var a = null, o = 0; o !== r; o++) {
                        var s = n[o];
                        if ("number" == typeof s && isNaN(s)) {
                            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, s), e = !1;
                            break
                        }
                        if (null !== a && a > s) {
                            console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s, a), e = !1;
                            break
                        }
                        a = s
                    }
                    if (void 0 !== i && zh.isTypedArray(i))
                        for (var o = 0, l = i.length; o !== l; ++o) {
                            var c = i[o];
                            if (isNaN(c)) {
                                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, c), e = !1;
                                break
                            }
                        }
                    return e
                },
                optimize: function () {
                    for (var e = this.times, t = this.values, n = this.getValueSize(), i = this.getInterpolation() === Sl, r = 1, a = e.length - 1, o = 1; o < a; ++o) {
                        var s = !1,
                            l = e[o],
                            c = e[o + 1];
                        if (l !== c && (1 !== o || l !== l[0]))
                            if (i) s = !0;
                            else
                                for (var u = o * n, h = u - n, d = u + n, p = 0; p !== n; ++p) {
                                    var f = t[u + p];
                                    if (f !== t[h + p] || f !== t[d + p]) {
                                        s = !0;
                                        break
                                    }
                                }
                        if (s) {
                            if (o !== r) {
                                e[r] = e[o];
                                for (var m = o * n, v = r * n, p = 0; p !== n; ++p) t[v + p] = t[m + p]
                            }++r
                        }
                    }
                    if (a > 0) {
                        e[r] = e[a];
                        for (var m = a * n, v = r * n, p = 0; p !== n; ++p) t[v + p] = t[m + p];
                        ++r
                    }
                    return r !== e.length && (this.times = zh.arraySlice(e, 0, r), this.values = zh.arraySlice(t, 0, r * n)), this
                },
                clone: function () {
                    var e = zh.arraySlice(this.times, 0),
                        t = zh.arraySlice(this.values, 0),
                        n = this.constructor,
                        i = new n(this.name, e, t);
                    return i.createInterpolant = this.createInterpolant, i
                }
            }), Li.prototype = Object.assign(Object.create(Ai.prototype), {
                constructor: Li,
                ValueTypeName: "bool",
                ValueBufferType: Array,
                DefaultInterpolation: Tl,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), Ri.prototype = Object.assign(Object.create(Ai.prototype), {
                constructor: Ri,
                ValueTypeName: "color"
            }), Ii.prototype = Object.assign(Object.create(Ai.prototype), {
                constructor: Ii,
                ValueTypeName: "number"
            }), Oi.prototype = Object.assign(Object.create(Ei.prototype), {
                constructor: Oi,
                interpolate_: function (e, t, n, i) {
                    for (var a = this.resultBuffer, o = this.sampleValues, s = this.valueSize, l = e * s, c = (n - t) / (i - t), u = l + s; l !== u; l += 4) r.slerpFlat(a, 0, o, l - s, o, l, c);
                    return a
                }
            }), ki.prototype = Object.assign(Object.create(Ai.prototype), {
                constructor: ki,
                ValueTypeName: "quaternion",
                DefaultInterpolation: El,
                InterpolantFactoryMethodLinear: function (e) {
                    return new Oi(this.times, this.values, this.getValueSize(), e)
                },
                InterpolantFactoryMethodSmooth: void 0
            }), Di.prototype = Object.assign(Object.create(Ai.prototype), {
                constructor: Di,
                ValueTypeName: "string",
                ValueBufferType: Array,
                DefaultInterpolation: Tl,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), zi.prototype = Object.assign(Object.create(Ai.prototype), {
                constructor: zi,
                ValueTypeName: "vector"
            }), Object.assign(Bi, {
                parse: function (e) {
                    for (var t = [], n = e.tracks, i = 1 / (e.fps || 1), r = 0, a = n.length; r !== a; ++r) t.push(Ui(n[r]).scale(i));
                    return new Bi(e.name, e.duration, t)
                },
                toJSON: function (e) {
                    for (var t = [], n = e.tracks, i = {
                            name: e.name,
                            duration: e.duration,
                            tracks: t,
                            uuid: e.uuid
                        }, r = 0, a = n.length; r !== a; ++r) t.push(Ai.toJSON(n[r]));
                    return i
                },
                CreateFromMorphTargetSequence: function (e, t, n, i) {
                    for (var r = t.length, a = [], o = 0; o < r; o++) {
                        var s = [],
                            l = [];
                        s.push((o + r - 1) % r, o, (o + 1) % r), l.push(0, 1, 0);
                        var c = zh.getKeyframeOrder(s);
                        s = zh.sortedArray(s, 1, c), l = zh.sortedArray(l, 1, c), i || 0 !== s[0] || (s.push(r), l.push(l[0])), a.push(new Ii(".morphTargetInfluences[" + t[o].name + "]", s, l).scale(1 / n))
                    }
                    return new Bi(e, (-1), a)
                },
                findByName: function (e, t) {
                    var n = e;
                    if (!Array.isArray(e)) {
                        var i = e;
                        n = i.geometry && i.geometry.animations || i.animations
                    }
                    for (var r = 0; r < n.length; r++)
                        if (n[r].name === t) return n[r];
                    return null
                },
                CreateClipsFromMorphTargetSequences: function (e, t, n) {
                    for (var i = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = e.length; a < o; a++) {
                        var s = e[a],
                            l = s.name.match(r);
                        if (l && l.length > 1) {
                            var c = l[1],
                                u = i[c];
                            u || (i[c] = u = []), u.push(s)
                        }
                    }
                    var h = [];
                    for (var c in i) h.push(Bi.CreateFromMorphTargetSequence(c, i[c], t, n));
                    return h
                },
                parseAnimation: function (e, t) {
                    if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                    for (var n = function (e, t, n, i, r) {
                            if (0 !== n.length) {
                                var a = [],
                                    o = [];
                                zh.flattenJSON(n, a, o, i), 0 !== a.length && r.push(new e(t, a, o))
                            }
                        }, i = [], r = e.name || "default", a = e.length || -1, o = e.fps || 30, s = e.hierarchy || [], l = 0; l < s.length; l++) {
                        var c = s[l].keys;
                        if (c && 0 !== c.length)
                            if (c[0].morphTargets) {
                                for (var u = {}, h = 0; h < c.length; h++)
                                    if (c[h].morphTargets)
                                        for (var d = 0; d < c[h].morphTargets.length; d++) u[c[h].morphTargets[d]] = -1;
                                for (var p in u) {
                                    for (var f = [], m = [], d = 0; d !== c[h].morphTargets.length; ++d) {
                                        var v = c[h];
                                        f.push(v.time), m.push(v.morphTarget === p ? 1 : 0)
                                    }
                                    i.push(new Ii(".morphTargetInfluence[" + p + "]", f, m))
                                }
                                a = u.length * (o || 1)
                            } else {
                                var g = ".bones[" + t[l].name + "]";
                                n(zi, g + ".position", c, "pos", i), n(ki, g + ".quaternion", c, "rot", i), n(zi, g + ".scale", c, "scl", i)
                            }
                    }
                    if (0 === i.length) return null;
                    var y = new Bi(r, a, i);
                    return y
                }
            }), Object.assign(Bi.prototype, {
                resetDuration: function () {
                    for (var e = this.tracks, t = 0, n = 0, i = e.length; n !== i; ++n) {
                        var r = this.tracks[n];
                        t = Math.max(t, r.times[r.times.length - 1])
                    }
                    return this.duration = t, this
                },
                trim: function () {
                    for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                    return this
                },
                validate: function () {
                    for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                    return e
                },
                optimize: function () {
                    for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                    return this
                },
                clone: function () {
                    for (var e = [], t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
                    return new Bi(this.name, this.duration, e)
                }
            });
            var Bh = {
                    enabled: !1,
                    files: {},
                    add: function (e, t) {
                        this.enabled !== !1 && (this.files[e] = t)
                    },
                    get: function (e) {
                        if (this.enabled !== !1) return this.files[e]
                    },
                    remove: function (e) {
                        delete this.files[e]
                    },
                    clear: function () {
                        this.files = {}
                    }
                },
                Nh = new ji,
                Uh = {};
            Object.assign(Fi.prototype, {
                load: function (e, t, n, i) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    var r = this,
                        a = Bh.get(e);
                    if (void 0 !== a) return r.manager.itemStart(e), setTimeout(function () {
                        t && t(a), r.manager.itemEnd(e)
                    }, 0), a;
                    if (void 0 !== Uh[e]) return void Uh[e].push({
                        onLoad: t,
                        onProgress: n,
                        onError: i
                    });
                    var o = /^data:(.*?)(;base64)?,(.*)$/,
                        s = e.match(o);
                    if (s) {
                        var l = s[1],
                            c = !!s[2],
                            u = s[3];
                        u = decodeURIComponent(u), c && (u = atob(u));
                        try {
                            var h, d = (this.responseType || "").toLowerCase();
                            switch (d) {
                                case "arraybuffer":
                                case "blob":
                                    for (var p = new Uint8Array(u.length), f = 0; f < u.length; f++) p[f] = u.charCodeAt(f);
                                    h = "blob" === d ? new Blob([p.buffer], {
                                        type: l
                                    }) : p.buffer;
                                    break;
                                case "document":
                                    var m = new DOMParser;
                                    h = m.parseFromString(u, l);
                                    break;
                                case "json":
                                    h = JSON.parse(u);
                                    break;
                                default:
                                    h = u
                            }
                            setTimeout(function () {
                                t && t(h), r.manager.itemEnd(e)
                            }, 0)
                        } catch (v) {
                            setTimeout(function () {
                                i && i(v), r.manager.itemError(e), r.manager.itemEnd(e)
                            }, 0)
                        }
                    } else {
                        Uh[e] = [], Uh[e].push({
                            onLoad: t,
                            onProgress: n,
                            onError: i
                        });
                        var g = new XMLHttpRequest;
                        g.open("GET", e, !0), g.addEventListener("load", function (t) {
                            var n = this.response;
                            Bh.add(e, n);
                            var i = Uh[e];
                            if (delete Uh[e], 200 === this.status || 0 === this.status) {
                                0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                for (var a = 0, o = i.length; a < o; a++) {
                                    var s = i[a];
                                    s.onLoad && s.onLoad(n)
                                }
                                r.manager.itemEnd(e)
                            } else {
                                for (var a = 0, o = i.length; a < o; a++) {
                                    var s = i[a];
                                    s.onError && s.onError(t)
                                }
                                r.manager.itemError(e), r.manager.itemEnd(e)
                            }
                        }, !1), g.addEventListener("progress", function (t) {
                            for (var n = Uh[e], i = 0, r = n.length; i < r; i++) {
                                var a = n[i];
                                a.onProgress && a.onProgress(t)
                            }
                        }, !1), g.addEventListener("error", function (t) {
                            var n = Uh[e];
                            delete Uh[e];
                            for (var i = 0, a = n.length; i < a; i++) {
                                var o = n[i];
                                o.onError && o.onError(t)
                            }
                            r.manager.itemError(e), r.manager.itemEnd(e)
                        }, !1), g.addEventListener("abort", function (t) {
                            var n = Uh[e];
                            delete Uh[e];
                            for (var i = 0, a = n.length; i < a; i++) {
                                var o = n[i];
                                o.onError && o.onError(t)
                            }
                            r.manager.itemError(e), r.manager.itemEnd(e)
                        }, !1), void 0 !== this.responseType && (g.responseType = this.responseType), void 0 !== this.withCredentials && (g.withCredentials = this.withCredentials), g.overrideMimeType && g.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                        for (var y in this.requestHeader) g.setRequestHeader(y, this.requestHeader[y]);
                        g.send(null)
                    }
                    return r.manager.itemStart(e), g
                },
                setPath: function (e) {
                    return this.path = e, this
                },
                setResponseType: function (e) {
                    return this.responseType = e, this
                },
                setWithCredentials: function (e) {
                    return this.withCredentials = e, this
                },
                setMimeType: function (e) {
                    return this.mimeType = e, this
                },
                setRequestHeader: function (e) {
                    return this.requestHeader = e, this
                }
            }), Object.assign(Gi.prototype, {
                load: function (e, t, n, i) {
                    var r = this,
                        a = new Fi(r.manager);
                    a.setPath(r.path), a.load(e, function (e) {
                        t(r.parse(JSON.parse(e)))
                    }, n, i)
                },
                parse: function (e, t) {
                    for (var n = [], i = 0; i < e.length; i++) {
                        var r = Bi.parse(e[i]);
                        n.push(r)
                    }
                    t(n)
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }), Object.assign(Hi.prototype, {
                load: function (e, t, n, i) {
                    function r(r) {
                        l.load(e[r], function (e) {
                            var n = a._parser(e, !0);
                            o[r] = {
                                width: n.width,
                                height: n.height,
                                format: n.format,
                                mipmaps: n.mipmaps
                            }, c += 1, 6 === c && (1 === n.mipmapCount && (s.minFilter = Cs), s.format = n.format, s.needsUpdate = !0, t && t(s))
                        }, n, i)
                    }
                    var a = this,
                        o = [],
                        s = new Zt;
                    s.image = o;
                    var l = new Fi(this.manager);
                    if (l.setPath(this.path), l.setResponseType("arraybuffer"), Array.isArray(e))
                        for (var c = 0, u = 0, h = e.length; u < h; ++u) r(u);
                    else l.load(e, function (e) {
                        var n = a._parser(e, !0);
                        if (n.isCubemap)
                            for (var i = n.mipmaps.length / n.mipmapCount, r = 0; r < i; r++) {
                                o[r] = {
                                    mipmaps: []
                                };
                                for (var l = 0; l < n.mipmapCount; l++) o[r].mipmaps.push(n.mipmaps[r * n.mipmapCount + l]), o[r].format = n.format, o[r].width = n.width, o[r].height = n.height
                            } else s.image.width = n.width, s.image.height = n.height, s.mipmaps = n.mipmaps;
                        1 === n.mipmapCount && (s.minFilter = Cs), s.format = n.format, s.needsUpdate = !0, t && t(s)
                    }, n, i);
                    return s
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }), Object.assign(Vi.prototype, {
                load: function (e, t, n, i) {
                    var r = this,
                        a = new d,
                        o = new Fi(this.manager);
                    return o.setResponseType("arraybuffer"), o.setPath(this.path), o.load(e, function (e) {
                        var n = r._parser(e);
                        n && (void 0 !== n.image ? a.image = n.image : void 0 !== n.data && (a.image.width = n.width, a.image.height = n.height, a.image.data = n.data), a.wrapS = void 0 !== n.wrapS ? n.wrapS : Ms, a.wrapT = void 0 !== n.wrapT ? n.wrapT : Ms, a.magFilter = void 0 !== n.magFilter ? n.magFilter : Cs, a.minFilter = void 0 !== n.minFilter ? n.minFilter : Ls, a.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (a.format = n.format), void 0 !== n.type && (a.type = n.type), void 0 !== n.mipmaps && (a.mipmaps = n.mipmaps), 1 === n.mipmapCount && (a.minFilter = Cs), a.needsUpdate = !0, t && t(a, n))
                    }, n, i), a
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }), Object.assign(Wi.prototype, {
                crossOrigin: "anonymous",
                load: function (e, t, n, i) {
                    function r() {
                        l.removeEventListener("load", r, !1), l.removeEventListener("error", a, !1), Bh.add(e, this), t && t(this), o.manager.itemEnd(e)
                    }

                    function a(t) {
                        l.removeEventListener("load", r, !1), l.removeEventListener("error", a, !1), i && i(t), o.manager.itemError(e), o.manager.itemEnd(e)
                    }
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    var o = this,
                        s = Bh.get(e);
                    if (void 0 !== s) return o.manager.itemStart(e), setTimeout(function () {
                        t && t(s), o.manager.itemEnd(e)
                    }, 0), s;
                    var l = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                    return l.addEventListener("load", r, !1), l.addEventListener("error", a, !1), "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (l.crossOrigin = this.crossOrigin), o.manager.itemStart(e), l.src = e, l
                },
                setCrossOrigin: function (e) {
                    return this.crossOrigin = e, this
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }), Object.assign(qi.prototype, {
                crossOrigin: "anonymous",
                load: function (e, t, n, i) {
                    function r(n) {
                        o.load(e[n], function (e) {
                            a.images[n] = e, s++, 6 === s && (a.needsUpdate = !0, t && t(a))
                        }, void 0, i)
                    }
                    var a = new se,
                        o = new Wi(this.manager);
                    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                    for (var s = 0, l = 0; l < e.length; ++l) r(l);
                    return a
                },
                setCrossOrigin: function (e) {
                    return this.crossOrigin = e, this
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }), Object.assign(Xi.prototype, {
                crossOrigin: "anonymous",
                load: function (e, t, n, i) {
                    var r = new s,
                        a = new Wi(this.manager);
                    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function (n) {
                        r.image = n;
                        var i = e.search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/);
                        r.format = i ? Vs : Ws, r.needsUpdate = !0, void 0 !== t && t(r)
                    }, n, i), r
                },
                setCrossOrigin: function (e) {
                    return this.crossOrigin = e, this
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }), Object.assign(Yi.prototype, {
                getPoint: function () {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                },
                getPointAt: function (e, t) {
                    var n = this.getUtoTmapping(e);
                    return this.getPoint(n, t)
                },
                getPoints: function (e) {
                    void 0 === e && (e = 5);
                    for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                    return t
                },
                getSpacedPoints: function (e) {
                    void 0 === e && (e = 5);
                    for (var t = [], n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
                    return t
                },
                getLength: function () {
                    var e = this.getLengths();
                    return e[e.length - 1]
                },
                getLengths: function (e) {
                    if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    var t, n, i = [],
                        r = this.getPoint(0),
                        a = 0;
                    for (i.push(0), n = 1; n <= e; n++) t = this.getPoint(n / e), a += t.distanceTo(r), i.push(a), r = t;
                    return this.cacheArcLengths = i, i
                },
                updateArcLengths: function () {
                    this.needsUpdate = !0, this.getLengths()
                },
                getUtoTmapping: function (e, t) {
                    var n, i = this.getLengths(),
                        r = 0,
                        a = i.length;
                    n = t ? t : e * i[a - 1];
                    for (var o, s = 0, l = a - 1; s <= l;)
                        if (r = Math.floor(s + (l - s) / 2), o = i[r] - n, o < 0) s = r + 1;
                        else {
                            if (!(o > 0)) {
                                l = r;
                                break
                            }
                            l = r - 1
                        } if (r = l, i[r] === n) return r / (a - 1);
                    var c = i[r],
                        u = i[r + 1],
                        h = u - c,
                        d = (n - c) / h,
                        p = (r + d) / (a - 1);
                    return p
                },
                getTangent: function (e) {
                    var t = 1e-4,
                        n = e - t,
                        i = e + t;
                    n < 0 && (n = 0), i > 1 && (i = 1);
                    var r = this.getPoint(n),
                        a = this.getPoint(i),
                        o = a.clone().sub(r);
                    return o.normalize()
                },
                getTangentAt: function (e) {
                    var t = this.getUtoTmapping(e);
                    return this.getTangent(t)
                },
                computeFrenetFrames: function (e, t) {
                    var n, r, o, s = new a,
                        l = [],
                        c = [],
                        u = [],
                        h = new a,
                        d = new i;
                    for (n = 0; n <= e; n++) r = n / e, l[n] = this.getTangentAt(r), l[n].normalize();
                    c[0] = new a, u[0] = new a;
                    var p = Number.MAX_VALUE,
                        f = Math.abs(l[0].x),
                        m = Math.abs(l[0].y),
                        v = Math.abs(l[0].z);
                    for (f <= p && (p = f, s.set(1, 0, 0)), m <= p && (p = m, s.set(0, 1, 0)), v <= p && s.set(0, 0, 1), h.crossVectors(l[0], s).normalize(), c[0].crossVectors(l[0], h), u[0].crossVectors(l[0], c[0]), n = 1; n <= e; n++) c[n] = c[n - 1].clone(), u[n] = u[n - 1].clone(), h.crossVectors(l[n - 1], l[n]), h.length() > Number.EPSILON && (h.normalize(), o = Math.acos(Wl.clamp(l[n - 1].dot(l[n]), -1, 1)), c[n].applyMatrix4(d.makeRotationAxis(h, o))), u[n].crossVectors(l[n], c[n]);
                    if (t === !0)
                        for (o = Math.acos(Wl.clamp(c[0].dot(c[e]), -1, 1)), o /= e, l[0].dot(h.crossVectors(c[0], c[e])) > 0 && (o = -o), n = 1; n <= e; n++) c[n].applyMatrix4(d.makeRotationAxis(l[n], o * n)), u[n].crossVectors(l[n], c[n]);
                    return {
                        tangents: l,
                        normals: c,
                        binormals: u
                    }
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                },
                toJSON: function () {
                    var e = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
                },
                fromJSON: function (e) {
                    return this.arcLengthDivisions = e.arcLengthDivisions, this
                }
            }), Zi.prototype = Object.create(Yi.prototype), Zi.prototype.constructor = Zi, Zi.prototype.isEllipseCurve = !0, Zi.prototype.getPoint = function (e, t) {
                for (var i = t || new n, r = 2 * Math.PI, a = this.aEndAngle - this.aStartAngle, o = Math.abs(a) < Number.EPSILON; a < 0;) a += r;
                for (; a > r;) a -= r;
                a < Number.EPSILON && (a = o ? 0 : r), this.aClockwise !== !0 || o || (a === r ? a = -r : a -= r);
                var s = this.aStartAngle + e * a,
                    l = this.aX + this.xRadius * Math.cos(s),
                    c = this.aY + this.yRadius * Math.sin(s);
                if (0 !== this.aRotation) {
                    var u = Math.cos(this.aRotation),
                        h = Math.sin(this.aRotation),
                        d = l - this.aX,
                        p = c - this.aY;
                    l = d * u - p * h + this.aX, c = d * h + p * u + this.aY
                }
                return i.set(l, c)
            }, Zi.prototype.copy = function (e) {
                return Yi.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
            }, Zi.prototype.toJSON = function () {
                var e = Yi.prototype.toJSON.call(this);
                return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
            }, Zi.prototype.fromJSON = function (e) {
                return Yi.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
            }, Ji.prototype = Object.create(Zi.prototype), Ji.prototype.constructor = Ji, Ji.prototype.isArcCurve = !0;
            var jh = new a,
                Fh = new $i,
                Gh = new $i,
                Hh = new $i;
            Qi.prototype = Object.create(Yi.prototype), Qi.prototype.constructor = Qi, Qi.prototype.isCatmullRomCurve3 = !0, Qi.prototype.getPoint = function (e, t) {
                var n = t || new a,
                    i = this.points,
                    r = i.length,
                    o = (r - (this.closed ? 0 : 1)) * e,
                    s = Math.floor(o),
                    l = o - s;
                this.closed ? s += s > 0 ? 0 : (Math.floor(Math.abs(s) / r) + 1) * r : 0 === l && s === r - 1 && (s = r - 2, l = 1);
                var c, u, h, d;
                if (this.closed || s > 0 ? c = i[(s - 1) % r] : (jh.subVectors(i[0], i[1]).add(i[0]), c = jh), u = i[s % r], h = i[(s + 1) % r], this.closed || s + 2 < r ? d = i[(s + 2) % r] : (jh.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), d = jh), "centripetal" === this.curveType || "chordal" === this.curveType) {
                    var p = "chordal" === this.curveType ? .5 : .25,
                        f = Math.pow(c.distanceToSquared(u), p),
                        m = Math.pow(u.distanceToSquared(h), p),
                        v = Math.pow(h.distanceToSquared(d), p);
                    m < 1e-4 && (m = 1), f < 1e-4 && (f = m), v < 1e-4 && (v = m), Fh.initNonuniformCatmullRom(c.x, u.x, h.x, d.x, f, m, v), Gh.initNonuniformCatmullRom(c.y, u.y, h.y, d.y, f, m, v), Hh.initNonuniformCatmullRom(c.z, u.z, h.z, d.z, f, m, v)
                } else "catmullrom" === this.curveType && (Fh.initCatmullRom(c.x, u.x, h.x, d.x, this.tension), Gh.initCatmullRom(c.y, u.y, h.y, d.y, this.tension), Hh.initCatmullRom(c.z, u.z, h.z, d.z, this.tension));
                return n.set(Fh.calc(l), Gh.calc(l), Hh.calc(l)), n
            }, Qi.prototype.copy = function (e) {
                Yi.prototype.copy.call(this, e), this.points = [];
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var i = e.points[t];
                    this.points.push(i.clone())
                }
                return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
            }, Qi.prototype.toJSON = function () {
                var e = Yi.prototype.toJSON.call(this);
                e.points = [];
                for (var t = 0, n = this.points.length; t < n; t++) {
                    var i = this.points[t];
                    e.points.push(i.toArray())
                }
                return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
            }, Qi.prototype.fromJSON = function (e) {
                Yi.prototype.fromJSON.call(this, e), this.points = [];
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var i = e.points[t];
                    this.points.push((new a).fromArray(i))
                }
                return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
            }, cr.prototype = Object.create(Yi.prototype), cr.prototype.constructor = cr, cr.prototype.isCubicBezierCurve = !0, cr.prototype.getPoint = function (e, t) {
                var i = t || new n,
                    r = this.v0,
                    a = this.v1,
                    o = this.v2,
                    s = this.v3;
                return i.set(lr(e, r.x, a.x, o.x, s.x), lr(e, r.y, a.y, o.y, s.y)), i
            }, cr.prototype.copy = function (e) {
                return Yi.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
            }, cr.prototype.toJSON = function () {
                var e = Yi.prototype.toJSON.call(this);
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
            }, cr.prototype.fromJSON = function (e) {
                return Yi.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
            }, ur.prototype = Object.create(Yi.prototype), ur.prototype.constructor = ur, ur.prototype.isCubicBezierCurve3 = !0, ur.prototype.getPoint = function (e, t) {
                var n = t || new a,
                    i = this.v0,
                    r = this.v1,
                    o = this.v2,
                    s = this.v3;
                return n.set(lr(e, i.x, r.x, o.x, s.x), lr(e, i.y, r.y, o.y, s.y), lr(e, i.z, r.z, o.z, s.z)), n
            }, ur.prototype.copy = function (e) {
                return Yi.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
            }, ur.prototype.toJSON = function () {
                var e = Yi.prototype.toJSON.call(this);
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
            }, ur.prototype.fromJSON = function (e) {
                return Yi.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
            }, hr.prototype = Object.create(Yi.prototype), hr.prototype.constructor = hr, hr.prototype.isLineCurve = !0, hr.prototype.getPoint = function (e, t) {
                var i = t || new n;
                return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i
            }, hr.prototype.getPointAt = function (e, t) {
                return this.getPoint(e, t)
            }, hr.prototype.getTangent = function () {
                var e = this.v2.clone().sub(this.v1);
                return e.normalize()
            }, hr.prototype.copy = function (e) {
                return Yi.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }, hr.prototype.toJSON = function () {
                var e = Yi.prototype.toJSON.call(this);
                return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }, hr.prototype.fromJSON = function (e) {
                return Yi.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }, dr.prototype = Object.create(Yi.prototype), dr.prototype.constructor = dr, dr.prototype.isLineCurve3 = !0, dr.prototype.getPoint = function (e, t) {
                var n = t || new a;
                return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
            }, dr.prototype.getPointAt = function (e, t) {
                return this.getPoint(e, t)
            }, dr.prototype.copy = function (e) {
                return Yi.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }, dr.prototype.toJSON = function () {
                var e = Yi.prototype.toJSON.call(this);
                return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }, dr.prototype.fromJSON = function (e) {
                return Yi.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }, pr.prototype = Object.create(Yi.prototype), pr.prototype.constructor = pr, pr.prototype.isQuadraticBezierCurve = !0, pr.prototype.getPoint = function (e, t) {
                var i = t || new n,
                    r = this.v0,
                    a = this.v1,
                    o = this.v2;
                return i.set(ir(e, r.x, a.x, o.x), ir(e, r.y, a.y, o.y)), i
            }, pr.prototype.copy = function (e) {
                return Yi.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }, pr.prototype.toJSON = function () {
                var e = Yi.prototype.toJSON.call(this);
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }, pr.prototype.fromJSON = function (e) {
                return Yi.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }, fr.prototype = Object.create(Yi.prototype), fr.prototype.constructor = fr, fr.prototype.isQuadraticBezierCurve3 = !0, fr.prototype.getPoint = function (e, t) {
                var n = t || new a,
                    i = this.v0,
                    r = this.v1,
                    o = this.v2;
                return n.set(ir(e, i.x, r.x, o.x), ir(e, i.y, r.y, o.y), ir(e, i.z, r.z, o.z)), n
            }, fr.prototype.copy = function (e) {
                return Yi.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
            }, fr.prototype.toJSON = function () {
                var e = Yi.prototype.toJSON.call(this);
                return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
            }, fr.prototype.fromJSON = function (e) {
                return Yi.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
            }, mr.prototype = Object.create(Yi.prototype), mr.prototype.constructor = mr, mr.prototype.isSplineCurve = !0, mr.prototype.getPoint = function (e, t) {
                var i = t || new n,
                    r = this.points,
                    a = (r.length - 1) * e,
                    o = Math.floor(a),
                    s = a - o,
                    l = r[0 === o ? o : o - 1],
                    c = r[o],
                    u = r[o > r.length - 2 ? r.length - 1 : o + 1],
                    h = r[o > r.length - 3 ? r.length - 1 : o + 2];
                return i.set(Ki(s, l.x, c.x, u.x, h.x), Ki(s, l.y, c.y, u.y, h.y)), i
            }, mr.prototype.copy = function (e) {
                Yi.prototype.copy.call(this, e), this.points = [];
                for (var t = 0, n = e.points.length; t < n; t++) {
                    var i = e.points[t];
                    this.points.push(i.clone())
                }
                return this
            }, mr.prototype.toJSON = function () {
                var e = Yi.prototype.toJSON.call(this);
                e.points = [];
                for (var t = 0, n = this.points.length; t < n; t++) {
                    var i = this.points[t];
                    e.points.push(i.toArray())
                }
                return e
            }, mr.prototype.fromJSON = function (e) {
                Yi.prototype.fromJSON.call(this, e), this.points = [];
                for (var t = 0, i = e.points.length; t < i; t++) {
                    var r = e.points[t];
                    this.points.push((new n).fromArray(r))
                }
                return this
            };
            var Vh = Object.freeze({
                ArcCurve: Ji,
                CatmullRomCurve3: Qi,
                CubicBezierCurve: cr,
                CubicBezierCurve3: ur,
                EllipseCurve: Zi,
                LineCurve: hr,
                LineCurve3: dr,
                QuadraticBezierCurve: pr,
                QuadraticBezierCurve3: fr,
                SplineCurve: mr
            });
            vr.prototype = Object.assign(Object.create(Yi.prototype), {
                constructor: vr,
                add: function (e) {
                    this.curves.push(e)
                },
                closePath: function () {
                    var e = this.curves[0].getPoint(0),
                        t = this.curves[this.curves.length - 1].getPoint(1);
                    e.equals(t) || this.curves.push(new hr(t, e))
                },
                getPoint: function (e) {
                    for (var t = e * this.getLength(), n = this.getCurveLengths(), i = 0; i < n.length;) {
                        if (n[i] >= t) {
                            var r = n[i] - t,
                                a = this.curves[i],
                                o = a.getLength(),
                                s = 0 === o ? 0 : 1 - r / o;
                            return a.getPointAt(s)
                        }
                        i++
                    }
                    return null
                },
                getLength: function () {
                    var e = this.getCurveLengths();
                    return e[e.length - 1]
                },
                updateArcLengths: function () {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                },
                getCurveLengths: function () {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    for (var e = [], t = 0, n = 0, i = this.curves.length; n < i; n++) t += this.curves[n].getLength(), e.push(t);
                    return this.cacheLengths = e, e
                },
                getSpacedPoints: function (e) {
                    void 0 === e && (e = 40);
                    for (var t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                    return this.autoClose && t.push(t[0]), t
                },
                getPoints: function (e) {
                    e = e || 12;
                    for (var t, n = [], i = 0, r = this.curves; i < r.length; i++)
                        for (var a = r[i], o = a && a.isEllipseCurve ? 2 * e : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? e * a.points.length : e, s = a.getPoints(o), l = 0; l < s.length; l++) {
                            var c = s[l];
                            t && t.equals(c) || (n.push(c), t = c)
                        }
                    return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
                },
                copy: function (e) {
                    Yi.prototype.copy.call(this, e), this.curves = [];
                    for (var t = 0, n = e.curves.length; t < n; t++) {
                        var i = e.curves[t];
                        this.curves.push(i.clone())
                    }
                    return this.autoClose = e.autoClose, this
                },
                toJSON: function () {
                    var e = Yi.prototype.toJSON.call(this);
                    e.autoClose = this.autoClose, e.curves = [];
                    for (var t = 0, n = this.curves.length; t < n; t++) {
                        var i = this.curves[t];
                        e.curves.push(i.toJSON())
                    }
                    return e
                },
                fromJSON: function (e) {
                    Yi.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = [];
                    for (var t = 0, n = e.curves.length; t < n; t++) {
                        var i = e.curves[t];
                        this.curves.push((new Vh[i.type]).fromJSON(i))
                    }
                    return this
                }
            }), gr.prototype = Object.assign(Object.create(vr.prototype), {
                constructor: gr,
                setFromPoints: function (e) {
                    this.moveTo(e[0].x, e[0].y);
                    for (var t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y)
                },
                moveTo: function (e, t) {
                    this.currentPoint.set(e, t)
                },
                lineTo: function (e, t) {
                    var i = new hr(this.currentPoint.clone(), new n(e, t));
                    this.curves.push(i), this.currentPoint.set(e, t)
                },
                quadraticCurveTo: function (e, t, i, r) {
                    var a = new pr(this.currentPoint.clone(), new n(e, t), new n(i, r));
                    this.curves.push(a), this.currentPoint.set(i, r)
                },
                bezierCurveTo: function (e, t, i, r, a, o) {
                    var s = new cr(this.currentPoint.clone(), new n(e, t), new n(i, r), new n(a, o));
                    this.curves.push(s), this.currentPoint.set(a, o)
                },
                splineThru: function (e) {
                    var t = [this.currentPoint.clone()].concat(e),
                        n = new mr(t);
                    this.curves.push(n), this.currentPoint.copy(e[e.length - 1])
                },
                arc: function (e, t, n, i, r, a) {
                    var o = this.currentPoint.x,
                        s = this.currentPoint.y;
                    this.absarc(e + o, t + s, n, i, r, a)
                },
                absarc: function (e, t, n, i, r, a) {
                    this.absellipse(e, t, n, n, i, r, a)
                },
                ellipse: function (e, t, n, i, r, a, o, s) {
                    var l = this.currentPoint.x,
                        c = this.currentPoint.y;
                    this.absellipse(e + l, t + c, n, i, r, a, o, s)
                },
                absellipse: function (e, t, n, i, r, a, o, s) {
                    var l = new Zi(e, t, n, i, r, a, o, s);
                    if (this.curves.length > 0) {
                        var c = l.getPoint(0);
                        c.equals(this.currentPoint) || this.lineTo(c.x, c.y)
                    }
                    this.curves.push(l);
                    var u = l.getPoint(1);
                    this.currentPoint.copy(u)
                },
                copy: function (e) {
                    return vr.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this
                },
                toJSON: function () {
                    var e = vr.prototype.toJSON.call(this);
                    return e.currentPoint = this.currentPoint.toArray(), e
                },
                fromJSON: function (e) {
                    return vr.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this
                }
            }), yr.prototype = Object.assign(Object.create(gr.prototype), {
                constructor: yr,
                getPointsHoles: function (e) {
                    for (var t = [], n = 0, i = this.holes.length; n < i; n++) t[n] = this.holes[n].getPoints(e);
                    return t
                },
                extractPoints: function (e) {
                    return {
                        shape: this.getPoints(e),
                        holes: this.getPointsHoles(e)
                    }
                },
                copy: function (e) {
                    gr.prototype.copy.call(this, e), this.holes = [];
                    for (var t = 0, n = e.holes.length; t < n; t++) {
                        var i = e.holes[t];
                        this.holes.push(i.clone())
                    }
                    return this
                },
                toJSON: function () {
                    var e = gr.prototype.toJSON.call(this);
                    e.uuid = this.uuid, e.holes = [];
                    for (var t = 0, n = this.holes.length; t < n; t++) {
                        var i = this.holes[t];
                        e.holes.push(i.toJSON())
                    }
                    return e
                },
                fromJSON: function (e) {
                    gr.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = [];
                    for (var t = 0, n = e.holes.length; t < n; t++) {
                        var i = e.holes[t];
                        this.holes.push((new gr).fromJSON(i))
                    }
                    return this
                }
            }), xr.prototype = Object.assign(Object.create(E.prototype), {
                constructor: xr,
                isLight: !0,
                copy: function (e) {
                    return E.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this
                },
                toJSON: function (e) {
                    var t = E.prototype.toJSON.call(this, e);
                    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
                }
            }), br.prototype = Object.assign(Object.create(xr.prototype), {
                constructor: br,
                isHemisphereLight: !0,
                copy: function (e) {
                    return xr.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
                }
            }), Object.assign(_r.prototype, {
                copy: function (e) {
                    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                toJSON: function () {
                    var e = {};
                    return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
                }
            }), wr.prototype = Object.assign(Object.create(_r.prototype), {
                constructor: wr,
                isSpotLightShadow: !0,
                update: function (e) {
                    var t = this.camera,
                        n = 2 * Wl.RAD2DEG * e.angle,
                        i = this.mapSize.width / this.mapSize.height,
                        r = e.distance || t.far;
                    n === t.fov && i === t.aspect && r === t.far || (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix())
                }
            }), Mr.prototype = Object.assign(Object.create(xr.prototype), {
                constructor: Mr,
                isSpotLight: !0,
                copy: function (e) {
                    return xr.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }), Tr.prototype = Object.assign(Object.create(xr.prototype), {
                constructor: Tr,
                isPointLight: !0,
                copy: function (e) {
                    return xr.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
                }
            }), Er.prototype = Object.assign(Object.create(Tt.prototype), {
                constructor: Er,
                isOrthographicCamera: !0,
                copy: function (e, t) {
                    return Tt.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
                },
                setViewOffset: function (e, t, n, i, r, a) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
                },
                clearViewOffset: function () {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function () {
                    var e = (this.right - this.left) / (2 * this.zoom),
                        t = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        i = (this.top + this.bottom) / 2,
                        r = n - e,
                        a = n + e,
                        o = i + t,
                        s = i - t;
                    if (null !== this.view && this.view.enabled) {
                        var l = this.zoom / (this.view.width / this.view.fullWidth),
                            c = this.zoom / (this.view.height / this.view.fullHeight),
                            u = (this.right - this.left) / this.view.width,
                            h = (this.top - this.bottom) / this.view.height;
                        r += u * (this.view.offsetX / l), a = r + u * (this.view.width / l), o -= h * (this.view.offsetY / c), s = o - h * (this.view.height / c)
                    }
                    this.projectionMatrix.makeOrthographic(r, a, o, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function (e) {
                    var t = E.prototype.toJSON.call(this, e);
                    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
                }
            }), Sr.prototype = Object.assign(Object.create(_r.prototype), {
                constructor: Sr
            }), Pr.prototype = Object.assign(Object.create(xr.prototype), {
                constructor: Pr,
                isDirectionalLight: !0,
                copy: function (e) {
                    return xr.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                }
            }), Cr.prototype = Object.assign(Object.create(xr.prototype), {
                constructor: Cr,
                isAmbientLight: !0
            }), Ar.prototype = Object.assign(Object.create(xr.prototype), {
                constructor: Ar,
                isRectAreaLight: !0,
                copy: function (e) {
                    return xr.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this
                },
                toJSON: function (e) {
                    var t = xr.prototype.toJSON.call(this, e);
                    return t.object.width = this.width, t.object.height = this.height, t
                }
            }), Object.assign(Lr.prototype, {
                load: function (e, t, n, i) {
                    var r = this,
                        a = new Fi(r.manager);
                    a.setPath(r.path), a.load(e, function (e) {
                        t(r.parse(JSON.parse(e)))
                    }, n, i)
                },
                parse: function (e) {
                    function t(e) {
                        return void 0 === r[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), r[e]
                    }
                    var r = this.textures,
                        s = new Dh[e.type];
                    if (void 0 !== e.uuid && (s.uuid = e.uuid), void 0 !== e.name && (s.name = e.name), void 0 !== e.color && s.color.setHex(e.color), void 0 !== e.roughness && (s.roughness = e.roughness), void 0 !== e.metalness && (s.metalness = e.metalness), void 0 !== e.emissive && s.emissive.setHex(e.emissive), void 0 !== e.specular && s.specular.setHex(e.specular), void 0 !== e.shininess && (s.shininess = e.shininess), void 0 !== e.clearCoat && (s.clearCoat = e.clearCoat), void 0 !== e.clearCoatRoughness && (s.clearCoatRoughness = e.clearCoatRoughness), void 0 !== e.vertexColors && (s.vertexColors = e.vertexColors), void 0 !== e.fog && (s.fog = e.fog), void 0 !== e.flatShading && (s.flatShading = e.flatShading), void 0 !== e.blending && (s.blending = e.blending), void 0 !== e.combine && (s.combine = e.combine), void 0 !== e.side && (s.side = e.side), void 0 !== e.opacity && (s.opacity = e.opacity), void 0 !== e.transparent && (s.transparent = e.transparent), void 0 !== e.alphaTest && (s.alphaTest = e.alphaTest), void 0 !== e.depthTest && (s.depthTest = e.depthTest), void 0 !== e.depthWrite && (s.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (s.colorWrite = e.colorWrite), void 0 !== e.wireframe && (s.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (s.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (s.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (s.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (s.rotation = e.rotation), 1 !== e.linewidth && (s.linewidth = e.linewidth), void 0 !== e.dashSize && (s.dashSize = e.dashSize), void 0 !== e.gapSize && (s.gapSize = e.gapSize), void 0 !== e.scale && (s.scale = e.scale), void 0 !== e.polygonOffset && (s.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (s.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (s.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (s.skinning = e.skinning), void 0 !== e.morphTargets && (s.morphTargets = e.morphTargets), void 0 !== e.dithering && (s.dithering = e.dithering), void 0 !== e.visible && (s.visible = e.visible), void 0 !== e.userData && (s.userData = e.userData), void 0 !== e.uniforms)
                        for (var c in e.uniforms) {
                            var u = e.uniforms[c];
                            switch (s.uniforms[c] = {}, u.type) {
                                case "t":
                                    s.uniforms[c].value = t(u.value);
                                    break;
                                case "c":
                                    s.uniforms[c].value = (new x).setHex(u.value);
                                    break;
                                case "v2":
                                    s.uniforms[c].value = (new n).fromArray(u.value);
                                    break;
                                case "v3":
                                    s.uniforms[c].value = (new a).fromArray(u.value);
                                    break;
                                case "v4":
                                    s.uniforms[c].value = (new l).fromArray(u.value);
                                    break;
                                case "m3":
                                    s.uniforms[c].value = (new o).fromArray(u.value);
                                case "m4":
                                    s.uniforms[c].value = (new i).fromArray(u.value);
                                    break;
                                default:
                                    s.uniforms[c].value = u.value
                            }
                        }
                    if (void 0 !== e.defines && (s.defines = e.defines), void 0 !== e.vertexShader && (s.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (s.fragmentShader = e.fragmentShader), void 0 !== e.extensions)
                        for (var h in e.extensions) s.extensions[h] = e.extensions[h];
                    if (void 0 !== e.shading && (s.flatShading = 1 === e.shading), void 0 !== e.size && (s.size = e.size), void 0 !== e.sizeAttenuation && (s.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (s.map = t(e.map)), void 0 !== e.alphaMap && (s.alphaMap = t(e.alphaMap), s.transparent = !0), void 0 !== e.bumpMap && (s.bumpMap = t(e.bumpMap)), void 0 !== e.bumpScale && (s.bumpScale = e.bumpScale), void 0 !== e.normalMap && (s.normalMap = t(e.normalMap)), void 0 !== e.normalMapType && (s.normalMapType = e.normalMapType), void 0 !== e.normalScale) {
                        var d = e.normalScale;
                        Array.isArray(d) === !1 && (d = [d, d]), s.normalScale = (new n).fromArray(d)
                    }
                    return void 0 !== e.displacementMap && (s.displacementMap = t(e.displacementMap)), void 0 !== e.displacementScale && (s.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (s.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (s.roughnessMap = t(e.roughnessMap)), void 0 !== e.metalnessMap && (s.metalnessMap = t(e.metalnessMap)), void 0 !== e.emissiveMap && (s.emissiveMap = t(e.emissiveMap)), void 0 !== e.emissiveIntensity && (s.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (s.specularMap = t(e.specularMap)), void 0 !== e.envMap && (s.envMap = t(e.envMap)), void 0 !== e.envMapIntensity && (s.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (s.reflectivity = e.reflectivity), void 0 !== e.lightMap && (s.lightMap = t(e.lightMap)), void 0 !== e.lightMapIntensity && (s.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (s.aoMap = t(e.aoMap)), void 0 !== e.aoMapIntensity && (s.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (s.gradientMap = t(e.gradientMap)), s
                },
                setPath: function (e) {
                    return this.path = e, this
                },
                setTextures: function (e) {
                    return this.textures = e, this
                }
            });
            var Wh = {
                decodeText: function (e) {
                    if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
                    for (var t = "", n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
                    return decodeURIComponent(escape(t))
                },
                extractUrlBase: function (e) {
                    var t = e.lastIndexOf("/");
                    return t === -1 ? "./" : e.substr(0, t + 1)
                }
            };
            Object.assign(Rr.prototype, {
                load: function (e, t, n, i) {
                    var r = this,
                        a = new Fi(r.manager);
                    a.setPath(r.path), a.load(e, function (e) {
                        t(r.parse(JSON.parse(e)))
                    }, n, i)
                },
                parse: function (e) {
                    var t = new U,
                        n = e.data.index;
                    if (void 0 !== n) {
                        var i = new qh[n.type](n.array);
                        t.setIndex(new P(i, 1))
                    }
                    var r = e.data.attributes;
                    for (var o in r) {
                        var s = r[o],
                            i = new qh[s.type](s.array),
                            l = new P(i, s.itemSize, s.normalized);
                        void 0 !== s.name && (l.name = s.name), t.addAttribute(o, l)
                    }
                    var c = e.data.morphAttributes;
                    if (c)
                        for (var o in c) {
                            for (var u = c[o], h = [], d = 0, p = u.length; d < p; d++) {
                                var s = u[d],
                                    i = new qh[s.type](s.array),
                                    l = new P(i, s.itemSize, s.normalized);
                                void 0 !== s.name && (l.name = s.name), h.push(l)
                            }
                            t.morphAttributes[o] = h
                        }
                    var m = e.data.groups || e.data.drawcalls || e.data.offsets;
                    if (void 0 !== m)
                        for (var d = 0, v = m.length; d !== v; ++d) {
                            var g = m[d];
                            t.addGroup(g.start, g.count, g.materialIndex)
                        }
                    var y = e.data.boundingSphere;
                    if (void 0 !== y) {
                        var x = new a;
                        void 0 !== y.center && x.fromArray(y.center), t.boundingSphere = new f(x, y.radius)
                    }
                    return e.name && (t.name = e.name), e.userData && (t.userData = e.userData), t
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            });
            var qh = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };
            Object.assign(Ir.prototype, {
                crossOrigin: "anonymous",
                load: function (e, t, n, i) {
                    var r = this,
                        a = void 0 === this.path ? Wh.extractUrlBase(e) : this.path;
                    this.resourcePath = this.resourcePath || a;
                    var o = new Fi(r.manager);
                    o.setPath(this.path), o.load(e, function (n) {
                        var a = null;
                        try {
                            a = JSON.parse(n)
                        } catch (o) {
                            return void 0 !== i && i(o), void console.error("THREE:ObjectLoader: Can't parse " + e + ".", o.message)
                        }
                        var s = a.metadata;
                        return void 0 === s || void 0 === s.type || "geometry" === s.type.toLowerCase() ? void console.error("THREE.ObjectLoader: Can't load " + e) : void r.parse(a, t)
                    }, n, i)
                },
                setPath: function (e) {
                    return this.path = e, this
                },
                setResourcePath: function (e) {
                    return this.resourcePath = e, this
                },
                setCrossOrigin: function (e) {
                    return this.crossOrigin = e, this
                },
                parse: function (e, t) {
                    var n = this.parseShape(e.shapes),
                        i = this.parseGeometries(e.geometries, n),
                        r = this.parseImages(e.images, function () {
                            void 0 !== t && t(s)
                        }),
                        a = this.parseTextures(e.textures, r),
                        o = this.parseMaterials(e.materials, a),
                        s = this.parseObject(e.object, i, o);
                    return e.animations && (s.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 !== t && t(s), s
                },
                parseShape: function (e) {
                    var t = {};
                    if (void 0 !== e)
                        for (var n = 0, i = e.length; n < i; n++) {
                            var r = (new yr).fromJSON(e[n]);
                            t[r.uuid] = r
                        }
                    return t
                },
                parseGeometries: function (e, t) {
                    var n = {};
                    if (void 0 !== e)
                        for (var i = new Rr, r = 0, a = e.length; r < a; r++) {
                            var o, s = e[r];
                            switch (s.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    o = new kh[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    o = new kh[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    o = new kh[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    o = new kh[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    o = new kh[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    o = new kh[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                case "DodecahedronBufferGeometry":
                                case "IcosahedronGeometry":
                                case "IcosahedronBufferGeometry":
                                case "OctahedronGeometry":
                                case "OctahedronBufferGeometry":
                                case "TetrahedronGeometry":
                                case "TetrahedronBufferGeometry":
                                    o = new kh[s.type](s.radius, s.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    o = new kh[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    o = new kh[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    o = new kh[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
                                    break;
                                case "TubeGeometry":
                                case "TubeBufferGeometry":
                                    o = new kh[s.type]((new Vh[s.path.type]).fromJSON(s.path), s.tubularSegments, s.radius, s.radialSegments, s.closed);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    o = new kh[s.type](s.points, s.segments, s.phiStart, s.phiLength);
                                    break;
                                case "PolyhedronGeometry":
                                case "PolyhedronBufferGeometry":
                                    o = new kh[s.type](s.vertices, s.indices, s.radius, s.details);
                                    break;
                                case "ShapeGeometry":
                                case "ShapeBufferGeometry":
                                    for (var l = [], c = 0, u = s.shapes.length; c < u; c++) {
                                        var h = t[s.shapes[c]];
                                        l.push(h)
                                    }
                                    o = new kh[s.type](l, s.curveSegments);
                                    break;
                                case "ExtrudeGeometry":
                                case "ExtrudeBufferGeometry":
                                    for (var l = [], c = 0, u = s.shapes.length; c < u; c++) {
                                        var h = t[s.shapes[c]];
                                        l.push(h)
                                    }
                                    var d = s.options.extrudePath;
                                    void 0 !== d && (s.options.extrudePath = (new Vh[d.type]).fromJSON(d)), o = new kh[s.type](l, s.options);
                                    break;
                                case "BufferGeometry":
                                    o = i.parse(s);
                                    break;
                                case "Geometry":
                                    if ("THREE" in window && "LegacyJSONLoader" in THREE) {
                                        var p = new THREE.LegacyJSONLoader;
                                        o = p.parse(s, this.resourcePath).geometry
                                    } else console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                                    break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                                    continue
                            }
                            o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), o.isBufferGeometry === !0 && void 0 !== s.userData && (o.userData = s.userData), n[s.uuid] = o
                        }
                    return n
                },
                parseMaterials: function (e, t) {
                    var n = {},
                        i = {};
                    if (void 0 !== e) {
                        var r = new Lr;
                        r.setTextures(t);
                        for (var a = 0, o = e.length; a < o; a++) {
                            var s = e[a];
                            if ("MultiMaterial" === s.type) {
                                for (var l = [], c = 0; c < s.materials.length; c++) {
                                    var u = s.materials[c];
                                    void 0 === n[u.uuid] && (n[u.uuid] = r.parse(u)), l.push(n[u.uuid])
                                }
                                i[s.uuid] = l
                            } else void 0 === n[s.uuid] && (n[s.uuid] = r.parse(s)), i[s.uuid] = n[s.uuid]
                        }
                    }
                    return i
                },
                parseAnimations: function (e) {
                    for (var t = [], n = 0; n < e.length; n++) {
                        var i = e[n],
                            r = Bi.parse(i);
                        void 0 !== i.uuid && (r.uuid = i.uuid), t.push(r)
                    }
                    return t
                },
                parseImages: function (e, t) {
                    function n(e) {
                        return i.manager.itemStart(e), o.load(e, function () {
                            i.manager.itemEnd(e)
                        }, void 0, function () {
                            i.manager.itemError(e), i.manager.itemEnd(e)
                        })
                    }
                    var i = this,
                        r = {};
                    if (void 0 !== e && e.length > 0) {
                        var a = new ji(t),
                            o = new Wi(a);
                        o.setCrossOrigin(this.crossOrigin);
                        for (var s = 0, l = e.length; s < l; s++) {
                            var c = e[s],
                                u = c.url;
                            if (Array.isArray(u)) {
                                r[c.uuid] = [];
                                for (var h = 0, d = u.length; h < d; h++) {
                                    var p = u[h],
                                        f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : i.resourcePath + p;
                                    r[c.uuid].push(n(f))
                                }
                            } else {
                                var f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : i.resourcePath + c.url;
                                r[c.uuid] = n(f)
                            }
                        }
                    }
                    return r
                },
                parseTextures: function (e, t) {
                    function n(e, t) {
                        return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e])
                    }
                    var i = {};
                    if (void 0 !== e)
                        for (var r = 0, a = e.length; r < a; r++) {
                            var o = e[r];
                            void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), void 0 === t[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image);
                            var l;
                            l = Array.isArray(t[o.image]) ? new se(t[o.image]) : new s(t[o.image]), l.needsUpdate = !0, l.uuid = o.uuid, void 0 !== o.name && (l.name = o.name), void 0 !== o.mapping && (l.mapping = n(o.mapping, Xh)), void 0 !== o.offset && l.offset.fromArray(o.offset), void 0 !== o.repeat && l.repeat.fromArray(o.repeat), void 0 !== o.center && l.center.fromArray(o.center), void 0 !== o.rotation && (l.rotation = o.rotation), void 0 !== o.wrap && (l.wrapS = n(o.wrap[0], Yh), l.wrapT = n(o.wrap[1], Yh)), void 0 !== o.format && (l.format = o.format), void 0 !== o.type && (l.type = o.type), void 0 !== o.encoding && (l.encoding = o.encoding), void 0 !== o.minFilter && (l.minFilter = n(o.minFilter, Zh)), void 0 !== o.magFilter && (l.magFilter = n(o.magFilter, Zh)), void 0 !== o.anisotropy && (l.anisotropy = o.anisotropy), void 0 !== o.flipY && (l.flipY = o.flipY), void 0 !== o.premultiplyAlpha && (l.premultiplyAlpha = o.premultiplyAlpha), void 0 !== o.unpackAlignment && (l.unpackAlignment = o.unpackAlignment), i[o.uuid] = l
                        }
                    return i
                },
                parseObject: function (e, t, n) {
                    function i(e) {
                        return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e]
                    }

                    function r(e) {
                        if (void 0 !== e) {
                            if (Array.isArray(e)) {
                                for (var t = [], i = 0, r = e.length; i < r; i++) {
                                    var a = e[i];
                                    void 0 === n[a] && console.warn("THREE.ObjectLoader: Undefined material", a), t.push(n[a])
                                }
                                return t
                            }
                            return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e), n[e]
                        }
                    }
                    var a;
                    switch (e.type) {
                        case "Scene":
                            a = new Ot, void 0 !== e.background && Number.isInteger(e.background) && (a.background = new x(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? a.fog = new It(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (a.fog = new Rt(e.fog.color, e.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            a = new Et(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (a.focus = e.focus), void 0 !== e.zoom && (a.zoom = e.zoom), void 0 !== e.filmGauge && (a.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (a.filmOffset = e.filmOffset), void 0 !== e.view && (a.view = Object.assign({}, e.view));
                            break;
                        case "OrthographicCamera":
                            a = new Er(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (a.zoom = e.zoom), void 0 !== e.view && (a.view = Object.assign({}, e.view));
                            break;
                        case "AmbientLight":
                            a = new Cr(e.color, e.intensity);
                            break;
                        case "DirectionalLight":
                            a = new Pr(e.color, e.intensity);
                            break;
                        case "PointLight":
                            a = new Tr(e.color, e.intensity, e.distance, e.decay);
                            break;
                        case "RectAreaLight":
                            a = new Ar(e.color, e.intensity, e.width, e.height);
                            break;
                        case "SpotLight":
                            a = new Mr(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
                            break;
                        case "HemisphereLight":
                            a = new br(e.color, e.groundColor, e.intensity);
                            break;
                        case "SkinnedMesh":
                            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                        case "Mesh":
                            var o = i(e.geometry),
                                s = r(e.material);
                            a = o.bones && o.bones.length > 0 ? new Ut(o, s) : new Z(o, s), void 0 !== e.drawMode && a.setDrawMode(e.drawMode);
                            break;
                        case "LOD":
                            a = new Nt;
                            break;
                        case "Line":
                            a = new Ht(i(e.geometry), r(e.material), e.mode);
                            break;
                        case "LineLoop":
                            a = new Wt(i(e.geometry), r(e.material));
                            break;
                        case "LineSegments":
                            a = new Vt(i(e.geometry), r(e.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            a = new Xt(i(e.geometry), r(e.material));
                            break;
                        case "Sprite":
                            a = new Bt(r(e.material));
                            break;
                        case "Group":
                            a = new Mt;
                            break;
                        default:
                            a = new E
                    }
                    if (a.uuid = e.uuid, void 0 !== e.name && (a.name = e.name), void 0 !== e.matrix ? (a.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (a.matrixAutoUpdate = e.matrixAutoUpdate), a.matrixAutoUpdate && a.matrix.decompose(a.position, a.quaternion, a.scale)) : (void 0 !== e.position && a.position.fromArray(e.position), void 0 !== e.rotation && a.rotation.fromArray(e.rotation), void 0 !== e.quaternion && a.quaternion.fromArray(e.quaternion), void 0 !== e.scale && a.scale.fromArray(e.scale)), void 0 !== e.castShadow && (a.castShadow = e.castShadow), void 0 !== e.receiveShadow && (a.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (a.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (a.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && a.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (a.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (a.visible = e.visible), void 0 !== e.frustumCulled && (a.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (a.renderOrder = e.renderOrder), void 0 !== e.userData && (a.userData = e.userData), void 0 !== e.layers && (a.layers.mask = e.layers), void 0 !== e.children)
                        for (var l = e.children, c = 0; c < l.length; c++) a.add(this.parseObject(l[c], t, n));
                    if ("LOD" === e.type)
                        for (var u = e.levels, h = 0; h < u.length; h++) {
                            var d = u[h],
                                p = a.getObjectByProperty("uuid", d.object);
                            void 0 !== p && a.addLevel(p, d.distance)
                        }
                    return a
                }
            });
            var Xh = {
                    UVMapping: fs,
                    CubeReflectionMapping: ms,
                    CubeRefractionMapping: vs,
                    EquirectangularReflectionMapping: gs,
                    EquirectangularRefractionMapping: ys,
                    SphericalReflectionMapping: xs,
                    CubeUVReflectionMapping: bs,
                    CubeUVRefractionMapping: _s
                },
                Yh = {
                    RepeatWrapping: ws,
                    ClampToEdgeWrapping: Ms,
                    MirroredRepeatWrapping: Ts
                },
                Zh = {
                    NearestFilter: Es,
                    NearestMipMapNearestFilter: Ss,
                    NearestMipMapLinearFilter: Ps,
                    LinearFilter: Cs,
                    LinearMipMapNearestFilter: As,
                    LinearMipMapLinearFilter: Ls
                };
            Or.prototype = {
                constructor: Or,
                setOptions: function (e) {
                    return this.options = e, this
                },
                load: function (e, t, n, i) {
                    void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                    var r = this,
                        a = Bh.get(e);
                    return void 0 !== a ? (r.manager.itemStart(e), setTimeout(function () {
                        t && t(a), r.manager.itemEnd(e)
                    }, 0), a) : (fetch(e).then(function (e) {
                        return e.blob()
                    }).then(function (e) {
                        return createImageBitmap(e, r.options)
                    }).then(function (n) {
                        Bh.add(e, n), t && t(n),
                            r.manager.itemEnd(e)
                    })["catch"](function (t) {
                        i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
                    }), void r.manager.itemStart(e))
                },
                setCrossOrigin: function () {
                    return this
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }, Object.assign(kr.prototype, {
                moveTo: function (e, t) {
                    this.currentPath = new gr, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t)
                },
                lineTo: function (e, t) {
                    this.currentPath.lineTo(e, t)
                },
                quadraticCurveTo: function (e, t, n, i) {
                    this.currentPath.quadraticCurveTo(e, t, n, i)
                },
                bezierCurveTo: function (e, t, n, i, r, a) {
                    this.currentPath.bezierCurveTo(e, t, n, i, r, a)
                },
                splineThru: function (e) {
                    this.currentPath.splineThru(e)
                },
                toShapes: function (e, t) {
                    function n(e) {
                        for (var t = [], n = 0, i = e.length; n < i; n++) {
                            var r = e[n],
                                a = new yr;
                            a.curves = r.curves, t.push(a)
                        }
                        return t
                    }

                    function i(e, t) {
                        for (var n = t.length, i = !1, r = n - 1, a = 0; a < n; r = a++) {
                            var o = t[r],
                                s = t[a],
                                l = s.x - o.x,
                                c = s.y - o.y;
                            if (Math.abs(c) > Number.EPSILON) {
                                if (c < 0 && (o = t[a], l = -l, s = t[r], c = -c), e.y < o.y || e.y > s.y) continue;
                                if (e.y === o.y) {
                                    if (e.x === o.x) return !0
                                } else {
                                    var u = c * (e.x - o.x) - l * (e.y - o.y);
                                    if (0 === u) return !0;
                                    if (u < 0) continue;
                                    i = !i
                                }
                            } else {
                                if (e.y !== o.y) continue;
                                if (s.x <= e.x && e.x <= o.x || o.x <= e.x && e.x <= s.x) return !0
                            }
                        }
                        return i
                    }
                    var r = Ih.isClockWise,
                        a = this.subPaths;
                    if (0 === a.length) return [];
                    if (t === !0) return n(a);
                    var o, s, l, c = [];
                    if (1 === a.length) return s = a[0], l = new yr, l.curves = s.curves, c.push(l), c;
                    var u = !r(a[0].getPoints());
                    u = e ? !u : u;
                    var h, d = [],
                        p = [],
                        f = [],
                        m = 0;
                    p[m] = void 0, f[m] = [];
                    for (var v = 0, g = a.length; v < g; v++) s = a[v], h = s.getPoints(), o = r(h), o = e ? !o : o, o ? (!u && p[m] && m++, p[m] = {
                        s: new yr,
                        p: h
                    }, p[m].s.curves = s.curves, u && m++, f[m] = []) : f[m].push({
                        h: s,
                        p: h[0]
                    });
                    if (!p[0]) return n(a);
                    if (p.length > 1) {
                        for (var y = !1, x = [], b = 0, _ = p.length; b < _; b++) d[b] = [];
                        for (var b = 0, _ = p.length; b < _; b++)
                            for (var w = f[b], M = 0; M < w.length; M++) {
                                for (var T = w[M], E = !0, S = 0; S < p.length; S++) i(T.p, p[S].p) && (b !== S && x.push({
                                    froms: b,
                                    tos: S,
                                    hole: M
                                }), E ? (E = !1, d[S].push(T)) : y = !0);
                                E && d[b].push(T)
                            }
                        x.length > 0 && (y || (f = d))
                    }
                    for (var P, v = 0, C = p.length; v < C; v++) {
                        l = p[v].s, c.push(l), P = f[v];
                        for (var A = 0, L = P.length; A < L; A++) l.holes.push(P[A].h)
                    }
                    return c
                }
            }), Object.assign(Dr.prototype, {
                isFont: !0,
                generateShapes: function (e, t) {
                    void 0 === t && (t = 100);
                    for (var n = [], i = zr(e, t, this.data), r = 0, a = i.length; r < a; r++) Array.prototype.push.apply(n, i[r].toShapes());
                    return n
                }
            }), Object.assign(Nr.prototype, {
                load: function (e, t, n, i) {
                    var r = this,
                        a = new Fi(this.manager);
                    a.setPath(this.path), a.load(e, function (e) {
                        var n;
                        try {
                            n = JSON.parse(e)
                        } catch (i) {
                            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(e.substring(65, e.length - 2))
                        }
                        var a = r.parse(n);
                        t && t(a)
                    }, n, i)
                },
                parse: function (e) {
                    return new Dr(e)
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }), Ur.Handlers = {
                handlers: [],
                add: function (e, t) {
                    this.handlers.push(e, t)
                },
                get: function (e) {
                    for (var t = this.handlers, n = 0, i = t.length; n < i; n += 2) {
                        var r = t[n],
                            a = t[n + 1];
                        if (r.test(e)) return a
                    }
                    return null
                }
            }, Object.assign(Ur.prototype, {
                crossOrigin: "anonymous",
                onLoadStart: function () {},
                onLoadProgress: function () {},
                onLoadComplete: function () {},
                initMaterials: function (e, t, n) {
                    for (var i = [], r = 0; r < e.length; ++r) i[r] = this.createMaterial(e[r], t, n);
                    return i
                },
                createMaterial: function () {
                    var e = {
                            NoBlending: Ao,
                            NormalBlending: Lo,
                            AdditiveBlending: Ro,
                            SubtractiveBlending: Io,
                            MultiplyBlending: Oo,
                            CustomBlending: ko
                        },
                        t = new x,
                        n = new Xi,
                        i = new Lr;
                    return function (r, a, o) {
                        function s(e, t, i, r, s) {
                            var c, u = a + e,
                                h = Ur.Handlers.get(u);
                            null !== h ? c = h.load(u) : (n.setCrossOrigin(o), c = n.load(u)), void 0 !== t && (c.repeat.fromArray(t), 1 !== t[0] && (c.wrapS = ws), 1 !== t[1] && (c.wrapT = ws)), void 0 !== i && c.offset.fromArray(i), void 0 !== r && ("repeat" === r[0] && (c.wrapS = ws), "mirror" === r[0] && (c.wrapS = Ts), "repeat" === r[1] && (c.wrapT = ws), "mirror" === r[1] && (c.wrapT = Ts)), void 0 !== s && (c.anisotropy = s);
                            var d = Wl.generateUUID();
                            return l[d] = c, d
                        }
                        var l = {},
                            c = {
                                uuid: Wl.generateUUID(),
                                type: "MeshLambertMaterial"
                            };
                        for (var u in r) {
                            var h = r[u];
                            switch (u) {
                                case "DbgColor":
                                case "DbgIndex":
                                case "opticalDensity":
                                case "illumination":
                                    break;
                                case "DbgName":
                                    c.name = h;
                                    break;
                                case "blending":
                                    c.blending = e[h];
                                    break;
                                case "colorAmbient":
                                case "mapAmbient":
                                    console.warn("THREE.Loader.createMaterial:", u, "is no longer supported.");
                                    break;
                                case "colorDiffuse":
                                    c.color = t.fromArray(h).getHex();
                                    break;
                                case "colorSpecular":
                                    c.specular = t.fromArray(h).getHex();
                                    break;
                                case "colorEmissive":
                                    c.emissive = t.fromArray(h).getHex();
                                    break;
                                case "specularCoef":
                                    c.shininess = h;
                                    break;
                                case "shading":
                                    "basic" === h.toLowerCase() && (c.type = "MeshBasicMaterial"), "phong" === h.toLowerCase() && (c.type = "MeshPhongMaterial"), "standard" === h.toLowerCase() && (c.type = "MeshStandardMaterial");
                                    break;
                                case "mapDiffuse":
                                    c.map = s(h, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy);
                                    break;
                                case "mapDiffuseRepeat":
                                case "mapDiffuseOffset":
                                case "mapDiffuseWrap":
                                case "mapDiffuseAnisotropy":
                                    break;
                                case "mapEmissive":
                                    c.emissiveMap = s(h, r.mapEmissiveRepeat, r.mapEmissiveOffset, r.mapEmissiveWrap, r.mapEmissiveAnisotropy);
                                    break;
                                case "mapEmissiveRepeat":
                                case "mapEmissiveOffset":
                                case "mapEmissiveWrap":
                                case "mapEmissiveAnisotropy":
                                    break;
                                case "mapLight":
                                    c.lightMap = s(h, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy);
                                    break;
                                case "mapLightRepeat":
                                case "mapLightOffset":
                                case "mapLightWrap":
                                case "mapLightAnisotropy":
                                    break;
                                case "mapAO":
                                    c.aoMap = s(h, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy);
                                    break;
                                case "mapAORepeat":
                                case "mapAOOffset":
                                case "mapAOWrap":
                                case "mapAOAnisotropy":
                                    break;
                                case "mapBump":
                                    c.bumpMap = s(h, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy);
                                    break;
                                case "mapBumpScale":
                                    c.bumpScale = h;
                                    break;
                                case "mapBumpRepeat":
                                case "mapBumpOffset":
                                case "mapBumpWrap":
                                case "mapBumpAnisotropy":
                                    break;
                                case "mapNormal":
                                    c.normalMap = s(h, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy);
                                    break;
                                case "mapNormalFactor":
                                    c.normalScale = h;
                                    break;
                                case "mapNormalRepeat":
                                case "mapNormalOffset":
                                case "mapNormalWrap":
                                case "mapNormalAnisotropy":
                                    break;
                                case "mapSpecular":
                                    c.specularMap = s(h, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy);
                                    break;
                                case "mapSpecularRepeat":
                                case "mapSpecularOffset":
                                case "mapSpecularWrap":
                                case "mapSpecularAnisotropy":
                                    break;
                                case "mapMetalness":
                                    c.metalnessMap = s(h, r.mapMetalnessRepeat, r.mapMetalnessOffset, r.mapMetalnessWrap, r.mapMetalnessAnisotropy);
                                    break;
                                case "mapMetalnessRepeat":
                                case "mapMetalnessOffset":
                                case "mapMetalnessWrap":
                                case "mapMetalnessAnisotropy":
                                    break;
                                case "mapRoughness":
                                    c.roughnessMap = s(h, r.mapRoughnessRepeat, r.mapRoughnessOffset, r.mapRoughnessWrap, r.mapRoughnessAnisotropy);
                                    break;
                                case "mapRoughnessRepeat":
                                case "mapRoughnessOffset":
                                case "mapRoughnessWrap":
                                case "mapRoughnessAnisotropy":
                                    break;
                                case "mapAlpha":
                                    c.alphaMap = s(h, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy);
                                    break;
                                case "mapAlphaRepeat":
                                case "mapAlphaOffset":
                                case "mapAlphaWrap":
                                case "mapAlphaAnisotropy":
                                    break;
                                case "flipSided":
                                    c.side = wo;
                                    break;
                                case "doubleSided":
                                    c.side = Mo;
                                    break;
                                case "transparency":
                                    console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), c.opacity = h;
                                    break;
                                case "depthTest":
                                case "depthWrite":
                                case "colorWrite":
                                case "opacity":
                                case "reflectivity":
                                case "transparent":
                                case "visible":
                                case "wireframe":
                                    c[u] = h;
                                    break;
                                case "vertexColors":
                                    h === !0 && (c.vertexColors = Co), "face" === h && (c.vertexColors = Po);
                                    break;
                                default:
                                    console.error("THREE.Loader.createMaterial: Unsupported", u, h)
                            }
                        }
                        return "MeshBasicMaterial" === c.type && delete c.emissive, "MeshPhongMaterial" !== c.type && delete c.specular, c.opacity < 1 && (c.transparent = !0), i.setTextures(l), i.parse(c)
                    }
                }()
            });
            var Jh, $h = {
                getContext: function () {
                    return void 0 === Jh && (Jh = new(window.AudioContext || window.webkitAudioContext)), Jh
                },
                setContext: function (e) {
                    Jh = e
                }
            };
            Object.assign(jr.prototype, {
                load: function (e, t, n, i) {
                    var r = new Fi(this.manager);
                    r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(e, function (e) {
                        var n = e.slice(0),
                            i = $h.getContext();
                        i.decodeAudioData(n, function (e) {
                            t(e)
                        })
                    }, n, i)
                },
                setPath: function (e) {
                    return this.path = e, this
                }
            }), Object.assign(Fr.prototype, {
                update: function () {
                    var e, t, n, r, a, o, s, l, c = new i,
                        u = new i;
                    return function (i) {
                        var h = e !== this || t !== i.focus || n !== i.fov || r !== i.aspect * this.aspect || a !== i.near || o !== i.far || s !== i.zoom || l !== this.eyeSep;
                        if (h) {
                            e = this, t = i.focus, n = i.fov, r = i.aspect * this.aspect, a = i.near, o = i.far, s = i.zoom;
                            var d = i.projectionMatrix.clone();
                            l = this.eyeSep / 2;
                            var p, f, m = l * a / t,
                                v = a * Math.tan(Wl.DEG2RAD * n * .5) / s;
                            u.elements[12] = -l, c.elements[12] = l, p = -v * r + m, f = v * r + m, d.elements[0] = 2 * a / (f - p), d.elements[8] = (f + p) / (f - p), this.cameraL.projectionMatrix.copy(d), p = -v * r - m, f = v * r - m, d.elements[0] = 2 * a / (f - p), d.elements[8] = (f + p) / (f - p), this.cameraR.projectionMatrix.copy(d)
                        }
                        this.cameraL.matrixWorld.copy(i.matrixWorld).multiply(u), this.cameraR.matrixWorld.copy(i.matrixWorld).multiply(c)
                    }
                }()
            }), Gr.prototype = Object.create(E.prototype), Gr.prototype.constructor = Gr, Object.assign(Hr.prototype, {
                start: function () {
                    this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                },
                stop: function () {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                },
                getElapsedTime: function () {
                    return this.getDelta(), this.elapsedTime
                },
                getDelta: function () {
                    var e = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        var t = ("undefined" == typeof performance ? Date : performance).now();
                        e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
                    }
                    return e
                }
            }), Vr.prototype = Object.assign(Object.create(E.prototype), {
                constructor: Vr,
                getInput: function () {
                    return this.gain
                },
                removeFilter: function () {
                    return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                },
                getFilter: function () {
                    return this.filter
                },
                setFilter: function (e) {
                    return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                },
                getMasterVolume: function () {
                    return this.gain.gain.value
                },
                setMasterVolume: function (e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                },
                updateMatrixWorld: function () {
                    var e = new a,
                        t = new r,
                        n = new a,
                        i = new a,
                        o = new Hr;
                    return function (r) {
                        E.prototype.updateMatrixWorld.call(this, r);
                        var a = this.context.listener,
                            s = this.up;
                        if (this.timeDelta = o.getDelta(), this.matrixWorld.decompose(e, t, n), i.set(0, 0, -1).applyQuaternion(t), a.positionX) {
                            var l = this.context.currentTime + this.timeDelta;
                            a.positionX.linearRampToValueAtTime(e.x, l), a.positionY.linearRampToValueAtTime(e.y, l), a.positionZ.linearRampToValueAtTime(e.z, l), a.forwardX.linearRampToValueAtTime(i.x, l), a.forwardY.linearRampToValueAtTime(i.y, l), a.forwardZ.linearRampToValueAtTime(i.z, l), a.upX.linearRampToValueAtTime(s.x, l), a.upY.linearRampToValueAtTime(s.y, l), a.upZ.linearRampToValueAtTime(s.z, l)
                        } else a.setPosition(e.x, e.y, e.z), a.setOrientation(i.x, i.y, i.z, s.x, s.y, s.z)
                    }
                }()
            }), Wr.prototype = Object.assign(Object.create(E.prototype), {
                constructor: Wr,
                getOutput: function () {
                    return this.gain
                },
                setNodeSource: function (e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
                },
                setMediaElementSource: function (e) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
                },
                setBuffer: function (e) {
                    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
                },
                play: function () {
                    if (this.isPlaying === !0) return void console.warn("THREE.Audio: Audio is already playing.");
                    if (this.hasPlaybackControl === !1) return void console.warn("THREE.Audio: this Audio has no playback control.");
                    var e = this.context.createBufferSource();
                    return e.buffer = this.buffer, e.loop = this.loop, e.onended = this.onEnded.bind(this), this.startTime = this.context.currentTime, e.start(this.startTime, this.offset), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                },
                pause: function () {
                    return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.isPlaying === !0 && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this)
                },
                stop: function () {
                    return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this)
                },
                connect: function () {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this
                },
                disconnect: function () {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this
                },
                getFilters: function () {
                    return this.filters
                },
                setFilters: function (e) {
                    return e || (e = []), this.isPlaying === !0 ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this
                },
                setDetune: function (e) {
                    if (this.detune = e, void 0 !== this.source.detune) return this.isPlaying === !0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                },
                getDetune: function () {
                    return this.detune
                },
                getFilter: function () {
                    return this.getFilters()[0]
                },
                setFilter: function (e) {
                    return this.setFilters(e ? [e] : [])
                },
                setPlaybackRate: function (e) {
                    return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this)
                },
                getPlaybackRate: function () {
                    return this.playbackRate
                },
                onEnded: function () {
                    this.isPlaying = !1
                },
                getLoop: function () {
                    return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                },
                setLoop: function (e) {
                    return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this)
                },
                getVolume: function () {
                    return this.gain.gain.value
                },
                setVolume: function (e) {
                    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
                }
            }), qr.prototype = Object.assign(Object.create(Wr.prototype), {
                constructor: qr,
                getOutput: function () {
                    return this.panner
                },
                getRefDistance: function () {
                    return this.panner.refDistance
                },
                setRefDistance: function (e) {
                    return this.panner.refDistance = e, this
                },
                getRolloffFactor: function () {
                    return this.panner.rolloffFactor
                },
                setRolloffFactor: function (e) {
                    return this.panner.rolloffFactor = e, this
                },
                getDistanceModel: function () {
                    return this.panner.distanceModel
                },
                setDistanceModel: function (e) {
                    return this.panner.distanceModel = e, this
                },
                getMaxDistance: function () {
                    return this.panner.maxDistance
                },
                setMaxDistance: function (e) {
                    return this.panner.maxDistance = e, this
                },
                setDirectionalCone: function (e, t, n) {
                    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this
                },
                updateMatrixWorld: function () {
                    var e = new a,
                        t = new r,
                        n = new a,
                        i = new a;
                    return function (r) {
                        if (E.prototype.updateMatrixWorld.call(this, r), this.hasPlaybackControl !== !0 || this.isPlaying !== !1) {
                            this.matrixWorld.decompose(e, t, n), i.set(0, 0, 1).applyQuaternion(t);
                            var a = this.panner;
                            if (a.positionX) {
                                var o = this.context.currentTime + this.listener.timeDelta;
                                a.positionX.linearRampToValueAtTime(e.x, o), a.positionY.linearRampToValueAtTime(e.y, o), a.positionZ.linearRampToValueAtTime(e.z, o), a.orientationX.linearRampToValueAtTime(i.x, o), a.orientationY.linearRampToValueAtTime(i.y, o), a.orientationZ.linearRampToValueAtTime(i.z, o)
                            } else a.setPosition(e.x, e.y, e.z), a.setOrientation(i.x, i.y, i.z)
                        }
                    }
                }()
            }), Object.assign(Xr.prototype, {
                getFrequencyData: function () {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                },
                getAverageFrequency: function () {
                    for (var e = 0, t = this.getFrequencyData(), n = 0; n < t.length; n++) e += t[n];
                    return e / t.length
                }
            }), Object.assign(Yr.prototype, {
                accumulate: function (e, t) {
                    var n = this.buffer,
                        i = this.valueSize,
                        r = e * i + i,
                        a = this.cumulativeWeight;
                    if (0 === a) {
                        for (var o = 0; o !== i; ++o) n[r + o] = n[o];
                        a = t
                    } else {
                        a += t;
                        var s = t / a;
                        this._mixBufferRegion(n, r, 0, s, i)
                    }
                    this.cumulativeWeight = a
                },
                apply: function (e) {
                    var t = this.valueSize,
                        n = this.buffer,
                        i = e * t + t,
                        r = this.cumulativeWeight,
                        a = this.binding;
                    if (this.cumulativeWeight = 0, r < 1) {
                        var o = 3 * t;
                        this._mixBufferRegion(n, i, o, 1 - r, t)
                    }
                    for (var s = t, l = t + t; s !== l; ++s)
                        if (n[s] !== n[s + t]) {
                            a.setValue(n, i);
                            break
                        }
                },
                saveOriginalState: function () {
                    var e = this.binding,
                        t = this.buffer,
                        n = this.valueSize,
                        i = 3 * n;
                    e.getValue(t, i);
                    for (var r = n, a = i; r !== a; ++r) t[r] = t[i + r % n];
                    this.cumulativeWeight = 0
                },
                restoreOriginalState: function () {
                    var e = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, e)
                },
                _select: function (e, t, n, i, r) {
                    if (i >= .5)
                        for (var a = 0; a !== r; ++a) e[t + a] = e[n + a]
                },
                _slerp: function (e, t, n, i) {
                    r.slerpFlat(e, t, e, t, e, n, i)
                },
                _lerp: function (e, t, n, i, r) {
                    for (var a = 1 - i, o = 0; o !== r; ++o) {
                        var s = t + o;
                        e[s] = e[s] * a + e[n + o] * i
                    }
                }
            });
            var Qh = "\\[\\]\\.:\\/";
            Object.assign(Zr.prototype, {
                getValue: function (e, t) {
                    this.bind();
                    var n = this._targetGroup.nCachedObjects_,
                        i = this._bindings[n];
                    void 0 !== i && i.getValue(e, t)
                },
                setValue: function (e, t) {
                    for (var n = this._bindings, i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(e, t)
                },
                bind: function () {
                    for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
                },
                unbind: function () {
                    for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
                }
            }), Object.assign(Jr, {
                Composite: Zr,
                create: function (e, t, n) {
                    return e && e.isAnimationObjectGroup ? new Jr.Composite(e, t, n) : new Jr(e, t, n)
                },
                sanitizeNodeName: function () {
                    var e = new RegExp("[" + Qh + "]", "g");
                    return function (t) {
                        return t.replace(/\s/g, "_").replace(e, "")
                    }
                }(),
                parseTrackName: function () {
                    var e = "[^" + Qh + "]",
                        t = "[^" + Qh.replace("\\.", "") + "]",
                        n = /((?:WC+[\/:])*)/.source.replace("WC", e),
                        i = /(WCOD+)?/.source.replace("WCOD", t),
                        r = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", e),
                        a = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", e),
                        o = new RegExp("^" + n + i + r + a + "$"),
                        s = ["material", "materials", "bones"];
                    return function (e) {
                        var t = o.exec(e);
                        if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                        var n = {
                                nodeName: t[2],
                                objectName: t[3],
                                objectIndex: t[4],
                                propertyName: t[5],
                                propertyIndex: t[6]
                            },
                            i = n.nodeName && n.nodeName.lastIndexOf(".");
                        if (void 0 !== i && i !== -1) {
                            var r = n.nodeName.substring(i + 1);
                            s.indexOf(r) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = r)
                        }
                        if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                        return n
                    }
                }(),
                findNode: function (e, t) {
                    if (!t || "" === t || "root" === t || "." === t || t === -1 || t === e.name || t === e.uuid) return e;
                    if (e.skeleton) {
                        var n = e.skeleton.getBoneByName(t);
                        if (void 0 !== n) return n
                    }
                    if (e.children) {
                        var i = function (e) {
                                for (var n = 0; n < e.length; n++) {
                                    var r = e[n];
                                    if (r.name === t || r.uuid === t) return r;
                                    var a = i(r.children);
                                    if (a) return a
                                }
                                return null
                            },
                            r = i(e.children);
                        if (r) return r
                    }
                    return null
                }
            }), Object.assign(Jr.prototype, {
                _getValue_unavailable: function () {},
                _setValue_unavailable: function () {},
                BindingType: {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                Versioning: {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                GetterByBindingType: [function (e, t) {
                    e[t] = this.node[this.propertyName]
                }, function (e, t) {
                    for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) e[t++] = n[i]
                }, function (e, t) {
                    e[t] = this.resolvedProperty[this.propertyIndex]
                }, function (e, t) {
                    this.resolvedProperty.toArray(e, t)
                }],
                SetterByBindingTypeAndVersioning: [
                    [function (e, t) {
                        this.targetObject[this.propertyName] = e[t]
                    }, function (e, t) {
                        this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
                    }, function (e, t) {
                        this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function (e, t) {
                        for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = e[t++]
                    }, function (e, t) {
                        for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                        this.targetObject.needsUpdate = !0
                    }, function (e, t) {
                        for (var n = this.resolvedProperty, i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function (e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t]
                    }, function (e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
                    }, function (e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function (e, t) {
                        this.resolvedProperty.fromArray(e, t)
                    }, function (e, t) {
                        this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
                    }, function (e, t) {
                        this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
                    }]
                ],
                getValue: function (e, t) {
                    this.bind(), this.getValue(e, t)
                },
                setValue: function (e, t) {
                    this.bind(), this.setValue(e, t)
                },
                bind: function () {
                    var e = this.node,
                        t = this.parsedPath,
                        n = t.objectName,
                        i = t.propertyName,
                        r = t.propertyIndex;
                    if (e || (e = Jr.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                    if (n) {
                        var a = t.objectIndex;
                        switch (n) {
                            case "materials":
                                if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                e = e.material.materials;
                                break;
                            case "bones":
                                if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                e = e.skeleton.bones;
                                for (var o = 0; o < e.length; o++)
                                    if (e[o].name === a) {
                                        a = o;
                                        break
                                    } break;
                            default:
                                if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                e = e[n]
                        }
                        if (void 0 !== a) {
                            if (void 0 === e[a]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                            e = e[a]
                        }
                    }
                    var s = e[i];
                    if (void 0 === s) {
                        var l = t.nodeName;
                        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + i + " but it wasn't found.", e)
                    }
                    var c = this.Versioning.None;
                    this.targetObject = e, void 0 !== e.needsUpdate ? c = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate);
                    var u = this.BindingType.Direct;
                    if (void 0 !== r) {
                        if ("morphTargetInfluences" === i) {
                            if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (e.geometry.isBufferGeometry) {
                                if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                for (var o = 0; o < this.node.geometry.morphAttributes.position.length; o++)
                                    if (e.geometry.morphAttributes.position[o].name === r) {
                                        r = o;
                                        break
                                    }
                            } else {
                                if (!e.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                for (var o = 0; o < this.node.geometry.morphTargets.length; o++)
                                    if (e.geometry.morphTargets[o].name === r) {
                                        r = o;
                                        break
                                    }
                            }
                        }
                        u = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                    } else void 0 !== s.fromArray && void 0 !== s.toArray ? (u = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (u = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                    this.getValue = this.GetterByBindingType[u], this.setValue = this.SetterByBindingTypeAndVersioning[u][c]
                },
                unbind: function () {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }), Object.assign(Jr.prototype, {
                _getValue_unbound: Jr.prototype.getValue,
                _setValue_unbound: Jr.prototype.setValue
            }), Object.assign($r.prototype, {
                isAnimationObjectGroup: !0,
                add: function () {
                    for (var e = this._objects, t = e.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._paths, a = this._parsedPaths, o = this._bindings, s = o.length, l = void 0, c = 0, u = arguments.length; c !== u; ++c) {
                        var h = arguments[c],
                            d = h.uuid,
                            p = i[d];
                        if (void 0 === p) {
                            p = t++, i[d] = p, e.push(h);
                            for (var f = 0, m = s; f !== m; ++f) o[f].push(new Jr(h, r[f], a[f]))
                        } else if (p < n) {
                            l = e[p];
                            var v = --n,
                                g = e[v];
                            i[g.uuid] = p, e[p] = g, i[d] = v, e[v] = h;
                            for (var f = 0, m = s; f !== m; ++f) {
                                var y = o[f],
                                    x = y[v],
                                    b = y[p];
                                y[p] = x, void 0 === b && (b = new Jr(h, r[f], a[f])), y[v] = b
                            }
                        } else e[p] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                    }
                    this.nCachedObjects_ = n
                },
                remove: function () {
                    for (var e = this._objects, t = this.nCachedObjects_, n = this._indicesByUUID, i = this._bindings, r = i.length, a = 0, o = arguments.length; a !== o; ++a) {
                        var s = arguments[a],
                            l = s.uuid,
                            c = n[l];
                        if (void 0 !== c && c >= t) {
                            var u = t++,
                                h = e[u];
                            n[h.uuid] = c, e[c] = h, n[l] = u, e[u] = s;
                            for (var d = 0, p = r; d !== p; ++d) {
                                var f = i[d],
                                    m = f[u],
                                    v = f[c];
                                f[c] = m, f[u] = v
                            }
                        }
                    }
                    this.nCachedObjects_ = t
                },
                uncache: function () {
                    for (var e = this._objects, t = e.length, n = this.nCachedObjects_, i = this._indicesByUUID, r = this._bindings, a = r.length, o = 0, s = arguments.length; o !== s; ++o) {
                        var l = arguments[o],
                            c = l.uuid,
                            u = i[c];
                        if (void 0 !== u)
                            if (delete i[c], u < n) {
                                var h = --n,
                                    d = e[h],
                                    p = --t,
                                    f = e[p];
                                i[d.uuid] = u, e[u] = d, i[f.uuid] = h, e[h] = f, e.pop();
                                for (var m = 0, v = a; m !== v; ++m) {
                                    var g = r[m],
                                        y = g[h],
                                        x = g[p];
                                    g[u] = y, g[h] = x, g.pop()
                                }
                            } else {
                                var p = --t,
                                    f = e[p];
                                i[f.uuid] = u, e[u] = f, e.pop();
                                for (var m = 0, v = a; m !== v; ++m) {
                                    var g = r[m];
                                    g[u] = g[p], g.pop()
                                }
                            }
                    }
                    this.nCachedObjects_ = n
                },
                subscribe_: function (e, t) {
                    var n = this._bindingsIndicesByPath,
                        i = n[e],
                        r = this._bindings;
                    if (void 0 !== i) return r[i];
                    var a = this._paths,
                        o = this._parsedPaths,
                        s = this._objects,
                        l = s.length,
                        c = this.nCachedObjects_,
                        u = new Array(l);
                    i = r.length, n[e] = i, a.push(e), o.push(t), r.push(u);
                    for (var h = c, d = s.length; h !== d; ++h) {
                        var p = s[h];
                        u[h] = new Jr(p, e, t)
                    }
                    return u
                },
                unsubscribe_: function (e) {
                    var t = this._bindingsIndicesByPath,
                        n = t[e];
                    if (void 0 !== n) {
                        var i = this._paths,
                            r = this._parsedPaths,
                            a = this._bindings,
                            o = a.length - 1,
                            s = a[o],
                            l = e[o];
                        t[l] = n, a[n] = s, a.pop(), r[n] = r[o], r.pop(), i[n] = i[o], i.pop()
                    }
                }
            }), Object.assign(Qr.prototype, {
                play: function () {
                    return this._mixer._activateAction(this), this
                },
                stop: function () {
                    return this._mixer._deactivateAction(this), this.reset()
                },
                reset: function () {
                    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                },
                isRunning: function () {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                },
                isScheduled: function () {
                    return this._mixer._isActiveAction(this)
                },
                startAt: function (e) {
                    return this._startTime = e, this
                },
                setLoop: function (e, t) {
                    return this.loop = e, this.repetitions = t, this
                },
                setEffectiveWeight: function (e) {
                    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
                },
                getEffectiveWeight: function () {
                    return this._effectiveWeight
                },
                fadeIn: function (e) {
                    return this._scheduleFading(e, 0, 1)
                },
                fadeOut: function (e) {
                    return this._scheduleFading(e, 1, 0)
                },
                crossFadeFrom: function (e, t, n) {
                    if (e.fadeOut(t), this.fadeIn(t), n) {
                        var i = this._clip.duration,
                            r = e._clip.duration,
                            a = r / i,
                            o = i / r;
                        e.warp(1, a, t), this.warp(o, 1, t)
                    }
                    return this
                },
                crossFadeTo: function (e, t, n) {
                    return e.crossFadeFrom(this, t, n)
                },
                stopFading: function () {
                    var e = this._weightInterpolant;
                    return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                },
                setEffectiveTimeScale: function (e) {
                    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
                },
                getEffectiveTimeScale: function () {
                    return this._effectiveTimeScale
                },
                setDuration: function (e) {
                    return this.timeScale = this._clip.duration / e, this.stopWarping()
                },
                syncWith: function (e) {
                    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
                },
                halt: function (e) {
                    return this.warp(this._effectiveTimeScale, 0, e)
                },
                warp: function (e, t, n) {
                    var i = this._mixer,
                        r = i.time,
                        a = this._timeScaleInterpolant,
                        o = this.timeScale;
                    null === a && (a = i._lendControlInterpolant(), this._timeScaleInterpolant = a);
                    var s = a.parameterPositions,
                        l = a.sampleValues;
                    return s[0] = r, s[1] = r + n, l[0] = e / o, l[1] = t / o, this
                },
                stopWarping: function () {
                    var e = this._timeScaleInterpolant;
                    return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                },
                getMixer: function () {
                    return this._mixer
                },
                getClip: function () {
                    return this._clip
                },
                getRoot: function () {
                    return this._localRoot || this._mixer._root
                },
                _update: function (e, t, n, i) {
                    if (!this.enabled) return void this._updateWeight(e);
                    var r = this._startTime;
                    if (null !== r) {
                        var a = (e - r) * n;
                        if (a < 0 || 0 === n) return;
                        this._startTime = null, t = n * a
                    }
                    t *= this._updateTimeScale(e);
                    var o = this._updateTime(t),
                        s = this._updateWeight(e);
                    if (s > 0)
                        for (var l = this._interpolants, c = this._propertyBindings, u = 0, h = l.length; u !== h; ++u) l[u].evaluate(o), c[u].accumulate(i, s)
                },
                _updateWeight: function (e) {
                    var t = 0;
                    if (this.enabled) {
                        t = this.weight;
                        var n = this._weightInterpolant;
                        if (null !== n) {
                            var i = n.evaluate(e)[0];
                            t *= i, e > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = t, t
                },
                _updateTimeScale: function (e) {
                    var t = 0;
                    if (!this.paused) {
                        t = this.timeScale;
                        var n = this._timeScaleInterpolant;
                        if (null !== n) {
                            var i = n.evaluate(e)[0];
                            t *= i, e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
                        }
                    }
                    return this._effectiveTimeScale = t, t
                },
                _updateTime: function (e) {
                    var t = this.time + e,
                        n = this._clip.duration,
                        i = this.loop,
                        r = this._loopCount,
                        a = i === Ml;
                    if (0 === e) return r === -1 ? t : a && 1 === (1 & r) ? n - t : t;
                    if (i === _l) {
                        r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                        e: {
                            if (t >= n) t = n;
                            else {
                                if (!(t < 0)) break e;
                                t = 0
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e < 0 ? -1 : 1
                            })
                        }
                    } else {
                        if (r === -1 && (e >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), t >= n || t < 0) {
                            var o = Math.floor(t / n);
                            t -= n * o, r += Math.abs(o);
                            var s = this.repetitions - r;
                            if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, t = e > 0 ? n : 0, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: e > 0 ? 1 : -1
                            });
                            else {
                                if (1 === s) {
                                    var l = e < 0;
                                    this._setEndings(l, !l, a)
                                } else this._setEndings(!1, !1, a);
                                this._loopCount = r, this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: o
                                })
                            }
                        }
                        if (a && 1 === (1 & r)) return this.time = t, n - t
                    }
                    return this.time = t, t
                },
                _setEndings: function (e, t, n) {
                    var i = this._interpolantSettings;
                    n ? (i.endingStart = Cl, i.endingEnd = Cl) : (e ? i.endingStart = this.zeroSlopeAtStart ? Cl : Pl : i.endingStart = Al, t ? i.endingEnd = this.zeroSlopeAtEnd ? Cl : Pl : i.endingEnd = Al)
                },
                _scheduleFading: function (e, t, n) {
                    var i = this._mixer,
                        r = i.time,
                        a = this._weightInterpolant;
                    null === a && (a = i._lendControlInterpolant(), this._weightInterpolant = a);
                    var o = a.parameterPositions,
                        s = a.sampleValues;
                    return o[0] = r, s[0] = t, o[1] = r + e, s[1] = n, this
                }
            }), Kr.prototype = Object.assign(Object.create(t.prototype), {
                constructor: Kr,
                _bindAction: function (e, t) {
                    var n = e._localRoot || this._root,
                        i = e._clip.tracks,
                        r = i.length,
                        a = e._propertyBindings,
                        o = e._interpolants,
                        s = n.uuid,
                        l = this._bindingsByRootAndName,
                        c = l[s];
                    void 0 === c && (c = {}, l[s] = c);
                    for (var u = 0; u !== r; ++u) {
                        var h = i[u],
                            d = h.name,
                            p = c[d];
                        if (void 0 !== p) a[u] = p;
                        else {
                            if (p = a[u], void 0 !== p) {
                                null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, d));
                                continue
                            }
                            var f = t && t._propertyBindings[u].binding.parsedPath;
                            p = new Yr(Jr.create(n, d, f), h.ValueTypeName, h.getValueSize()), ++p.referenceCount, this._addInactiveBinding(p, s, d), a[u] = p
                        }
                        o[u].resultBuffer = p.buffer
                    }
                },
                _activateAction: function (e) {
                    if (!this._isActiveAction(e)) {
                        if (null === e._cacheIndex) {
                            var t = (e._localRoot || this._root).uuid,
                                n = e._clip.uuid,
                                i = this._actionsByClip[n];
                            this._bindAction(e, i && i.knownActions[0]), this._addInactiveAction(e, n, t)
                        }
                        for (var r = e._propertyBindings, a = 0, o = r.length; a !== o; ++a) {
                            var s = r[a];
                            0 === s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                        }
                        this._lendAction(e)
                    }
                },
                _deactivateAction: function (e) {
                    if (this._isActiveAction(e)) {
                        for (var t = e._propertyBindings, n = 0, i = t.length; n !== i; ++n) {
                            var r = t[n];
                            0 === --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                        }
                        this._takeBackAction(e)
                    }
                },
                _initMemoryManager: function () {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    var e = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return e._actions.length
                            },
                            get inUse() {
                                return e._nActiveActions
                            }
                        },
                        bindings: {
                            get total() {
                                return e._bindings.length
                            },
                            get inUse() {
                                return e._nActiveBindings
                            }
                        },
                        controlInterpolants: {
                            get total() {
                                return e._controlInterpolants.length;
                            },
                            get inUse() {
                                return e._nActiveControlInterpolants
                            }
                        }
                    }
                },
                _isActiveAction: function (e) {
                    var t = e._cacheIndex;
                    return null !== t && t < this._nActiveActions
                },
                _addInactiveAction: function (e, t, n) {
                    var i = this._actions,
                        r = this._actionsByClip,
                        a = r[t];
                    if (void 0 === a) a = {
                        knownActions: [e],
                        actionByRoot: {}
                    }, e._byClipCacheIndex = 0, r[t] = a;
                    else {
                        var o = a.knownActions;
                        e._byClipCacheIndex = o.length, o.push(e)
                    }
                    e._cacheIndex = i.length, i.push(e), a.actionByRoot[n] = e
                },
                _removeInactiveAction: function (e) {
                    var t = this._actions,
                        n = t[t.length - 1],
                        i = e._cacheIndex;
                    n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null;
                    var r = e._clip.uuid,
                        a = this._actionsByClip,
                        o = a[r],
                        s = o.knownActions,
                        l = s[s.length - 1],
                        c = e._byClipCacheIndex;
                    l._byClipCacheIndex = c, s[c] = l, s.pop(), e._byClipCacheIndex = null;
                    var u = o.actionByRoot,
                        h = (e._localRoot || this._root).uuid;
                    delete u[h], 0 === s.length && delete a[r], this._removeInactiveBindingsForAction(e)
                },
                _removeInactiveBindingsForAction: function (e) {
                    for (var t = e._propertyBindings, n = 0, i = t.length; n !== i; ++n) {
                        var r = t[n];
                        0 === --r.referenceCount && this._removeInactiveBinding(r)
                    }
                },
                _lendAction: function (e) {
                    var t = this._actions,
                        n = e._cacheIndex,
                        i = this._nActiveActions++,
                        r = t[i];
                    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
                },
                _takeBackAction: function (e) {
                    var t = this._actions,
                        n = e._cacheIndex,
                        i = --this._nActiveActions,
                        r = t[i];
                    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
                },
                _addInactiveBinding: function (e, t, n) {
                    var i = this._bindingsByRootAndName,
                        r = i[t],
                        a = this._bindings;
                    void 0 === r && (r = {}, i[t] = r), r[n] = e, e._cacheIndex = a.length, a.push(e)
                },
                _removeInactiveBinding: function (e) {
                    var t = this._bindings,
                        n = e.binding,
                        i = n.rootNode.uuid,
                        r = n.path,
                        a = this._bindingsByRootAndName,
                        o = a[i],
                        s = t[t.length - 1],
                        l = e._cacheIndex;
                    s._cacheIndex = l, t[l] = s, t.pop(), delete o[r];
                    e: {
                        for (var c in o) break e;delete a[i]
                    }
                },
                _lendBinding: function (e) {
                    var t = this._bindings,
                        n = e._cacheIndex,
                        i = this._nActiveBindings++,
                        r = t[i];
                    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
                },
                _takeBackBinding: function (e) {
                    var t = this._bindings,
                        n = e._cacheIndex,
                        i = --this._nActiveBindings,
                        r = t[i];
                    e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
                },
                _lendControlInterpolant: function () {
                    var e = this._controlInterpolants,
                        t = this._nActiveControlInterpolants++,
                        n = e[t];
                    return void 0 === n && (n = new Pi(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = t, e[t] = n), n
                },
                _takeBackControlInterpolant: function (e) {
                    var t = this._controlInterpolants,
                        n = e.__cacheIndex,
                        i = --this._nActiveControlInterpolants,
                        r = t[i];
                    e.__cacheIndex = i, t[i] = e, r.__cacheIndex = n, t[n] = r
                },
                _controlInterpolantsResultBuffer: new Float32Array(1),
                clipAction: function (e, t) {
                    var n = t || this._root,
                        i = n.uuid,
                        r = "string" == typeof e ? Bi.findByName(n, e) : e,
                        a = null !== r ? r.uuid : e,
                        o = this._actionsByClip[a],
                        s = null;
                    if (void 0 !== o) {
                        var l = o.actionByRoot[i];
                        if (void 0 !== l) return l;
                        s = o.knownActions[0], null === r && (r = s._clip)
                    }
                    if (null === r) return null;
                    var c = new Qr(this, r, t);
                    return this._bindAction(c, s), this._addInactiveAction(c, a, i), c
                },
                existingAction: function (e, t) {
                    var n = t || this._root,
                        i = n.uuid,
                        r = "string" == typeof e ? Bi.findByName(n, e) : e,
                        a = r ? r.uuid : e,
                        o = this._actionsByClip[a];
                    return void 0 !== o ? o.actionByRoot[i] || null : null
                },
                stopAllAction: function () {
                    var e = this._actions,
                        t = this._nActiveActions,
                        n = this._bindings,
                        i = this._nActiveBindings;
                    this._nActiveActions = 0, this._nActiveBindings = 0;
                    for (var r = 0; r !== t; ++r) e[r].reset();
                    for (var r = 0; r !== i; ++r) n[r].useCount = 0;
                    return this
                },
                update: function (e) {
                    e *= this.timeScale;
                    for (var t = this._actions, n = this._nActiveActions, i = this.time += e, r = Math.sign(e), a = this._accuIndex ^= 1, o = 0; o !== n; ++o) {
                        var s = t[o];
                        s._update(i, e, r, a)
                    }
                    for (var l = this._bindings, c = this._nActiveBindings, o = 0; o !== c; ++o) l[o].apply(a);
                    return this
                },
                getRoot: function () {
                    return this._root
                },
                uncacheClip: function (e) {
                    var t = this._actions,
                        n = e.uuid,
                        i = this._actionsByClip,
                        r = i[n];
                    if (void 0 !== r) {
                        for (var a = r.knownActions, o = 0, s = a.length; o !== s; ++o) {
                            var l = a[o];
                            this._deactivateAction(l);
                            var c = l._cacheIndex,
                                u = t[t.length - 1];
                            l._cacheIndex = null, l._byClipCacheIndex = null, u._cacheIndex = c, t[c] = u, t.pop(), this._removeInactiveBindingsForAction(l)
                        }
                        delete i[n]
                    }
                },
                uncacheRoot: function (e) {
                    var t = e.uuid,
                        n = this._actionsByClip;
                    for (var i in n) {
                        var r = n[i].actionByRoot,
                            a = r[t];
                        void 0 !== a && (this._deactivateAction(a), this._removeInactiveAction(a))
                    }
                    var o = this._bindingsByRootAndName,
                        s = o[t];
                    if (void 0 !== s)
                        for (var l in s) {
                            var c = s[l];
                            c.restoreOriginalState(), this._removeInactiveBinding(c)
                        }
                },
                uncacheAction: function (e, t) {
                    var n = this.existingAction(e, t);
                    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                }
            }), ea.prototype.clone = function () {
                return new ea(void 0 === this.value.clone ? this.value : this.value.clone())
            }, ta.prototype = Object.assign(Object.create(U.prototype), {
                constructor: ta,
                isInstancedBufferGeometry: !0,
                copy: function (e) {
                    return U.prototype.copy.call(this, e), this.maxInstancedCount = e.maxInstancedCount, this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                }
            }), na.prototype = Object.assign(Object.create(kt.prototype), {
                constructor: na,
                isInstancedInterleavedBuffer: !0,
                copy: function (e) {
                    return kt.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
                }
            }), ia.prototype = Object.assign(Object.create(P.prototype), {
                constructor: ia,
                isInstancedBufferAttribute: !0,
                copy: function (e) {
                    return P.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
                }
            }), Object.assign(ra.prototype, {
                linePrecision: 1,
                set: function (e, t) {
                    this.ray.set(e, t)
                },
                setFromCamera: function (e, t) {
                    t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize()) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
                },
                intersectObject: function (e, t, n) {
                    var i = n || [];
                    return oa(e, this, i, t), i.sort(aa), i
                },
                intersectObjects: function (e, t, n) {
                    var i = n || [];
                    if (Array.isArray(e) === !1) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
                    for (var r = 0, a = e.length; r < a; r++) oa(e[r], this, i, t);
                    return i.sort(aa), i
                }
            }), Object.assign(sa.prototype, {
                set: function (e, t, n) {
                    return this.radius = e, this.phi = t, this.theta = n, this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
                },
                makeSafe: function () {
                    var e = 1e-6;
                    return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this
                },
                setFromVector3: function (e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                },
                setFromCartesianCoords: function (e, t, n) {
                    return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Wl.clamp(t / this.radius, -1, 1))), this
                }
            }), Object.assign(la.prototype, {
                set: function (e, t, n) {
                    return this.radius = e, this.theta = t, this.y = n, this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
                },
                setFromVector3: function (e) {
                    return this.setFromCartesianCoords(e.x, e.y, e.z)
                },
                setFromCartesianCoords: function (e, t, n) {
                    return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this
                }
            }), Object.assign(ca.prototype, {
                set: function (e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                },
                setFromPoints: function (e) {
                    this.makeEmpty();
                    for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                    return this
                },
                setFromCenterAndSize: function () {
                    var e = new n;
                    return function (t, n) {
                        var i = e.copy(n).multiplyScalar(.5);
                        return this.min.copy(t).sub(i), this.max.copy(t).add(i), this
                    }
                }(),
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                },
                makeEmpty: function () {
                    return this.min.x = this.min.y = +(1 / 0), this.max.x = this.max.y = -(1 / 0), this
                },
                isEmpty: function () {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                },
                getCenter: function (e) {
                    return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new n), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function (e) {
                    return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"), e = new n), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
                },
                expandByPoint: function (e) {
                    return this.min.min(e), this.max.max(e), this
                },
                expandByVector: function (e) {
                    return this.min.sub(e), this.max.add(e), this
                },
                expandByScalar: function (e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                },
                containsPoint: function (e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
                },
                containsBox: function (e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
                },
                getParameter: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new n), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
                },
                intersectsBox: function (e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
                },
                clampPoint: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new n), t.copy(e).clamp(this.min, this.max)
                },
                distanceToPoint: function () {
                    var e = new n;
                    return function (t) {
                        var n = e.copy(t).clamp(this.min, this.max);
                        return n.sub(t).length()
                    }
                }(),
                intersect: function (e) {
                    return this.min.max(e.min), this.max.min(e.max), this
                },
                union: function (e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                },
                translate: function (e) {
                    return this.min.add(e), this.max.add(e), this
                },
                equals: function (e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }), Object.assign(ua.prototype, {
                set: function (e, t) {
                    return this.start.copy(e), this.end.copy(t), this
                },
                clone: function () {
                    return (new this.constructor).copy(this)
                },
                copy: function (e) {
                    return this.start.copy(e.start), this.end.copy(e.end), this
                },
                getCenter: function (e) {
                    return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new a), e.addVectors(this.start, this.end).multiplyScalar(.5)
                },
                delta: function (e) {
                    return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"), e = new a), e.subVectors(this.end, this.start)
                },
                distanceSq: function () {
                    return this.start.distanceToSquared(this.end)
                },
                distance: function () {
                    return this.start.distanceTo(this.end)
                },
                at: function (e, t) {
                    return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"), t = new a), this.delta(t).multiplyScalar(e).add(this.start)
                },
                closestPointToPointParameter: function () {
                    var e = new a,
                        t = new a;
                    return function (n, i) {
                        e.subVectors(n, this.start), t.subVectors(this.end, this.start);
                        var r = t.dot(t),
                            a = t.dot(e),
                            o = a / r;
                        return i && (o = Wl.clamp(o, 0, 1)), o
                    }
                }(),
                closestPointToPoint: function (e, t, n) {
                    var i = this.closestPointToPointParameter(e, t);
                    return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new a), this.delta(n).multiplyScalar(i).add(this.start)
                },
                applyMatrix4: function (e) {
                    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
                },
                equals: function (e) {
                    return e.start.equals(this.start) && e.end.equals(this.end)
                }
            }), ha.prototype = Object.create(E.prototype), ha.prototype.constructor = ha, ha.prototype.isImmediateRenderObject = !0, da.prototype = Object.create(Vt.prototype), da.prototype.constructor = da, da.prototype.update = function () {
                var e = new a,
                    t = new a,
                    n = new o;
                return function () {
                    var i = ["a", "b", "c"];
                    this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
                    var r = this.object.matrixWorld,
                        a = this.geometry.attributes.position,
                        o = this.object.geometry;
                    if (o && o.isGeometry)
                        for (var s = o.vertices, l = o.faces, c = 0, u = 0, h = l.length; u < h; u++)
                            for (var d = l[u], p = 0, f = d.vertexNormals.length; p < f; p++) {
                                var m = s[d[i[p]]],
                                    v = d.vertexNormals[p];
                                e.copy(m).applyMatrix4(r), t.copy(v).applyMatrix3(n).normalize().multiplyScalar(this.size).add(e), a.setXYZ(c, e.x, e.y, e.z), c += 1, a.setXYZ(c, t.x, t.y, t.z), c += 1
                            } else if (o && o.isBufferGeometry)
                                for (var g = o.attributes.position, y = o.attributes.normal, c = 0, p = 0, f = g.count; p < f; p++) e.set(g.getX(p), g.getY(p), g.getZ(p)).applyMatrix4(r), t.set(y.getX(p), y.getY(p), y.getZ(p)), t.applyMatrix3(n).normalize().multiplyScalar(this.size).add(e), a.setXYZ(c, e.x, e.y, e.z), c += 1, a.setXYZ(c, t.x, t.y, t.z), c += 1;
                    a.needsUpdate = !0
                }
            }(), pa.prototype = Object.create(E.prototype), pa.prototype.constructor = pa, pa.prototype.dispose = function () {
                this.cone.geometry.dispose(), this.cone.material.dispose()
            }, pa.prototype.update = function () {
                var e = new a;
                return function () {
                    this.light.updateMatrixWorld();
                    var t = this.light.distance ? this.light.distance : 1e3,
                        n = t * Math.tan(this.light.angle);
                    this.cone.scale.set(n, n, t), e.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(e), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                }
            }(), ma.prototype = Object.create(Vt.prototype), ma.prototype.constructor = ma, ma.prototype.updateMatrixWorld = function () {
                var e = new a,
                    t = new i,
                    n = new i;
                return function (i) {
                    var r = this.bones,
                        a = this.geometry,
                        o = a.getAttribute("position");
                    n.getInverse(this.root.matrixWorld);
                    for (var s = 0, l = 0; s < r.length; s++) {
                        var c = r[s];
                        c.parent && c.parent.isBone && (t.multiplyMatrices(n, c.matrixWorld), e.setFromMatrixPosition(t), o.setXYZ(l, e.x, e.y, e.z), t.multiplyMatrices(n, c.parent.matrixWorld), e.setFromMatrixPosition(t), o.setXYZ(l + 1, e.x, e.y, e.z), l += 2)
                    }
                    a.getAttribute("position").needsUpdate = !0, E.prototype.updateMatrixWorld.call(this, i)
                }
            }(), va.prototype = Object.create(Z.prototype), va.prototype.constructor = va, va.prototype.dispose = function () {
                this.geometry.dispose(), this.material.dispose()
            }, va.prototype.update = function () {
                void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
            }, ga.prototype = Object.create(Ht.prototype), ga.prototype.constructor = ga, ga.prototype.update = function () {
                if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color);
                else {
                    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
                    var e = this.material.color,
                        t = Math.max(e.r, e.g, e.b);
                    t > 1 && e.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color)
                }
            }, ga.prototype.dispose = function () {
                this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
            }, ya.prototype = Object.create(E.prototype), ya.prototype.constructor = ya, ya.prototype.dispose = function () {
                this.children[0].geometry.dispose(), this.children[0].material.dispose()
            }, ya.prototype.update = function () {
                var e = new a,
                    t = new x,
                    n = new x;
                return function () {
                    var i = this.children[0];
                    if (void 0 !== this.color) this.material.color.set(this.color);
                    else {
                        var r = i.geometry.getAttribute("color");
                        t.copy(this.light.color), n.copy(this.light.groundColor);
                        for (var a = 0, o = r.count; a < o; a++) {
                            var s = a < o / 2 ? t : n;
                            r.setXYZ(a, s.r, s.g, s.b)
                        }
                        r.needsUpdate = !0
                    }
                    i.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate())
                }
            }(), xa.prototype = Object.create(Vt.prototype), xa.prototype.constructor = xa, ba.prototype = Object.create(Vt.prototype), ba.prototype.constructor = ba, _a.prototype = Object.create(Ht.prototype), _a.prototype.constructor = _a, _a.prototype.update = function () {
                function e(e, i, a, o) {
                    var s = (i - e) / a;
                    for (f.setXYZ(h, 0, 0, 0), d++, t = e; t < i; t += s) n = h + d, f.setXYZ(n, Math.sin(t) * r, 0, Math.cos(t) * r), f.setXYZ(n + 1, Math.sin(Math.min(t + s, i)) * r, 0, Math.cos(Math.min(t + s, i)) * r), f.setXYZ(n + 2, 0, 0, 0), d += 3;
                    p.addGroup(h, d, o), h += d, d = 0
                }
                var t, n, i = this.audio,
                    r = this.range,
                    a = this.divisionsInnerAngle,
                    o = this.divisionsOuterAngle,
                    s = Wl.degToRad(i.panner.coneInnerAngle),
                    l = Wl.degToRad(i.panner.coneOuterAngle),
                    c = s / 2,
                    u = l / 2,
                    h = 0,
                    d = 0,
                    p = this.geometry,
                    f = p.attributes.position;
                p.clearGroups(), e(-u, -c, o, 0), e(-c, c, a, 1), e(c, u, o, 0), f.needsUpdate = !0, s === l && (this.material[0].visible = !1)
            }, _a.prototype.dispose = function () {
                this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose()
            }, wa.prototype = Object.create(Vt.prototype), wa.prototype.constructor = wa, wa.prototype.update = function () {
                var e = new a,
                    t = new a,
                    n = new o;
                return function () {
                    this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
                    for (var i = this.object.matrixWorld, r = this.geometry.attributes.position, a = this.object.geometry, o = a.vertices, s = a.faces, l = 0, c = 0, u = s.length; c < u; c++) {
                        var h = s[c],
                            d = h.normal;
                        e.copy(o[h.a]).add(o[h.b]).add(o[h.c]).divideScalar(3).applyMatrix4(i), t.copy(d).applyMatrix3(n).normalize().multiplyScalar(this.size).add(e), r.setXYZ(l, e.x, e.y, e.z), l += 1, r.setXYZ(l, t.x, t.y, t.z), l += 1
                    }
                    r.needsUpdate = !0
                }
            }(), Ma.prototype = Object.create(E.prototype), Ma.prototype.constructor = Ma, Ma.prototype.dispose = function () {
                this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
            }, Ma.prototype.update = function () {
                var e = new a,
                    t = new a,
                    n = new a;
                return function () {
                    e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), n.subVectors(t, e), this.lightPlane.lookAt(t), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(t), this.targetLine.scale.z = n.length()
                }
            }(), Ta.prototype = Object.create(Vt.prototype), Ta.prototype.constructor = Ta, Ta.prototype.update = function () {
                function e(e, a, o, s) {
                    i.set(a, o, s).unproject(r);
                    var l = n[e];
                    if (void 0 !== l)
                        for (var c = t.getAttribute("position"), u = 0, h = l.length; u < h; u++) c.setXYZ(l[u], i.x, i.y, i.z)
                }
                var t, n, i = new a,
                    r = new Tt;
                return function () {
                    t = this.geometry, n = this.pointMap;
                    var i = 1,
                        a = 1;
                    r.projectionMatrix.copy(this.camera.projectionMatrix), e("c", 0, 0, -1), e("t", 0, 0, 1), e("n1", -i, -a, -1), e("n2", i, -a, -1), e("n3", -i, a, -1), e("n4", i, a, -1), e("f1", -i, -a, 1), e("f2", i, -a, 1), e("f3", -i, a, 1), e("f4", i, a, 1), e("u1", .7 * i, 1.1 * a, -1), e("u2", .7 * -i, 1.1 * a, -1), e("u3", 0, 2 * a, -1), e("cf1", -i, 0, 1), e("cf2", i, 0, 1), e("cf3", 0, -a, 1), e("cf4", 0, a, 1), e("cn1", -i, 0, -1), e("cn2", i, 0, -1), e("cn3", 0, -a, -1), e("cn4", 0, a, -1), t.getAttribute("position").needsUpdate = !0
                }
            }(), Ea.prototype = Object.create(Vt.prototype), Ea.prototype.constructor = Ea, Ea.prototype.update = function () {
                var e = new p;
                return function (t) {
                    if (void 0 !== t && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && e.setFromObject(this.object), !e.isEmpty()) {
                        var n = e.min,
                            i = e.max,
                            r = this.geometry.attributes.position,
                            a = r.array;
                        a[0] = i.x, a[1] = i.y, a[2] = i.z, a[3] = n.x, a[4] = i.y, a[5] = i.z, a[6] = n.x, a[7] = n.y, a[8] = i.z, a[9] = i.x, a[10] = n.y, a[11] = i.z, a[12] = i.x, a[13] = i.y, a[14] = n.z, a[15] = n.x, a[16] = i.y, a[17] = n.z, a[18] = n.x, a[19] = n.y, a[20] = n.z, a[21] = i.x, a[22] = n.y, a[23] = n.z, r.needsUpdate = !0, this.geometry.computeBoundingSphere()
                    }
                }
            }(), Ea.prototype.setFromObject = function (e) {
                return this.object = e, this.update(), this
            }, Ea.prototype.copy = function (e) {
                return Vt.prototype.copy.call(this, e), this.object = e.object, this
            }, Ea.prototype.clone = function () {
                return (new this.constructor).copy(this)
            }, Sa.prototype = Object.create(Vt.prototype), Sa.prototype.constructor = Sa, Sa.prototype.updateMatrixWorld = function (e) {
                var t = this.box;
                t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), E.prototype.updateMatrixWorld.call(this, e))
            }, Pa.prototype = Object.create(Ht.prototype), Pa.prototype.constructor = Pa, Pa.prototype.updateMatrixWorld = function (e) {
                var t = -this.plane.constant;
                Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? wo : _o, this.lookAt(this.plane.normal), E.prototype.updateMatrixWorld.call(this, e)
            };
            var Kh, ed;
            Ca.prototype = Object.create(E.prototype), Ca.prototype.constructor = Ca, Ca.prototype.setDirection = function () {
                var e, t = new a;
                return function (n) {
                    n.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : n.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (t.set(n.z, 0, -n.x).normalize(), e = Math.acos(n.y), this.quaternion.setFromAxisAngle(t, e))
                }
            }(), Ca.prototype.setLength = function (e, t, n) {
                void 0 === t && (t = .2 * e), void 0 === n && (n = .2 * t), this.line.scale.set(1, Math.max(0, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
            }, Ca.prototype.setColor = function (e) {
                this.line.material.color.copy(e), this.cone.material.color.copy(e)
            }, Ca.prototype.copy = function (e) {
                return E.prototype.copy.call(this, e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
            }, Ca.prototype.clone = function () {
                return (new this.constructor).copy(this)
            }, Aa.prototype = Object.create(Vt.prototype), Aa.prototype.constructor = Aa;
            var td = 0,
                nd = 1;
            Yi.create = function (e, t) {
                return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Yi.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
            }, Object.assign(vr.prototype, {
                createPointsGeometry: function (e) {
                    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var t = this.getPoints(e);
                    return this.createGeometry(t)
                },
                createSpacedPointsGeometry: function (e) {
                    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var t = this.getSpacedPoints(e);
                    return this.createGeometry(t)
                },
                createGeometry: function (e) {
                    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    for (var t = new S, n = 0, i = e.length; n < i; n++) {
                        var r = e[n];
                        t.vertices.push(new a(r.x, r.y, r.z || 0))
                    }
                    return t
                }
            }), Object.assign(gr.prototype, {
                fromPoints: function (e) {
                    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e)
                }
            }), Ja.prototype = Object.create(Qi.prototype), $a.prototype = Object.create(Qi.prototype), Qa.prototype = Object.create(Qi.prototype), Object.assign(Qa.prototype, {
                initFromArray: function () {
                    console.error("THREE.Spline: .initFromArray() has been removed.")
                },
                getControlPointsArray: function () {
                    console.error("THREE.Spline: .getControlPointsArray() has been removed.")
                },
                reparametrizeByArcLength: function () {
                    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
                }
            }), xa.prototype.setColors = function () {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            }, ma.prototype.update = function () {
                console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
            }, Object.assign(Ur.prototype, {
                extractUrlBase: function (e) {
                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Wh.extractUrlBase(e)
                }
            }), Object.assign(Ir.prototype, {
                setTexturePath: function (e) {
                    return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e)
                }
            }), Object.assign(ca.prototype, {
                center: function (e) {
                    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e)
                },
                empty: function () {
                    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function (e) {
                    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
                },
                size: function (e) {
                    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e)
                }
            }), Object.assign(p.prototype, {
                center: function (e) {
                    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e)
                },
                empty: function () {
                    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function (e) {
                    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
                },
                isIntersectionSphere: function (e) {
                    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
                },
                size: function (e) {
                    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e)
                }
            }), ua.prototype.center = function (e) {
                return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e)
            }, Object.assign(Wl, {
                random16: function () {
                    return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
                },
                nearestPowerOfTwo: function (e) {
                    return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Wl.floorPowerOfTwo(e)
                },
                nextPowerOfTwo: function (e) {
                    return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Wl.ceilPowerOfTwo(e)
                }
            }), Object.assign(o.prototype, {
                flattenToArrayOffset: function (e, t) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
                },
                multiplyVector3: function (e) {
                    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
                },
                multiplyVector3Array: function () {
                    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
                },
                applyToBuffer: function (e) {
                    return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
                },
                applyToVector3Array: function () {
                    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
                }
            }), Object.assign(i.prototype, {
                extractPosition: function (e) {
                    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
                },
                flattenToArrayOffset: function (e, t) {
                    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t)
                },
                getPosition: function () {
                    var e;
                    return function () {
                        return void 0 === e && (e = new a), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), e.setFromMatrixColumn(this, 3)
                    }
                }(),
                setRotationFromQuaternion: function (e) {
                    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
                },
                multiplyToArray: function () {
                    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
                },
                multiplyVector3: function (e) {
                    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
                },
                multiplyVector4: function (e) {
                    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
                },
                multiplyVector3Array: function () {
                    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
                },
                rotateAxis: function (e) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
                },
                crossVector: function (e) {
                    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
                },
                translate: function () {
                    console.error("THREE.Matrix4: .translate() has been removed.")
                },
                rotateX: function () {
                    console.error("THREE.Matrix4: .rotateX() has been removed.")
                },
                rotateY: function () {
                    console.error("THREE.Matrix4: .rotateY() has been removed.")
                },
                rotateZ: function () {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.")
                },
                rotateByAxis: function () {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                },
                applyToBuffer: function (e) {
                    return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e)
                },
                applyToVector3Array: function () {
                    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
                },
                makeFrustum: function (e, t, n, i, r, a) {
                    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, i, n, r, a)
                }
            }), m.prototype.isIntersectionLine = function (e) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
            }, r.prototype.multiplyVector3 = function (e) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
            }, Object.assign(q.prototype, {
                isIntersectionBox: function (e) {
                    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
                },
                isIntersectionPlane: function (e) {
                    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e)
                },
                isIntersectionSphere: function (e) {
                    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
                }
            }), Object.assign(X.prototype, {
                area: function () {
                    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
                },
                barycoordFromPoint: function (e, t) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t)
                },
                midpoint: function (e) {
                    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e)
                },
                normal: function (e) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e)
                },
                plane: function (e) {
                    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e)
                }
            }), Object.assign(X, {
                barycoordFromPoint: function (e, t, n, i, r) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), X.getBarycoord(e, t, n, i, r)
                },
                normal: function (e, t, n, i) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), X.getNormal(e, t, n, i)
                }
            }), Object.assign(yr.prototype, {
                extractAllPoints: function (e) {
                    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e)
                },
                extrude: function (e) {
                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Yn(this, e)
                },
                makeGeometry: function (e) {
                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new ai(this, e)
                }
            }), Object.assign(n.prototype, {
                fromAttribute: function (e, t, n) {
                    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
                },
                distanceToManhattan: function (e) {
                    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
                },
                lengthManhattan: function () {
                    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(a.prototype, {
                setEulerFromRotationMatrix: function () {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                },
                setEulerFromQuaternion: function () {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                },
                getPositionFromMatrix: function (e) {
                    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
                },
                getScaleFromMatrix: function (e) {
                    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
                },
                getColumnFromMatrix: function (e, t) {
                    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e)
                },
                applyProjection: function (e) {
                    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e)
                },
                fromAttribute: function (e, t, n) {
                    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
                },
                distanceToManhattan: function (e) {
                    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e)
                },
                lengthManhattan: function () {
                    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(l.prototype, {
                fromAttribute: function (e, t, n) {
                    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, n)
                },
                lengthManhattan: function () {
                    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(S.prototype, {
                computeTangents: function () {
                    console.error("THREE.Geometry: .computeTangents() has been removed.");
                },
                computeLineDistances: function () {
                    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
                }
            }), Object.assign(E.prototype, {
                getChildByName: function (e) {
                    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
                },
                renderDepth: function () {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                },
                translate: function (e, t) {
                    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
                },
                getWorldRotation: function () {
                    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
                }
            }), Object.defineProperties(E.prototype, {
                eulerOrder: {
                    get: function () {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                    },
                    set: function (e) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
                    }
                },
                useQuaternion: {
                    get: function () {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function () {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }), Object.defineProperties(Nt.prototype, {
                objects: {
                    get: function () {
                        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                    }
                }
            }), Object.defineProperty(jt.prototype, "useVertexTexture", {
                get: function () {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                },
                set: function () {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                }
            }), Ut.prototype.initBones = function () {
                console.error("THREE.SkinnedMesh: initBones() has been removed.")
            }, Object.defineProperty(Yi.prototype, "__arcLengthDivisions", {
                get: function () {
                    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
                },
                set: function (e) {
                    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e
                }
            }), Et.prototype.setLens = function (e, t) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e)
            }, Object.defineProperties(xr.prototype, {
                onlyShadow: {
                    set: function () {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
                    }
                },
                shadowCameraLeft: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
                    }
                },
                shadowCameraRight: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
                    }
                },
                shadowCameraTop: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
                    }
                },
                shadowCameraBottom: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
                    }
                },
                shadowCameraNear: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
                    }
                },
                shadowCameraFar: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
                    }
                },
                shadowCameraVisible: {
                    set: function () {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
                    }
                },
                shadowDarkness: {
                    set: function () {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
                    }
                },
                shadowMapHeight: {
                    set: function (e) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
                    }
                }
            }), Object.defineProperties(P.prototype, {
                length: {
                    get: function () {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                    }
                },
                copyIndicesArray: function () {
                    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
                }
            }), Object.assign(U.prototype, {
                addIndex: function (e) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
                },
                addDrawCall: function (e, t, n) {
                    void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
                },
                clearDrawCalls: function () {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
                },
                computeTangents: function () {
                    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                },
                computeOffsets: function () {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                }
            }), Object.defineProperties(U.prototype, {
                drawcalls: {
                    get: function () {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                    }
                },
                offsets: {
                    get: function () {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                    }
                }
            }), Object.assign(Zn.prototype, {
                getArrays: function () {
                    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
                },
                addShapeList: function () {
                    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
                },
                addShape: function () {
                    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
                }
            }), Object.defineProperties(ea.prototype, {
                dynamic: {
                    set: function () {
                        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                    }
                },
                onUpdate: {
                    value: function () {
                        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                    }
                }
            }), Object.defineProperties(V.prototype, {
                wrapAround: {
                    get: function () {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    },
                    set: function () {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    }
                },
                overdraw: {
                    get: function () {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    },
                    set: function () {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    }
                },
                wrapRGB: {
                    get: function () {
                        return console.warn("THREE.Material: .wrapRGB has been removed."), new x
                    }
                },
                shading: {
                    get: function () {
                        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                    },
                    set: function (e) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = e === To
                    }
                }
            }), Object.defineProperties(xi.prototype, {
                metal: {
                    get: function () {
                        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                    },
                    set: function () {
                        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                    }
                }
            }), Object.defineProperties(W.prototype, {
                derivatives: {
                    get: function () {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                    },
                    set: function (e) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
                    }
                }
            }), Object.assign(Lt.prototype, {
                clearTarget: function (e, t, n, i) {
                    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, n, i)
                },
                animate: function (e) {
                    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e)
                },
                getCurrentRenderTarget: function () {
                    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
                },
                getMaxAnisotropy: function () {
                    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
                },
                getPrecision: function () {
                    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
                },
                resetGLState: function () {
                    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
                },
                supportsFloatTextures: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
                },
                supportsHalfFloatTextures: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
                },
                supportsStandardDerivatives: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
                },
                supportsCompressedTextureS3TC: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
                },
                supportsCompressedTexturePVRTC: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
                },
                supportsBlendMinMax: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
                },
                supportsVertexTextures: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
                },
                supportsInstancedArrays: function () {
                    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
                },
                enableScissorTest: function (e) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
                },
                initMaterial: function () {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                },
                addPrePlugin: function () {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                },
                addPostPlugin: function () {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                },
                updateShadowMap: function () {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                },
                setFaceCulling: function () {
                    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
                }
            }), Object.defineProperties(Lt.prototype, {
                shadowMapEnabled: {
                    get: function () {
                        return this.shadowMap.enabled
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
                    }
                },
                shadowMapType: {
                    get: function () {
                        return this.shadowMap.type
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
                    }
                },
                shadowMapCullFace: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(xt.prototype, {
                cullFace: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderReverseSided: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderSingleSided: {
                    get: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function () {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(h.prototype, {
                activeCubeFace: {
                    set: function () {
                        console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().")
                    }
                },
                activeMipMapLevel: {
                    set: function () {
                        console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().")
                    }
                }
            }), Object.defineProperties(c.prototype, {
                wrapS: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
                    }
                },
                wrapT: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
                    }
                },
                magFilter: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
                    }
                },
                minFilter: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
                    }
                },
                anisotropy: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
                    }
                },
                offset: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
                    }
                },
                repeat: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
                    }
                },
                format: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
                    }
                },
                type: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
                    }
                },
                generateMipmaps: {
                    get: function () {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                    },
                    set: function (e) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
                    }
                }
            }), Object.defineProperties(Ct.prototype, {
                standing: {
                    set: function () {
                        console.warn("THREE.WebVRManager: .standing has been removed.")
                    }
                },
                userHeight: {
                    set: function () {
                        console.warn("THREE.WebVRManager: .userHeight has been removed.")
                    }
                }
            }), Wr.prototype.load = function (e) {
                console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                var t = this,
                    n = new jr;
                return n.load(e, function (e) {
                    t.setBuffer(e)
                }), this
            }, Xr.prototype.getData = function () {
                return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
            }, Gr.prototype.updateCubeMap = function (e, t) {
                return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t)
            };
            var id = {
                merge: function (e, t, n) {
                    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
                    var i;
                    t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), i = t.matrix, t = t.geometry), e.merge(t, i, n)
                },
                center: function (e) {
                    return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center()
                }
            };
            Xl.crossOrigin = void 0, Xl.loadTexture = function (e, t, n, i) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                var r = new Xi;
                r.setCrossOrigin(this.crossOrigin);
                var a = r.load(e, n, void 0, i);
                return t && (a.mapping = t), a
            }, Xl.loadTextureCube = function (e, t, n, i) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                var r = new qi;
                r.setCrossOrigin(this.crossOrigin);
                var a = r.load(e, n, void 0, i);
                return t && (a.mapping = t), a
            }, Xl.loadCompressedTexture = function () {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            }, Xl.loadCompressedTextureCube = function () {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            };
            var rd = {
                createMultiMaterialObject: function () {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                detach: function () {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                attach: function () {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                }
            };
            e.WebGLMultisampleRenderTarget = u, e.WebGLRenderTargetCube = h, e.WebGLRenderTarget = c, e.WebGLRenderer = Lt, e.ShaderLib = uh, e.UniformsLib = ch, e.UniformsUtils = sh, e.ShaderChunk = oh, e.FogExp2 = Rt, e.Fog = It, e.Scene = Ot, e.Sprite = Bt, e.LOD = Nt, e.SkinnedMesh = Ut, e.Skeleton = jt, e.Bone = Ft, e.Mesh = Z, e.LineSegments = Vt, e.LineLoop = Wt, e.Line = Ht, e.Points = Xt, e.Group = Mt, e.VideoTexture = Yt, e.DataTexture = d, e.DataTexture3D = le, e.CompressedTexture = Zt, e.CubeTexture = se, e.CanvasTexture = Jt, e.DepthTexture = $t, e.Texture = s, e.AnimationLoader = Gi, e.CompressedTextureLoader = Hi, e.DataTextureLoader = Vi, e.CubeTextureLoader = qi, e.TextureLoader = Xi, e.ObjectLoader = Ir, e.MaterialLoader = Lr, e.BufferGeometryLoader = Rr, e.DefaultLoadingManager = Nh, e.LoadingManager = ji, e.ImageLoader = Wi, e.ImageBitmapLoader = Or, e.FontLoader = Nr, e.FileLoader = Fi, e.Loader = Ur, e.LoaderUtils = Wh, e.Cache = Bh, e.AudioLoader = jr, e.SpotLightShadow = wr, e.SpotLight = Mr, e.PointLight = Tr, e.RectAreaLight = Ar, e.HemisphereLight = br, e.DirectionalLightShadow = Sr, e.DirectionalLight = Pr, e.AmbientLight = Cr, e.LightShadow = _r, e.Light = xr, e.StereoCamera = Fr, e.PerspectiveCamera = Et, e.OrthographicCamera = Er, e.CubeCamera = Gr, e.ArrayCamera = St, e.Camera = Tt, e.AudioListener = Vr, e.PositionalAudio = qr, e.AudioContext = $h, e.AudioAnalyser = Xr, e.Audio = Wr, e.VectorKeyframeTrack = zi, e.StringKeyframeTrack = Di, e.QuaternionKeyframeTrack = ki, e.NumberKeyframeTrack = Ii, e.ColorKeyframeTrack = Ri, e.BooleanKeyframeTrack = Li, e.PropertyMixer = Yr, e.PropertyBinding = Jr, e.KeyframeTrack = Ai, e.AnimationUtils = zh, e.AnimationObjectGroup = $r, e.AnimationMixer = Kr, e.AnimationClip = Bi, e.Uniform = ea, e.InstancedBufferGeometry = ta, e.BufferGeometry = U, e.Geometry = S, e.InterleavedBufferAttribute = Dt, e.InstancedInterleavedBuffer = na, e.InterleavedBuffer = kt, e.InstancedBufferAttribute = ia, e.Face3 = w, e.Object3D = E, e.Raycaster = ra, e.Layers = T, e.EventDispatcher = t, e.Clock = Hr, e.QuaternionLinearInterpolant = Oi, e.LinearInterpolant = Pi, e.DiscreteInterpolant = Ci, e.CubicInterpolant = Si, e.Interpolant = Ei, e.Triangle = X, e.Math = Wl, e.Spherical = sa, e.Cylindrical = la, e.Plane = m, e.Frustum = v, e.Sphere = f, e.Ray = q, e.Matrix4 = i, e.Matrix3 = o, e.Box3 = p, e.Box2 = ca, e.Line3 = ua, e.Euler = M, e.Vector4 = l, e.Vector3 = a, e.Vector2 = n, e.Quaternion = r, e.Color = x, e.ImmediateRenderObject = ha, e.VertexNormalsHelper = da, e.SpotLightHelper = pa, e.SkeletonHelper = ma, e.PointLightHelper = va, e.RectAreaLightHelper = ga, e.HemisphereLightHelper = ya, e.GridHelper = xa, e.PolarGridHelper = ba, e.PositionalAudioHelper = _a, e.FaceNormalsHelper = wa, e.DirectionalLightHelper = Ma, e.CameraHelper = Ta, e.BoxHelper = Ea, e.Box3Helper = Sa, e.PlaneHelper = Pa, e.ArrowHelper = Ca, e.AxesHelper = Aa, e.Shape = yr, e.Path = gr, e.ShapePath = kr, e.Font = Dr, e.CurvePath = vr, e.Curve = Yi, e.ImageUtils = Xl, e.ShapeUtils = Ih, e.WebGLUtils = wt, e.WireframeGeometry = Qt, e.ParametricGeometry = Kt, e.ParametricBufferGeometry = en, e.TetrahedronGeometry = rn, e.TetrahedronBufferGeometry = an, e.OctahedronGeometry = on, e.OctahedronBufferGeometry = sn, e.IcosahedronGeometry = ln, e.IcosahedronBufferGeometry = cn, e.DodecahedronGeometry = un, e.DodecahedronBufferGeometry = hn, e.PolyhedronGeometry = tn, e.PolyhedronBufferGeometry = nn, e.TubeGeometry = dn, e.TubeBufferGeometry = pn, e.TorusKnotGeometry = fn, e.TorusKnotBufferGeometry = mn, e.TorusGeometry = vn, e.TorusBufferGeometry = gn, e.TextGeometry = $n, e.TextBufferGeometry = Qn, e.SphereGeometry = Kn, e.SphereBufferGeometry = ei, e.RingGeometry = ti, e.RingBufferGeometry = ni, e.PlaneGeometry = G, e.PlaneBufferGeometry = H, e.LatheGeometry = ii, e.LatheBufferGeometry = ri, e.ShapeGeometry = ai, e.ShapeBufferGeometry = oi, e.ExtrudeGeometry = Yn, e.ExtrudeBufferGeometry = Zn, e.EdgesGeometry = li, e.ConeGeometry = hi, e.ConeBufferGeometry = di, e.CylinderGeometry = ci, e.CylinderBufferGeometry = ui, e.CircleGeometry = pi, e.CircleBufferGeometry = fi, e.BoxGeometry = j, e.CubeGeometry = j, e.BoxBufferGeometry = F, e.ShadowMaterial = mi, e.SpriteMaterial = zt, e.RawShaderMaterial = vi, e.ShaderMaterial = W, e.PointsMaterial = qt, e.MeshPhysicalMaterial = yi, e.MeshStandardMaterial = gi, e.MeshPhongMaterial = xi, e.MeshToonMaterial = bi, e.MeshNormalMaterial = _i, e.MeshLambertMaterial = wi, e.MeshDepthMaterial = gt, e.MeshDistanceMaterial = yt, e.MeshBasicMaterial = Y, e.MeshMatcapMaterial = Mi, e.LineDashedMaterial = Ti, e.LineBasicMaterial = Gt, e.Material = V, e.Float64BufferAttribute = z, e.Float32BufferAttribute = D, e.Uint32BufferAttribute = k, e.Int32BufferAttribute = O, e.Uint16BufferAttribute = I, e.Int16BufferAttribute = R, e.Uint8ClampedBufferAttribute = L, e.Uint8BufferAttribute = A, e.Int8BufferAttribute = C, e.BufferAttribute = P, e.ArcCurve = Ji, e.CatmullRomCurve3 = Qi, e.CubicBezierCurve = cr, e.CubicBezierCurve3 = ur, e.EllipseCurve = Zi, e.LineCurve = hr, e.LineCurve3 = dr, e.QuadraticBezierCurve = pr, e.QuadraticBezierCurve3 = fr, e.SplineCurve = mr, e.REVISION = co, e.MOUSE = uo, e.CullFaceNone = ho, e.CullFaceBack = po, e.CullFaceFront = fo, e.CullFaceFrontBack = mo, e.FrontFaceDirectionCW = vo, e.FrontFaceDirectionCCW = go, e.BasicShadowMap = yo, e.PCFShadowMap = xo, e.PCFSoftShadowMap = bo, e.FrontSide = _o, e.BackSide = wo, e.DoubleSide = Mo, e.FlatShading = To, e.SmoothShading = Eo, e.NoColors = So, e.FaceColors = Po, e.VertexColors = Co, e.NoBlending = Ao, e.NormalBlending = Lo, e.AdditiveBlending = Ro, e.SubtractiveBlending = Io, e.MultiplyBlending = Oo, e.CustomBlending = ko, e.AddEquation = Do, e.SubtractEquation = zo, e.ReverseSubtractEquation = Bo, e.MinEquation = No, e.MaxEquation = Uo, e.ZeroFactor = jo, e.OneFactor = Fo, e.SrcColorFactor = Go, e.OneMinusSrcColorFactor = Ho, e.SrcAlphaFactor = Vo, e.OneMinusSrcAlphaFactor = Wo, e.DstAlphaFactor = qo, e.OneMinusDstAlphaFactor = Xo, e.DstColorFactor = Yo, e.OneMinusDstColorFactor = Zo, e.SrcAlphaSaturateFactor = Jo, e.NeverDepth = $o, e.AlwaysDepth = Qo, e.LessDepth = Ko, e.LessEqualDepth = es, e.EqualDepth = ts, e.GreaterEqualDepth = ns, e.GreaterDepth = is, e.NotEqualDepth = rs, e.MultiplyOperation = as, e.MixOperation = os, e.AddOperation = ss, e.NoToneMapping = ls, e.LinearToneMapping = cs, e.ReinhardToneMapping = us, e.Uncharted2ToneMapping = hs, e.CineonToneMapping = ds, e.ACESFilmicToneMapping = ps, e.UVMapping = fs, e.CubeReflectionMapping = ms, e.CubeRefractionMapping = vs, e.EquirectangularReflectionMapping = gs, e.EquirectangularRefractionMapping = ys, e.SphericalReflectionMapping = xs, e.CubeUVReflectionMapping = bs, e.CubeUVRefractionMapping = _s, e.RepeatWrapping = ws, e.ClampToEdgeWrapping = Ms, e.MirroredRepeatWrapping = Ts, e.NearestFilter = Es, e.NearestMipMapNearestFilter = Ss, e.NearestMipMapLinearFilter = Ps, e.LinearFilter = Cs, e.LinearMipMapNearestFilter = As, e.LinearMipMapLinearFilter = Ls, e.UnsignedByteType = Rs, e.ByteType = Is, e.ShortType = Os, e.UnsignedShortType = ks, e.IntType = Ds, e.UnsignedIntType = zs, e.FloatType = Bs, e.HalfFloatType = Ns, e.UnsignedShort4444Type = Us, e.UnsignedShort5551Type = js, e.UnsignedShort565Type = Fs, e.UnsignedInt248Type = Gs, e.AlphaFormat = Hs, e.RGBFormat = Vs, e.RGBAFormat = Ws, e.LuminanceFormat = qs, e.LuminanceAlphaFormat = Xs, e.RGBEFormat = Ys, e.DepthFormat = Zs, e.DepthStencilFormat = Js, e.RedFormat = $s, e.RGB_S3TC_DXT1_Format = Qs, e.RGBA_S3TC_DXT1_Format = Ks, e.RGBA_S3TC_DXT3_Format = el, e.RGBA_S3TC_DXT5_Format = tl, e.RGB_PVRTC_4BPPV1_Format = nl, e.RGB_PVRTC_2BPPV1_Format = il, e.RGBA_PVRTC_4BPPV1_Format = rl, e.RGBA_PVRTC_2BPPV1_Format = al, e.RGB_ETC1_Format = ol, e.RGBA_ASTC_4x4_Format = sl, e.RGBA_ASTC_5x4_Format = ll, e.RGBA_ASTC_5x5_Format = cl, e.RGBA_ASTC_6x5_Format = ul, e.RGBA_ASTC_6x6_Format = hl, e.RGBA_ASTC_8x5_Format = dl, e.RGBA_ASTC_8x6_Format = pl, e.RGBA_ASTC_8x8_Format = fl, e.RGBA_ASTC_10x5_Format = ml, e.RGBA_ASTC_10x6_Format = vl, e.RGBA_ASTC_10x8_Format = gl, e.RGBA_ASTC_10x10_Format = yl, e.RGBA_ASTC_12x10_Format = xl, e.RGBA_ASTC_12x12_Format = bl, e.LoopOnce = _l, e.LoopRepeat = wl, e.LoopPingPong = Ml, e.InterpolateDiscrete = Tl, e.InterpolateLinear = El, e.InterpolateSmooth = Sl, e.ZeroCurvatureEnding = Pl, e.ZeroSlopeEnding = Cl, e.WrapAroundEnding = Al, e.TrianglesDrawMode = Ll, e.TriangleStripDrawMode = Rl, e.TriangleFanDrawMode = Il, e.LinearEncoding = Ol, e.sRGBEncoding = kl, e.GammaEncoding = Dl, e.RGBEEncoding = zl, e.LogLuvEncoding = Bl, e.RGBM7Encoding = Nl, e.RGBM16Encoding = Ul, e.RGBDEncoding = jl, e.BasicDepthPacking = Fl, e.RGBADepthPacking = Gl, e.TangentSpaceNormalMap = Hl, e.ObjectSpaceNormalMap = Vl, e.Face4 = La, e.LineStrip = td, e.LinePieces = nd, e.MeshFaceMaterial = Ra, e.MultiMaterial = Ia, e.PointCloud = Oa, e.Particle = ka, e.ParticleSystem = Da, e.PointCloudMaterial = za, e.ParticleBasicMaterial = Ba, e.ParticleSystemMaterial = Na, e.Vertex = Ua, e.DynamicBufferAttribute = ja, e.Int8Attribute = Fa, e.Uint8Attribute = Ga, e.Uint8ClampedAttribute = Ha, e.Int16Attribute = Va, e.Uint16Attribute = Wa, e.Int32Attribute = qa, e.Uint32Attribute = Xa, e.Float32Attribute = Ya, e.Float64Attribute = Za, e.ClosedSplineCurve3 = Ja, e.SplineCurve3 = $a, e.Spline = Qa, e.AxisHelper = Ka, e.BoundingBoxHelper = eo, e.EdgesHelper = to, e.WireframeHelper = no, e.XHRLoader = io, e.BinaryTextureLoader = ro, e.GeometryUtils = id, e.Projector = ao, e.CanvasRenderer = oo, e.JSONLoader = so, e.SceneUtils = rd, e.LensFlare = lo, Object.defineProperty(e, "__esModule", {
                value: !0
            })
        })
    }, {}],
    50: [function (e, t, n) {
        (function (t, i) {
            function r(e, t) {
                this._id = e, this._clearFn = t
            }
            var a = e("process/browser.js").nextTick,
                o = Function.prototype.apply,
                s = Array.prototype.slice,
                l = {},
                c = 0;
            n.setTimeout = function () {
                return new r(o.call(setTimeout, window, arguments), clearTimeout)
            }, n.setInterval = function () {
                return new r(o.call(setInterval, window, arguments), clearInterval)
            }, n.clearTimeout = n.clearInterval = function (e) {
                e.close()
            }, r.prototype.unref = r.prototype.ref = function () {}, r.prototype.close = function () {
                this._clearFn.call(window, this._id)
            }, n.enroll = function (e, t) {
                clearTimeout(e._idleTimeoutId), e._idleTimeout = t
            }, n.unenroll = function (e) {
                clearTimeout(e._idleTimeoutId), e._idleTimeout = -1
            }, n._unrefActive = n.active = function (e) {
                clearTimeout(e._idleTimeoutId);
                var t = e._idleTimeout;
                t >= 0 && (e._idleTimeoutId = setTimeout(function () {
                    e._onTimeout && e._onTimeout()
                }, t))
            }, n.setImmediate = "function" == typeof t ? t : function (e) {
                var t = c++,
                    i = !(arguments.length < 2) && s.call(arguments, 1);
                return l[t] = !0, a(function () {
                    l[t] && (i ? e.apply(null, i) : e.call(null), n.clearImmediate(t))
                }), t
            }, n.clearImmediate = "function" == typeof i ? i : function (e) {
                delete l[e]
            }
        }).call(this, e("timers").setImmediate, e("timers").clearImmediate)
    }, {
        "process/browser.js": 42,
        timers: 50
    }],
    51: [function (e, t, n) {
        function i() {
            return (i = Object.assign || function (e) {
                for (var t = 1; t < arguments.length; t++) {
                    var n = arguments[t];
                    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i])
                }
                return e
            }).apply(this, arguments)
        }

        function r(e) {
            return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                return typeof e
            } : function (e) {
                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
            })(e)
        }! function (e, i) {
            "object" === ("undefined" == typeof n ? "undefined" : r(n)) && "undefined" != typeof t ? t.exports = i() : "function" == typeof define && define.amd ? define(i) : e.LazyLoad = i()
        }(this, function () {
            "use strict";
            var e = "undefined" != typeof window,
                t = e && !("onscroll" in window) || "undefined" != typeof navigator && /(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent),
                n = e && "IntersectionObserver" in window,
                r = e && "classList" in document.createElement("p"),
                a = {
                    elements_selector: "img",
                    container: t || e ? document : null,
                    threshold: 300,
                    thresholds: null,
                    data_src: "src",
                    data_srcset: "srcset",
                    data_sizes: "sizes",
                    data_bg: "bg",
                    class_loading: "loading",
                    class_loaded: "loaded",
                    class_error: "error",
                    load_delay: 0,
                    auto_unobserve: !0,
                    callback_enter: null,
                    callback_exit: null,
                    callback_reveal: null,
                    callback_loaded: null,
                    callback_error: null,
                    callback_finish: null
                },
                o = function (e, t) {
                    return e.getAttribute("data-" + t)
                },
                s = function (e, t, n) {
                    var i = "data-" + t;
                    null !== n ? e.setAttribute(i, n) : e.removeAttribute(i)
                },
                l = function (e) {
                    return "true" === o(e, "was-processed")
                },
                c = function (e, t) {
                    return s(e, "ll-timeout", t)
                },
                u = function (e) {
                    return o(e, "ll-timeout")
                },
                h = function (e, t) {
                    var n, i = new e(t);
                    try {
                        n = new CustomEvent("LazyLoad::Initialized", {
                            detail: {
                                instance: i
                            }
                        })
                    } catch (e) {
                        (n = document.createEvent("CustomEvent")).initCustomEvent("LazyLoad::Initialized", !1, !1, {
                            instance: i
                        })
                    }
                    window.dispatchEvent(n)
                },
                d = function (e, t) {
                    e && e(t)
                },
                p = function (e, t) {
                    e._loadingCount += t, 0 === e._elements.length && 0 === e._loadingCount && d(e._settings.callback_finish)
                },
                f = function (e) {
                    for (var t, n = [], i = 0; t = e.children[i]; i += 1) "SOURCE" === t.tagName && n.push(t);
                    return n
                },
                m = function (e, t, n) {
                    n && e.setAttribute(t, n)
                },
                v = function (e, t) {
                    m(e, "sizes", o(e, t.data_sizes)), m(e, "srcset", o(e, t.data_srcset)), m(e, "src", o(e, t.data_src))
                },
                g = {
                    IMG: function (e, t) {
                        var n = e.parentNode;
                        n && "PICTURE" === n.tagName && f(n).forEach(function (e) {
                            v(e, t)
                        }), v(e, t)
                    },
                    IFRAME: function (e, t) {
                        m(e, "src", o(e, t.data_src))
                    },
                    VIDEO: function (e, t) {
                        f(e).forEach(function (e) {
                            m(e, "src", o(e, t.data_src))
                        }), m(e, "src", o(e, t.data_src)), e.load()
                    }
                },
                y = function (e, t) {
                    var n, i, r = t._settings,
                        a = e.tagName,
                        s = g[a];
                    return s ? (s(e, r), p(t, 1), void(t._elements = (n = t._elements, i = e, n.filter(function (e) {
                        return e !== i
                    })))) : void! function (e, t) {
                        var n = o(e, t.data_src),
                            i = o(e, t.data_bg);
                        n && (e.style.backgroundImage = 'url("'.concat(n, '")')), i && (e.style.backgroundImage = i)
                    }(e, r)
                },
                x = function (e, t) {
                    r ? e.classList.add(t) : e.className += (e.className ? " " : "") + t
                },
                b = function (e, t, n) {
                    e.addEventListener(t, n)
                },
                _ = function (e, t, n) {
                    e.removeEventListener(t, n)
                },
                w = function (e, t, n) {
                    _(e, "load", t), _(e, "loadeddata", t), _(e, "error", n)
                },
                M = function (e, t, n) {
                    var i = n._settings,
                        a = t ? i.class_loaded : i.class_error,
                        o = t ? i.callback_loaded : i.callback_error,
                        s = e.target;
                    ! function (e, t) {
                        r ? e.classList.remove(t) : e.className = e.className.replace(new RegExp("(^|\\s+)" + t + "(\\s+|$)"), " ").replace(/^\s+/, "").replace(/\s+$/, "")
                    }(s, i.class_loading), x(s, a), d(o, s), p(n, -1)
                },
                T = function (e, t) {
                    var n = function r(n) {
                            M(n, !0, t), w(e, r, i)
                        },
                        i = function a(i) {
                            M(i, !1, t), w(e, n, a)
                        };
                    ! function (e, t, n) {
                        b(e, "load", t), b(e, "loadeddata", t), b(e, "error", n)
                    }(e, n, i)
                },
                E = ["IMG", "IFRAME", "VIDEO"],
                S = function (e, t) {
                    A(e, t), t._settings.auto_unobserve && t._observer.unobserve(e)
                },
                P = function (e) {
                    var t = u(e);
                    t && (clearTimeout(t), c(e, null))
                },
                C = function (e, t) {
                    var n = t._settings.load_delay,
                        i = u(e);
                    i || (i = setTimeout(function () {
                        S(e, t), P(e)
                    }, n), c(e, i))
                },
                A = function (e, t, n) {
                    var i = t._settings;
                    !n && l(e) || (E.indexOf(e.tagName) > -1 && (T(e, t), x(e, i.class_loading)), y(e, t), function (e) {
                        s(e, "was-processed", "true")
                    }(e), d(i.callback_reveal, e))
                },
                L = function (e) {
                    return !!n && (e._observer = new IntersectionObserver(function (t) {
                        t.forEach(function (t) {
                            return function (e) {
                                return e.isIntersecting || e.intersectionRatio > 0
                            }(t) ? function (e, t) {
                                var n = t._settings;
                                d(n.callback_enter, e), n.load_delay ? C(e, t) : S(e, t)
                            }(t.target, e) : function (e, t) {
                                var n = t._settings;
                                d(n.callback_exit, e), n.load_delay && P(e)
                            }(t.target, e)
                        })
                    }, {
                        root: (t = e._settings).container === document ? null : t.container,
                        rootMargin: t.thresholds || t.threshold + "px"
                    }), !0);
                    var t
                },
                R = function (e, t) {
                    this._settings = function (e) {
                        return i({}, a, e)
                    }(e), this._loadingCount = 0, L(this), this.update(t)
                };
            return R.prototype = {
                update: function (e) {
                    var n = this,
                        i = this._settings,
                        r = e || i.container.querySelectorAll(i.elements_selector);
                    this._elements = function (e) {
                        return e.filter(function (e) {
                            return !l(e)
                        })
                    }(Array.prototype.slice.call(r)), !t && this._observer ? this._elements.forEach(function (e) {
                        n._observer.observe(e)
                    }) : this.loadAll()
                },
                destroy: function () {
                    var e = this;
                    this._observer && (this._elements.forEach(function (t) {
                        e._observer.unobserve(t)
                    }), this._observer = null), this._elements = null, this._settings = null
                },
                load: function (e, t) {
                    A(e, this, t)
                },
                loadAll: function () {
                    var e = this;
                    this._elements.forEach(function (t) {
                        S(t, e)
                    })
                }
            }, e && function (e, t) {
                if (t)
                    if (t.length)
                        for (var n, i = 0; n = t[i]; i += 1) h(e, n);
                    else h(e, t);
            }(R, window.lazyLoadOptions), R
        })
    }, {}]
}, {}, [1]);
